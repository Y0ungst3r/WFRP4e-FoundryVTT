class CareerSelector extends  HandlebarsApplicationMixin(ApplicationV2)
{
    static DEFAULT_OPTIONS = {
        tag: "form",
        classes: ["warhammer", "standard-form", "career-selector", "item-dialog"],
        window: {
            title: "Career Selector",
            resizable : true,
        },
        position : {
            width: 400,
            height: 800
        },
        form: {
            submitOnChange: false,
            closeOnSubmit : true,
            handler: this._onSubmit
        },
        actions : {
            clickCareer : {buttons: [0, 2], handler : this._onClickCareer}
        }
    }

    constructor(document, options) {
        super(options);
        this.careers = [];
        this.document = document;
        this.currentCareer = document.currentCareer;
        this.selectedIndex = -1;
    }


      /** @override */
    static PARTS = {
        form: {
        template: "systems/wfrp4e/templates/apps/career-selector.hbs",
        scrollable: [".dialog-list"]
        },
    };

    async _prepareContext(options) {
        let context = await super._prepareContext(options);

        await this.loadCareers();

        if (!this._sortedCareers)
        {
            this._sortedCareers = this.sortCareers();
        }
        context.currentCareer = this.currentCareer;
        context.careers = this._sortedCareers;
        context.xp = this.computeXP();
        return context
    }

    async loadCareers() {
        if (this.careers.length)
        {
            return 
        }
        const currentCareerGroup = this.currentCareer.system.careergroup.value;
        this.careers = await warhammer.utility.findAllItems("career", game.i18n.localize("CAREER.Loading"), true, ["system.careergroup.value", "system.level.value", "system.class.value"]);
        this.careers = this.careers.sort((a, b) => a.system.careergroup.value > b.system.careergroup.value ? 1 : -1);
        const currentCareers = this.careers.filter((a) => a.system.careergroup.value === currentCareerGroup);
        this.careers = this.careers.filter((a) => a.system.careergroup.value !== currentCareerGroup);
        this.careers.unshift(...currentCareers);

        this.careers = this.careers.filter(i =>
        {
            if (game.user.isGM)
            {
                return true;
            }
            
            let {collection} = foundry.utils.parseUuid(i.uuid);

            return ((collection.metadata && collection.visible) || i.testUserPermission?.(game.user, CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER))
        });
    }

    sortCareers() {
        let careerList = {
            inClass: {},
            outOfClass: {},
        };
        if (!this.careers.length)
            return careerList

        this.careers.forEach((tier, i) => {
            try 
            {
                if (tier.system.careergroup.value) 
                {
                    let data = { level: tier.system.level.value, uuid: tier.uuid, img: tier.img, name: tier.name, index: i };
                    let type = "outOfClass";
                    if (this.currentCareer && this.currentCareer.system.class.value == tier.system.class.value)
                        type = "inClass";

                    if (careerList[type][tier.system.careergroup.value]?.length) 
                    {
                        if (!careerList[type][tier.system.careergroup.value].find(i => i.name == tier.name)) // avoid duplicates
                            careerList[type][tier.system.careergroup.value].push(data);
                    }
                    else
                        careerList[type][tier.system.careergroup.value] = [data];
                }
            }
            catch (e) {
                ui.notifications.error(`Error when displaying ${tier.name}: ${e}`);
            }
        });

        for (let career in careerList.inClass)
            careerList.inClass[career] = careerList.inClass[career].sort((a, b) => a.level > b.level ? 1 : -1);
        for (let career in careerList.outOfClass)
            careerList.outOfClass[career] = careerList.outOfClass[career].sort((a, b) => a.level > b.level ? 1 : -1);

        return careerList
    }

    static async _onSubmit(event, form, formData) {
        let selectedCareer = this.careers[this.selectedIndex];
        await this.document.createEmbeddedDocuments("Item", [(await fromUuid(selectedCareer.uuid)).toObject()]);
        let experience = foundry.utils.duplicate(this.document.system.details.experience);
        experience.spent += parseInt(formData.object.xp);
        experience.log = this.document.system.addToExpLog(formData.exp, `${game.i18n.format("LOG.CareerChange", { career: selectedCareer.name })}`, experience.spent, undefined);
        this.document.update({ "system.details.experience" : experience });
    }

    computeXP(careerIndex) 
    {
        let exp = 0, reasons = [];
        if (!careerIndex || careerIndex == -1)
        {
            return { exp, reasons }
        }

        let selectedCareer = this.careers[careerIndex];
        if (this.currentCareer) 
        {
            exp += this.currentCareer.complete.value ? 100 : 200;

            reasons.push(this.currentCareer.complete.value ? game.i18n.localize("CAREER.LeaveComplete") : game.i18n.localize("CAREER.LeaveIncomplete"));


            if (selectedCareer.system.class.value != this.currentCareer.system.class.value) 
            {
                exp += 100;
                reasons.push(game.i18n.localize("CAREER.DifferentClass"));
            }

        }
        else 
        {
            exp += 100;
        }

        return { amount: exp, tooltip: reasons.join(", ") }
    }

    static _onClickCareer(ev,target)
    {
        if (ev.button == 2)
        {
            fromUuid(this.careers[target.dataset.index].uuid).then(i => i.sheet.render(true));
        }
        else 
        {

            if (target.classList.contains("active"))
            {
                target.classList.toggle("active");
                this.selectedIndex = -1;
            }
            else 
            {
                this.element.querySelectorAll(".dialog-item").forEach(e => e.classList.remove("active"));
                target.classList.toggle("active");
               this.selectedIndex = target.dataset.index;
            }

            let input = this.element.querySelector("input[name='xp']");
            let xp = this.computeXP(this.selectedIndex);
            input.value = xp.amount;
            input.closest(".form-group").dataset.tooltip = xp.tooltip;
        }
    }
}

class WFRP_Audio {
  static PlayContextAudio(context) {
    this.MatchContextAudio(context).then(sound => {
      if (!sound || !sound.file) {
        console.warn("wfrp4e | Sound file not found for context: %o", context);
        return
      }
      warhammer.utility.log(`wfrp4e | Playing Sound: ${sound.file}`);
      AudioHelper.play({ src: sound.file }, sound.global);
    });
    
  }

  static FindContext(test) {
    let context = undefined;

    if (test.skill) {
      if (test.skill.name == game.i18n.localize("NAME.ConsumeAlcohol")) {
        context = { item: test.skill, action: "consumeAlcohol" };
        context.outcome = (test.result.roll <= 5 || test.result.roll <= test.result.target) ? "success" : "fail";
      }
      if (test.skill.name == game.i18n.localize("NAME.PickLock")) {
        context = { item: test.skill, action: "pickLock" };
      }
      else if (test.skill.name == game.i18n.localize("NAME.Stealth")) {
        context = { item: test.skill, action: "stealth" };
        context.outcome = (test.result.roll <= 5 || test.result.roll <= test.result.target) ? "success" : "fail";
      }
    }
    if (test.weapon) {
      context = { item: test.weapon, action: "fire" };
      if (test.result.misfire)
        context.action = "misfire";

      if (test.weapon.isRanged && test.failed &&
        (test.weapon.weaponGroup.value === "bow"
          || test.weapon.weaponGroup.value === "crossbow"
          || test.weapon.weaponGroup.value === "blackpowder"
          || test.weapon.weaponGroup.value === "engineering")) {
        let delayedContext = foundry.utils.deepClone(context);
        delayedContext.action = "miss";
        setTimeout((delayedContext) => { this.PlayContextAudio(delayedContext); }, 1000, delayedContext);
      }

      if (test.weapon.weaponGroup == "explosives" || test.weapon.weaponGroup == "throwing")
        context.action = "throw";
    }
    if (test.result.critical && test.weapon && test.weapon.properties.qualities.impale) {
      context = { item: {}, action: "hit", outcome: "crit_impale" };
    }
    if (test.spell) {
        if (test.result.castOutcome == "success"){
        context = { item: test.spell, action: "cast" };
        if (test.spell.damage)
          context.outcome = "damage";
      }

      if (test.result.minormis || test.result.majormis)
        context = { item: test.spell, action: "miscast" };
    }
    if (test.prayer) {
      if (test.result.outcome == "success")
        context = { item: test.prayer, action: "cast" };

      if (test.result.wrath)
        context = { item: test.prayer, action: "miscast" };
    }

    return context
  }



  /** CONTEXTUAL MODEL
   *  context = {
   *      action : equip, cast, lose, gain, etc.
   *      item : item associated with the action
   *      outcome : typcially success or failure, or other specifier, sometimes unused
   *  }
   */

  static async MatchContextAudio(context) {
    if (!game.settings.get("wfrp4e", "soundPath") || !context)
      return {}

    try {
      let files, file, group;
      await foundry.applications.apps.FilePicker.implementation.browse("user", game.settings.get("wfrp4e", "soundPath")).then(resp => {
        files = resp.files;
      });
      if (context.action == "hit")
        file = "hit";
      let globalSound = false;
      {
        switch (context.item.type) {
          case "weapon":
            group = context.item.weaponGroup.value;
            if (group == "crossbow")
              file = context.action == "equip" ? "weapon_bow" : "weapon_xbow";
            else if (group == "bow")
              file = "weapon_bow";
            else if (group == "fencing" || group == "parry" || group == "twohanded")
              file = context.action == "fire" ? "weapon-" : "weapon_sword";
            else if (group == "flail" && context.action == "fire") {
              file = "weapon_flail-";
              if (context.item.properties.qualities.impact)
                file = "weapon_flail_impact";
            }
            else if (group == "blackpowder" || group == "engineering")
              file = "weapon_gun";
            else if (group == "explosives")
              file = "weapon_bomb";
            else if (group == "throwintg") {
              file = "weapon-";
              if (context.action != "equip") {
                file = "weapon_throw";
                if (context.item.properties.qualities.hack)
                  file = "weapon_axe_throw";
              }
            }
            else if (group == "entangling" && context.action != "swing")
              file = "weapon_entangling";
            else
              file = "weapon-";
            break;
          case "armour":
            if (context.action.includes("equip")) {
              group = context.item.armorType.value;
              file = group.includes("Leather") ? "leather" : group;
            }
            else if (context.action == "hit") {
              group = context.item.type;
              file = context.outcome || "";
            }
            break;
          case "trapping":
            file = context.item.trappingType.value.includes("clothing") ? "cloth" : "item";
            break;
          case "spell":
            file = "spell";
            break;
          case "prayer":
            file = "prayer";
            break;
          case "round":
            file = "round";
            globalSound = true;
            break;
          case "skill":
            file = "skill";
            break;
          case "money":
            file = "money";
            break;
          case "shield":
            file = "weapon_shield";
            break;
          case "throw":
            file = "hit_throw-";
            break;
          case "throw_axe":
            file = "hit_throw_axe";
            break;
        }
      }
      if (context.item.special == "warhammer")
        file = "warhammer";
      files = files.filter(f => f.includes(file));

      if (context.item.type == "weapon") {
        globalSound = true;

        if (context.action == "miss")
          files = files.filter(f => f.includes("-miss"));
        else if (context.action == "misfire")
          files = files.filter(f => f.includes("-misfire"));
        else if (context.action == "fire") {
          if (file == "weapon_xbow" || file == "weapon_bow" || file == "weapon_gun" || file.includes("throw"))
            files = files.filter(f => f.includes("-fire"));
          else if (file != "weapon_bomb")
            files = files.filter(f => f.includes("-swing"));
          else
            files = files.filter(f => f.includes("-throw"));
        }
        else if (context.action == "load")
          files = files.filter(f => f.includes("-load"));
        else if (context.action == "damage") {
          globalSound = false;
          files = files.filter(f => f.includes("damage"));
          if (context.outcome == "shield")
            files = files.filter(f => f.includes("shield"));
        }

      }
      if (context.item.type == "shield") {
        files = files.filter(f => f.includes(context.action));
      }
      if (context.action == "equip") {
        if (context.outcome || context.item.type == "weapon") {
          files = files.filter(f => f.includes("-equip"));
        }
        else {
          files = files.filter(f => f.includes("deequip"));
        }
      }
      if (context.action == "hit") {
        files = files.filter(f => f.includes("hit"));
      }

      if (context.item.type == "spell") {
        if (context.action == "memorize")
          files = files.filter(f => f.includes("-memorize"));
        else if (context.action == "unmemorize")
          files = files.filter(f => f.includes("unmemorize"));
        else if (context.action == "cast") {
          if (context.outcome == "damage")
            files = files.filter(f => f.includes("damage-cast"));
          else
            files = files.filter(f => f.includes("-cast") && !f.includes("damage"));
          globalSound = true;
        }
        else {
          files = files.filter(f => f.includes("miscast"));
          globalSound = true;
        }
      }

      if (context.item.type == "prayer") {
        globalSound = true;
        if (context.action == "cast")
          files = files.filter(f => f.includes("-cast"));
        else
          files = files.filter(f => f.includes("miscast"));
      }

      if (context.action == "hit") {
        globalSound = true;
        if (context.outcome == "blocked")
          files = files.filter(f => f.includes(context.item.armourType));
        else if (context.item.type == "armour")
          files = files.filter(f => f.includes("armour"));
        else
          files = files.filter(f => !f.includes("armour")); // all non-armour sounds

        if (context.outcome == "normal")
          files = files.filter(f => f.includes("normal"));

        if (context.outcome == "warhammer")
          files = files.filter(f => f.includes("warhammer"));


        if (context.outcome == "crit")
          files = files.filter(f => f.includes("crit-"));
        if (context.outcome == "crit_impale")
          files = files.filter(f => f.includes("crit_impale"));
      }

      if (context.item.type == "skill") {
        if (context.action == "consumeAlcohol")
          files = files.filter(f => f.includes(`consumeAlcohol-${context.outcome == "fail" ? 'fail' : 'success'}`));
        if (context.action == "stealth")
          files = files.filter(f => f.includes(`stealth-${context.outcome == "fail" ? 'fail' : 'success'}`));
        if (context.action == "pickLock")
          files = files.filter(f => f.includes(context.action));
      }

      return { file: files[(await new Roll(`1d${files.length}-1`).roll({allowInteractive : false})).total], global: globalSound }
    }
    catch (e) {
      warhammer.utility.log("Sound Context Error: " + e, true);
    }
  }
}

/** Creates and manages an Item posted to chat, retrievable by dragging and dropping from chat into an Actor sheet.
 *  If the item is physical, with quantity and price, it also tracks who has dragged and the amount it has been dragged
 *  If a "Post Quantity" is specified, then it can only be retrieved that many times before disallowing further dragging.
 */
class PayMessageModel extends WarhammerMessageModel {
  static defineSchema() 
  {
      let schema = {};

      // Pay string i.e. "5gc1ss12bp"
      schema.payString = new foundry.data.fields.StringField({});

      // What payment is for
      schema.product = new foundry.data.fields.StringField();

      // Targeted Player
      schema.player = new foundry.data.fields.StringField();

      // Track who has retrieved this item from chat
      schema.paidBy = new foundry.data.fields.ArrayField(new foundry.data.fields.StringField());
      return schema;
  }

  static handlePayCommand(amount, {target, product}={})
  {
      //If the user isnt a GM, they pay
      if (!game.user.isGM) 
        {
        let actor = game.user.character;
        let money = game.wfrp4e.market.payCommand(amount, actor);
        if (money)
          actor.updateEmbeddedDocuments("Item", money);
      } 
      else // If GM
      {
        if ( target) // If targeted pay
        {
          let actor = game.actors.find(a => a.name.toLowerCase().includes(target.toLowerCase() ) );
          if ( actor ) 
          {
            let p = getActiveDocumentOwner(actor);
            if (actor.hasPlayerOwner && p ) 
            {
              target = p.name; // In this case, replace the actor by the player name for chat card, as usual
            } 
            else 
            {
              game.wfrp4e.market.directPayCommand(amount, actor); // No player/Not active -> substract money
              return false;
            }
          }
        }
        // Default choice, display chat card
        this.createPayMessage(amount, {product, player: target});
      }
      return false;
  }
  

  static createPayMessage(amount, {product, player}={}, mergeChatData={})
  {
    let parsedPayRequest = game.wfrp4e.market.parseMoneyTransactionString(amount);

    //If the /pay command has a syntax error, we display an error message to the gm
    if (!parsedPayRequest) {
      let msg = `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.PayCommandExample")}</i></p>`;
      ChatMessage.create(game.wfrp4e.utility.chatDataSetup(msg, "gmroll", false, {alias : game.i18n.localize("MARKET.PayRequest")}));
    } 
    else //generate a card with a summary and a pay button
    {
      let cardData = {
        product,
        QtGC: parsedPayRequest.gc,
        QtSS: parsedPayRequest.ss,
        QtBP: parsedPayRequest.bp
      };
      foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/market/market-pay.hbs", cardData).then(html => {
        let chatData = game.wfrp4e.utility.chatDataSetup(html, "roll", false, {forceWhisper: player, flavor : (product && "For: " + product), alias : game.i18n.localize("MARKET.PayRequest")});
        foundry.utils.mergeObject(chatData, mergeChatData);
        chatData.type = "pay";
        chatData.system = {payString : amount, player, product};
        ChatMessage.create(chatData);
      });
    }
  }

  static get actions() {
    return foundry.utils.mergeObject(super.actions, {
      pay : this._onPay,
    });
  }


  static async _onPay(ev, target)
  {
      if (!game.user.isGM) 
      {
        game.wfrp4e.market.handlePlayerPayment({payString : this.payString});
      } 
      else 
      {
        for(let actor of targetsWithFallback())
        {
          game.wfrp4e.market.handlePlayerPayment({payString: this.payString, target : actor});
        }
      }
  }

}

/**
 * WIP
 * This class contains functions and helpers related to the market and Pay system
 */
class MarketWFRP4e {
  /**
   * Roll a test for the availability and the stock quantity of an item based on the rulebook
   * Takes as a parameter an object with localized settlement type, localized rarity and a modifier for the roll
   * @param {Object} options settlement, rarity, modifier, name
   */
  static async testForAvailability({ settlement, rarity, modifier=0, name }) {
    //This method read the table  game.wfrp4e.config.availabilityTable defined in the config file

    //First we get the different settlements size
    let validSettlements = Object.getOwnPropertyNames(game.wfrp4e.config.availabilityTable);
    let validSettlementsLocalized = {};
    let validRarityLocalized = {};

    //For each settlements we found in the config, we try to translate them and we build a correlation table
    validSettlements.forEach(function (index) {
      validSettlementsLocalized[game.i18n.localize(index).toLowerCase()] = index;
    });

    //If we found a valid settlement size, we now do the same thing for the rarity datas
    if (settlement && validSettlementsLocalized.hasOwnProperty(settlement)) {
      let validRarity = Object.getOwnPropertyNames(game.wfrp4e.config.availabilityTable[validSettlementsLocalized[settlement]]);
      validRarity.forEach(function (index) {
        validRarityLocalized[game.i18n.localize(index).toLowerCase()] = index;
      });
    }

    let msg = `<h3><b>${game.i18n.localize("MARKET.AvailabilityTest")}</b></h3>`;

    //If at least one of the args isnt specified or if the specified options are not valid, we give informations on the correct syntax
    if (!settlement || !rarity || !validSettlementsLocalized.hasOwnProperty(settlement) || !validRarityLocalized.hasOwnProperty(rarity)) {
      msg += `<p>${game.i18n.localize("MARKET.AvailWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.AvailCommandExample")}</i></p>`;
    }
    //Everything is ok, lets roll for availability
    else {
      let roll = await new Roll("1d100 - @modifier", { modifier: modifier }).roll();
      //we retrieve the correct line
      let availabilityLookup = game.wfrp4e.config.availabilityTable[validSettlementsLocalized[settlement]][validRarityLocalized[rarity]];
      let isAvailable = availabilityLookup.test > 0 && roll.total <= availabilityLookup.test;

      let finalResult = {
        settlement: settlement.charAt(0).toUpperCase() + settlement.slice(1),
        rarity: rarity.charAt(0).toUpperCase() + rarity.slice(1),
        instock: isAvailable ? game.i18n.localize("Yes") : game.i18n.localize("No"),
        quantity: isAvailable ? availabilityLookup.stock : 0,
        roll: roll.total
      };

      //We roll the stock if we detect a valid roll value
      if (availabilityLookup.stock.includes("d")) {
        let stockRoll = await new Roll(availabilityLookup.stock).roll({allowInteractive : false});
        finalResult.quantity = stockRoll.total;
      }

      //Format the message before sending it back to chat
      msg += this.formatTestForChat(finalResult);
    }
    ChatMessage.create(game.wfrp4e.utility.chatDataSetup(msg, "roll", true, {flavor: name}));
  }

  /**
   * Format an availability test before sending it to chat
   * @param {Object} result
   */
  static formatTestForChat(result) {
    return `
        <b>${game.i18n.localize("MARKET.SettlementSize")}</b> ${result.settlement}<br>
        <b>${game.i18n.localize("MARKET.Rarity")}</b> ${result.rarity}<br><br>
        <b>${game.i18n.localize("MARKET.InStock")}</b> ${result.instock}<br>
        <b>${game.i18n.localize("MARKET.QuantityAvailable")}</b> ${result.quantity}<br>
        <b>${game.i18n.localize("Roll")}:</b> ${result.roll}
      `;
  }

  /**
   * Send a whispered card menu to the player to start an availability test
   * The card let him choose a settlement size
   * @param {string} rarity
   * @param {string} name
   */
  static generateSettlementChoice(rarity, name) {
    let cardData = {
      rarity: game.wfrp4e.config.availability[rarity],
      name
    };
    foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/market/market-settlement.hbs", cardData).then(html => {
      let chatData = game.wfrp4e.utility.chatDataSetup(html, "selfroll");
      ChatMessage.create(chatData);
    });
  }

  /**
   * Consolidate every money the player has in order to give him the fewer coins possible
   * @param {Array} money
   */
  static consolidateMoney(money) {
    //We sort the money from the highest BP value to the lowest (so gc => ss => bp)
    //This allow us to deal with custom money too and to not be dependent on the money name (translation errors could break the code otherwise)
    money.sort((a, b) => b.system.coinValue.value - a.system.coinValue.value);

    let brass = 0;
    //First we calculate the BP value
    for (let m of money)
      brass += m.system.quantity.value * m.system.coinValue.value;

    //Then we consolidate the coins
    for (let m of money) {
      //We don't know what players could create as a custom money and we dont want to divide by zero, ever. It would kill a kitten somewhere, probably.
      if (m.system.coinValue.value <= 0)
        break;
      m.system.quantity.value = Math.trunc(brass / m.system.coinValue.value);
      brass = brass % m.system.coinValue.value;
    }

    return money;
  }
  
  static convertMoney(money, type)
  {

    money = money.map(m => m.toObject());
  
    if (type == "gc")
    {
      let currentGC = money.find(i => i.name == game.i18n.localize("NAME.GC"));
      let currentSS = money.find(i => i.name == game.i18n.localize("NAME.SS"));

      if (currentGC && currentSS && currentGC.system.quantity.value )
      {
        currentGC.system.quantity.value -= 1;
        currentSS.system.quantity.value += 20;
        return [currentGC, currentSS];
      }
      else
        return ui.notifications.error(game.i18n.localize("ErrorMoneyConvert"))
    }
    
    if (type == "ss")
    {
      let currentSS = money.find(i => i.name == game.i18n.localize("NAME.SS"));
      let currentBP = money.find(i => i.name == game.i18n.localize("NAME.BP"));

      if (currentBP && currentSS  && currentSS.system.quantity.value)
      {
        currentSS.system.quantity.value -= 1;
        currentBP.system.quantity.value += 12;
        return [currentBP, currentSS];
      }
      else
        return ui.notifications.error(game.i18n.localize("ErrorMoneyConvert"))
    }
  }

  /**
   * Execute a /credit amount and add the money to the player inventory
   * @param {string} amount the amount of money transfered
   * @param {Array} moneyItemInventory
   */
  static creditCommand(amount, actor, options = {}) {
    //First we parse the amount
    let moneyItemInventory = actor.itemTags["money"].map(i => i.toObject());
    let moneyToSend = this.parseMoneyTransactionString(amount);
    let msg = `<h3><b>${game.i18n.localize("MARKET.CreditCommand")}</b></h3>`;
    let errorOccured = false;
    //Wrong amount
    if (!moneyToSend) {
      msg += `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.CreditCommandExample")}</i></p>`;
      errorOccured = true;
    }
    //Command is ok, let's try to pay
    else {
      //We need to get the character money items for gc, ss and bp. This is a "best effort" lookup method. If it fails, we stop the amount to prevent any data loss.
      let characterMoney = this.getCharacterMoney(moneyItemInventory);
      this.checkCharacterMoneyValidity(moneyItemInventory, characterMoney);

      //If one money is missing, we stop here before doing anything bad
      if (Object.values(characterMoney).includes(false)) {
        msg += `<p>${game.i18n.localize("MARKET.CantFindMoneyItems")}</p>`;
        errorOccured = true;
      } else {
        //Great, we can just deduce the quantity for each money
        moneyItemInventory[characterMoney.gc].system.quantity.value += moneyToSend.gc;
        moneyItemInventory[characterMoney.ss].system.quantity.value += moneyToSend.ss;
        moneyItemInventory[characterMoney.bp].system.quantity.value += moneyToSend.bp;
      }
    }
    if (errorOccured)
      moneyItemInventory = false;
    else {
      msg += game.i18n.format("MARKET.Credit", {
        number1: moneyToSend.gc,
        number2: moneyToSend.ss,
        number3: moneyToSend.bp
      });
      msg += `<br><b>${game.i18n.localize("MARKET.ReceivedBy")}</b> ${actor.name}`;
      this.throwMoney(moneyToSend);

    }
    if (options.suppressMessage)
      ui.notifications.notify(`${actor.name} received ${moneyToSend.gc}${game.i18n.localize("MARKET.Abbrev.GC")} ${moneyToSend.ss}${game.i18n.localize("MARKET.Abbrev.SS")} ${moneyToSend.bp}${game.i18n.localize("MARKET.Abbrev.BP")}`);
    else
      ChatMessage.create(game.wfrp4e.utility.chatDataSetup(msg, "roll"));
    return moneyItemInventory;
  }

  /**
   * Execute a /pay command and remove the money from an actor inventory, without chat card
   * @param {String} amount
   * @param {Actor} actor
   */
   static directPayCommand(amount, actor, options = {}) {
    let moneyPaid = this.payCommand(amount, actor);
    if (moneyPaid) {
      actor.updateEmbeddedDocuments("Item", moneyPaid);
    }
  }

  static async handlePlayerPayment({payString = '', target}) {

    // Priority: target argument -> controlled tokens -> assigned character
    
    let payments = [];
    let actors = target ? [target] : warhammer.utility.selectedWithFallback();
    if (actors.length == 0)
    {
      ui.notifications.notify(game.i18n.localize("MARKET.NotifyNoActor"));
    }
    else 
    {
      for(let actor of actors)
      {
        let money = MarketWFRP4e.payCommand(payString, actor);
        if (money) {
          WFRP_Audio.PlayContextAudio({ item: { "type": "money" }, action: "lose" });
          await actor.updateEmbeddedDocuments("Item", money);
          payments.push(actor);
        }
      }
    }
    return payments;
  }

  /**
   * Execute a /pay command and remove the money from the player inventory
   * @param {String} command
   * @param {Array} moneyItemInventory
   * @param transactionType  game.wfrp4e.config.transactionType, is it a payment or an income
   */
  static payCommand(command, actor, options = {}) {
    //First we parse the command
    let moneyItemInventory = actor.itemTags["money"].map(i => i.toObject());
    let commandParts = command.split(",");
    let moneyToPay = this.parseMoneyTransactionString(commandParts[0]);
    let msg = ``;
    let errorOccured = false;
    //Wrong command
    if (!moneyToPay) {
      msg += `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.PayCommandExample")}</i></p>`;
      errorOccured = true;
    }
    //Command is ok, let's try to pay
    else {
      //We need to get the character money items for gc, ss and bp. This is a "best effort" lookup method. If it fails, we stop the command to prevent any data loss.
      let characterMoney = this.getCharacterMoney(moneyItemInventory);
      this.checkCharacterMoneyValidity(moneyItemInventory, characterMoney);
      //If one money is missing, we stop here before doing anything bad
      if (Object.values(characterMoney).includes(false)) {
        msg += `<p>${game.i18n.localize("MARKET.CantFindMoneyItems")}</p>`;
        errorOccured = true;
      } else {
        //Now its time to check if the actor has enough money to pay
        //We'll start by trying to pay without consolidating the money
        if (moneyToPay.gc <= moneyItemInventory[characterMoney.gc].system.quantity.value &&
          moneyToPay.ss <= moneyItemInventory[characterMoney.ss].system.quantity.value &&
          moneyToPay.bp <= moneyItemInventory[characterMoney.bp].system.quantity.value) {
          //Great, we can just deduce the quantity for each money
          moneyItemInventory[characterMoney.gc].system.quantity.value -= moneyToPay.gc;
          moneyItemInventory[characterMoney.ss].system.quantity.value -= moneyToPay.ss;
          moneyItemInventory[characterMoney.bp].system.quantity.value -= moneyToPay.bp;
        } else //We'll need to calculate the brass value on both the pay command and the actor inventory, and then consolidate
        {
          let totalBPAvailable = 0;
          for (let m of moneyItemInventory)
            totalBPAvailable += m.system.quantity.value * m.system.coinValue.value;

          let totalBPPay = moneyToPay.gc * 240 + moneyToPay.ss * 12 + moneyToPay.bp;

          //Does we have enough money in the end?
          if (totalBPAvailable < totalBPPay) {
            //No
            msg += `${game.i18n.localize("MARKET.NotEnoughMoney")}<br>
              <b>${game.i18n.localize("MARKET.MoneyNeeded")}</b> ${totalBPPay} ${game.i18n.localize("NAME.BP")}<br>
              <b>${game.i18n.localize("MARKET.MoneyAvailable")}</b> ${totalBPAvailable} ${game.i18n.localize("NAME.BP")}`;
            errorOccured = true;
          } else //Yes!
          {
            totalBPAvailable -= totalBPPay;
            moneyItemInventory[characterMoney.gc].system.quantity.value = 0;
            moneyItemInventory[characterMoney.ss].system.quantity.value = 0;
            moneyItemInventory[characterMoney.bp].system.quantity.value = totalBPAvailable;

            //Then we consolidate
            moneyItemInventory = this.consolidateMoney(moneyItemInventory);
          }
        }
      }
    }
    if (errorOccured) {
      moneyItemInventory = false;
    } else {
      if (commandParts[1]) {
        msg += game.i18n.format("MARKET.PaidFor", {
          product: commandParts[1]
        }) + "<br>";
      }
      msg += game.i18n.format("MARKET.Paid", {
        number1: moneyToPay.gc,
        number2: moneyToPay.ss,
        number3: moneyToPay.bp
      });
      msg += `<br><b>${game.i18n.localize("MARKET.PaidBy")}</b> ${actor.name}`;

      this.throwMoney(moneyToPay);
    }
    if (options.suppressMessage)
      ui.notifications.notify(msg);
    else
      ChatMessage.create(game.wfrp4e.utility.chatDataSetup(msg, "roll", false, {flavor : game.i18n.localize("MARKET.PayCommand"), alias : actor.name}));
    return moneyItemInventory;
  }

  /**
   * we'll try to look for the coin value equals to the gc/ss/bp coin value for any entry that wasn't found.
   * This allows for a better chance at detecting the money items, as they are currently not properly identified by a unique id. Meaning if a translation module made a typo in the compendium
   * or if a player/gm edit the name of the money items for any reasons, it would not be found by the first method
   * @param moneyItemInventory
   * @param characterMoney
   */
  static checkCharacterMoneyValidity(moneyItemInventory, characterMoney) {
    for (let m = 0; m < moneyItemInventory.length; m++) {
      switch (moneyItemInventory[m].system.coinValue.value) {
        case 240://gc
          if (characterMoney.gc === false)
            characterMoney.gc = m;
          break;
        case 12://ss
          if (characterMoney.ss === false)
            characterMoney.ss = m;
          break;
        case 1://bp
          if (characterMoney.bp === false)
            characterMoney.bp = m;
          break;
      }
    }
  }

  /**
   * From a moneyItemInventory we get the money of the character (GC, SS and BP)
   * @param moneyItemInventory
   * @returns {{ss: boolean, gc: boolean, bp: boolean}}
   */
  static getCharacterMoney(moneyItemInventory) {
    let moneyTypeIndex = {
      gc: false,
      ss: false,
      bp: false
    };
    //First we'll try to look at the localized name
    for (let m = 0; m < moneyItemInventory.length; m++) {
      switch (moneyItemInventory[m].name) {
        case game.i18n.localize("NAME.GC"):
          moneyTypeIndex.gc = m;
          break;
        case game.i18n.localize("NAME.SS"):
          moneyTypeIndex.ss = m;
          break;
        case game.i18n.localize("NAME.BP"):
          moneyTypeIndex.bp = m;
          break;
      }
    }
    return moneyTypeIndex;
  }

  static throwMoney(moneyValues) {
    let number = moneyValues.gc || 0;
    if ((moneyValues.ss || 0) > number)
      number = moneyValues.ss || 0;
    if ((moneyValues.bp || 0) > number)
      number = moneyValues.bp || 0;

    if (game.dice3d && game.settings.get("wfrp4e", "throwMoney")) {
      new Roll(`${number}dc`).evaluate({allowInteractive : false}).then((roll) => {
        game.dice3d.showForRoll(roll, game.user, true);
      });
    }
  }

  /**
   * Parse a price string
   * Like "8gc6bp" or "74ss 12gc", etc
   * This method use localized abbreviations
   * return an object with the moneys and quantity
   * @param {String} string
   * @returns {Object}
   */
  static parseMoneyTransactionString(string) {
    //Regular expression to match any number followed by any abbreviation. Ignore whitespaces
    const expression = /((\d+)\s?(\p{L}+))/ug;
    let matches = [...string.matchAll(expression)];

    let payRecap = {
      gc: 0,
      ss: 0,
      bp: 0
    };
    let isValid = matches.length;
    for (let match of matches) {
      //Check if we have a valid command. We should have 4 groups per match
      if (match.length !== 4) {
        isValid = false;
        break;
      }
      //Should contains the abbreviated money (like "gc")
      switch (match[3].toLowerCase()) {
        case game.i18n.localize("MARKET.Abbrev.GC").toLowerCase():
          payRecap.gc += parseInt(match[2], 10);
          break;
        case game.i18n.localize("MARKET.Abbrev.SS").toLowerCase():
          payRecap.ss += parseInt(match[2], 10);
          break;
        case game.i18n.localize("MARKET.Abbrev.BP").toLowerCase():
          payRecap.bp += parseInt(match[2], 10);
          break;
      }
    }
    if (isValid && (payRecap.gc + payRecap.ss + payRecap.bp === 0))
      isValid = false;
    if (isValid && (payRecap.gc + payRecap.ss + payRecap.bp === 0))
      isValid = false;
    return isValid ? payRecap : false;
  }


  static generatePayCard(payRequest, player) {
    console.warn("WFRP4e | MarketWfrp4e.generatePayCard is deprecated, please use PayMessageModel.createPayMessage instead");
    PayMessageModel.createPayMessage(payRequest, {player});
  }

  /**
* Make some change ... to avoid player going around with tons of bronze coins
* @param {int} amount
* @returns {Object} an amount {amount.gc,amount.ss,amount.bp}
*/
  static makeSomeChange(amount, bpRemainder) {
    let gc = 0, ss = 0, bp = 0;
    if (amount >= 0) {
      gc = Math.floor(amount / 240);
      amount = amount % 240;
      ss = Math.floor(amount / 12);
      bp = amount % 12;
      bp = bp + ((bpRemainder > 0) ? 1 : 0);
    }
    return { gc: gc, ss: ss, bp: bp };
  }

  /**
* Transforms an amount of money to a string with value + currency like 2gc4ss8bp localized.
* @param {Object} amount
* @return {String} the amount
*/
  static amountToString(amount) {
    let gc = game.i18n.localize("MARKET.Abbrev.GC");
    let ss = game.i18n.localize("MARKET.Abbrev.SS");
    let bp = game.i18n.localize("MARKET.Abbrev.BP");
    return `${amount.gc || amount.g || 0}${gc} ${amount.ss || amount.s || 0}${ss} ${amount.bp || amount.b || 0}${bp}`
  }


  /**
*
* @param initialAmount {Object} {initialAmount.gc,initialAmount.ss,initialAmount.bp}
* @param {int} nbOfPlayers to split among them
* return amount {Object} an amount {amount.gc,amount.ss,amount.bp}
*/
  static splitAmountBetweenAllPlayers(initialAmount, nbOfPlayers) {
    // convert initialAmount in bp
    let bpAmount = initialAmount.gc * 240 + initialAmount.ss * 12 + initialAmount.bp;
    // divide bpAmount by nb of players and get the true remainder
    let bpRemainder = bpAmount % nbOfPlayers;
    bpAmount = Math.floor(bpAmount / nbOfPlayers);
    // rebuild an amount of gc/ss/bp from bpAmount
    let amount = this.makeSomeChange(bpAmount, bpRemainder);
    return amount;
  }


  /**TODO: Known Issue: /credit amount actor does not provide a chat message to the owning player
   * Process the credit management options.
   * GM Only
   * @param {String} creditRequest
   * @param {String} optionOrName
   */
  static processCredit(creditRequest, optionOrName) {
    let parsedPayRequest = this.parseMoneyTransactionString(creditRequest);

    //If the /credit command has a syntax error, we display an error message to the gm
    if (!parsedPayRequest) {
      let msg = `<h3><b>${game.i18n.localize("MARKET.CreditRequest")}</b></h3>`;
      msg += `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.CreditCommandExample")}</i></p>`;
      ChatMessage.create(game.wfrp4e.utility.chatDataSetup(msg, "gmroll"));
    } else //generate a card with a summary and a receive button
    {
      let amount, message, forceWhisper;
      optionOrName = optionOrName || "split"; // Default behavior

      // Process split/each options
      let nbActivePlayers = Array.from(game.users).filter(u => u.role != 4 && u.active).length;
      if ( optionOrName.toLowerCase() == "each" || optionOrName.toLowerCase() == "split") {
        if (nbActivePlayers == 0 ) {
          let message = game.i18n.localize("MARKET.NoPlayers");
          ChatMessage.create({ content: message });
          return
        }
        if (optionOrName.toLowerCase() === "split") {
          amount = this.splitAmountBetweenAllPlayers(parsedPayRequest, nbActivePlayers);
          message = game.i18n.format("MARKET.RequestMessageForSplitCredit", {
            activePlayerNumber: nbActivePlayers,
            initialAmount: this.amountToString(parsedPayRequest)
          });
        }
        else if (optionOrName.toLowerCase() === "each") {
          amount = parsedPayRequest;
          message = game.i18n.format("MARKET.RequestMessageForEachCredit", {
            activePlayerNumber: nbActivePlayers,
            initialAmount: this.amountToString(parsedPayRequest)
          });
        }
      } else {
        amount = parsedPayRequest;
        let paName = optionOrName.trim().toLowerCase();
        let player = game.users.players.filter(p => p.name.toLowerCase() == paName);
        if (player[0]) { // Player found !
          forceWhisper = player[0].name;
          message = game.i18n.format("MARKET.CreditToUser", {
            userName: player[0].name,
            initialAmount: this.amountToString(parsedPayRequest)
          });
        } else {
          let actor = game.actors.find(a => a.name.toLowerCase().includes(paName.toLowerCase()) );
          if ( actor) {
            let money = this.creditCommand(this.amountToString(amount), actor); // Imediate processing!
            if (money) {
              actor.updateEmbeddedDocuments("Item", money);
            }
            return
          } else {
            message = game.i18n.localize("MARKET.NoMatchingPlayer");
            ChatMessage.create({ content: message });
            return
          }
        }
      }
      let cardData = {
        digestMessage: message,
        amount: this.amountToString(amount),
        QtGC: amount.gc,
        QtSS: amount.ss,
        QtBP: amount.bp
      };
      foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/market/market-credit.hbs", cardData).then(html => {
        let chatData = game.wfrp4e.utility.chatDataSetup(html, "roll", false, {forceWhisper});
        foundry.utils.setProperty(chatData, "flags.wfrp4e.instances", nbActivePlayers);
        ChatMessage.create(chatData);
      });
    }
  }




  static async rollIncome(career, {standing, tier}={}) {
    standing = standing || career.system.status.standing;
    tier = tier || career.system.status.tier;

    let dieAmount = game.wfrp4e.config.earningValues[tier]; // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)
    dieAmount = parseInt(dieAmount) * standing;     // Multilpy that first letter by your standing (Brass 4 = 8d10 pennies)
    let earned;
    if (tier != "g") // Don't roll for gold, just use standing value
    {
      dieAmount = dieAmount + "d10";
      earned = (await new Roll(dieAmount).roll({allowInteractive : false})).total;
    }
    else
      earned = dieAmount;

      let item;
      if (tier == "g")
      {
        item = await game.wfrp4e.utility.find(game.i18n.localize("NAME.GC"), "money");
      }
      else if (tier == "s")
      {
        item = await game.wfrp4e.utility.find(game.i18n.localize("NAME.SS"), "money");
      }
      else if (tier == "b")
      {
        item = await game.wfrp4e.utility.find(game.i18n.localize("NAME.BP"), "money");
      }

      item = item?.toObject();

      if (item)
      {
        item.system.quantity.value = earned;
      }

      return {earned, type : tier, item}
  }


  static addMoneyTo(actor, moneyString) {
    // Money string is in the format of <amt><type>, so 12b, 5g, 1.5g
    let type = moneyString.slice(-1);
    let amt;
    // Failure means divide by two, so mark whether we should add half a gold or half a silver, just round pennies
    let halfS = false, halfG = false;
    if (type === "b")
      amt = Math.round(moneyString.slice(0, -1));
    else if (type === "s") {
      if (moneyString.slice(0, -1).includes("."))
        halfS = true;
      amt = Math.floor(moneyString.slice(0, -1));
    }
    else if (type === "g") {
      if (moneyString.slice(0, -1).includes("."))
        halfG = true;
      amt = Math.floor(moneyString.slice(0, -1));
    }
    let money = actor.itemTags["money"].map(m => m.toObject());

    let moneyItem;
    switch (type) {
      case 'b':
        moneyItem = money.find(i => i.name === game.i18n.localize("NAME.BP"));
        break;
      case 's':
        moneyItem = money.find(i => i.name === game.i18n.localize("NAME.SS"));
        break;
      case 'g':
        moneyItem = money.find(i => i.name === game.i18n.localize("NAME.GC"));
        break;
    }

    // If 0, means they failed the roll by -6 or more, delete all money
    if (!amt && !halfG && !halfS)
      money.forEach(m => m.system.quantity.value = 0);
    else // Otherwise, add amount to designated type
      moneyItem.system.quantity.value += amt;

    // add halves
    if (halfS)
      money.find(i => i.name === game.i18n.localize("NAME.BP")).system.quantity.value += 6;
    if (halfG)
      money.find(i => i.name === game.i18n.localize("NAME.SS")).system.quantity.value += 10;

    return money;
  }
}

class CorruptionMessageModel extends WarhammerMessageModel {
  static defineSchema() 
  {
      let schema = {};

      schema.strength = new foundry.data.fields.StringField({});
      schema.skill = new foundry.data.fields.StringField();
      schema.source = new foundry.data.fields.StringField();


      return schema;
  }

  static handleCorruptionCommand(strength, skill, source)
  {
    this.createCorruptionMessage(strength.toLowerCase(), {skill, source});
  }
  

  static createCorruptionMessage(strength, {skill, source=""}={}, chatData={})
  {
    foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/corruption.hbs", { strength, skill : skill?.capitalize(), source}).then(html => {
      ChatMessage.create(foundry.utils.mergeObject({ 
        type : "corruption", 
        content: html, 
        speaker : {
          alias  : game.i18n.localize("CORRUPTION.Exposure"),
        },
        flavor : source,
        system : {
          strength, 
          source,
          skill
        }}, chatData));
    });
  }

  static get actions() {
    return foundry.utils.mergeObject(super.actions, {
      resist : this._onResist,
    });
  }

  static async _onResist(ev, target)
  {
    let strength = this.strength.toLowerCase();
    if (game.i18n.localize(strength) != game.i18n.localize("CORRUPTION.Moderate") && game.i18n.localize(strength) != game.i18n.localize("CORRUPTION.Minor") && game.i18n.localize(strength) != game.i18n.localize("CORRUPTION.Major"))
      return ui.notifications.error("ErrorCorruption", {localize : true})


    let actors = warhammer.utility.targetedOrAssignedActors();
    if (actors.length == 0)
      return ui.notifications.error("ErrorCharAssigned", {localize : true})


    actors.forEach(a => {
      a.corruptionDialog(strength, this.skill);
    });
  }

}

class PsychMessageModel extends WarhammerMessageModel {
  static defineSchema() 
  {
      let schema = {};

      schema.type = new foundry.data.fields.StringField({choices : ["fear", "terror"]});

      schema.rating = new foundry.data.fields.NumberField({});

      schema.source  = new foundry.data.fields.StringField({});

      return schema;
  }

  static handleFearCommand(rating, source)
  {
    this.createFearMessage(rating, source);
  }

  static createFearMessage(rating, source)
  {

    if (isNaN(rating))
    {
      rating = 0;
    }
    
    let title = `${game.i18n.localize("CHAT.Fear")} ${rating}`;

    if (source)
    {
        title += ` - ${source}`;
    }

    foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/fear.hbs", { title}).then(html => {
      ChatMessage.create({ 
        type : "psych", 
        content: html, 
        speaker : {
          alias  : game.i18n.localize("CHAT.Fear"),
        },
        system : {
          type : "fear",
          rating,
          source
        }});
    });
  }

  static handleTerrorCommand(rating, source)
  {
    this.createTerrorMessage(rating, source);
  }

  static createTerrorMessage(rating, source)
  {

    if (isNaN(rating))
    {
      rating = 0;
    }
    
    let title = `${game.i18n.localize("CHAT.Terror")} ${rating}`;

    if (source)
    {
        title += ` - ${source}`;
    }

    foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/fear.hbs", { title}).then(html => {
      ChatMessage.create({ 
        type : "psych", 
        content: html, 
        speaker : {
          alias  : game.i18n.localize("CHAT.Terror"),
        },
        system : {
          type : "terror",
          rating,
          source
        }});
    });
  }

  static get actions() {
    return foundry.utils.mergeObject(super.actions, {
      apply : this._onApply,
    });
  }


  static async _onApply(ev, target)
  {

    if (game.user.isGM) 
    {
      let actors = warhammer.utility.targetsWithFallback();
      if (!actors.length)
      {
        return ui.notifications.warn("ErrorTarget", {localize : true})
      }
      actors.forEach(actor => 
      {
        if (this.type == "fear")
        {
          actor.applyFear(this.rating, this.source);
        }
        else if (this.type == "terror")
        {
          actor.applyTerror(this.rating, this.source);
        }
      });

      if (canvas.scene) 
      {
        game.canvas.tokens.setTargets([]);
      }
    }
    else 
    {
      if (!game.user.character)
      {
        return ui.notifications.warn("ErrorCharAssigned", {localize : true})
      }
      if (this.type == "fear")
      {
        game.user.character.applyFear(this.rating, this.source);
      }
      else if (this.type == "terror")
      {
        game.user.character.applyTerror(this.rating, this.source);
      }
    }
  }


  static _onFearButtonClicked(event) {


    if (game.user.isGM) 
    {
      if (!targets.length)
        return ui.notifications.warn("ErrorTarget", {localize : true})
      targets.forEach(t => {
        t.actor.applyFear(value, name);
        if (canvas.scene) {
          game.canvas.tokens.setTargets([]);
        }
      });
    }
    else 
    {
      if (!game.user.character)
        return ui.notifications.warn(game.i18n.localize("ErrorCharAssigned"))
      game.user.character.applyFear(value, name);
    }
  }

  static _onTerrorButtonClicked(event) {
    let value = parseInt($(event.currentTarget).attr("data-value"));
    let name = parseInt($(event.currentTarget).attr("data-name"));
    
    let targets = canvas.tokens.controlled.concat(Array.from(game.user.targets).filter(i => !canvas.tokens.controlled.includes(i)));
    if (canvas.scene) {
      game.canvas.tokens.setTargets([]);
    }

    if (game.user.isGM) {
      if (!targets.length)
        return ui.notifications.warn(game.i18n.localize("ErrorTarget"))
      targets.forEach(t => {
        t.actor.applyTerror(value, name);
      });
    }
    else {
      if (!game.user.character)
        return ui.notifications.warn(game.i18n.localize("ErrorCharAssigned"))
      game.user.character.applyTerror(value, name);
    }
  }

}

class XPMessageModel extends WarhammerMessageModel {
  static defineSchema() 
  {
      let schema = {};

      // amount of XP
      schema.amount = new foundry.data.fields.NumberField({});

      // What XP reward is for
      schema.reason = new foundry.data.fields.StringField();

      // Who has received the XP already
      schema.receivedBy = new foundry.data.fields.ArrayField(new foundry.data.fields.StringField);

      return schema;
  }

  static handleXPCommand(amount, reason)
  {
     
    if (isNaN(amount))
      return ui.notifications.error(game.i18n.localize("ERROR.Experience"))


    this.createXPMessage(amount, reason);
  }
  

  static createXPMessage(amount, reason)
  {

    foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/experience.hbs", { amount, reason}).then(html => {
      ChatMessage.create({ 
        type : "xp", 
        content: html, 
        speaker : {
          alias  : game.i18n.localize("CHAT.Experience"),
        },
        system : {
          amount, reason
        }});
    });
  }

  static get actions() {
    return foundry.utils.mergeObject(super.actions, {
      receive : this._onReceive,
    });
  }

  updateReceived(actor)
  {
    this.parent.update({"system.receivedBy" : this.system.receivedBy.concat(actor.id)});
  }


  static async _onReceive(ev, target)
  {

    if (game.user.isGM) 
    {
      let actors = warhammer.utility.targetsWithFallback();
      if (!actors.length)
      {
        return ui.notifications.warn("ErrorExp", {localize : true})
      }

      actors.forEach(actor => 
      {
        if (!this.receivedBy.includes(actor.id)) 
        {
          this.receivedBy.push(actor.id); // Add locally to handle fast clicking or no GM 
          actor.system.awardExp(this.amount, this.reason, this.parent.id);
        }
        else
        {
          ui.notifications.notify(`${actor.name} already received this reward.`);
        }
      });

      if (canvas.scene)
      { 
        game.canvas.tokens.setTargets([]);
      }
    }
    else // Not GM User
    {
      if (!game.user.character)
      {
        return ui.notifications.warn("ErrorCharAssigned", {localize : true})
      }
      if (this.receivedBy.includes(game.user.character.id))
      {
        return ui.notifications.notify(`${game.user.character.name} already received this reward.`)
      }

      this.receivedBy.push(game.user.character.id); // Add locally to handle fast clicking or no GM 
      game.user.character.system.awardExp(this.amount, this.reason, this.parent.id);
    }
  }

}

/**
 * Provides general useful functions for various different parts of the system.
 *
 * This is basically a catch-all for useful functions that don't quite fit anywhere
 * else, but is used by many different areas of the system. Most of these functions
 * involve retrieving data from the configuration values or the compendia.
 *
 */
class WFRP_Utility {
  /**
   * Roll characteristics given a species, or take average depending input
   * 
   * @param {string} species      Key or value for species in config
   * @param {bool} average        Take average or not
   */
  static async  speciesCharacteristics(species, average, subspecies) {
    let characteristics = {};
    let characteristicFormulae = game.wfrp4e.config.speciesCharacteristics[species];
    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].characteristics)
      characteristicFormulae = game.wfrp4e.config.subspecies[species][subspecies].characteristics;

    if (!characteristicFormulae) {
      ui.notifications.info(`${game.i18n.format("ERROR.Species", { name: species })}`);
      warhammer.utility.log("Could not find species " + species + ": " + error, true);
      throw error
    }


    for (let char in game.wfrp4e.config.characteristics) {
      if (average) {
        // Take average - 2d10+20 -> split on +, take the 20, add 10 (average of 2d10). This assumes, perhaps erroneously, that all species will have a 2d10 randomizer
        characteristics[char] = { value: Roll.safeEval(characteristicFormulae[char].replace("2d10", "10")) , formula: characteristicFormulae[char] };
      }
      else {
        let roll = await new Roll(characteristicFormulae[char]).roll({allowInteractive : false});
        characteristics[char] = { value: roll.total, formula: characteristicFormulae[char] + ` (${roll.result})` };
      }
    }
    return characteristics
  }


  static speciesSkillsTalents(species, subspecies) {
    let skills, talents, randomTalents, talentReplacement, traits;

    skills = game.wfrp4e.config.speciesSkills[species];
    talents = game.wfrp4e.config.speciesTalents[species];
    randomTalents = game.wfrp4e.config.speciesRandomTalents[species] || {talents: 0};
    talentReplacement = game.wfrp4e.config.speciesTalentReplacement[species] || {};
    traits = game.wfrp4e.config.speciesTraits[species] || [];

    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].skills)
      skills = game.wfrp4e.config.subspecies[species][subspecies].skills;

    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].talents)
      talents = game.wfrp4e.config.subspecies[species][subspecies].talents;

    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].randomTalents)
      randomTalents = game.wfrp4e.config.subspecies[species][subspecies].randomTalents || {talents: 0};

    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].talentReplacement)
      talentReplacement = game.wfrp4e.config.subspecies[species][subspecies].talentReplacement || {};

    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].speciesTraits)
    {
      traits = game.wfrp4e.config.subspecies[species][subspecies].speciesTraits || [];
    }

    return { skills, talents, randomTalents, talentReplacement, traits };
  }

  /**
   * Retrieves species movement value from config.
   * 
   * @param {String} species  species key for lookup
   */
  static speciesMovement(species, subspecies) {
    let move = game.wfrp4e.config.speciesMovement[species];
    if (subspecies && game.wfrp4e.config.subspecies[species].movement)
      move = game.wfrp4e.config.subspecies[species].movement;
    return move;
  }

  static getSystemEffects(vehicle=false) {
    if (vehicle)
    {
      return foundry.utils.duplicate(game.wfrp4e.config.vehicleSystemEffects)
    }
    else 
    {
      return foundry.utils.mergeObject(foundry.utils.duplicate(game.wfrp4e.config.systemEffects), foundry.utils.duplicate(game.wfrp4e.config.symptomEffects))
    }

  }

  static find(name, type)
  {
    if (type == "skill")
      return this.findSkill(name)
    if (type == "talent")
      return this.findTalent(name)
    else 
      return this.findItem(name, type)
  }

  /**
   * Specialized function to find a skill that accommodates for specializations.
   * 
   * Special considerations needs to be provided for finding skills because of specializations.
   * First, it will try to find the skill exactly, if that cannot be found, remove the specialization
   * and try to find any skill that would match if it had no specialization. If it is found, it will 
   * return that skill, renaming it to match the query.
   * 
   * For example, input could be Lore (Cheese), which doesn't exist. So it will try again testing
   * with just the skill "Lore", and trying to match it with any other skill by removing its 
   * specialization as well. Thus, lore matches with the first Lore skill, which should be 
   * the blank "Lore ()" skill. This is renamed as Lore (Cheese) and returned.
   * 
   * @param {String} skillName skill name to be searched for
   */
  static async findSkill(skillName) {
    let skill = await this.findExactName(skillName, "skill");

    if (skill)
      return skill;

    skill = await this.findBaseName(skillName, "skill");

    if (skill)
    {
      let skillData = skill.toObject();
      skillData.effects = [];
      return new Item.implementation(skillData);
    }

    throw `"${game.i18n.format("ERROR.NoSkill", {skill: skillName})}"`;
  }

  /**
   * Specialized function to find a talent that accommodates for specializations.
   * 
   * Special considerations needs to be provided for finding talents because of specializations.
   * First, it will try to find the talent exactly, if that cannot be found, remove the specialization
   * and try to find any talent that would match if it had no specialization. If it is found, it will 
   * return that talent, renaming it to match the query.
   * 
   * For example, input could be Etiquette (Cheesemongers), which doesn't exist. So it will try again testing
   * with just the talent "Etiquette", and trying to match it with any other talent by removing its 
   * specialization as well. Thus, Etiquette matches with the first Etiquette talent, which should be 
   * the blank "Etiquette ()" talent. This is renamed as Etiquette (Cheesemongers) and returned.
   * 
   * @param {String} talentName talent name to be searched for
   */
  static async findTalent(talentName) {
    let talent = await WFRP_Utility.findExactName(talentName, "talent");

    if (talent)
      return talent;

    talent = await WFRP_Utility.findBaseName(talentName, "talent");

    if (talent)
      return talent;

    throw `"${game.i18n.format("ERROR.NoTalent", {talent: talentName})}"`;
  }

  /**
   * Finds an item of the exact same name (Prejudice (Target) !== Prejudice (Nobles)).
   *
   * @param {string} name item name to be searched for
   * @param {[]|string} type type or array of types of item to be searched for
   *
   */
  static async findExactName(name, type) {
    if (typeof type === "string")
      type = [type];

    if (!type)
      type = [];

    // First try world items
    let searchResult = game.items.contents.find(t => (type.length == 0 || type.includes(t.type)) && t.name === name);

    if (searchResult) {
      return searchResult;
    }

    // Search compendium packs for base name item
    for (let pack of game.wfrp4e.tags.getPacksWithTag(type)) {
      const index = pack.indexed ? pack.index : await pack.getIndex();
      let indexResult = index.find(t => t.name === name && (type.length == 0 || type.includes(t.type)));

      if (indexResult)
        return pack.getDocument(indexResult._id);
    }
  }

  /**
   * Finds an item with the same base name (Prejudice (Target) == Prejudice (Nobles)).
   *
   * @param {String} name item name to be searched for
   * @param {Collection} collection collection to search in, could be a world collection or pack index
   * @param {String} pack if collection is a pack index, include the pack to retrieve the document
   *
   */
  static async findBaseName(name, type)
  {
    if (typeof type == "string")
    {
      type = [type];
    }

    if (!type)
    {
      type = [];
    }

    let baseName = this.extractBaseName(name);

    let searchResult = game.items.contents.find(t => (type.length == 0 || type.includes(t.type)) && (t.name == name || this.extractBaseName(t.name) == baseName));
    if (!searchResult)
    {
      // Search compendium packs for base name item
      for (let pack of game.wfrp4e.tags.getPacksWithTag(type)) {
        const index = pack.indexed ? pack.index : await pack.getIndex();
        let indexResult = index.find(t => this.extractBaseName(t.name) == this.extractBaseName(name) && (type.length == 0 || type.includes(t.type))); // if type is specified, check, otherwise it doesn't matter
        if (indexResult)
          searchResult = await pack.getDocument(indexResult._id);
      }
    }

    if (searchResult) {
      let item = searchResult.clone();
      item.updateSource({ name }); // This is important if a specialized talent wasn't found. Without it, <Talent ()> would be added instead of <Talent (Specialization)>
      return item;
    }
  }

  static extractBaseName(name)
  {
    return name.split("(")[0].trim();
  }


  // Obviously this isn't very good, but it works for now
  static extractParenthesesText(name="", opening="(")
  {
    // Default
    let closing = ")";

    if (opening == "[")
      closing = "]";

    if (opening == "<")
      closing = ">";

    return name.split(opening)[1]?.split(closing)[0].trim();
  }


  /**
   * 
   * @param {String} itemName   Item name to be searched for 
   * @param {String|Array} itemType   Item's type (armour, weapon, etc.)
   */
  static async findItem(itemName, itemType) {
    let item = await WFRP_Utility.findExactName(itemName, itemType);

    if (item)
      return item;

    item = await WFRP_Utility.findBaseName(itemName, itemType);

    if (item)
      return item;

    console.error("Cannot find " + itemName);
  }


  // Used to sort arrays based on string value (used in organizing skills to be alphabetical - see ActorWFRP4e.prepareItems())
  static nameSorter(a, b) {
    if (a.name.toLowerCase() < b.name.toLowerCase())
      return -1;
    if (a.name.toLowerCase() > b.name.toLowerCase())
      return 1;
    return 0;
  }

  /**
   * Return a list of all qualities
   */
  static qualityList(type = null) {
    let weapon = foundry.utils.duplicate(game.wfrp4e.config.weaponQualities);
    let armor = foundry.utils.duplicate(game.wfrp4e.config.armorQualities);
    let item = foundry.utils.duplicate(game.wfrp4e.config.itemQualities);

    switch (type) {
      case "weapon":
        return foundry.utils.mergeObject(item, weapon);
      case "armor":
        return foundry.utils.mergeObject(item, armor);
      default:
        return foundry.utils.mergeObject(weapon, foundry.utils.mergeObject(item, armor));
    }
  }


  /**
   * Return a list of all flaws
   */
  static flawList(type = null) {
    let weapon = foundry.utils.duplicate(game.wfrp4e.config.weaponFlaws);
    let armor = foundry.utils.duplicate(game.wfrp4e.config.armorFlaws);
    let item = foundry.utils.duplicate(game.wfrp4e.config.itemFlaws);

    switch (type) {
      case "weapon":
        return foundry.utils.mergeObject(item, weapon);
      case "armor":
        return foundry.utils.mergeObject(item, armor);
      default:
        return foundry.utils.mergeObject(weapon, foundry.utils.mergeObject(item, armor));
    }
  }

  static allProperties(type = null) {
    return foundry.utils.mergeObject(this.qualityList(type), this.flawList(type))
  }


  /**
   * Posts the symptom effects, then secretly posts the treatment to the GM.
   * 
   * @param {String} symptom  symptom name to be posted
   */
  static async postSymptom(symptom) {
    let symkey = warhammer.utility.findKey(symptom.split("(")[0].trim(), game.wfrp4e.config.symptoms);
    let content = `<b>${symptom}</b>: ${game.wfrp4e.config.symptomDescriptions[symkey]}`;
    let chatOptions = {
      user: game.user.id,
      rollMode: game.settings.get("core", "rollMode"),
      content: content
    };
    if (["gmroll", "blindroll"].includes(chatOptions.rollMode)) chatOptions["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (chatOptions.rollMode === "blindroll") chatOptions["blind"] = true;
    ChatMessage.create(chatOptions);

    if (game.user.isGM) {
      content = `<b>${symptom} ${game.i18n.localize("Treatment")}</b>: ${game.wfrp4e.config.symptomTreatment[symkey]}`;
      chatOptions = {
        user: game.user.id,
        rollMode: game.settings.get("core", "rollMode"),
        content: await foundry.applications.ux.TextEditor.implementation.enrichHTML(content, {async: true})
      };
      chatOptions["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
      ChatMessage.create(chatOptions);
    }
  }

  /**
   * Posts the definition of a quality or flaw to chat.
   * 
   * @param {String} property   name of the quality or flaw
   */
  static  async postProperty(propertyText) {
    let properties = foundry.utils.mergeObject(WFRP_Utility.qualityList(), WFRP_Utility.flawList()),
      propertyDescr = Object.assign(duplicate(game.wfrp4e.config.qualityDescriptions), game.wfrp4e.config.flawDescriptions),
      propertyKey;

    let property = this.parsePropertyName(propertyText.replace(/,/g, '').trim());

    propertyKey = warhammer.utility.findKey(property, properties);

    let propertyDescription = propertyDescr[propertyKey];
    propertyDescription = propertyDescription.replace("(Rating)", property.split(" ")[1]);


    let chatOptions = {
      user: game.user.id,
      rollMode: game.settings.get("core", "rollMode"),
      speaker : {alias : propertyText},
      content: await foundry.applications.ux.TextEditor.implementation.enrichHTML(propertyDescription, {async: true})
    };
    if (["gmroll", "blindroll"].includes(chatOptions.rollMode)) chatOptions["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (chatOptions.rollMode === "blindroll") chatOptions["blind"] = true;
    ChatMessage.create(chatOptions);
  }

  /**
   * Helper function to easily find the property name
   * // Todo: regex?
   * @param {String} property 
   */
  static parsePropertyName(property) {
    property = property.trim();
    if (!isNaN(property[property.length - 1]))
      return property.substring(0, property.length - 2).trim()
    else if (property.includes("("))
      return property.split("(")[0].trim()
    else
      return property;
  }

  /**
   * Helper function to set up chat data (set roll mode and content).
   * 
   * @param {String} content 
   * @param {String} modeOverride 
   * @param {Boolean} isRoll 
   */
  static chatDataSetup(content, modeOverride, isRoll = false, {forceWhisper, alias, flavor}={}) {
    let chatData = {
      user: game.user.id,
      rollMode: modeOverride || game.settings.get("core", "rollMode"),
      content: content
    };
    if (isRoll)
      chatData.sound = CONFIG.sounds.dice;

    if (["gmroll", "blindroll"].includes(chatData.rollMode)) chatData["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (chatData.rollMode === "blindroll") chatData["blind"] = true;
    else if (chatData.rollMode === "selfroll") chatData["whisper"] = [game.user.id];

    if (alias)
      chatData.speaker = {alias};
    if (flavor)
      chatData.flavor = flavor;

    if (forceWhisper) { // Final force !
      chatData["speaker"] = ChatMessage.getSpeaker();
      chatData["whisper"] = ChatMessage.getWhisperRecipients(forceWhisper);
    }

    return chatData;
  }

  /**
   * Looks through object values and finds the one that most closely matches the query, returning the key.
   * 
   * Used by condition lookup.
   * 
   * @param {Object} Object Object being searched in
   * @param {*} query Value trying to match
   */
  static matchClosest(object, query, options = {}) {
    query = query.toLowerCase();
    let keys = Object.keys(object);
    let match = [];
    for (let key of keys) {
      let percentage = 0;
      let matchCounter = 0;
      let myword;
      if (options.matchKeys)
        myword = key.toLowerCase();
      else
        myword = object[key].toLowerCase();
      for (let i = 0; i < myword.length; i++) {
        if (myword[i] == query[i]) {
          matchCounter++;
        }
      }
      percentage = matchCounter / key.length;
      match.push(percentage);
    }
    let maxIndex = match.indexOf(Math.max.apply(Math, match));
    return keys[maxIndex]
  }

  /**
   * Returns token speaker if available, otherwise, returns actor.
   * 
   * @param {Object} speaker  speaker object containing actor and otken
   */
  static getSpeaker(speaker) {
    let actor = game.actors.get(speaker.actor);
    if (speaker.token && speaker.scene)
      actor = game.scenes.get(speaker.scene).tokens.get(speaker.token).actor;
    return actor
  }


  static getToken(speaker) {
    return game.scenes.get(speaker?.scene)?.tokens?.get(speaker?.token)
  }

  /**
   * Returns all basic skills from the skills compendium
   */
  static async allBasicSkills() {
    let skillData = [];

    const packs = game.wfrp4e.tags.getPacksWithTag(["skill"]);

    if (!packs.length)
      return []

    for (let pack of packs) 
    {
      let skills = (await pack.getDocuments({ type__in: ["skill"] })).filter(i => i.system.isBasic);
      for (let i of skills) 
      {
        if (i.system.isGrouped) 
        {
          if (!i.specifier) 
          {
            let data = i.toObject();
            data.name = i.baseName;
            skillData.push(data);
          }
        }
        else 
        {
          skillData.push(i.toObject());
        }
      }
    }
    warhammer.utility.log("Found Basic Skills: ", undefined, skillData);
    return skillData;
  }

  /**
   * Returns Gold Crown, Silver Shilling, and Brass Penny from trappings compendium
   */
  static async allMoneyItems() {
    let moneyItems = [];
    const packs = game.wfrp4e.tags.getPacksWithTag("money");

    if (!packs.length)
      return []

    for (let pack of packs) {
      let items;
      await pack.getDocuments().then(content => items = content.filter(i => i.type == "money").map(i => i.toObject()));

      let money = items.filter(t => Object.values(game.wfrp4e.config.moneyNames).map(n => n.toLowerCase()).includes(t.name.toLowerCase()));

      moneyItems = moneyItems.concat(money.filter(m => !moneyItems.find(i => i.name.toLowerCase() == m.name.toLowerCase()))); // Remove duplicates
    }
    warhammer.utility.log("Found Money Items: ", undefined, moneyItems);
    return moneyItems
  }

  static alterDifficulty(difficulty, steps) {
    let difficulties = Object.keys(game.wfrp4e.config.difficultyLabels);
    let difficultyIndex = difficulties.findIndex(d => d == difficulty) + steps;
    difficultyIndex = Math.clamp(difficultyIndex, 0, difficulties.length - 1);
    return difficulties[difficultyIndex]
  }


  /**
   * Collects data from the table click event and sends it to game.wfrp4e.tables to be rolled.
   * 
   * @param {Object} event  click event
   */
  static async handleTableClick(event, target) {
    let modifier = parseInt(target.dataset.modifier) || 0;
    let messageId= this.id;
    let html;
    let chatOptions = this.chatDataSetup("", game.settings.get("core", "rollMode"), true);

    if (event.button == 0) {
      let clickText = event.target.text || event.target.textContent;
      if (clickText.trim() == game.i18n.localize("ROLL.CritCast")) {
        html = game.wfrp4e.tables.criticalCastMenu(target.dataset.table);
      }

      else if (clickText.trim() == game.i18n.localize("ROLL.TotalPower"))
        html = game.wfrp4e.tables.restrictedCriticalCastMenu();

      // Not really a table but whatever
      else if (target.dataset.table == "misfire") {
        let damage = target.dataset.damage;
        html = game.i18n.format("ROLL.Misfire", { damage: damage });
      }
      else if (target.dataset.table) 
      {
        html = (await game.wfrp4e.tables.formatChatRoll(target.dataset.table,
          {
            modifier: modifier,
            showRoll: true,
            messageId
          }, target.dataset.column));
      }

      chatOptions["content"] = html;
      chatOptions["type"] = 0;
      if (!foundry.utils.isEmpty(html))
      {
        ChatMessage.create(chatOptions);
      }

    }
  }

  /**
   * Post condition when clicked.
   * 
   * @param {Object} event click event
   */
  static handleConditionClick(event, target) {
    let cond = target.dataset.cond;
    if (!cond)
      cond = event.target.text.trim();
    if (!isNaN(cond.split(" ").pop())) // check if the condition level is specified
      cond = cond.split(" ").slice(0, -1).join(" "); // remove the condition level
    let condkey = warhammer.utility.findKey(cond, game.wfrp4e.config.conditions, { caseInsensitive: true });
    let condName = game.wfrp4e.config.conditions[condkey];
    let condDescr = game.wfrp4e.config.conditionDescriptions[condkey];
    let messageContent = `<b>${condName}</b><br>${condDescr}`;

    let chatData = WFRP_Utility.chatDataSetup(messageContent);
    ChatMessage.create(chatData);
  }

  /**
   * Post property description when clicked.
   *
   * @param {Object} event click event
   */
  static handlePropertyClick(event, target) {
    let prop = target.text.trim();

    // If property rating is present, remove it
    if (!isNaN(prop.split(" ").pop()))
      prop = prop.split(" ").slice(0, -1).join(" ");

    const allProps = this.allProperties();
    const propKey = warhammer.utility.findKey(prop, allProps, { caseInsensitive: true });
    const propName = allProps[propKey];
    const description = game.wfrp4e.config.qualityDescriptions[propKey] || game.wfrp4e.config.flawDescriptions[propKey];
    const messageContent = `<b>${propName}</b><br>${description}`;

    const chatData = WFRP_Utility.chatDataSetup(messageContent, null);
    ChatMessage.create(chatData);
  }

  /**
   * Post symptom when clicked
   * 
   * @param {Object} event click event
   */
  static handleSymptomClick(event, target) {
    let symptom = target.dataset.symptom;
    if (!symptom)
      symptom = target.text;
    WFRP_Utility.postSymptom(symptom);
  }

  /**
   * Roll to chat when roll entity is clicked
   * 
   * @param {Object} event clicke event
   */
  static async handleRollClick(event, target) {
    let roll = target.dataset.roll;
    if (!roll)
      roll = target.text.trim();
    let rollMode = game.settings.get("core", "rollMode");
    (await new Roll(roll).roll({allowInteractive : false})).toMessage(
      {
        user: game.user.id,
        rollMode
      });
  }


  /**
 * Handle a payment entity link
 * 
 * @param {Object} event clicke event
 */
  static handlePayClick(event, target) {
    let payString = target.dataset.args;
    if (game.user.isGM)
      game.wfrp4e.commands.call("pay", payString);
    else
      MarketWFRP4e.handlePlayerPayment({payString});
  }

  static handleCreditClick(event, target) 
  {
    game.wfrp4e.commands.call("credit", target.dataset.args);
  }

  static handleCorruptionClick(event, target)
  {
    CorruptionMessageModel.createCorruptionMessage(target.dataset.strength);
  }

  static postCorruptionTest(strength, chatData={})
  {
    console.warn("WFRP4e | WFRP_Utility.postCorruptionTest is deprecated, use CorruptionMessageModel.createCorruptionMessage instead");
    CorruptionMessageModel.createCorruptionMessage(strength, {}, chatData);
  }


  static handleFearClick(event, target) {
    return PsychMessageModel.createFearMessage(target.dataset.value, target.dataset.name);
  }

  static postFear(value = 0, name = undefined) {
    console.warn("WFRP4e | WFRP_Utility.postFear is deprecated, use PsychMessageModel.createFearMessage instead");
    return PsychMessageModel.createFearMessage(value, name);
  }

  static handleTerrorClick(event, target) {
    return PsychMessageModel.createTerrorMessage(target.dataset.value, target.dataset.name);
  }

  static handleExpClick(event, target) {
    return XPMessageModel.handleXPCommand(target.dataset.amount, target.dataset.reason);
  }

  static postTerror(value = 1, name = undefined) {
    console.warn("WFRP4e | WFRP_Utility.postTerror is deprecated, use PsychMessageModel.createTerrorMessage instead");
    return PsychMessageModel.createTerrorMessage(value, name);
  }


  static postExp(amount, reason = undefined) {
    console.warn("WFRP4e | WFRP_Utility.postExp is deprecated, use XPMessageModel.handleXpCommand instead");
    return XPMessageModel.handleXPCommand(amount, reason);
  }


  static _onDragConditionLink(event) {
    event.stopPropagation();
    const a = event.currentTarget;
    let dragData = null;
    dragData = { type: "condition", payload: a.dataset.cond };

    event.originalEvent.dataTransfer.setData("text/plain", JSON.stringify(dragData));
  }

  /**
   * Retrieves the item being requested by the macro from the selected actor,
   * sending it to the correct setup____ function to be rolled.
   * 
   * @param {String} itemName name of item being rolled
   * @param {String} itemType type of item ("weapon", "spell", etc)
   */
  static rollItemMacro(itemName, itemType, bypassData) {
    const speaker = ChatMessage.getSpeaker();
    let actor;
    if (speaker.token) actor = game.actors.tokens[speaker.token];
    if (!actor) actor = game.actors.get(speaker.actor);
    let item;
    // Not technically an item, used for convenience
    if (itemType == "characteristic") {
      return actor.setupCharacteristic(itemName, bypassData).then(test => test.roll());
    }
    else {
      item = actor ? actor.itemTags[itemType].find(i => i.name === itemName) : null;
    }
    if (!item) return ui.notifications.warn(`${game.i18n.localize("ErrorMacroItemMissing")} ${itemName}`);

    // Trigger the item roll
    switch (item.type) {
      case "weapon":
        return actor.setupWeapon(item, bypassData).then(test => test.roll());
      case "spell":
        return actor.sheet.castOrChannelPrompt(item, bypassData).then(test => test.roll());
      case "prayer":
        return actor.setupPrayer(item, bypassData).then(test => test.roll());
      case "trait":
        return actor.setupTrait(item, bypassData).then(test => test.roll());
      case "skill":
        return actor.setupSkill(item, bypassData).then(test => test.roll());
    }
  }

  static async toggleMorrslieb() {

    let morrsliebActive = canvas.scene.getFlag("wfrp4e", "morrslieb");
    morrsliebActive = !morrsliebActive;
    await canvas.scene.setFlag("wfrp4e", "morrslieb", morrsliebActive);

    if (game.modules.get("fxmaster") && game.modules.get("fxmaster").active) {
      FXMASTER.filters.switch("morrslieb", "color", CONFIG.MorrsliebObject);
    }
    else {
      SocketHandlers.call("morrslieb", null, "ALL");
      canvas.draw();
    }
  }

  static updateGroupAdvantage({players=undefined, enemies=undefined}={})
  {
    if (!game.user.isGM)
    {
      game.socket.emit("system.wfrp4e", {type : "changeGroupAdvantage", payload : {players, enemies}});
    }
    else if (game.user.isUniqueGM)
    {
      let advantage = game.settings.get("wfrp4e", "groupAdvantageValues");
      if (Number.isNumeric(players))
        advantage.players = players;
      if (Number.isNumeric(enemies))
        advantage.enemies = enemies;
    
      return game.settings.set("wfrp4e", "groupAdvantageValues", advantage)
    }
  }
  
  static logHomebrew(message) {
    warhammer.utility.log("Applying Homebrew Rule: " + message, true);
  }

  static extractLinkLabel(link)
  {
    let text;
    try {
      // Extract text
      text = Array.from(link.matchAll(/{(.+?)}/gm))[0][1];
      if (!text)
        text = link;
    }
    catch(e)
    {
      text = link;
    }
    return text
  }

  static mergeCareerReplacements(replacements)
  {

    // For each species in added replacements
    for(let species in replacements)
    {
      // Check if there already is a species listing
      if (game.wfrp4e.config.speciesCareerReplacements[species])
      {
        let currentReplacements = game.wfrp4e.config.speciesCareerReplacements[species];

        // For each career in the added replacements
        for(let career in replacements[species])
        {
          // If there are replacement options already, concatenate them
          if (currentReplacements[career]?.length > 0)
          {
            currentReplacements[career] = currentReplacements[career].concat(replacements[species][career]);
          }
          else  // If no current replacement opions, simply use the added replacements
          {
            currentReplacements[career] = replacements[species][career];
          }
        }
      }
      else // If no species listing, simply use the added replacements 
      {
        game.wfrp4e.config.speciesCareerReplacements[species] = replacements[species];
      }
    }
  }
}

class Advancement
{
    actor = null;

    constructor(actor, career)
    {
        this.actor = actor;
        this.career = career;
    }


    //#region Utility Functions

    
      /**
  * Checks that the selected advancement can be afforded by the actor
  *
  * @param {Integer} total: the xp total for the actor
  * @param {Integer} spent: the spent xp plus cost
  * @param {String} action: the action, buy or improve for example
  * @param {String} item: the title of the skill, talent or characteristic
  */
  static checkValidAdvancement(total, spent, action, item) {
    if(total - spent < 0) {
       throw new Error(game.i18n.format("ACTOR.AdvancementError", { action: action, item: item }));
    }
  }

     /**
   * Looks up advancement cost based on current advancement and type.
   *
   * @param {Number} currentAdvances   Number of advances currently
   * @param {String} type              "characteristic" or "skill"
   * @param {Number} modifier          Cost modifier per advancement
   */
  static calculateAdvCost(currentAdvances, type, modifier = 0) {
    let index = Math.floor(currentAdvances / 5);
    index = index < 0 ? 0 : index; // min 0

    if (index >= game.wfrp4e.config.xpCost[type].length)
      return game.wfrp4e.config.xpCost[type][game.wfrp4e.config.xpCost[type].length - 1] + modifier;
    return game.wfrp4e.config.xpCost[type][index] + modifier;
  }

  /**
   * Looks up a bulk advancement cost based on current advancement and type.
   *
   * @param {Number} start        Number of current advances
   * @param {Number} end          Target number of advances
   * @param {String} type         "characteristic" or "skill"
   * @param {Number} modifier     Cost modifier of the skill
   */
  static calculateAdvRangeCost(start, end, type, modifier = 0) {
    let cost = 0;

    let multiplier = 1;

    // If reverse advance, multiply by -1 to grant XP back
    if (end < start) {
      multiplier = -1;
      let temp = end;
      end = start;
      start = temp;
    }

    while (start < end) {
      cost += this.calculateAdvCost(start, type, modifier);
      start++;
    }
    return cost * multiplier
  }

  static advancementDialog(item, advances, type, actor)
  {
    let start = item instanceof Item ? item.advances.value : actor.system.characteristics[item].advances;
    let end = advances;
    let name = item instanceof Item ? item.name : game.wfrp4e.config.characteristics[item];

    let career = false;
    try 
    {

      if (item instanceof Item)
      {
        let currentCareer = actor.currentCareer;
        if (currentCareer.system.skills.concat(currentCareer.system.addedSkills).find(i => i == item.name))
        {
          career = true;
        }
      }
      else 
      {
        career = actor.system.characteristics[item].career;
      }
    }
    catch(e)
    {
      career = false;
    }
    return new Promise(resolve => {
      let xp = this.calculateAdvRangeCost(start, end, type, item.advances?.costModifier);
      if (!career)
      {
        xp *= 2;
      }
      if (xp) {
        new foundry.applications.api.DialogV2({
          window : { title: game.i18n.localize("DIALOG.Advancement")},
          content: 
          `
          <p>${game.i18n.localize("DIALOG.AdvancementContent")}</p>
          <div class="form-group">
          <input type="number" name="xp" value=${xp}>
          </div>
          `,
          buttons: [
            {action : "ok",
              label: game.i18n.localize("Ok"),
              callback: async (ev, button) => {
                xp = parseInt(button.form.elements.xp.value) || xp;
                if (xp != 0)
                {
                  try {

                    let newSpent = actor.details.experience.spent + xp;
                    this.checkValidAdvancement(actor.details.experience.total, newSpent, game.i18n.localize("ACTOR.ErrorImprove"), name);
                    let log = actor.system.addToExpLog(xp, `${name} (${end-start})`, newSpent);
                    actor.update({ "system.details.experience.spent": newSpent, "system.details.experience.log": log });
                    resolve(true);
                  }
                  catch (e)
                  {
                    ui.notifications.error(e);
                    resolve(false);
                  }
                }
              }
            },
            {
              action : "free",
              label: game.i18n.localize("Free"),
              callback: () => {
                  let newSpent = actor.details.experience.spent;
                  let log = actor.system.addToExpLog(0, `${name} (${end-start})`, newSpent);
                  actor.update({ "system.details.experience.spent": newSpent, "system.details.experience.log": log });
                  resolve(true); 
                }
            }],
          close : () => {resolve(false);}
        }).render(true);
      }
      else resolve(true);
    })
  }

  static async memorizeCostDialog(spell, actor) {
    let xp = this.calculateSpellCost(spell, actor);
    if (xp) {
        return await foundry.applications.api.DialogV2.wait({
          window : {title: game.i18n.localize("DIALOG.MemorizeSpell")},
          content: `<p>${game.i18n.format("DIALOG.MemorizeSpellContent", { xp })}</p>`,
          buttons: [
            {
              action : "ok",
              label: game.i18n.localize("Ok"),
              callback: () => {
                let newSpent = actor.details.experience.spent + xp;
                let log = actor.system.addToExpLog(xp, game.i18n.format("LOG.MemorizedSpell", { name: spell.name }), newSpent);
                actor.update({ "system.details.experience.spent": newSpent, "system.details.experience.log": log });
              }
            },
            {
              action : "free",
              label: game.i18n.localize("Free"),
              callback: () => { 
                let newSpent = actor.details.experience.spent;
                let log = actor.system.addToExpLog(0, game.i18n.format("LOG.MemorizedSpell", { name: spell.name }), newSpent);
                actor.update({ "system.details.experience.spent": newSpent, "system.details.experience.log": log });
              }
            }
          ],
        })
    }
  }


  
  static async miracleGainedDialog(miracle, actor)
  {
    let xp = 100 * (actor.itemTags["prayer"].filter(p => p.prayerType.value == "miracle").length);
    if (xp) {
      return await foundry.applications.api.DialogV2.wait({
        window : {title: game.i18n.localize("DIALOG.GainPrayer")},
        content: `<p>${game.i18n.format("DIALOG.GainPrayerContent", { xp })}</p>`,
        buttons: [
          {
            action : "ok",
            label: game.i18n.localize("Ok"),
            callback: () => {
              let newSpent = actor.details.experience.spent + xp;
              let log = actor.system.addToExpLog(xp, game.i18n.format("LOG.GainPrayer", { name: miracle.name }), newSpent);
              actor.update({ "system.details.experience.spent": newSpent, "system.details.experience.log": log });
            }
          },
          {
            action : "free",
            label: game.i18n.localize("Free"),
            callback: () => { }
          }
        ]
      })
    }
  }

  static calculateSpellCost(spell, actor)
  {
    let cost = 0;
    let bonus = 0;
    let currentlyKnown = 0;

    if (spell.system.ritual.value)
    {
      return spell.system.ritual.xp;
    }


    if (["slaanesh", "tzeentch", "nurgle"].includes(spell.lore.value))
      return 0

    if (spell.lore.value == "petty" || spell.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))
      bonus = actor.characteristics.wp.bonus;
    else 
      bonus = actor.characteristics.int.bonus;

    if (spell.lore.value != "petty" && spell.lore.value != game.i18n.localize("WFRP4E.MagicLores.petty"))
    {
      currentlyKnown = actor.itemTags["spell"].filter(i => i.lore.value == spell.lore.value && i.memorized.value).length;
    }
    else if (spell.lore.value == "petty" || spell.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))
    {
      currentlyKnown = actor.itemTags["spell"].filter(i => i.lore.value == spell.lore.value).length;
      if (currentlyKnown < bonus)
        return 0 // First WPB petty spells are free
    }

    let costKey = currentlyKnown;
    if (spell.lore.value != "petty" && spell.lore.value != game.i18n.localize("WFRP4E.MagicLores.petty"))
      costKey++; // Not sure if this is right, but arcane and petty seem to scale different per th example given

    cost = Math.ceil(costKey / bonus) * 100;

    if (spell.lore.value == "petty" || spell.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty")) cost *= 0.5; // Petty costs 50 each instead of 100

    return cost
  }
  //#endregion


    //#region Auto Advancement
    /* --------------------------------------------------------------------------------------------------------- */
  /* -------------------------------------- Auto-Advancement Functions --------------------------------------- */
  /* --------------------------------------------------------------------------------------------------------- */
  /**
   * These functions are primarily for NPCs and Creatures and their automatic advancement capabilities. 
   *
  /* --------------------------------------------------------------------------------------------------------- */



    /**
   * Advance NPC based on given career
   * 
   * A specialized function used by NPC type Actors that triggers when you click on a 
   * career to be "complete". This takes all the career data and uses it (and the helpers
   * defined above) to advance the actor accordingly. It adds all skills (advanced to the 
   * correct amount to be considered complete), advances all characteristics similarly, and 
   * adds all talents.
   * 
   * Note: This adds *all* skills and talents, which is not necessary to be considered complete.
   * However, I find deleting the ones you don't want to be much easier than trying to pick and 
   * choose the ones you do want.
   *
   */
    async advance() {
        let updateObj = {items : []};
        let advancesNeeded = this.career.system.level.value * 5; // Tier 1 needs 5, 2 needs 10, 3 needs 15, 4 needs 20 in all characteristics and skills
      
        // Update all necessary characteristics to the advancesNeeded
        for (let advChar of Object.keys(this.career.system.characteristics).filter(i => this.career.system.characteristics[i]))
          if (this.actor.system.characteristics[advChar].advances < 5 * this.career.system.level.value)
            updateObj[`system.characteristics.${advChar}.advances`] = 5 * this.career.system.level.value;
    
        // Advance all skills in the career
        for (let skill of this.career.system.skills)
          updateObj.items.push(await this._advanceSkill(skill, advancesNeeded));
    
        // Add all talents in the career
        for (let talent of this.career.system.talents)
          updateObj.items.push(await this._advanceTalent(talent));
    
        ui.notifications.notify(`Advancing ${this.career.name} Characteristics, Skills, and Talents...`);
        this.actor.update(updateObj);
      }

    async advanceSpeciesCharacteristics()
    {

      let species = this.actor.details.species.value;
      let subspecies = this.actor.details.species.subspecies;
         
      let creatureMethod = false;
      let characteristics = this.actor.toObject().system.characteristics;
      if (this.actor.type == "creature" || !species) creatureMethod = true;

      if (!creatureMethod) 
      {
        let averageCharacteristics = await WFRP_Utility.speciesCharacteristics(species, true, subspecies);
        for (let char in characteristics) 
        {
          if (characteristics[char].initial != averageCharacteristics[char].value) creatureMethod = true;
        }
      }
      if (!creatureMethod) 
      {
        let rolledCharacteristics = await WFRP_Utility.speciesCharacteristics(species, false, subspecies);
        for (let char in rolledCharacteristics) 
        {
          characteristics[char].initial = rolledCharacteristics[char].value;
        }
        await this.actor.update({ "system.characteristics": characteristics });
      }
      else if (creatureMethod) 
      {
        let roll = new Roll("2d10");
        await roll.roll({allowInteractive : false});
        let characteristics = this.actor.toObject().system.characteristics;
        for (let char in characteristics) 
        {
          if (characteristics[char].initial == 0)
            continue
          characteristics[char].modifier = -10;
          characteristics[char].modifier += (await roll.reroll()).total;
        }
        await this.actor.update({ "system.characteristics": characteristics });
      }
      return
    }

  /**
   * Advances an actor's skills based on their species and character creation rules
   * 
    * Per character creation, 3 skills from your species list are advanced by 5, and 3 more are advanced by 3.
    * This functions uses the Foundry Roll class to randomly select skills from the list (defined in config.js)
    * and advance the first 3 selected by 5, and the second 3 selected by 3. This function uses the advanceSkill()
    * helper defined below.
   */
  async advanceSpeciesSkills() {
    let skillList;

    // A species may not be entered in the actor, so use some error handling.
    try {
      let { skills } = game.wfrp4e.utility.speciesSkillsTalents(this.actor.system.details.species.value, this.actor.system.details.species.subspecies);
      skillList = skills;
      if (!skillList) {
        throw game.i18n.localize("ErrorSpeciesSkills") + " " + this.actor.system.details.species.value;
      }
    }
    catch (error) {
      ui.notifications.info(`${game.i18n.format("ERROR.Species", { name: this.actor.system.details.species.value })}`);
      warhammer.utility.log("Could not find species " + this.actor.system.details.species.value + ": " + error, true);
      throw error
    }
    // The Roll class used to randomly select skills
    let skillSelector = new Roll(`1d${skillList.length}- 1`);
    await skillSelector.roll({allowInteractive : false});

    // Store selected skills
    let skillsSelected = [];
    while (skillsSelected.length < 6) {
      skillSelector = await skillSelector.reroll();
      if (!skillsSelected.includes(skillSelector.total)) // Do not push duplicates
        skillsSelected.push(skillSelector.total);
    }

    let skills = [];
    // Advance the first 3 by 5, advance the second 3 by 3.
    for (let skillIndex = 0; skillIndex < skillsSelected.length; skillIndex++) {
      if (skillIndex <= 2)
        skills.push(await this._advanceSkill(skillList[skillsSelected[skillIndex]], 5));
      else
        skills.push(await this._advanceSkill(skillList[skillsSelected[skillIndex]], 3));
    }
    this.actor.update({items : skills});
  }


  /**
   * Advances an actor's talents based on their species and character creation rules
   * 
   * Character creation rules for talents state that you get all talents in your species, but there
   * are a few where you must choose between two instead. See config.js for how the species talent 
   * object is set up for support in this. Basically species talents are an array of strings, however
   * ones that offer a choice is formatted as "<talent1>, <talent2>", each talent being a choice. Finally,
   * the last element of the talent list is a number denoting the number of random talents. This function uses
   * the advanceTalent() helper defined below.
   */
  async advanceSpeciesTalents() {
    // A species may not be entered in the actor, so use some error handling.
    let talentList;
    try {
      let { talents } = game.wfrp4e.utility.speciesSkillsTalents(this.actor.system.details.species.value, this.actor.system.details.species.subspecies);
      talentList = talents;
      if (!talentList) {
      }
    }
    catch (error) {
      ui.notifications.info(`${game.i18n.format("ERROR.Species", { name: this.actor.system.details.species.value })}`);
      warhammer.utility.log("Could not find species " + this.actor.system.details.species.value + ": " + error, true);
      throw error
    }
    let talentSelector;
    let talentsToAdd = [];
    for (let talent of talentList) {
      if (!isNaN(talent)) // If is a number, roll on random talents
      {
        for (let i = 0; i < talent; i++) {
          let result = await game.wfrp4e.tables.rollTable("talents");
          talentsToAdd.push(await this._advanceTalent(result.object.name));
        }
        continue
      }
      // If there is a comma, talent.split() will yield an array of length > 1
      let talentOptions = talent.split(',').map(function (item) {
        return item.trim();
      });

      // Randomly choose a talent option and advance it.
      if (talentOptions.length > 1) {
        talentSelector = await new Roll(`1d${talentOptions.length} - 1`).roll({allowInteractive : false});
        talentsToAdd.push(await this._advanceTalent(talentOptions[talentSelector.total]));
      }
      else // If no option, simply advance the talent.
      {
        talentsToAdd.push(await this._advanceTalent(talent));
      }
    }

    this.actor.createEmbeddedDocuments("Item", talentsToAdd);

  }


  /**
   * Adds (if needed) and advances a skill by the specified amount.
   * 
   * As the name suggests, this function advances any given skill, if 
   * the actor does not currently have that skill, it will be added 
   * from the compendium and advanced. Note that this function is neither
   * used by manually advancing skills nor when clicking on advancement 
   * indicators. This will simply add the advancement value with no
   * other processing.
   * 
   * @param {String} skillName    Name of the skill to advance/add
   * @param {Number} advances     Advances to add to the skill
   */
  async _advanceSkill(skillName, advances) {
    // Look through items and determine if the actor has the skill
    let existingSkill = this.actor.has(skillName, "skill");
    // If so, simply update the skill with the new advancement value. 
    if (existingSkill) {
      existingSkill = existingSkill.toObject();
      existingSkill.system.advances.value = (existingSkill.system.advances.value < advances) ? advances : existingSkill.system.advances.value;
      return existingSkill;
    }

    // If the actor does not already own skill, search through compendium and add it
    try {
      // See findSkill() for a detailed explanation of how it works
      // Advanced find function, returns the skill the user expects it to return, even with skills not included in the compendium (Lore (whatever))
      let skillToAdd = (await game.wfrp4e.utility.findSkill(skillName)).toObject();
      skillToAdd.system.advances.value = advances;
      return skillToAdd;
    }
    catch (error) {
      console.error("Something went wrong when adding skill " + skillName + ": " + error);
      ui.notifications.error(game.i18n.format("CAREER.AddSkillError", { skill: skillName, error: error }));
    }
  }

  /**
   * Adds the given talent to the actor
   * 
   * In my implementation, adding a talent is the same as advancing a talent. See
   * prepareTalent() and you'll see that the total number of any given talent is the
   * advencement value.
   * 
   * @param {String} talentName     Name of the talent to add/advance.
   */
  async _advanceTalent(talentName) {
    try {
      // See findTalent() for a detailed explanation of how it works
      // Advanced find function, returns the Talent the user expects it to return, even with Talents not included in the compendium (Etiquette (whatever))
      let talent = await game.wfrp4e.utility.findTalent(talentName);
      return talent.toObject();
    }
    catch (error) {
      console.error("Something went wrong when adding talent " + talentName + ": " + error);
      ui.notifications.error(game.i18n.format("CAREER.AddTalentError", { talent: talentName, error: error }));
    }
  }

  //#endregion
}

/**
 * WIP
 * This class contains functions and helpers related to the market and Pay system
 */
class TravelDistanceWFRP4e {
    /**
    * This method load the travel data from the internal JSON file
    */
    static async loadTravelData() {

        foundry.applications.apps.FilePicker.implementation.browse("data", `systems/wfrp4e/data/`).then(resp => {

        for (var file of resp.files) {
          try {
            if (!file.endsWith(".json"))
              continue
            let filename = file.substring(file.lastIndexOf("/") + 1, file.indexOf(".json"));

            fetch(file).then(r => r.json()).then(async records => {
                this.travel_data = records;
            });
          }
          catch (error) {
            console.error("Error reading " + file + ": " + error);
          }
        }
    });
  }

  /**
   * Returns a human-readable danger level for the road
  */
  static dangerToString( dangerLevel )
  {
    if ( dangerLevel == "") return game.i18n.localize("TRAVEL.DangerVeryLow");
    if ( dangerLevel == '!') return game.i18n.localize("TRAVEL.DangerLow");
    if ( dangerLevel == '!!') return game.i18n.localize("TRAVEL.DangerMedium");
    if ( dangerLevel == '!!!') return game.i18n.localize("TRAVEL.DangerHigh");
    return game.i18n.localize("TRAVEL.DangerVeryHigh");
  }

  /**
   * Returns either a decimal value or x.5 value
   * @param {Number} duration 
   * @returns new duration
   */
  static roundDuration( duration ) 
  {
    let trunc = Math.trunc(duration);
    let frac = duration - trunc;
    let adjust = 0;
    if ( frac > 0.75) adjust = 1;
    else if ( frac >= 0.25) adjust = 0.5;
    return trunc + adjust;
  }

    /**
    * This method either display the distances between 2 towns (ie when toTown is set) or display a list of destinations
    * @param {string} fromTown
    * @param {string} toTown
    * @returns 
    */
   static displayTravelDistance( fromTown, toTown ) {
    
    let message = "";

    //("TRAVEL ...", fromTown, toTown );
    if ( toTown ) {
      fromTown = fromTown.toLowerCase();
      toTown = toTown.toLowerCase();
      for ( var travel of this.travel_data) {
        if ( travel.from.toLowerCase() == fromTown && travel.to.toLowerCase() == toTown ) {
          message += `<p>${game.i18n.format("TRAVEL.TravelMessageBase", travel)}`;
          if ( travel.road_distance != "" ) {
            travel.road_horse_heavy_days = this.roundDuration( travel.road_days * 0.8);
            travel.road_horse_fast_days  = this.roundDuration( travel.road_days * 0.65);
            travel.road_feet_days  = this.roundDuration( travel.road_days * 1.25 );
            travel.road_danger_string = this.dangerToString( travel.road_danger );
            travel.road_danger_feet_string = this.dangerToString( travel.road_danger + "!" ); // Increase danger level by feet
            message += `${game.i18n.format("TRAVEL.TravelMessageRoad", travel)}`;                    
          }
          if ( travel.river_distance != "" ) {
            travel.river_danger_string = this.dangerToString( travel.river_danger );
            message += `${game.i18n.format("TRAVEL.TravelMessageRiver", travel)}`;                    
          }
          if ( travel.sea_distance != "" ) {
            travel.sea_danger_string = this.dangerToString( travel.sea_danger );
            message += `${game.i18n.format("TRAVEL.TravelMessageSea", travel)}`;                    
          }
          message += "</p>";
        }
      }
    
    } else if ( fromTown && fromTown == "help") {
      message += `<p>${game.i18n.localize("TRAVEL.Helper")}</p>`;

    } else if ( fromTown) {
      fromTown = fromTown.toLowerCase();
      message += `<h3>${game.i18n.localize("TRAVEL.TownPrompt")}</h3>`;
      for ( var travel of this.travel_data) {
        if ( travel.from.toLowerCase() == fromTown ) {
          message += `<p><a class="action-link" data-action="clickTravel" data-from="${travel.from}" data-to="${travel.to}"><i class="fas fa-list"></i> ${travel.to}</a></p>`;
        }
      }
    } else {
      message += `<h3>${game.i18n.localize("TRAVEL.TownOriginPrompt")}</h3>`;
      let uniqTown = {};
      for ( var travel of this.travel_data) {
        if ( uniqTown[travel.from] == undefined ) {
          uniqTown[travel.from] = 1; // Already added in the list
          message += `<p><a class="action-link" data-action="clickTravel" data-from="${travel.from}"><i class="fas fa-list"></i> ${travel.from}</a></p>`;
        }
      }
    }
    ChatMessage.create( WFRP_Utility.chatDataSetup( message, "gmroll" ) );      
   }

   /**
    * 
    */
   static handleTravelClick( event, target ) {
    let fromTown = target.dataset.from;
    let toTown = target.dataset.to;
    TravelDistanceWFRP4e.displayTravelDistance( fromTown, toTown);
   }
}

class GenericActions
{

    static actions = {
        clickSymptom : WFRP_Utility.handleSymptomClick.bind(WFRP_Utility),
        clickConditionText : WFRP_Utility.handleConditionClick.bind(WFRP_Utility),
        clickProperty : WFRP_Utility.handlePropertyClick.bind(WFRP_Utility),
        clickTable : WFRP_Utility.handleTableClick.bind(WFRP_Utility),
        clickPay : WFRP_Utility.handlePayClick.bind(WFRP_Utility),
        clickCredit : WFRP_Utility.handleCreditClick.bind(WFRP_Utility),
        clickCorruption : WFRP_Utility.handleCorruptionClick.bind(WFRP_Utility),
        clickFear : WFRP_Utility.handleFearClick.bind(WFRP_Utility),
        clickTerror : WFRP_Utility.handleTerrorClick.bind(WFRP_Utility),
        clickExp : WFRP_Utility.handleExpClick.bind(WFRP_Utility),
        clickTravel : TravelDistanceWFRP4e.handleTravelClick.bind(TravelDistanceWFRP4e),
        clickSkill : this.onClickSkill,
        clickTalent : this.onClickTalent
    }

    static addEventListeners(html, document)
    {
        html.addEventListener("click", ev => {
            let element = ev.target.closest("[data-action]");
            if (!element) return;

            let action = this.actions[element.dataset.action];
            if (action)
            {
                action.bind(document)(ev, element);
            }
        });
    }

    static onClickSkill(ev)
    {
        WFRP_Utility.findSkill(ev.target.text).then(skill => skill.sheet.render(true));
    }

    static onClickTalent(ev)
    {
        WFRP_Utility.findTalent(ev.target.text).then(talent => talent.sheet.render(true));
    }
 
}

class ActorSettings extends WHFormApplication
{
  static DEFAULT_OPTIONS = {
    id: "actor-settings",
    tag: "form",
    classes : ["warhammer", "standard-form"],
    window: {
      contentClasses : ["standard-form"],
      title: "Actor Settings"
    },
    form: {
      submitOnChange: true,
      closeOnSubmit: false,
      handler : this.submit
    }
}

get title() 
{
    return `Actor Settings: ${this.document.name}`;
}

constructor(document, options)
{
    super(options);
    this.document = document;
}

  /** @override */
  static PARTS = {
    form: {
      classes: ["standard-form"],
      template: "systems/wfrp4e/templates/apps/actor-settings.hbs",
      scrollable: [""]
    }
  };

    async _prepareContext(options) 
    {
        let context = await super._prepareContext(options);
        context.tables =  game.wfrp4e.config.hitLocationTables;

        context.fields = this.document.system.schema.fields;
        context.source = this.document._source;

        context.displays = {};

        if (this.document.type == "character")
        {
            context.displays.size = true;
            context.displays.movement = true;
            context.displays.wounds = true;
            context.displays.critwounds = true;
            context.displays.corruption = true;
            context.displays.encumbrance = true;
            context.displays.hitloc = true;
            context.displays.equipPoints = true;
            context.displays.mainHand = true;
        }
        if (this.document.type == "npc")
        {
            context.displays.size = true;
            context.displays.movement = true;
            context.displays.wounds = true;
            context.displays.critwounds = true;
            context.displays.encumbrance = true;
            context.displays.hitloc = true;
            context.displays.equipPoints = true;
            context.displays.mainHand = true;
        }
        if (this.document.type == "creature")
        {
            context.displays.size = true;
            context.displays.movement = true;
            context.displays.wounds = true;
            context.displays.critwounds = true;
            context.displays.encumbrance = true;
            context.displays.hitloc = true;
            context.displays.equipPoints = true;
        }
        if (this.document.type == "vehicle")
        {
            context.displays.vehicle = true;
            context.displays.critwounds = true;
            context.displays.hitloc = true;
        }

        return context;
    }

    static async submit(event, form, formData) 
    {
        return this.document.update(formData.object)
    }

}

class BaseWFRP4eActorSheet extends WarhammerActorSheetV2
{

  static DEFAULT_OPTIONS = {
    classes: ["wfrp4e"],
    window : {
      controls : [
        {
          icon : 'fa-solid fa-gear',
          label : "Actor Settings",
          action : "configureActor"
        }
      ]
    },
    actions : {
      rollTest : this._onRollTest,
      toggleSummary : this._toggleSummary,
      toggleSummaryAlt : {buttons: [2], handler : this._toggleSummary}, // TODO secondary actions
      toggleExtendedTests : this._toggleExtendedTests,
      removeAttacker : this._onRemoveAttacker,
      itemPropertyDropdown : this._onItemPropertyDropdown,
      combatDropdown : this._onCombatDropdown,
      clickCondition : {buttons : [0, 2], handler : this._onClickCondition},
      removeFromContainer : this._onRemoveItemFromContainer,
      convertCurrency : this._onConvertCurrency,
      consolidateCurrency : this._onConsolidateCurrency,
      collapseSection : this._onCollapseSection,
      containerSort : this._onContainerSort,
      createItem : this._onCreateItem,
      configureActor : this._onConfigureActor,
      useAspect : this._onUseAspect,
      toggleQuality : this._onToggleQuality,
      groupActions : this._onToggleGroupActions,
      useGroupAction : this._onUseGroupAction,
      postItemProperty: this._postItemProperty
    },
    defaultTab : "main"
  }

  _prepareTabs(options) {
    let tabs = super._prepareTabs(options);

    if (!this.actor.hasSpells) {
      delete tabs.magic;
    }

    if (!this.actor.hasPrayers) {
      delete tabs.religion;
    }

    return tabs;
  }

  
  async _onFirstRender(context, options)
  {
      await super._onFirstRender(context, options);

      this.setTheme();
  }

  setTheme(theme = game.settings.get("wfrp4e", "theme"))
  {
    if (!theme.actor.enabled)
    {
      this.element.classList.add("no-theme");
      this.element.classList.remove("classic-font");
    }
    else 
    {
      this.element.classList.remove("no-theme");

      if (theme.actor.font == "classic")
      {
        this.element.classList.add("classic-font");
      }
      else
      {
        this.element.classList.remove("classic-font");
      }
    }
  }


  async _prepareContext(options)
  {
    let context = await super._prepareContext(options);
    context.items = foundry.utils.deepClone(this.actor.itemTags);
    let aspects = {
      talents : {}, 
      effects : {}, 
      combat : {},
      magic: {}
    };
    this.actor.itemTags.aspect?.forEach(item => {
        if (aspects[item.system.placement][item.system.pluralLabel])
        {
          aspects[item.system.placement][item.system.pluralLabel].push(item);
        }
        else 
        {
          aspects[item.system.placement][item.system.pluralLabel] = [item];
        }
    });
    if (context.system.status?.armour)
    {
      this.formatArmourSection(context);
    }
    context.items.aspect = aspects;
    context.showExtendedTests = this.showExtendedTests;
    return context;
  }

    //#region Trappings
    prepareInventory() {

      let collapsed = this.actor.getFlag("wfrp4e", "sheetCollapsed");
      // Inventory object is for the Trappings tab - each sub object is for an individual inventory section
      const categories = {
        weapons: {
          label: game.i18n.localize("WFRP4E.TrappingType.Weapon"), // Label - what is displayed in the inventory section header
          items: this.actor.itemTags["weapon"], // Array of items in the sectio.filter(i => !i.system.location.value)n
          toggle: true,                                 // Is there a toggle in the section? (Equipped, worn, etc.)
          toggleName: game.i18n.localize("Equipped"),   // What is the name of the toggle in the header
          show: false,                                  // Should this section be shown (if an item exists in this list, it is set to true)
          collapsed: collapsed?.weapons,
          dataType: "weapon"                            // What type of FVTT Item is in this section (used by the + button to add an item of this type)
        },
        armor: {
          label: game.i18n.localize("WFRP4E.TrappingType.Armour"),
          items: this.actor.itemTags["armour"],
          toggle: true,
          toggleName: game.i18n.localize("Worn"),
          show: false,
          collapsed: collapsed?.armor,
          dataType: "armour"
        },
        ammunition: {
          label: game.i18n.localize("WFRP4E.TrappingType.Ammunition"),
          items: this.actor.itemTags["ammunition"],
          show: false,
          collapsed: collapsed?.ammunition,
          dataType: "ammunition"
        },
        clothingAccessories: {
          label: game.i18n.localize("WFRP4E.TrappingType.ClothingAccessories"),
          items: this.actor.itemTags["trapping"].filter(i => i.system.trappingType.value == "clothingAccessories"),
          toggle: true,
          toggleName: game.i18n.localize("Worn"),
          show: false,
          collapsed: collapsed?.clothingAccessories,
          dataType: "trapping"
        },
        booksAndDocuments: {
          label: game.i18n.localize("WFRP4E.TrappingType.BooksDocuments"),
          items: this.actor.itemTags["trapping"].filter(i => i.system.trappingType.value == "booksAndDocuments"),
          show: false,
          collapsed: collapsed?.booksAndDocuments,
          dataType: "trapping"
        },
        toolsAndKits: {
          label: game.i18n.localize("WFRP4E.TrappingType.ToolsKits"),
          items: this.actor.itemTags["trapping"].filter(i => i.system.trappingType.value == "toolsAndKits" || i.system.trappingType.value == "tradeTools"),
          show: false,
          collapsed: collapsed?.toolsAndKits,
          dataType: "trapping"
        },
        foodAndDrink: {
          label: game.i18n.localize("WFRP4E.TrappingType.FoodDrink"),
          items: this.actor.itemTags["trapping"].filter(i => i.system.trappingType.value == "foodAndDrink"),
          show: false,
          collapsed: collapsed?.foodAndDrink,
          dataType: "trapping"
        },
        drugsPoisonsHerbsDraughts: {
          label: game.i18n.localize("WFRP4E.TrappingType.DrugsPoisonsHerbsDraughts"),
          items: this.actor.itemTags["trapping"].filter(i => i.system.trappingType.value == "drugsPoisonsHerbsDraughts"),
          show: false,
          collapsed: collapsed?.drugsPoisonsHerbsDraughts,
          dataType: "trapping"
        },
        misc: {
          label: game.i18n.localize("WFRP4E.TrappingType.Misc"),
          items: this.actor.itemTags["trapping"].filter(i => i.system.trappingType.value == "misc" || !i.system.trappingType.value),
          show: true,
          collapsed: collapsed?.misc,
          dataType: "trapping"
        },
        ingredient: {
          label: game.i18n.localize("WFRP4E.TrappingType.Ingredient"),
          items: this.actor.itemTags["trapping"].filter(i => i.system.trappingType.value == "ingredient"),
          show: false,
          collapsed: collapsed?.ingredient,
          dataType: "trapping"
        },
        cargo: {
          label: game.i18n.localize("WFRP4E.TrappingType.Cargo"),
          items: this.actor.itemTags["cargo"],
          show: false,
          collapsed: collapsed?.cargo,
          dataType: "cargo"
        }
      };
  
      const money = {
        items: this.actor.itemTags["money"],
        total: 0,     // Total coinage value
        show: true,
        collapsed : false
      };
      const containers = {
        items: this.actor.itemTags["container"],
        show: false
      };
      const misc = {};
      let inContainers = []; // inContainers is the temporary storage for items within a container
  
      
      if (this.actor.hasSpells || this.actor.type == "vehicle")
        inContainers = this._filterItemCategory(categories.ingredient, inContainers);
      else
      {
        categories.misc.items = categories.misc.items.concat(categories.ingredient.items);
        delete categories.ingredient;
      }
  
      // Allow 3rd party modules to expand Inventory by adding new categories
      Hooks.callAll("wfrp4e:constructInventory", this, categories, collapsed);
  
      for (let itemCategory in categories)
        inContainers = this._filterItemCategory(categories[itemCategory], inContainers);
  
      inContainers = this._filterItemCategory(money, inContainers);
      inContainers = this._filterItemCategory(containers, inContainers);
  
      // Add names of containers to item.location object. Used for ammo selection
      inContainers.forEach(i => {
        const container = this.actor.itemTags["container"].find(c => c.id === i.system.location.value);
        i.system.location.name = container?.name || false;
      });
  
      misc.totalShieldDamage = categories["weapons"].items.reduce((prev, current) => prev += current.system.damageToItem.shield, 0);
  
      money.total = money.items.reduce((prev, current) => { return prev + (current.system.coinValue.value * current.system.quantity.value) }, 0);
  
      categories.misc.show = true;
  
      // ******************************** Container Setup ***********************************
  
      for (var cont of this.actor.itemTags["container"]) // For each container
      {
        // All items referencing (inside) that container
        var itemsInside = inContainers.filter(i => i.system.location.value == cont.id);
        cont.system.carrying = itemsInside.filter(i => i.type != "container");//.sort((a, b) => a.sort - b.sort);    // cont.system.carrying -> items the container is carrying
        cont.system.packsInside = itemsInside.filter(i => i.type == "container");//.sort((a, b) => a.sort - b.sort); // cont.system.packsInside -> containers the container is carrying
        cont.system.carries.current = itemsInside.reduce(function (prev, cur) {   // cont.system.holding -> total encumbrance the container is holding
          return Number(prev) + Number(cur.system.encumbrance.total);
        }, 0);
        cont.system.carries.current = Math.floor(cont.system.carries.current * 10) / 10;
        cont.system.collapsed = this.actor.getFlag("wfrp4e", "sheetCollapsed")?.[cont.id];
      }
  
      return {
        categories,
        money,
        containers,
        misc
      }
    }
    
    _filterItemCategory(category, itemsInContainers) {
      itemsInContainers = itemsInContainers.concat(category.items.filter(i => !!i.system.location?.value));
      category.items = category.items.filter(i => !i.system.location?.value);//.sort((a, b) => a.sort - b.sort);
      category.show = category.items.length > 0;
      return itemsInContainers
    }

  formatArmourSection(context) {
    let AP = context.system.status.armour;

    // Change out hit locations if using custom table
    let table = game.wfrp4e.tables.findTable(context.system.details.hitLocationTable.value);
    for (let loc in AP) {
      if (loc == "shield" || loc == "shieldDamage")
        continue
      if (table)
      {
        try {
          let result  = table.results.find(r => r.getFlag("wfrp4e", "loc") == loc);
          if (result)
          AP[loc].label = game.i18n.localize(result.description);
          else
          AP[loc].show = false;
        }
        catch(e)
        {
          ui.notifications.error("Error formatting armour section using Hit Location Table, using fallback implementation");
          warhammer.utility.log("Hit Location Format Error: " + e, true);
          AP[loc].label = game.i18n.localize(game.wfrp4e.config.locations[loc]);
        }
      }
      else if (game.wfrp4e.config.locations[loc]) // fallback implementation
      {
        AP[loc].label = game.i18n.localize(game.wfrp4e.config.locations[loc]);
      }
    }
  }
  _getContextMenuOptions()
  { 
    let getParent = this._getParent.bind(this);
    return [
      {
        name: "Edit",
        icon: '<i class="fas fa-edit"></i>',
        condition: li => !!li.dataset.uuid || getParent(li, "[data-uuid]"),
        callback: async li => {
          let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
          const document = await fromUuid(uuid);
          document.sheet.render(true);
        }
      },
      {
        name: "Remove",
        icon: '<i class="fas fa-times"></i>',
        condition: li => {
          let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
          if (uuid)
          {
            let parsed = foundry.utils.parseUuid(uuid);
            if (parsed.type == "ActiveEffect")
            {
              return parsed.primaryId == this.document.id; // If an effect's parent is not this document, don't show the delete option
            }
            else if (parsed.type)
            {
              return true;
            }
            return false;
          }
          else return false;
        },
        callback: async li => 
        {
          let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
          const document = await fromUuid(uuid);
          document.delete();
        }
      },
      {
        name: "Post to Chat",
        icon: '<i class="fas fa-comment"></i>',
        condition: li => {
          let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
          if (uuid)
          {
            let parsed = foundry.utils.parseUuid(uuid);
            return parsed.type == "Item"; // Can only post Items to chat
          }
          else return false;
        },
        callback: async li => 
        {
          let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
          const document = await fromUuid(uuid);
          document.postItem();
        }
      },
      {
        name: "Duplicate",
        icon: '<i class="fa-solid fa-copy"></i>',
        condition: li => {
          let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
          if (uuid && !uuid.includes("Compendium"))
          {
            let doc = fromUuidSync(uuid);
            return doc?.documentName == "Item" && doc.system.isPhysical; // Can only duplicate physical items
          }
          else return false;
        },
        callback: async li => 
        {
            let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
            const document = await fromUuid(uuid);
            this.actor.createEmbeddedDocuments("Item", [document.toObject()]);
        }
      },
      {
        name: "Split",
        icon: '<i class="fa-solid fa-split"></i>',
        condition: li => {
          let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
          if (uuid && !uuid.includes("Compendium"))
          {
            let doc = fromUuidSync(uuid);
            return doc?.documentName == "Item" && doc.system.isPhysical; // Can only split physical items
          }
          else return false;
        },
        callback: async li => 
        {
            let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
            if (uuid)
            {
              let doc = fromUuidSync(uuid);
              let amt = await ValueDialog.create({title : game.i18n.localize("SHEET.SplitTitle"), text : game.i18n.localize("SHEET.SplitPrompt")});
              doc.system.split(amt);
            }
        }
      }
    ];
  }

  async _onDropItem(data, ev)
  {
      let containerDropElement = this._getParent(ev.target, ".container-drop");
      if (containerDropElement)
      {
        let document = await fromUuid(data.uuid);
        let container = await fromUuid(containerDropElement.dataset.uuid);

        let documentData = document.toObject();

        //
        if (container.id == document.system.location.value)
        {
          return super._onDropItem(data, ev);
        }
        if (container)
        {
          documentData.system.location.value = container.id;
          foundry.utils.setProperty(documentData, "system.equipped.value", false);
          
          // This handles both updating when dragging within the same sheet and creating a new item when dragging from another sheet
          this.document.updateEmbeddedDocuments("Item",  [documentData]);
        }
      }
      else 
      {
        return super._onDropItem(data, ev);
      }
  }

  // From Income results - drag money value over to add
  _onDropIncome(data)
  {
    this.document.updateEmbeddedDocuments("Item", MarketWFRP4e.addMoneyTo(this.document, data.amount));
  }

  //#region Effects

  _prepareEffectsContext(context) {
    super._prepareEffectsContext(context);
    
    context.effects.passive = this._consolidateEffects(context.effects.passive);
    context.effects.temporary = this._consolidateEffects(context.effects.temporary);
    context.effects.disabled = this._consolidateEffects(context.effects.disabled);
    context.effects.system = game.wfrp4e.utility.getSystemEffects(this.actor.type == "vehicle");

  }


  _getConditionData(context) {
    try {
      let conditions = foundry.utils.duplicate(game.wfrp4e.config.statusEffects).map(e => new ActiveEffect.implementation(e));
      let currentConditions = this.actor.effects.filter(e => e.isCondition);
      delete conditions.splice(conditions.length - 1, 1);

      for (let condition of conditions) {
        let owned = currentConditions.find(e => e.conditionId == condition.conditionId);
        if (owned) {
          condition.existing = true;
          condition.system.condition.value = owned.conditionValue;
        }
        else if (condition.isNumberedCondition) {
          condition.system.condition.value = 0;
        }
      }
      return conditions;
    }
    catch (e)
    {
      ui.notifications.error("Error Adding Condition Data: " + e);
    }
  }

  _consolidateEffects(effects) {
    let consolidated = [];
    for (let effect of effects) {
      let existing = consolidated.find(e => e.name == effect.name);
      if (!existing)
        consolidated.push(effect);
    }
    for (let effect of consolidated) {
      let count = effects.filter(e => e.name == effect.name).length;
      effect.count = count;
    }
    return consolidated
  }

  //#endregion

  /** @inheritDoc */
  _attachFrameListeners() {
    super._attachFrameListeners();
    GenericActions.addEventListeners(this.element, this);
  }

  _addEventListeners()
  {
    super._addEventListeners();
    this.element.querySelectorAll('.symptom-tag').forEach(el => el.addEventListener("click", WFRP_Utility.handleSymptomClick.bind(WFRP_Utility)));
    this.element.querySelectorAll('.condition-chat').forEach(el => el.addEventListener("click", WFRP_Utility.handleConditionClick.bind(WFRP_Utility)));
    this.element.querySelectorAll('.property-chat').forEach(el => el.addEventListener("click", WFRP_Utility.handlePropertyClick.bind(WFRP_Utility)));
    this.element.querySelectorAll('.table-click').forEach(el => el.addEventListener("click", WFRP_Utility.handleTableClick.bind(WFRP_Utility)));
    this.element.querySelectorAll('.pay-link').forEach(el => el.addEventListener("click", WFRP_Utility.handlePayClick.bind(WFRP_Utility)));
    this.element.querySelectorAll('.credit-link').forEach(el => el.addEventListener("click", WFRP_Utility.handleCreditClick.bind(WFRP_Utility)));
    this.element.querySelectorAll('.corruption-link').forEach(el => el.addEventListener("click", WFRP_Utility.handleCorruptionClick.bind(WFRP_Utility)));
    this.element.querySelectorAll('.fear-link').forEach(el => el.addEventListener("click", WFRP_Utility.handleFearClick.bind(WFRP_Utility)));
    this.element.querySelectorAll('.terror-link').forEach(el => el.addEventListener("click", WFRP_Utility.handleTerrorClick.bind(WFRP_Utility)));
    this.element.querySelectorAll('.exp-link').forEach(el => el.addEventListener("click", WFRP_Utility.handleExpClick.bind(WFRP_Utility)));

    this.element.querySelector(".system-effects")?.addEventListener("change", (ev) => {
      let key = ev.target.value;
      this.actor.addSystemEffect(key);
    });

    this.element.querySelectorAll(".rollable").forEach(element => {
      element.addEventListener("mouseenter", ev => {
        let img = ev.target.matches("img") ? ev.target : ev.target.querySelector("img") ;
        if (img)
        {
          this._icon = img.src;
          img.src = "systems/wfrp4e/ui/buttons/d10.webp";
        }
      });
      element.addEventListener("mouseleave", ev => {
        let img = ev.target.matches("img") ? ev.target : ev.target.querySelector("img") ;
        if (img)
        {
          img.src = this._icon;
        }
      });
    });
  }


  async _handleEnrichment() {
    let enrichment = {};
    enrichment["system.details.biography.value"] = await foundry.applications.ux.TextEditor.implementation.enrichHTML(this.actor.system.details.biography.value, { async: true, secrets: this.actor.isOwner, relativeTo: this.actor });
    enrichment["system.details.gmnotes.value"] = await foundry.applications.ux.TextEditor.implementation.enrichHTML(this.actor.system.details.gmnotes.value, { async: true, secrets: this.actor.isOwner, relativeTo: this.actor });

    enrichment.conditions = {};

    for(let c in game.wfrp4e.config.conditionDescriptions)
    {
      enrichment.conditions[c] = await foundry.applications.ux.TextEditor.implementation.enrichHTML(game.wfrp4e.config.conditionDescriptions[c]);
    }
    return foundry.utils.expandObject(enrichment)
  }

    /**
     * Prevent effects from stacking up each form submission
   * @override
   */
    async _processSubmitData(event, form, submitData) {
      let diffData = foundry.utils.diffObject(this.document.toObject(false), submitData);
      await this.document.update(diffData);
    }
  

  //#region Action Handlers

    static async _onCreateItem(ev) 
    {
        let type = this._getParent(ev.target, "[data-type]").dataset.type;
        let category = this._getParent(ev.target, "[data-type]").dataset.category;
        let itemData = {type, name : `New ${game.i18n.localize(CONFIG.Item.typeLabels[type])}`};

        if (type == "trapping")
        {
          itemData["system.trappingType.value"] = category;
        }
        else if (type == "spell" && category == "petty")
        {
          itemData["system.lore.value"] = category;
        }
        else if (type == "prayer")
        {
          itemData["system.type.value"] = category;
        }
        else if (type == "trait")
        {
          itemData["system.category"] = category || "standard";
        }

        this.document.createEmbeddedDocuments("Item", [itemData]).then(item => item[0].sheet.render(true));
    }

    static async _onConfigureActor(ev)
    {
      new ActorSettings(this.actor).render(true);
    }

    static async _onUseAspect(ev)
    {
      let document = await this._getDocumentAsync(ev);
      if (document && document.system.usable)
      {
        document.system.use();
      }
    }
    
    static async _onUseGroupAction(ev, target)
    {
      let index = target.dataset.index;

      let action = game.wfrp4e.config.groupAdvantageActions[index];

      if ((await this.actor.spend("system.status.advantage.value", action.cost)))//action.cost > this.actor.status.advantage.value)
      {
        if (action)
          {
            let html = await foundry.applications.ux.TextEditor.enrichHTML(`
            <p><strong>${action.name}</strong>: ${action.description}</p>
            <p>${action.effect}</p>
            `);
    
            ChatMessage.create({
              content : html,
              speaker : {alias : this.actor.token?.name || this.actor.prototypeToken.name},
              flavor : "Group Advantage Action"
            });
    
            if (action.test)
            {
              if (action.test.type == "characteristic")
              {
                this.actor.setupCharacteristic(action.test.value, {appendTitle : ` - ${action.name}`}).then(test => test.roll());
              }
            }
          }
      }
      else 
      {
        return ui.notifications.error("Not enough Advantage!")
      }


    }

    static async _onToggleQuality(ev)
    {
      let document = await this._getDocumentAsync(ev);
      let index = this._getIndex(ev);

      let inactive = Object.values(document.system.properties.inactiveQualities);
  
      // Find clicked quality
      let toggled = inactive[index];
  
      // Find currently active
      let qualities = foundry.utils.deepClone(document.system.qualities.value);
  
      // Disable all qualities of clicked group
      qualities.filter(i => i.group == toggled.group).forEach(i => i.active = false);
  
      // Enabled clicked quality
      qualities.find(i => i.name == toggled.key).active = true;
  
      document.update({"system.qualities.value" : qualities});
    }

    static async _onToggleGroupActions(ev, target)
    {
      let actions = this.element.querySelector(".group-actions");
      if (actions.children.length > 0)
      {
        target.querySelector("i").classList.replace("fa-chevron-up", "fa-chevron-down");
        actions.replaceChildren();
        this._toggleDropdownAt(actions);
      }
      else 
      {
        target.querySelector("i").classList.replace("fa-chevron-down", "fa-chevron-up");
        let html = ``;
        if (game.wfrp4e.config.groupAdvantageActions.length > 0) 
        {
          game.wfrp4e.config.groupAdvantageActions.forEach((action, i) => {
            html += `<div class="action">
              <button data-action="useGroupAction" data-index="${i}">${action.name}</button>
              <p>${action.description}</p>
              <p class="cost"><strong>Cost</strong>: ${action.cost}</p>
              <p class="effect">${action.effect}</p>
              </div><hr>`;
          });
        }
        else 
        {
          html = "No Actions Available";
        }

        this._toggleDropdownAt(actions, await foundry.applications.ux.TextEditor.enrichHTML(html));
      }
    }

    static async _onRollTest(ev)
    {
      let test;
      let document = await this._getDocumentAsync(ev);
      let options = {fields : {}};
      let target = this._getParent(ev.target, "[data-action='rollTest']");
      if (target)
      {
        options.fields.modifier = Number(target.dataset.modifier) || 0;
      }
      switch (target.dataset.type)
      {
        case "characteristic": 
          test = await this.document.setupCharacteristic(ev.target.dataset.characteristic, options);
          break;
        case "skill":
          test = await this.document.setupSkill(document.name, options);
          break;
        case "extendedTest":
          test = await this.document.setupExtendedTest(document, options);
          break;
        case "trait":
          test = await this.document.setupTrait(document, options);
          break;
        case "weapon":
          test = await this.document.setupWeapon(document, options);
          break;
        case "spell":
          test = await this.castOrChannelPrompt(document, options);
          break;
        case "prayer":
          test = await this.actor.setupPrayer(document, options);
          break;
      }

      test?.roll();
    }

    castOrChannelPrompt(spell, options = {}) {
      // Do not show the dialog for Petty spells, just cast it.
      if (spell.system.lore.value == "petty" || spell.system.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))
      {
        return this.actor.setupCast(spell, options)
      }
      else {
          return foundry.applications.api.DialogV2.wait({
            window : {title: game.i18n.localize("DIALOG.CastOrChannel")},
            content: `<div class="cast-channel-dialog selection"> 
                      <p>${game.i18n.localize("DIALOG.CastChannel")}</p> 
                      </div>`,
            buttons: [
              {
                action : "cast",
                default: true,
                label: game.i18n.localize("Cast"),
                callback: btn => {
                  return this.actor.setupCast(spell, options);
                }
              },
              {
                action : "channel",
                label: game.i18n.localize("Channel"),
                callback: async btn => {
                  return this.actor.setupChannell(spell, options);
                  // TODO: move this elsewhere
                  // await test.roll();
                  // if (test.context.channelUntilSuccess) {
                  //   await warhammer.utility.sleep(200);
                  //   do {
                  //     if (test.item.cn.SL >= test.item.cn.value) {
                  //       break;
                  //     }
                  //     if (test.result.minormis || test.result.majormis || test.result.catastrophicmis) {
                  //       break;
                  //     }
                  //     test.context.messageId = null; // Clear message so new message is made
                  //     await test.roll();
                  //     await warhammer.utility.sleep(200);
                  //   } while (true);
                  // }
                }
              }
            ],
          });
      }
    }

    static async _toggleExtendedTests(ev)
    {
      this.showExtendedTests = !this.showExtendedTests;
      this.render(true);
    }

    static _onRemoveAttacker(ev) {
      this.actor.update({ "flags.-=oppose": null });
    }

    static _onClickCondition(ev) {
      let conditionKey = this._getParent(ev.target, ".condition")?.dataset.key;
      let existing = this.actor.hasCondition(conditionKey);
      
      if (!existing?.isNumberedCondition && ev.button == 0)
      {
        this.actor.removeCondition(conditionKey);
      }
      
      ev.button == 0 ? this.actor.addCondition(conditionKey) : this.actor.removeCondition(conditionKey); 
    }

    static async _onRemoveItemFromContainer(ev)
    {
      let item = await this._getDocumentAsync(ev);
      return item.update({ "system.location.value": "" })
    }


    static async _toggleSummary(ev)
    {
      let document = await this._getDocumentAsync(ev);
      if (document)
      {
        let expandData = await document.system.expandData({secrets: this.actor.isOwner});
        this._toggleDropdown(ev, expandData.description.value + `<div class="tags">${expandData.properties?.length ? "<div class='tag'>" + expandData.properties.join("</div><div class='tag'>") : ""}</div>`);
      }
    }
    static async _onItemPropertyDropdown(ev) {
      let item = await this._getDocumentAsync(ev);
      let type = ev.target.dataset.type;
      let properties = Object.values(item.system.properties[type]);
      if (type == "qualities")
      {
        properties = properties.concat(Object.values(item.system.properties.unusedQualities), Object.values(item.system.properties.inactiveQualities));
      }
      let propData = properties.find(p => p.display == ev.target.text);
      let key = propData.key;
      let value = propData.value;
      let propertyDescriptions = foundry.utils.mergeObject(foundry.utils.deepClone(game.wfrp4e.config.qualityDescriptions), game.wfrp4e.config.flawDescriptions);
      if (key)
      {
        let description = propertyDescriptions[key]?.replace("(Rating)", value) || `Description for ${ev.target.text} was not found`;
        
        this._toggleDropdown(ev, description);
      }
    }

    static async _onCombatDropdown(ev) {
      let property = ev.target.dataset.property;
      let item = await this._getDocumentAsync(ev);
      let description = "";

      switch(property)
      {
        case "group":
          description = game.wfrp4e.config.weaponGroupDescriptions[item.system.weaponGroup.value];
          break;
        case "reach":
          description = game.wfrp4e.config.reachDescription[item.system.reach.value];
          break;
        case "special":
          description = item.system.properties.special;
          break;
        case "specialAmmmo":
          description = item.system.properties.specialAmmo;
          break;
        case "range":
            if (!game.settings.get("wfrp4e", "homebrew").mooRangeBands)
            {

              description =
              `<a data-action="rollTest" data-type="weapon" data-modifier="${item.system.range.bands[`${game.i18n.localize("Point Blank")}`].modifier}">${item.system.range.bands[`${game.i18n.localize("Point Blank")}`].range[0]} ${game.i18n.localize("yds")} - ${item.system.range.bands[`${game.i18n.localize("Point Blank")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Point Blank"]]}</a><br>
                <a data-action="rollTest" data-type="weapon" data-modifier="${item.system.range.bands[`${game.i18n.localize("Short Range")}`].modifier}">${item.system.range.bands[`${game.i18n.localize("Short Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.system.range.bands[`${game.i18n.localize("Short Range")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Short Range"]]}</a><br>
                <a data-action="rollTest" data-type="weapon" data-modifier="${item.system.range.bands[`${game.i18n.localize("Normal")}`].modifier}">${item.system.range.bands[`${game.i18n.localize("Normal")}`].range[0]} ${game.i18n.localize("yds")} - ${item.system.range.bands[`${game.i18n.localize("Normal")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Normal"]]}</a><br>
                <a data-action="rollTest" data-type="weapon" data-modifier="${item.system.range.bands[`${game.i18n.localize("Long Range")}`].modifier}">${item.system.range.bands[`${game.i18n.localize("Long Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.system.range.bands[`${game.i18n.localize("Long Range")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Long Range"]]}</a><br>
                <a data-action="rollTest" data-type="weapon" data-modifier="${item.system.range.bands[`${game.i18n.localize("Extreme")}`].modifier}">${item.system.range.bands[`${game.i18n.localize("Extreme")}`].range[0]} ${game.i18n.localize("yds")} - ${item.system.range.bands[`${game.i18n.localize("Extreme")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Extreme"]]}</a><br>
                `;
                
            }
            //@HOUSE
            else {
              game.wfrp4e.utility.logHomebrew("mooRangeBands");
              description =
              `<a data-action="rollTest" data-type="weapon" data-modifier="${item.system.range.bands[`${game.i18n.localize("Point Blank")}`].modifier}">${item.system.range.bands[`${game.i18n.localize("Point Blank")}`].range[0]} ${game.i18n.localize("yds")} - ${item.system.range.bands[`${game.i18n.localize("Point Blank")}`].range[1]} ${game.i18n.localize("yds")}: ${item.system.range.bands[`${game.i18n.localize("Point Blank")}`].modifier}</a><br>
                <a data-action="rollTest" data-type="weapon" data-modifier="${item.system.range.bands[`${game.i18n.localize("Short Range")}`].modifier}">${item.system.range.bands[`${game.i18n.localize("Short Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.system.range.bands[`${game.i18n.localize("Short Range")}`].range[1]} ${game.i18n.localize("yds")}: ${item.system.range.bands[`${game.i18n.localize("Short Range")}`].modifier}</a><br>
                <a data-action="rollTest" data-type="weapon" data-modifier="${item.system.range.bands[`${game.i18n.localize("Normal")}`].modifier}">${item.system.range.bands[`${game.i18n.localize("Normal")}`].range[0]} ${game.i18n.localize("yds")} - ${item.system.range.bands[`${game.i18n.localize("Normal")}`].range[1]} ${game.i18n.localize("yds")}: ${item.system.range.bands[`${game.i18n.localize("Normal")}`].modifier}</a><br>
                <a data-action="rollTest" data-type="weapon" data-modifier="${item.system.range.bands[`${game.i18n.localize("Long Range")}`].modifier}">${item.system.range.bands[`${game.i18n.localize("Long Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.system.range.bands[`${game.i18n.localize("Long Range")}`].range[1]} ${game.i18n.localize("yds")}: ${item.system.range.bands[`${game.i18n.localize("Long Range")}`].modifier}</a><br>
                <a data-action="rollTest" data-type="weapon" data-modifier="${item.system.range.bands[`${game.i18n.localize("Extreme")}`].modifier}">${item.system.range.bands[`${game.i18n.localize("Extreme")}`].range[0]} ${game.i18n.localize("yds")} - ${item.system.range.bands[`${game.i18n.localize("Extreme")}`].range[1]} ${game.i18n.localize("yds")}: ${item.system.range.bands[`${game.i18n.localize("Extreme")}`].modifier}</a><br>
                `;
            }
          break;
      }
        
      this._toggleDropdown(ev, description);
    }

    static _onConvertCurrency(ev) 
    {

      ev.preventDefault();
      let type = this._getParent(ev.target, "a").dataset.type;
      let money = this.actor.itemTypes.money;
      let itemData = MarketWFRP4e.convertMoney(money, type);
      return this.actor.updateEmbeddedDocuments("Item", itemData)
    }

    static _onConsolidateCurrency(ev) 
    {
      ev.preventDefault();
      let money = this.actor.itemTypes.money;
      let newMoney = MarketWFRP4e.consolidateMoney(money.map(i => i.toObject()));
      return this.actor.updateEmbeddedDocuments("Item", newMoney)
    }

    static _onCollapseSection(ev)
    {
      let section = this._getParent(ev.target, "a").dataset.section;
      let collapsed = this.actor.getFlag("wfrp4e", "sheetCollapsed")?.[section];
  
      this.actor.setFlag("wfrp4e", `sheetCollapsed.${section}`, !collapsed);
    }
    
    static async _onContainerSort(ev)
    {
      let direction = this._getParent(ev.target, "a").dataset.direction;

      let container = await this._getDocumentAsync(ev);

      // All Containers on the same level as the sorted container
      let containers = this.actor.itemTags.container.sort((a, b) => a.sort - b.sort).filter(i => i.system.location.value == container.system.location.value);

      // Index of the sorted container
      let index = containers.findIndex(i => i.id == container.id);

      if ((index == 0 && direction == "up") || (index == containers.length - 1 && direction == "down"))
        {
          return;
        }

        // Index of the target container
        let targetIndex = direction == "up" ? index - 1 : index + 1;
        let target = containers[targetIndex];

        // Remove sorted container
        containers = containers.filter(i => i.id != container.id);

      let sorted = foundry.utils.SortingHelpers.performIntegerSort(container, {target, siblings: containers});
      this.actor.updateEmbeddedDocuments("Item", sorted.map(s => 
      {
          return foundry.utils.mergeObject({
              _id : s.target.id,
          }, s.update);
      }));
  
    }

    static _postItemProperty(ev)
    {
      WFRP_Utility.postProperty(ev.target.text);
    }

    //#endregion
}

class StandardWFRP4eActorSheet extends BaseWFRP4eActorSheet
{

  static DEFAULT_OPTIONS = {
    position : {
      height: 750,
      width: 650
    },
    actions : {
      useDodge : this._onDodgeClick,
      useUnarmed : this._onUnarmedClick,
      useImprovised : this._onImprovisedClick,
      useStomp : this._onStompClick,
      removeMount : this._removeMount,
      dismount : this._dismount,
      showMount : this._showMount,
      randomize: this._randomize,
      stepAilment: {buttons: [0, 2], handler: this._onStepAilment},
    },
  }

  static TABS = {
    main: {
      id: "main",
      group: "primary",
      label: "Main",
    },
    skills: {
      id: "skills",
      group: "primary",
      label: "Skills",
    },
    talents: {
      id: "talents",
      group: "primary",
      label: "Talents",
    },
    combat: {
      id: "combat",
      group: "primary",
      label: "Combat",
    },
    effects: {
      id: "effects",
      group: "primary",
      label: "Effects",
    },
    religion: {
      id: "religion",
      group: "primary",
      label: "Religion",
    },
    magic: {
      id: "magic",
      group: "primary",
      label: "Magic",
    },
    trappings: {
      id: "trappings",
      group: "primary",
      label: "Trappings",
    },
    notes: {
      id: "notes",
      group: "primary",
      label: "Notes",
    }
  }

    /**
     * Callback actions which occur when a dragged element is over a drop target.
     * @param {DragEvent} event       The originating DragEvent
     * @protected
     */
    _onDragOver(event) {
      
    }

    _onDropActor(document, event)
    {
      let mount = fromUuidSync(document.uuid);
      if (event.target.classList.contains("mount-drop"))
      {
        if (game.wfrp4e.config.actorSizeNums[mount.system.details.size.value] < game.wfrp4e.config.actorSizeNums[this.actor.details.size.value])
          return ui.notifications.error(game.i18n.localize("MountError"))
  
        let mountData = {
          id: mount.id,
          mounted: true,
          isToken: false
        };
        if(this.actor.prototypeToken.actorLink && !mount.prototypeToken.actorLink)
          ui.notifications.warn(game.i18n.localize("WarnUnlinkedMount"));
  
        this.actor.update({ "system.status.mount": mountData });
      }
    }

    async _onDropCustom(data, event)
    {
      await super._onDropCustom(data, event);
      if (data.custom == "wounds")
      {
        this.actor.modifyWounds(data.wounds);
      }
    }

  _prepareSkillsContext(context) {
    context.skills = {
      basic: this.actor.itemTypes.skill.filter(i => i.system.advanced.value == "bsc" && i.system.grouped.value == "noSpec").sort(WFRP_Utility.nameSorter),
      advanced: this.actor.itemTypes.skill.filter(i => i.system.advanced.value == "adv" || i.system.grouped.value == "isSpec").sort(WFRP_Utility.nameSorter)
    };
  }

  // Consolidate talents
  _prepareTalentsContext(context) {
    let talents = context.items.talent;
    context.items.talent = [];
    talents.forEach(t => {
      if (!context.items.talent.find(existing => existing.name == t.name))
      {
        context.items.talent.push(t);
      }
    });
  }

    // Organize Spells
    _prepareMagicContext(context) {
      let spells = context.items.spell;
      context.items.spell = {petty : [], lore : []};
      spells.forEach(s => {
        if (s.system.lore.value == "petty")
        {
          context.items.spell.petty.push(s);
        }
        else 
        {
          context.items.spell.lore.push(s);
        }
      });
    }

    // Organize Prayers
    _prepareReligionContext(context) {
      let prayer = context.items.prayer;
      context.items.prayer = {blessing : [], miracle : []};
      prayer.forEach(p => {
        if (p.system.type.value == "blessing")
        {
          context.items.prayer.blessing.push(p);
        }
        else 
        {
          context.items.prayer.miracle.push(p);
        }
      });
    }


  //#region Trappings
  _prepareTrappingsContext(context) {
    context.inventory = this.prepareInventory();
  }
  
  _filterItemCategory(category, itemsInContainers) {
    itemsInContainers = itemsInContainers.concat(category.items.filter(i => !!i.system.location?.value));
    category.items = category.items.filter(i => !i.system.location?.value);//.sort((a, b) => a.sort - b.sort);
    category.show = category.items.length > 0;
    return itemsInContainers
  }
  //#endregion

  
  _configureLimitedParts(options)
  {
      let limited = {
          header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/actor/limited/limited-header.hbs', classes: ["sheet-header", "limited"] },
          notes: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/limited/limited-notes.hbs', classes: ["limited"]  },
      };
      Object.values(limited).forEach(p => p.templates ??= []);
      return limited;
  }


  _addEventListeners()
  {    
    super._addEventListeners();
    this.element.querySelectorAll("[data-action='editCharacteristic']").forEach(e => e.addEventListener("change", this.constructor._onEditCharacteristic.bind(this)));
    this.element.querySelector("[data-action='editSpecies']")?.addEventListener("change", this.constructor._onEditSpecies.bind(this));
    this.element.querySelectorAll("[data-action='addSkill']").forEach(e => e.addEventListener("change", this.constructor._onAddSkill.bind(this)));
  }

  static _onEditCharacteristic(ev)
  {
    let characteristic = ev.target.dataset.characteristic;
    let value = Number(ev.target.value);
    let characteristics = this.actor.system.characteristics.toObject();
    if (!(value == characteristics[characteristic].initial + characteristics[characteristic].advances)) 
    {
      characteristics[characteristic].initial = value;
      characteristics[characteristic].advances = 0;
      characteristics[characteristic].modifier = 0;
    }
    return this.actor.update({ "system.characteristics": characteristics })
  }

  
  static async _onEditSpecies(ev) {
    let split = ev.target.value.split("(");
    let species = split[0].trim();
    let subspecies;
    if (split.length > 1) 
    {
        subspecies = split[1].split(")")[0].trim();
    }

    let speciesKey = warhammer.utility.findKey(species, game.wfrp4e.config.species) || species;
    let subspeciesKey = "";
    if (subspecies) 
    {
        for (let sub in game.wfrp4e.config.subspecies[speciesKey]) {
            if (game.wfrp4e.config.subspecies[speciesKey][sub].name == subspecies) subspeciesKey = sub;
        }
        if (!subspeciesKey) {
            subspeciesKey = subspecies;
        }
    }
    let update = { "system.details.species.value": speciesKey, "system.details.species.subspecies": subspeciesKey };
    try 
    {
        let initialValues = await WFRP_Utility.speciesCharacteristics(speciesKey, true, subspeciesKey);
        let characteristics = this.actor.toObject().system.characteristics;
        for (let c in characteristics) {
            characteristics[c].initial = initialValues[c].value;
        }

        if (this.actor.type != "character" && (await foundry.applications.api.DialogV2.confirm({ content: game.i18n.localize("SpecChar"), window : {title: game.i18n.localize("Species Characteristics") }})) )
        {
          foundry.utils.mergeObject(update, {system: { characteristics, "details.move.value" : WFRP_Utility.speciesMovement(speciesKey) || 4 }});
        }
    } 
    catch(e) 
    { 
        warhammer.utility.log("Error applying species stats: " + e.stack);
    }
    await this.actor.update(update);

}

  static _onAddSkill(ev)
  {
    let nameInput = ev.target.parentElement.querySelector("input");
    let charInput = ev.target.parentElement.querySelector("select");

    if (nameInput.value && charInput.value)
    {
      let type = ev.target.parentElement.dataset.type;
      let item = {type : "skill", name : nameInput.value, system : {advanced : {value : type}, characteristic: {value : charInput.value}}};
      if (this.actor.itemTypes.skill.find(i => i.name == item.name))
      { 
        ui.notifications.error("ERROR.SkillAlreadyExists", {localize: true});
      }
      else 
      {
        this.actor.createEmbeddedDocuments("Item", [item]);
      }
    }
  }

  static _onUnarmedClick(ev) {
    ev.preventDefault();
    let unarmed = game.wfrp4e.config.systemItems.unarmed;
    this.actor.setupWeapon(unarmed).then(setupData => {
      this.actor.weaponTest(setupData);
    });
  }
  static _onDodgeClick(ev) {
      this.actor.setupSkill(game.i18n.localize("NAME.Dodge"), {skipTargets: true}).then(test => {
        test.roll();
      });
  }
  static _onImprovisedClick(ev) {
    ev.preventDefault();
    let improv = game.wfrp4e.config.systemItems.improv;
    this.actor.setupWeapon(improv).then(setupData => {
      this.actor.weaponTest(setupData);
    });
  }

  static _onStompClick(ev) {
    ev.preventDefault();
    let stomp = game.wfrp4e.config.systemItems.stomp;
    this.actor.setupTrait(stomp).then(setupData => {
      this.actor.traitTest(setupData);
    });
  }

  static _dismount(ev) {
    ev.stopPropagation();
    this.actor.update({ "system.status.mount.mounted": !this.actor.status.mount.mounted });
  }

  static _removeMount(ev) {
    ev.stopPropagation();
    let mountData = { id: "", mounted: false, isToken: false };
    this.actor.update({ "system.status.mount": mountData });
  }

  static _onContextMenushowMount(ev) {
    this.actor.mount.sheet.render(true);
  }

  static _randomize(ev)
  {
    let advancement = new Advancement(this.actor);

    try {
      switch (ev.target.dataset.type) {
        case "characteristics":
          advancement.advanceSpeciesCharacteristics();
          return
        case "skills": 
          advancement.advanceSpeciesSkills();
          return
        case "talents":
          advancement.advanceSpeciesTalents();
          return
      }
    }
    catch (error) {
      warhammer.utility.log("Could not randomize: " + error, true);
    }
  }

  static async _onStepAilment(ev)
  {
    ev.stopPropagation();
    ev.preventDefault();
    let document = (await this._getDocument(ev)) || this.document;

    if (!document) return;

    if (ev.button === 0) {
      document.system.decrement();
    } else {
      document.system.increment();
    }
  }

}

class ActorSheetWFRP4eCharacter extends StandardWFRP4eActorSheet
{
    static DEFAULT_OPTIONS = {
        classes: ["character"],
        actions: {
          advanceCharacteristic : {buttons: [0, 2], handler : this._onAdvanceCharacteristic},
          advanceSkill : {buttons: [0, 2], handler : this._onAdvanceSkill},
          advanceTalent : {buttons: [0, 2], handler : this._onAdvanceTalent},
          addUntrainedSkill : this._onAddUntrainedSkill,
          clickUntrainedTalent : {buttons: [0, 2], handler : this._onClickUntrainedTalent},
          rollIncome : this._onRollIncome,
          changeCareer : this._onChangeCareer,
          onRest : this._onRest,
          deleteExp : this._onDeleteExp
        },
        window : {
          resizable : true
        },
      }

      static PARTS = {
        header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/actor/character/character-header.hbs', classes: ["sheet-header"] },
        tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/actor-tabs.hbs' },
        main: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/character/character-main.hbs' },
        skills: { scrollable: ["", ".basic .list-content", ".advanced .list-content"], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-skills.hbs' },
        talents: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-talents.hbs' },
        combat: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-combat.hbs' },
        effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-effects.hbs' },
        magic: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-magic.hbs' },
        religion: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-religion.hbs' },
        trappings: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-inventory.hbs' },
        notes: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/character/character-notes.hbs' },
      }
      
      async _prepareContext(options)
      {
        let context = await super._prepareContext(options);
        context.experienceLog = this._condenseXPLog();
        context.nonTrivialCriticals = context.items.critical.filter(c => Number.isNumeric(c.system.wounds.value));
        context.canEditExperience = game.user.isGM || game.settings.get("wfrp4e", "playerExperienceEditing");
  
        return context;
      }
    
    _condenseXPLog() {
      let condensed= [];
      for (
        let logIndex = 0, lastPushed, lastPushedCounter = 0;
        logIndex < this.document.details.experience.log.length;
        logIndex++) {
        let condense = false;
        if ( // If last pushed exists, and is the same, type, same reason, and both are positiev or both are negative
          lastPushed &&
          lastPushed.type == this.document.details.experience.log[logIndex].type &&
          lastPushed.reason == this.document.details.experience.log[logIndex].reason &&
          ((lastPushed.amount >= 0 && this.document.details.experience.log[logIndex].amount >= 0)
            || (lastPushed.amount <= 0 && this.document.details.experience.log[logIndex].amount <= 0))) { condense = true; }
  
        if (condense) {
          lastPushed[lastPushed.type] = this.document.details.experience.log[logIndex][lastPushed.type];
          lastPushed.amount += this.document.details.experience.log[logIndex].amount;
          lastPushed.index = logIndex; // If condensed entry, keep the "latest" log index so when a condensed entry is deleted, it deletes from the latest
          lastPushed.spent = this.document.details.experience.log[logIndex].spent;
          lastPushed.total = this.document.details.experience.log[logIndex].total;
          lastPushed.counter++;
        }
        else {
          lastPushed = foundry.utils.duplicate(this.document.details.experience.log[logIndex]);
          lastPushed.index = logIndex;
          lastPushed.counter = 1;
          condensed.push(lastPushed);
          lastPushedCounter = 0;
  
        }
      }
      for (let log of condensed) {
        if (log.counter && log.counter > 1)
          log.reason += ` (${log.counter})`;
      }
      return condensed.reverse()
    }

    static async _onAddUntrainedSkill(ev)
    {
      let skill = await WFRP_Utility.findSkill(ev.target.text);

      // Right click - show sheet
      if (ev.button == 2) {
        skill.sheet.render(true);
      }
      else {
        try {
          if (await foundry.applications.api.DialogV2.confirm({ window : {title: game.i18n.localize("SHEET.AddSkillTitle")}, content: `<p>${game.i18n.localize("SHEET.AddSkillPrompt")}</p>`}))
          {
            this.actor.createEmbeddedDocuments("Item", [skill], {career : true});
          }
        }
        catch
        {
          console.error(error);
          ui.notifications.error(error);
        }
      }
    }

    static async _onClickUntrainedTalent(ev)
    {
      let talent = await WFRP_Utility.findTalent(ev.target.text);

      // Right click - show sheet
      if (ev.button == 2) 
      {
        talent.sheet.render(true);
      }
  
      else {
        try {
          new foundry.applications.api.DialogV2(
            {
              window : {title: game.i18n.localize("SHEET.AddTalentTitle")},
              content: `<p>${game.i18n.localize("SHEET.AddTalentPrompt")}</p>`,
              buttons:
              [
                {
                  action: "yes",
                  label: game.i18n.localize("Yes"),
                  default: true,
                  callback: dlg => {
                    try {
                      Advancement.checkValidAdvancement(this.actor.details.experience.total, this.actor.details.experience.spent + 100, game.i18n.localize("ACTOR.ErrorAdd"), talent.name);
                      this.actor.createEmbeddedDocuments("Item", [talent.toObject()]);
                      let expLog = foundry.utils.duplicate(this.actor.details.experience.log || []); 
                      expLog.push({amount : 100, reason : talent.name, spent : this.actor.details.experience.spent + 100, total : this.actor.details.experience.total, type : "spent"});
                      ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : 100, reason : talent.name}));
                      this.actor.update( // Subtract experience if added
                        {
                          "system.details.experience.spent": this.actor.details.experience.spent + 100,
                          "system.details.experience.log": expLog
                        });
                    } catch(error) {
                      ui.notifications.error(error);
                    }
                  }
                },
                {
                  action: "yesNoExp",
                  label: game.i18n.localize("Free"),
                  callback: dlg => { this.actor.createEmbeddedDocuments("Item", [talent.toObject()]); }
                },
                {
                  action: "cancel",
                  label: game.i18n.localize("Cancel"),
                  callback: dlg => { return }
                },
              ],
            }).render(true);
        }
        catch
        {
          console.error(error);
          ui.notifications(error);
        }
      }
    }

    static _onChangeCareer(ev)
    {
      new CareerSelector(this.document).render(true);
    }

    static async _onRest(ev) {
      let skill = this.actor.itemTags.skill.find(s => s.name == game.i18n.localize("NAME.Endurance"));
      let options = {rest: true, tb: this.actor.characteristics.t.bonus, skipTargets: true};
      let test;
      if (skill)
      {
        test = await this.actor.setupSkill(skill, options);
      }
      else 
      {
        test = await this.actor.setupCharacteristic("t", options);
      }
      test.roll();
    }


    static async _onRollIncome(ev)
    {
      let career = this._getDocument(ev);
      let skills = career.system.incomeSkill.map(i => career.system.skills[i]).map(i => this.actor.itemTypes.skill.find(sk => sk.name == i)).filter(i => i);
      let skill;
      if (skills.length == 0)
      {
        ui.notifications.error("SHEET.SkillMissingWarning", {localize: true});
        return;
      }

      if (skills.length == 1)
      {
        skill = skills[0];
      }
      else 
      {
        skill = (await ItemDialog.create(skill, 1, {title : "Choose Skill"}))[0];
      }

      if (!skill)
      {
        skill = skills[0];
      }

      let options = {
        title: `${skill.name} - ${game.i18n.localize("Income")}`, 
        income: this.actor.details.status, 
        career: career.toObject()
      };

      this.actor.setupSkill(skill, options).then(test => test.roll());
    }

    static async _onAdvanceCharacteristic(ev)
    {
      // Prevent clicking until update (which refreshes the sheet)
      ev.target.style.pointerEvents = "none";
      let characteristic = ev.target.dataset.characteristic;
      let current = this.actor.system.characteristics[characteristic];
      let system = this.actor.system.toObject();

      if (ev.button == 0) 
      {
        // Calculate the advancement cost based on the current number of advances, subtract that amount, advance by 1
        let cost = Advancement.calculateAdvCost(current.advances, "characteristic");
        try 
        {
          Advancement.checkValidAdvancement(system.details.experience.total, system.details.experience.spent + cost, game.i18n.localize("ACTOR.ErrorImprove"), game.wfrp4e.config.characteristics[characteristic]);
          system.characteristics[characteristic].advances++;
          system.details.experience.spent = Number(system.details.experience.spent) + cost;

          let expLog = this.actor.system.addToExpLog(cost, game.wfrp4e.config.characteristics[characteristic], system.details.experience.spent);
          ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : cost, reason : game.wfrp4e.config.characteristics[characteristic]}));
          system.details.experience.log = expLog;
        } 
        catch(error) 
        {
          ui.notifications.error(error);
          this.render(true); // Refresh sheet to allow clicking again
        }
      }
      else if (ev.button == 2) 
      {
        // Calculate the advancement cost based on advances -1, add that amount back into exp
        if (current.advances == 0)
          return this.render(true); // Rerender to allow clicking again
        let cost = Advancement.calculateAdvCost(current.advances - 1, "characteristic");

        system.characteristics[characteristic].advances--;
        system.details.experience.spent = Number(system.details.experience.spent) - cost;

        let expLog = this.actor.system.addToExpLog(-1 * cost, game.wfrp4e.config.characteristics[characteristic], system.details.experience.spent);
        ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : -1 * cost, reason : game.wfrp4e.config.characteristics[characteristic]}));
        system.details.experience.log = expLog;
      }
      
      this.actor.update({system}, {skipExperienceChecks : true});
    }

    static _onAdvanceSkill(ev)
    {
      ev.stopPropagation();
      let skill = this._getDocument(ev);
      let system = this.actor.system.toObject();
      let update = {items : []};
      if(!skill)
      {
        return;
      }
      ev.target.style.pointerEvents = "none";

      if (ev.button == 0) {
        // Calculate the advancement cost based on the current number of advances, subtract that amount, advance by 1
        let cost = Advancement.calculateAdvCost(skill.system.advances.value, "skill", skill.system.advances.costModifier);
        try 
        {
          Advancement.checkValidAdvancement(system.details.experience.total, system.details.experience.spent + cost, game.i18n.localize("ACTOR.ErrorImprove"), skill.name);
          system.details.experience.spent = Number(system.details.experience.spent) + cost;
          update.items.push({_id : skill.id, "system.advances.value" : skill.system.advances.value + 1});

          system.details.experience.log = this.actor.system.addToExpLog(cost, skill.name, system.details.experience.spent);
          ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : cost, reason: skill.name}));
          update.system = system;
        } 
        catch(error) 
        {
          ui.notifications.error(error);
        }
      }
      else if (ev.button == 2) {
        // Do the reverse, calculate the advancement cost (after subtracting 1 advancement), add that exp back
        if (skill.system.advances.value == 0)
            return this.render(true); // Rerender to allow clicking again
        let cost = Advancement.calculateAdvCost(skill.system.advances.value - 1, "skill", skill.system.advances.costModifier);
        system.details.experience.spent = Number(system.details.experience.spent) - cost;
        update.items.push({_id : skill.id, "system.advances.value" : skill.system.advances.value - 1});

        system.details.experience.log = this.actor.system.addToExpLog(-1 * cost, skill.name, system.details.experience.spent);
        ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : -1 * cost, reason : skill.name}));
        update.system = system;
      }

      this.actor.update(update, {skipExperienceChecks : true});
    }


    static async _onAdvanceTalent(ev) 
    {

      let talent = this._getDocument(ev);
      let advances = talent.system.Advances;

      if(!talent)
      {
        return;
      }

      if (ev.button == 0) {
        // All career talents are stored in flags, retrieve the one clicked - use to calculate exp
        let spent = 0;
        let cost = (advances + 1) * 100;
        try {
          Advancement.checkValidAdvancement(this.actor.details.experience.total, this.actor.details.experience.spent + cost, game.i18n.localize("ACTOR.ErrorImprove"), talent.name);
          if (advances < talent.system.Max || talent.system.Max == "-") {
            spent = this.actor.details.experience.spent + cost;
          }
          else
            return
          
          ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", { amount: cost, reason: talent.name }));
          let expLog = this.actor.system.addToExpLog(cost, talent.name, spent);
          await this.actor.update({ "system.details.experience.spent": spent, "system.details.experience.log": expLog });
          await this.actor.createEmbeddedDocuments("Item", [talent.toObject()]);
        } catch (error) {
          ui.notifications.error(error);
        }
      }
      // If right click, ask to refund EXP or not
      else if (ev.button == 2) {
        let spent = 0;
        let cost = (advances) * 100;
        spent = this.actor.details.experience.spent - cost;

        new foundry.applications.api.DialogV2(
          {
            window : {title: game.i18n.localize("SHEET.RefundXPTitle")},
            content: `<p>${game.i18n.localize("SHEET.RefundXPPrompt")} (${(advances) * 100})</p>`,
            buttons:
            {
              yes:
              {
                action : "yes",
                default: true,
                label: game.i18n.localize("Yes"),
                callback: async dlg => {
                  let expLog = this.actor.system.addToExpLog(-1 * cost, talent.name, spent);
                  ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", { amount: -1 * cost, reason: talent.name }));
                  await this.actor.update({ "system.details.experience.spent": spent, "system.details.experience.log": expLog });
                  await talent.delete();
                }
              },
              no:
              {
                action : "no",
                label: game.i18n.localize("No"),
                callback: async dlg => {
                  await talent.delete();
                },
              },
              cancel:
              {
                action : "cancel",
                label: game.i18n.localize("Cancel"),
                callback: dlg => { return }
              }
            },
          }).render(true);
      }


  }

  static _onDeleteExp(ev) {
    let index = this._getIndex(ev);
    let experience = foundry.utils.duplicate(this.actor.system.details.experience);
    let entry = experience.log[index];
    let exp = parseInt(entry.amount);
    let type = entry.type;
    experience.log.splice(index, 1);

    foundry.applications.api.DialogV2.confirm({
      window : {title: game.i18n.localize("RevertExperience")}, 
      content: `<p>${game.i18n.localize("DIALOG.RevertExperience")}</p>`,
      yes: {
        callback: () => {
          experience[type] -= exp;
          this.actor.update({ "system.details.experience": experience });
        }
      },
      no: {
        callback: () => {
          this.actor.update({ "system.details.experience": experience });
        }
      }
    });
  }

}

class ActorSheetWFRP4eNPC extends StandardWFRP4eActorSheet
{
    static DEFAULT_OPTIONS = {
        classes: ["npc"],
        actions: {
          getIncome: this._getIncome
        },
        window : {
          resizable : true
        },
      }

      static PARTS = {
        header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/actor/characteristic-header.hbs', classes: ["sheet-header"] },
        tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/actor-tabs.hbs' },
        main: { scrollable: ["", ".basic .list-content", ".advanced .list-content"], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-skills.hbs', classes: ["skills"] },
        careers: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/npc/npc-careers.hbs' },
        talents: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-talents.hbs' },
        combat: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-combat.hbs' },
        effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-effects.hbs' },
        magic: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-magic.hbs' },
        religion: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-religion.hbs' },
        trappings: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-inventory.hbs' },
        notes: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/npc/npc-notes.hbs' },
      }

      static TABS = {
        main: {
          id: "main",
          group: "primary",
          label: "Main",
        },
        careers: {
          id: "careers",
          group: "primary",
          label: "Careers",
        },
        talents: {
          id: "talents",
          group: "primary",
          label: "Talents",
        },
        combat: {
          id: "combat",
          group: "primary",
          label: "Combat",
        },
        effects: {
          id: "effects",
          group: "primary",
          label: "Effects",
        },
        religion: {
          id: "religion",
          group: "primary",
          label: "Religion",
        },
        magic: {
          id: "magic",
          group: "primary",
          label: "Magic",
        },
        trappings: {
          id: "trappings",
          group: "primary",
          label: "Trappings",
        },
        notes: {
          id: "notes",
          group: "primary",
          label: "Notes",
        }
      }
      
      async _prepareContext(options)
      {
        let context = await super._prepareContext(options);
        return context;
      }

      _prepareMainContext(context) {
        return super._prepareSkillsContext(context);
      }
    
    static async _getIncome(event) {
      let status = this.actor.system.details.status.value.split(" ");
      let tier = warhammer.utility.findKey(status[0], game.wfrp4e.config.statusTiers)[0]; // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)
      let standing = Number(status[1]);     // Multilpy that first letter by your standing (Brass 4 = 8d10 pennies)
      let {earned} = await game.wfrp4e.market.rollIncome(null, {standing, tier});
  
      let paystring;
      switch (tier) {
        case "b":
          paystring = `${earned}${game.i18n.localize("MARKET.Abbrev.BP").toLowerCase()}.`;
          break;
        case "s":
          paystring = `${earned}${game.i18n.localize("MARKET.Abbrev.SS").toLowerCase()}.`;
          break;
        case "g":
          paystring = `${earned}${game.i18n.localize("MARKET.Abbrev.GC").toLowerCase()}.`;
          break;
      }
      let money = game.wfrp4e.market.creditCommand(paystring, this.actor, { suppressMessage: true });
      WFRP_Audio.PlayContextAudio({ item: { type: "money" }, action: "gain" });
      this.actor.updateEmbeddedDocuments("Item", money);
    }
}

class ActorSheetWFRP4eCreature extends StandardWFRP4eActorSheet
{
    static DEFAULT_OPTIONS = {
        classes: ["creature"],
        actions: {
          overviewDropdown : this._onOverviewDropdown,
        },
        window : {
          resizable : true
        },
      }

      static PARTS = {
        header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/actor/characteristic-header.hbs', classes: ["sheet-header"] },
        tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/actor-tabs.hbs' },
        main: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/creature/creature-main.hbs'},
        skills: { scrollable: ["", ".basic .list-content", ".advanced .list-content"], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-skills.hbs' },
        combat: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-combat.hbs' },
        effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-effects.hbs' },
        magic: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-magic.hbs' },
        religion: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-religion.hbs' },
        trappings: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/tabs/actor-inventory.hbs' },
        notes: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/creature/creature-notes.hbs' },
      }

      static TABS = {
        main: {
          id: "main",
          group: "primary",
          label: "Main",
        },
        skills: {
          id: "skills",
          group: "primary",
          label: "Skills",
        },
        combat: {
          id: "combat",
          group: "primary",
          label: "Combat",
        },
        effects: {
          id: "effects",
          group: "primary",
          label: "Effects",
        },
        religion: {
          id: "religion",
          group: "primary",
          label: "Religion",
        },
        magic: {
          id: "magic",
          group: "primary",
          label: "Magic",
        },
        trappings: {
          id: "trappings",
          group: "primary",
          label: "Trappings",
        },
        notes: {
          id: "notes",
          group: "primary",
          label: "Notes",
        }
      }
      
      async _prepareContext(options)
      {
        let context = await super._prepareContext(options);
        return context;
      }

    _prepareMainContext(context) {
    
        context.trained = this.actor.itemTags.skill.filter(i => i.advances.value > 0).sort(WFRP_Utility.nameSorter);
        context.includedTraits = this.actor.itemTags.trait.filter(i => i.included).sort(WFRP_Utility.nameSorter);
        context.talents = [];
        for(let talent of context.items.talent)
        {
          if (!context.talents.find(existing => existing.name == talent.name))
          {
            context.talents.push(talent);
          }
        }
        
        context.overviewButtons = this.actor.items.contents.reduce((buttons, item) => {
          let add = [];
          if (item.included)
          {
            add = item.sheetButtons.filter(i => !buttons.find(b => i.label == b.label));
          }
          return buttons.concat(add);
        }, []);
      }

      static async _onOverviewDropdown(ev) {
        let document = await this._getDocumentAsync(ev);
        let expandData = await document.system.expandData({secrets: this.actor.isOwner});
        this._toggleDropdown(ev, expandData.description.value + `<div class="tags">${expandData.properties?.length ? "<div class='tag'>" + expandData.properties.join("</div><div class='tag'>") : ""}</div>`, ".overview-content");
      }
}

class VehicleCrew extends DraggableApp(HandlebarsApplicationMixin(ApplicationV2))
{
    static DEFAULT_OPTIONS = {
        tag: "form",
        classes: ["warhammer", "standard-form", "vehicle-crew"],
        window: {
            title: "Vehicle Crew",
            resizable: true,
        },
        position: {
            width: 400,
            height: 500
        },
        form: {
            submitOnChange: true,
            handler: this._onSubmit
        },
        actions: {
            unassign: this._onUnassign,
            deleteRole: this._onDeleteRole,
            openRole: { buttons: [2], handler: this._onOpenRole },
            addRole: this._onAddRole
        },
        dragDrop: [{ dragSelector: '.role', dropSelector: null }],
    }


    /** @override */
    static PARTS = {
        form: {
            template: "systems/wfrp4e/templates/apps/vehicle-crew.hbs",
            scrollable: [""]
        }
    };

    constructor(document, options) {
        super(options);
        this.document = document;
    }

    async _prepareContext(options) {
        let context = await super._prepareContext(options);
        context.system = this.document.system;
        context.roles = this.document.itemTypes.vehicleRole;
        context.passengers = context.system.passengers.list;
        return context;
    }

    async _onSubmit(event, form, formData) {

    }

    /**
     * Add role id to drag data
     * 
     * @param {DragEvent} ev Drag event
     */
    async _onDragStart(ev) {
        ev.dataTransfer.setData("text/plain", ev.target.dataset.id);
    }

    /**
     * Handle dropping roles onto crew members
     * 
     * @param {Event} ev Drop event 
     */
    async _onDrop(ev) {
        let roleId = ev.dataTransfer.getData("text/plain"); // Dragged role
        let passengerId = ev.target.dataset.id;             // Dropped on passenger

        if (roleId && passengerId) {
            await this.document.update(this.document.system.passengers.addRole(passengerId, roleId));
            this.render(true);
        }
    }

    static async _onUnassign(ev, target) {
        let passengerId = target.closest(".passenger-roles").dataset.id;        let roleId = target.dataset.id;

        await this.document.update(this.document.system.passengers.removeRole(passengerId, roleId));
        this.render(true);
    }

    static async _onDeleteRole(ev, target) {
        await this.document.items.get(target.parentElement.dataset.id)?.delete();
        this.render(true);
    }

    static _onOpenRole(ev, target) {
        this.document.items.get(target.parentElement.dataset.id)?.sheet?.render(true);
    }

    static async _onAddRole(ev, target) {
        await this.document.createEmbeddedDocuments("Item", [{ name: game.i18n.localize("VEHICLE.NewRole"), type: "vehicleRole" }], { renderSheet: true });
        this.render(true);
    }
}

class VehicleCumulativeModifiersConfig extends HandlebarsApplicationMixin(ApplicationV2)
{
    static DEFAULT_OPTIONS = {
        tag: "form",
        classes: ["warhammer", "standard-form", "vehicle-modifiers"],
        window: {
            title: "Vehicle Modifiers",
            resizable: true,
        },
        position: {
            width: 600,
            height: 800
        },
        form: {
            submitOnChange: true,
            handler: this._onSubmit
        },
        actions: {
            add : this._onAddSource,
            remove : this._onRemoveSource,
            roll : this._onRoll,
        }
    }

    static PARTS = {
        form : {scrollable: [""], template : "systems/wfrp4e/templates/apps/vehicle-modifiers.hbs"},
        footer : {template : "templates/generic/form-footer.hbs"}
    }

    constructor(document, options)
    {
        super(options);
        this.document = document;
    }

    get title()
    {
        return this.key == "morale" ? game.i18n.localize("VEHICLE.VehicleMorale") : game.i18n.localize("VEHICLE.ManannsMood")
    }

    get key ()
    {
        return this.options.key;
    }

    _rollData = {}

    async _prepareContext(options) {
        if (game.modules.get("foundryvtt-simple-calendar")?.active) 
        {
            this.options.weekLabel = SimpleCalendar.api.currentDateTimeDisplay()?.date;
        }
        let context = await super._prepareContext(options);
        context.roll = this.options.roll;
        context.key = this.key;
        context.system = this.document.system;
        context.sources = context.system.status[this.key].sources;
        context.starting = context.system.status[this.key].starting;
        context.buttons = [context.roll ?  { type: "roll", label: "Roll", icon: "fa-solid fa-dice", action: "roll" } : { type: "add", label: "Add", icon: "fa-solid fa-plus", action: "add" }];
        return context
    }

    static async _onSubmit(event, form, formData) {
        this.document.update(formData.object);
    }

    close() 
    {
        // Remove any blank sources when the sheet is closed
        this.document.update({[`system.status.${this.key}.sources`] : this.document.system.status[this.key].sources.filter(i => i.description)});
        super.close();
    }

    async _onRender(_context, _options) 
    {
        await super._onRender(_context, _options);
        
        this.element.querySelectorAll(".sources input").forEach(e => {
            e.addEventListener("change", async ev => {
                let index = Number(ev.currentTarget.parentElement.dataset.index);
                let sources = foundry.utils.deepClone(this.document.system.status[this.key].sources);
    
                if (ev.currentTarget.type == "checkbox")
                {
                    sources[index].active = !sources[index].active;                
                }
                else 
                {
                    sources[index][ev.currentTarget.dataset.property] = ev.currentTarget.value;
                }
                await this.document.update({[`system.status.${this.key}.sources`] : sources.filter(i => i.description)});
                this.render(true);
            });
        });
    }

    static async _onAddSource(ev, target)
    {
        let sources = foundry.utils.deepClone(this.document.system.status[this.key].sources);
        sources.push({description : "", formula : "", active : false});
        await this.document.update({[`system.status.${this.key}.sources`] : sources});
        this.render(true);
    }

    static async _onRemoveSource(ev, target)
    {
        let index = Number(target.parentElement.dataset.index);
        let sources = foundry.utils.deepClone(this.document.system.status[this.key].sources);
        sources.splice(index, 1);
        await this.document.update({[`system.status.${this.key}.sources`] : sources});
        this.render(true);
    }

    static  async _onRoll(ev, target)
    {
        const formData = new FormDataExtended(this.form).object;
        if (!formData.weekLabel)
        {
            ui.notifications.error(game.i18n.localize("VEHICLE.LabelError"));
        }
        else 
        {
            if (formData.setValue)
            {
                this.document.system.status[this.key].setValue(formData.weekLabel, parseInt(formData.setValue));
            }
            else 
            {
                this.document.system.status[this.key].roll(formData.weekLabel);
            }
            this.close();
        }
    }
}

class VehicleMoveConfig extends HandlebarsApplicationMixin(ApplicationV2) {

    static DEFAULT_OPTIONS = {
        tag: "form",
        classes: ["warhammer", "standard-form", "vehicle-move"],
        window: {
            title: "VEHICLE.Move",
        },
        position: {
            width: 600,
        },
        form: {
            closeOnSubmit: true,
            handler: this._onSubmit
        },
        actions: {
        }
    }

    static PARTS = {
        form: { scrollable: [""], template: "systems/wfrp4e/templates/apps/vehicle-move.hbs" },
        footer: { template: "templates/generic/form-footer.hbs" }
    }

    constructor(document, options) {
        super(options);
        this.document = document;
    }

    async _prepareContext(options)
    {
        let context = await super._prepareContext(options);
        context.system = this.document.system;
        context.buttons = [{ type: "submit", label: "Submit", icon: "fa-solid fa-save" }];
        return context;
    }

    static async _onSubmit(event, form, formData) {
        if (formData.sailPrimary) {
            formData["system.details.move.primary"] = "sail";
            delete formData.sailPrimary;
        }
        else if (formData.oarsPrimary)
        {
            formData["system.details.move.primary"] = "oars";
            delete formData.oarsPrimary;
        }
        this.document.update(formData.object);
    }

    async _onRender(options)
    {
        await super._onRender(options);
        this.sailSection = this.element.querySelector(".sail");
        this.oarsSection = this.element.querySelector(".oars");

        this.sailEnable = this.element.querySelector("[name='system.details.move.sail.enabled'");
        this.oarsEnable = this.element.querySelector("[name='system.details.move.oars.enabled'");

        this.sailPrimary = this.element.querySelector("[name='sailPrimary']");
        this.oarsPrimary = this.element.querySelector("[name='oarsPrimary']");

        this.element.querySelector(".enableToggle").addEventListener("change", (ev => {
            this.checkToggles();
        }));

        this.element.querySelectorAll(".primaryToggle").forEach(e => e.addEventListener("change", (ev => {
            if (ev.target.name == "sailPrimary" && ev.target.checked)
            {
                this.oarsPrimary.checked = false;
            }
            else if (ev.target.name == "oarsPrimary" && ev.target.checked)
            {
                this.sailPrimary.checked = false;
            }
        })));
        
        this.checkToggles();
    }

    checkToggles()
    {
        if (this.sailEnable.checked && this.sailSection.classList.contains("disabled"))
        {
            this.sailSection.classList.remove("disabled");
        }
        if (!this.sailEnable.checked && !this.sailSection.classList.contains("disabled"))
        {
            this.sailSection.classList.add("disabled");
            this.sailPrimary.checked = false;
        }

        if (this.oarsEnable.checked && this.oarsSection.classList.contains("disabled"))
        {
            this.oarsSection.classList.remove("disabled");
        }
        if (!this.oarsEnable.checked && !this.oarsSection.classList.contains("disabled"))
        {
            this.oarsSection.classList.add("disabled");
            this.oarsPrimary.checked = false;
        }
    }
}

let fields$F = foundry.data.fields;

class MountModel extends foundry.abstract.DataModel 
{
    static defineSchema() 
    {
        return {
            id : new fields$F.StringField({initial : ""}),
            mounted : new fields$F.BooleanField({initial : false}),
            isToken : new fields$F.BooleanField({initial : false}),
            tokenData : new fields$F.SchemaField({
                scene : new fields$F.StringField({initial : ""}),
                token : new fields$F.StringField({initial : ""})
            }),
        }
    }
}

let fields$E = foundry.data.fields;

class StandardDetailsModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.species = new fields$E.SchemaField({
            value: new fields$E.StringField(),
            subspecies: new fields$E.StringField(),
        });
        schema.gender = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.biography = new fields$E.SchemaField({
            value: new fields$E.HTMLField()
        });
        schema.gmnotes = new fields$E.SchemaField({
            value: new fields$E.HTMLField()
        });
        schema.size = new fields$E.SchemaField({
            value: new fields$E.StringField({ initial: "avg" })
        });
        schema.move = new fields$E.SchemaField({
            value: new fields$E.NumberField({ initial: 4 }),
            walk: new fields$E.StringField(),
            run: new fields$E.StringField(),
        });
        schema.god = new fields$E.SchemaField({
            value: new fields$E.StringField({label : game.i18n.localize("Blessed By")})
        });

        schema.age = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.height = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.weight = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.haircolour = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.eyecolour = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.distinguishingmark = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.status = new fields$E.SchemaField({
            value: new fields$E.StringField(),
            standing: new fields$E.StringField(),
            tier: new fields$E.NumberField({ initial: 0 }),
            modifier: new fields$E.NumberField({ initial: 0 }),
        });
        schema.hitLocationTable = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.mainHand = new fields$E.StringField({initial : "r", choices : {r : "Right", l : "Left"}});
        return schema;
    }

    static get compendiumBrowserDetailsFilters() {
        return new Map([
            ["species", {
                label: "Species",
                type: "text",
                config: {
                    keyPath: "system.details.species.value"
                }
            }],
            ["size", {
                label: "Size",
                type: "set",
                config: {
                    choices: game.wfrp4e.config.actorSizes,
                    keyPath: "system.details.size.value"
                }
            }],
            ["move", {
                label: "Move",
                type: "range",
                config: {
                    keyPath: "system.details.move.value"
                }
            }],
        ]);
    }
}


class CharacterDetailsModel extends StandardDetailsModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.experience = new fields$E.SchemaField({
            total: new fields$E.NumberField({ initial: 0 }),
            spent: new fields$E.NumberField({ initial: 0 }),
            log: new fields$E.ArrayField(new fields$E.ObjectField())
        });

        schema["personal-ambitions"] = new fields$E.SchemaField({
            "short-term": new fields$E.StringField(),
            "long-term": new fields$E.StringField()
        });
        schema["party-ambitions"] = new fields$E.SchemaField({
            "name": new fields$E.StringField(),
            "short-term": new fields$E.StringField(),
            "long-term": new fields$E.StringField()
        });
        schema.motivation = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.class = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.career = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.careerlevel = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        schema.starsign = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        return schema;
    }
}

// DOES NOT INHERIT STANDARD
class VehicleDetailsModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.move = new fields$E.SchemaField({
            value: new fields$E.NumberField(),
            sail : new fields$E.SchemaField({
                enabled : new fields$E.BooleanField(),
                value : new fields$E.NumberField(),
                crew : new fields$E.NumberField(),
            }),
            oars : new fields$E.SchemaField({
                enabled : new fields$E.BooleanField(),
                value : new fields$E.NumberField(),
                crew : new fields$E.NumberField(),
            }),
            custom : new fields$E.SchemaField({
                label : new fields$E.StringField(),
                value : new fields$E.NumberField(),
                crew : new fields$E.NumberField()
            }),
            primary : new fields$E.StringField({initial : "sail", choices: ["sail", "oars"]})
        });
        schema.man = new fields$E.NumberField({initial : 0});
        schema.crew = new fields$E.SchemaField({
            starting : new fields$E.NumberField({initial : 0}),
            current : new fields$E.NumberField({initial : 0})
        });
        schema.size = new fields$E.SchemaField({
            value: new fields$E.StringField({ initial: "avg" })
        });
        schema.length = new fields$E.SchemaField({
            value: new fields$E.NumberField({min: 1, initial : 25})
        });
        schema.description = new fields$E.SchemaField({
            value: new fields$E.HTMLField()
        });
        schema.gmdescription = new fields$E.SchemaField({
            value: new fields$E.HTMLField()
        });
        schema.price = new fields$E.SchemaField({
            gc: new fields$E.NumberField({initial : 0})
        });
        schema.availability = new fields$E.SchemaField({
            value: new fields$E.StringField(),
        });
        schema.motivePower = new fields$E.SchemaField({
            value: new fields$E.StringField(),
        });
        schema.hitLocationTable = new fields$E.SchemaField({
            value: new fields$E.StringField()
        });
        return schema;
    }

    static get compendiumBrowserVehicleDetailsFilters() {
        return new Map([
            ["move", {
                label: "Move",
                type: "range",
                config: {
                    keyPath: "system.details.move.value"
                }
            }],
            ["sail", {
                label: "VEHICLE.Sail",
                type: "boolean",
                config: {
                    keyPath: "system.details.move.sail.enabled"
                }
            }],
            ["oars", {
                label: "VEHICLE.Oars",
                type: "boolean",
                config: {
                    keyPath: "system.details.move.oars.enabled"
                }
            }],
            ["price", {
                label: "Price",
                type: "range",
                config: {
                    text: true,
                    keyPath: "system.details.price.gc"
                }
            }],
            ["availability", {
                label: "Availability",
                type: "set",
                config: {
                    keyPath: "system.details.availability.value",
                    choices: game.wfrp4e.config.availability
                }
            }],
            ["size", {
                label: "Size",
                type: "set",
                config: {
                    choices: game.wfrp4e.config.actorSizes,
                    keyPath: "system.details.size.value"
                }
            }],
            ["length", {
                label: "Length",
                type: "range",
                config: {
                    choices: game.wfrp4e.config.actorSizes,
                    keyPath: "system.details.length.value"
                }
            }],
        ]);
    }

    computeSize()
    {
        let sizeNum = this.length.value;
        if (sizeNum <= 10)
        {
            return "tiny"
        }
        if (sizeNum <= 15)
        {
            return "ltl"
        }
        if (sizeNum <= 20)
        {
            return "sml"
        }
        if (sizeNum <= 35)
        {
            return "avg"
        }
        if (sizeNum <= 50)
        {
            return "lrg"
        }
        if (sizeNum <= 80)
        {
            return "enor"
        }
        return "mnst";
    }

    computeCrewEncumbrance(passengers)
    {
        let crewEncumbrance = 0;
        for (let p of passengers)
        {
            for(let count = 0; count < p.count; count++)
            {
                let bulk = game.wfrp4e.config.crewBulk[p.actor?.details.size.value];
                if (bulk)
                {
                    if (this.crew.current + bulk.crew > this.crew.starting)
                    {
                        crewEncumbrance += bulk.encumbrance;
                    }
                    this.crew.current += bulk.crew;
                }
            }
        }
        return crewEncumbrance
    }

    computeMove()
    {
        if (this.move.custom.label && this.move.custom.value)
        {
            this.move.value = this.move.custom.value;
        }
        else 
        {
            this.move.value = this.move[this.move.primary].value || 0;
        }
        this.move.display = this.formatMoveString();
    }

    formatMoveString()
    {
        let string = "";

        if (this.move.custom.label)
        {
            string = `${this.move.custom.label}`;
            if (this.move.custom.value)
            {
                string += ` (${this.move.custom.value})`;
            }
        }

        if (this.move.sail.enabled)
        {
            if (this.move.primary == "sail")
            {
                string += "<strong>" + game.i18n.localize("VEHICLE.S") + "</strong>"; 
            }
            else 
            {
                string += game.i18n.localize("VEHICLE.S"); 
            }
            if (this.move.sail.value)
            {
                string += ` (${this.move.sail.value})`;
            }
        }

        if (this.move.oars.enabled)
        {
            if (string)
            {
                string += " / ";
            }

            if (this.move.primary == "oars")
            {
                string += "<strong>" + game.i18n.localize("VEHICLE.O") + "</strong>"; 
            }
            else 
            {
                string += game.i18n.localize("VEHICLE.O"); 
            }

            if (this.move.oars.value)
            {
                string += ` (${this.move.oars.value})`;
            }
        }

        return string;
    }
}

foundry.data.fields;
/**
 * Abstract class that interfaces with the Actor class
 */
class BaseActorModel extends BaseWarhammerActorModel {

    static preventItemTypes = [];

    static defineSchema() {
        let schema = {};
        return schema;
    }

    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
            ["linked", {
                label: "TOKEN.CharLink",
                type: "boolean",
                config: {
                    keyPath: "prototypeToken.actorLink"
                }
            }],
        ]);
    }

    static _deriveSource(uuid) {
        const source = super._deriveSource(uuid);

        if (game.wfrp4e.config.premiumModules[source.slug])
            source.value = game.wfrp4e.config.premiumModules[source.slug];

        return source;
    }

    async _preCreate(data, options, user) 
    {
        await super._preCreate(data, options, user);
        
        let preCreateData = {};
        let defaultToken = game.settings.get("core", "prototypeTokenOverrides")[data.type];

        // Set wounds, advantage, and display name visibility
        if (!data.prototypeToken)
            foundry.utils.mergeObject(preCreateData,
                {
                    "prototypeToken.lockRotation": true,
                    "prototypeToken.bar1": { "attribute": "status.wounds" },                 // Default Bar 1 to Wounds
                    "prototypeToken.bar2": { "attribute": "status.advantage" },               // Default Bar 2 to Advantage
                    "prototypeToken.displayName": defaultToken?.displayName || CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,    // Default display name to be on owner hover
                    "prototypeToken.displayBars": defaultToken?.displayBars || CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,    // Default display bars to be on owner hover
                    "prototypeToken.disposition": defaultToken?.disposition || CONST.TOKEN_DISPOSITIONS.NEUTRAL,         // Default disposition to neutral
                    "prototypeToken.name": data.name,                                       // Set token name to actor name,
                    "prototypeToken.texture.src": "systems/wfrp4e/tokens/unknown.png"      // Set token image
                });


        // Set custom default token
        if (!data.img || data.img == "icons/svg/mystery-man.svg") {
            preCreateData.img = "systems/wfrp4e/tokens/unknown.png";
        }

        this.parent.updateSource(preCreateData);
    }

    async _onUpdate(data, options, user) {
        super._onUpdate();
        if (game.user.id == user)
        {
            await this.checkSize();
        }
    }

    /**
     * @return {{}}
     */
    get movementDistance() {
        return {};
    }

    initialize() {}

    computeBase() {
        this.initialize();
    }

    computeItems()
    {
        
    }

    tokenSize() {
        return {}
    }

    getInitialItems()
    {
      return [];
    }

    // Resize tokens based on size property
    checkSize() {
        let actor = this.parent;

        // if (game.user.id != getActiveDocumentOwner(actor)?.id) {
        //     return
        // }
        if (actor.system.autoCalc.size && game.canvas.ready) {
            let tokenData = this.tokenSize();
            if (actor.isToken) 
            {
                return actor.token.update(tokenData)
            }
            else if (canvas) 
            {
                return actor.update({ prototypeToken: tokenData }).then(() => {
                    actor.getActiveTokens().forEach(t => t.document.update(tokenData));
                })
            }
        }
    }

    // toEmbed(config, options)
    // {
    //     config.caption = false;
    //     let img = document.createElement("img");
    //     if (config.token)
    //     {
    //         img.src = this.parent.prototypeToken.texture.src;
    //     }
    //     else 
    //     {
    //         img.src = this.parent.img;
    //     }
    //     return img;
    // }
}

let fields$D = foundry.data.fields;

class CharacteristicsModel extends foundry.abstract.DataModel 
{
    static defineSchema() 
    {
        let schema = {};
        schema.ws = new fields$D.EmbeddedDataField(CharacteristicModel);
        schema.bs = new fields$D.EmbeddedDataField(CharacteristicModel);
        schema.s = new fields$D.EmbeddedDataField(CharacteristicModel);
        schema.t = new fields$D.EmbeddedDataField(CharacteristicModel);
        schema.i = new fields$D.EmbeddedDataField(CharacteristicModel);
        schema.ag = new fields$D.EmbeddedDataField(CharacteristicModel);
        schema.dex = new fields$D.EmbeddedDataField(CharacteristicModel);
        schema.int = new fields$D.EmbeddedDataField(CharacteristicModel);
        schema.wp = new fields$D.EmbeddedDataField(CharacteristicModel);
        schema.fel = new fields$D.EmbeddedDataField(CharacteristicModel);
        return schema;
    }


    compute() 
    {
        for(let ch in this)
        {
            this[ch].computeValue();
            this[ch].computeBonus();
            this[ch].computeCost();
        }
    }
}

class CharacteristicModel extends foundry.abstract.DataModel
{
    static defineSchema() 
    {
        let schema = {};
        schema.initial = new fields$D.NumberField({initial : 20});
        schema.modifier = new fields$D.NumberField({initial : 0});
        schema.advances = new fields$D.NumberField({initial : 0});
        schema.bonusMod = new fields$D.NumberField({initial : 0});
        schema.calculationBonusModifier = new fields$D.NumberField({initial : 0});
        return schema;
    }


    computeValue() 
    {
        this.value = this.initial + this.modifier + this.advances;
    }

    computeBonus() 
    {
        this.bonus = Math.floor(this.value / 10) + this.bonusMod;
    }

    computeCost()
    {
        this.cost = Advancement.calculateAdvCost(this.advances, "characteristic");
    }
}

let fields$C = foundry.data.fields;

class CumulativeVehicleModifiers extends foundry.abstract.DataModel {

    static key = "";
    static initialSources = "";
    static chatRollLabel = "";
    static chatNoModifierLabel = "";
    static starting = 0;


    static defineSchema() {
        let schema = {};
        schema.starting = new fields$C.NumberField({initial: this.starting});
        schema.modifiers = new fields$C.ArrayField(new fields$C.SchemaField({
            value : new fields$C.NumberField(),
            formula : new fields$C.StringField(),
            description : new fields$C.StringField()
        }));
        schema.sources = new fields$C.ArrayField(new fields$C.SchemaField({
            formula : new fields$C.StringField(),
            description : new fields$C.StringField(),
            active : new fields$C.BooleanField()
        }), {initial: game.wfrp4e.config[this.initialSources] || []});
        schema.log = new fields$C.ArrayField(new fields$C.SchemaField({
            label : new fields$C.StringField(),
            range : new fields$C.ArrayField(new fields$C.NumberField())
        }));
        return schema;
    }

    compute()
    {
        this.value = this.starting;
        for(let entry of this.log)
        {
            entry.modifiers = this.modifiers.slice(entry.range[0], entry.range[1]+1);
            entry.value = entry.modifiers.reduce((total, modifier) => total += Number(modifier?.value || 0), 0) || 0;
            this.value += entry.value;
            entry.sum = this.value;
        }
    }

    async roll(label, suppressMsg = false)
    {
        if (!label)
        {
            return;
        }

        let msg = `<h2>${game.i18n.localize(this.constructor.chatRollLabel)}</h2><h4>${label}</h4>`;
        let sources = foundry.utils.deepClone(this.sources.filter(i => i.active));
        if (!sources.length)
        {
            msg += `<p>${game.i18n.localize(this.constructor.chatNoModifierLabel)}</p>`;
        }
        else 
        {
            for(let source of sources)
            {
                let roll = await new Roll(source.formula).roll({allowInteractive : false});
                source.value = roll.total;
                msg += `<p><a class="inline-roll" data-tooltip="${source.formula}">${source.value}</a>: ${source.description}</p>`;
            }
        }
        if (!suppressMsg)
        {
            ChatMessage.create({content : msg}, {speaker : {alias : this.parent.parent.name}, whisper : ChatMessage.getWhisperRecipients("GM")});
        }
        let log = this.updateLog(label, sources);
        this.parent.parent.parent.update({["system.status." + this.constructor.key] :  {modifiers : this.modifiers.concat(sources), log}});
    }

    // Helper for adding a single morale value with a label
    addEntry(label, modifier)
    {
        let modifierEntry = [{value : modifier}];
        return this.parent.parent.parent.update({["system.status." + this.constructor.key] :  {modifiers : this.modifiers.concat(modifierEntry), log : this.updateLog(label, modifierEntry)}});
    }

    setValue(label, value)
    {
        let diffValue = value - this.value;
        return this.addEntry(label, diffValue)
    }

    updateLog(label, newModifiers)
    {
        let range = [this.modifiers.length, this.modifiers.length + newModifiers.length - 1];
        return this.log.concat([{label, range}])
    }

    deleteLog(index)
    {
        let newLog = foundry.utils.deepClone(this.log);
        newLog.splice(index, 1);
        return newLog
    }

    clear()
    {
        this.parent.parent.parent.update({["system.status." + this.constructor.key] :  {modifiers : [], log : []}});
    }
}

class ManannMoodModel extends CumulativeVehicleModifiers {

    static key = "mood";
    static initialSources = "initialMoodSources";
    static chatRollLabel = "VEHICLE.ManannsMoodRolls";
    static chatNoModifierLabel = "VEHICLE.NoManannsMoodModifiers";


    async rollEvents(key)
    {
        let modifier = this.value;
        if (key == "port-stay-events")
        {
            modifier = this.value > 0 ? 1 : -1;
        }

        let result = await game.wfrp4e.tables.formatChatRoll(key, {modifier, showRoll : true});

        if (result)
        {
            ChatMessage.create(ChatMessage.applyRollMode({content : result, speaker : {alias : this.parent.parent.parent.name}, flavor : game.i18n.localize("VEHICLE.ManannsMood") + " - " + game.wfrp4e.tables.findTable(key).name}, "gmroll"));
        }

    }
}

let fields$B = foundry.data.fields;

class MoraleModel extends CumulativeVehicleModifiers {

    static key = "morale";
    static initialSources = "initialMoraleSources";
    static chatRollLabel = "VEHICLE.MoraleRolls";
    static chatNoModifierLabel = "VEHICLE.NoMoraleModifiers";
    static starting = 75;

    static defineSchema() {
        let schema = super.defineSchema();
        schema.transferEffects = new fields$B.BooleanField({initial : true});
        return schema;
    }


    getMoraleEffects(actor)
    {
        if (this.transferEffects)
        {
            if (this.value >= 101)
            {
                return [game.wfrp4e.config.vehicleSystemEffects["master-captain"]].filter(i => i).map(i => new ActiveEffect.implementation(i, {parent: actor}))
            }
            else if (this.value >= 76)
            {
                return [game.wfrp4e.config.vehicleSystemEffects["fine-crew"]].filter(i => i).map(i => new ActiveEffect.implementation(i, {parent: actor}))
            }
            else if (this.value <= 50)
            {
                return [game.wfrp4e.config.vehicleSystemEffects["knaves"]].filter(i => i).map(i => new ActiveEffect.implementation(i, {parent: actor}))
            }
        }
                    
        return []
    }
}

let fields$A = foundry.data.fields;

class StandardStatusModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.advantage = new fields$A.SchemaField({
            value: new fields$A.NumberField({ initial: 0 }),
            max: new fields$A.NumberField({})
        });

        schema.wounds = new fields$A.SchemaField({
            value: new fields$A.NumberField({ initial: 8, min : 0}),
            max: new fields$A.NumberField({initial: 8, min : 0}),
        });
        schema.criticalWounds = new fields$A.SchemaField({
            value: new fields$A.NumberField({ initial: 0, min : 0 }),
            max: new fields$A.NumberField(),
        });
        schema.sin = new fields$A.SchemaField({
            value: new fields$A.NumberField({ initial: 0, min : 0 })
        });

        schema.corruption = new fields$A.SchemaField({
            value: new fields$A.NumberField({ initial: 0, min : 0 }),
            max : new fields$A.NumberField({initial : 0})
        });

        schema.encumbrance = new fields$A.SchemaField({
            current: new fields$A.NumberField({ initial: 0, min : 0 }),
            max: new fields$A.NumberField({ initial: 0 }),
        });

        schema.ward = new fields$A.SchemaField({
            value : new fields$A.NumberField({ initial: 0 }),
            // sources : new fields.ArrayField(new fields.StringField())
        });
        schema.mount = new fields$A.EmbeddedDataField(MountModel);
        return schema;
    }

    initializeArmour()
    {
        this.armour = {
            head: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Head"),
                show: true,
            },
            body: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Body"),
                show: true
            },
            rArm: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Right Arm"),
                show: true
            },
            lArm: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Left Arm"),
                show: true
            },
            rLeg: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Right Leg"),
                show: true

            },
            lLeg: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Left Leg"),
                show: true
            },
            shield: 0,
            shieldDamage: 0
        };
    }

    // Add armour values from armour items specifically
    addArmourItem(item) {
        // If the armor protects a certain location, add the AP value of the armor to the AP object's location value
        // Then pass it to addLayer to parse out important information about the armor layer, namely qualities/flaws
        for (let loc in item.system.currentAP) {
          if (item.system.currentAP[loc] > 0) {
    
            this.armour[loc].value += item.system.currentAP[loc];
    
            let layer = {
              value: item.system.currentAP[loc],
              armourType: item.system.armorType.value, // used for sound
              source : item
            };
    
            let properties = item.system.properties;
            layer.impenetrable = !!properties.qualities.impenetrable;
            layer.partial = !!properties.flaws.partial;
            layer.weakpoints = !!properties.flaws.weakpoints;
            layer.magical = item.system.isMagical;
    
            layer.metal = item.system.isMetal;
    
            this.armour[loc].layers.push(layer);
          }
        }
    }

    // Add armour values from shield items specifically
    addShieldItem(item)
    {
        this.armour.shield += item.properties.qualities.shield.value - Math.max(0, item.damageToItem.shield - Number(item.properties.qualities.durable?.value || 0));
        this.armour.shieldDamage += item.damageToItem.shield;
    }

    // General function (usually used by scripts) to add armour values
    addArmour(value, {locations=[], source=null, metal=false, magical=false, impenetrable=false, partial=false, weakpoints=false, damage={}}={})
    {
        if (!locations || locations.length == 0)
        {
            // If no locations provided, assume all
            locations = ["lArm", "rArm", "lLeg", "rLeg", "body", "head"];
        }

        if (typeof locations == "string")
        {
            locations = [locations];
        }

        for(let loc of locations)
        {
            // Subtract damage from protection value, can't be below 0
            let armour = Math.max(0, value - (damage[loc] || 0));
            this.armour[loc].value += armour;
            
            this.armour[loc].layers.push({
                source,
                impenetrable,
                partial,
                weakpoints,
                magical,
                metal,
                value : armour
            });
        }
    }
}


class CharacterStatusModel extends StandardStatusModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.fortune = new fields$A.SchemaField({
            value: new fields$A.NumberField({ initial: 0, min: 0}),
        });
        schema.fate = new fields$A.SchemaField({
            value: new fields$A.NumberField({ initial: 0, min: 0}),
        });
        schema.resilience = new fields$A.SchemaField({
            value: new fields$A.NumberField({ initial: 0, min: 0}),
        });
        schema.resolve = new fields$A.SchemaField({
            value: new fields$A.NumberField({ initial: 0, min: 0}),
        });
        return schema;
    }

    increment(type)
    {
        return {[`system.${this.schema.fieldPath}.${type}.value`] : this[type].value + 1}
    }

    decrement(type)
    {
        return {[`system.${this.schema.fieldPath}.${type}.value`] : this[type].value - 1}
    }
}

let fields$z = foundry.data.fields;

/**
 * Represents actors that have characteristics and skills
 * Encompasses player characters and NPCs
 */
class StandardActorModel extends BaseActorModel {
    static preventItemTypes = ["vehicleMod", "vehicleRole", "vehicleTest"];

    static metadata = Object.freeze(foundry.utils.mergeObject(super.metadata, {
        isStandard: true
    }, {inplace: false}));

    static LOCALIZATION_PREFIXES = ["WH.Models.standard"];


    static defineSchema() {
        let schema = super.defineSchema();
        schema.characteristics = new fields$z.EmbeddedDataField(CharacteristicsModel);
        schema.status = new fields$z.EmbeddedDataField(StandardStatusModel);
        schema.details = new fields$z.EmbeddedDataField(StandardDetailsModel);
        schema.settings = new fields$z.SchemaField({
            equipPoints : new fields$z.NumberField({initial : 2}),
            autoCalc : new fields$z.SchemaField({
                run: new fields$z.BooleanField({initial : true}),
                walk: new fields$z.BooleanField({initial : true}),
                wounds: new fields$z.BooleanField({initial : true}),
                criticals: new fields$z.BooleanField({initial : true}),
                corruption: new fields$z.BooleanField({initial : true}),
                encumbrance: new fields$z.BooleanField({initial : true}),
                size: new fields$z.BooleanField({initial : true})
            })
        });
        return schema;
    }

    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
            ...Array.from(StandardDetailsModel.compendiumBrowserDetailsFilters),
        ]);
    }

    async _preCreate(data, options, user) {
        await super._preCreate(data, options, user);
    }

    async _preUpdate(data, options, user) {
        await super._preUpdate(data, options, user);

        // Treat the custom default token as a true default token
        // If you change the actor image from the default token, it will automatically set the same image to be the token image
        if (this.prototypeToken?.texture?.src == "systems/wfrp4e/tokens/unknown.png" && data.img) 
        {
            data["prototypeToken.texture.src"] = data.img;
        }

        await this._handleGroupAdvantage(data, options);
        this._handleWoundsUpdate(data, options);
        this._handleAdvantageUpdate(data, options);

    }

    /**
     * @return {ItemWFRP4e|undefined}
     */
    get canFly() {
        return this.parent.has(game.i18n.localize("NAME.Flight"));
    }

    /**
     * @return {boolean}
     */
    get canSwim() {
        return (this.parent.has(game.i18n.localize("NAME.Swim"), "skill") || this.parent.has(game.i18n.localize("NAME.Amphibious")));
    }

    /**
     * @return {boolean}
     */
    get canCrawl() {
        return true;
    }

    /**
     * @return {boolean}
     */
    get canClimb() {
        return true;
    }

    /**
     * @return {{walk: number[], swim: number[], climb: number[], crawl: number, fly: number}}
     */
    get movementDistance() {
        const value = this.details.move.value;
        const walk = [this.details.move.walk, this.details.move.run];

        return {
            walk,
            swim: this.parent.has(game.i18n.localize("NAME.Amphibious")) ? walk : walk.map(v => v * 0.5),
            climb: walk.map(v => v * 0.5),
            crawl: value * 0.5,
            fly: this.canFly?.system.specification.value || 0,
        }
    }

    itemIsAllowed(item) {
        let allowed = super.itemIsAllowed(item);

        // Prevent vehicle traits
        if (allowed && item.type == "trait")
        {
            allowed = allowed && item.system.category == "standard";
            if (!allowed)
            {
                ui.notifications.error("ERROR.VehicleTraitsOnStandard", {localize : true});
                return false;
            }
        }
        return allowed
    }

    
    computeItems()
    {
        for (let i of this.parent.items) {
            i.prepareOwnedData();
            
            if (i.location && i.location.value && i.type != "critical" && i.type != "injury") 
            ;
            else if (i.encumbrance && i.type != "vehicleMod")
            {
                this.status.encumbrance.current += Number(i.encumbrance.total);
            }
        }
        this.status.encumbrance.current = this.status.encumbrance.current.toFixed(2);
    }

    computeBase() {
        super.computeBase();
        this.characteristics.compute();

        let flags = this.parent.flags;
        // TODO: Find alternative to this
        flags.meleeDamageIncrease = 0;
        flags.rangedDamageIncrease = 0;
        flags.robust = 0;
        flags.resolute = 0;
        flags.ambi = 0;
        flags.useless = {};

        this.runScripts("prePrepareData", { actor: this.parent });
    }

    computeDerived() {
        this.runScripts("prePrepareItems", {actor : this.parent });
        // Recompute bonuses as active effects may have changed it
        this.computeTemplates();
        this.characteristics.compute();
        this.computeItems();
        super.computeDerived();
        this.runScripts("computeCharacteristics", this.parent);
        this.computeSize();
        if (this.checkWounds())
        {
            return;
        }
        this.computeAdvantage();
        this.computeMove();
        this.computeEncumbranceMax();
        this.runScripts("computeEncumbrance", this.parent);
        this.computeEncumbranceState();
        this.computeArmour();
        this.computeMount();

        if (game.actors && this.parent.inCollection) // Only check system effects if past this: isn't an on-load prepareData and the actor is in the world (can be updated)
            this.parent.checkSystemEffects();

        this.runScripts("prepareData", { actor: this.parent });

    }

    computeTemplates()
    {
        let templates = this.parent.itemTypes.template;
        for(let t of templates)
        {
            for(let c in this.characteristics)
            {
                this.characteristics[c].modifier += t.system.characteristics[c];
            }
        }
    }

    computeAdvantage() {
        if (!game.settings.get("wfrp4e", "useGroupAdvantage")) {
            if (game.settings.get("wfrp4e", "capAdvantageIB")) {
                this.status.advantage.max = this.characteristics.i.bonus;
                this.status.advantage.value = Math.clamp(this.status.advantage.value, 0, this.status.advantage.max);
            }
            else
                this.status.advantage.max = game.settings.get("wfrp4e", "advantagemax");
        }
    }


    computeMove() {
        // Auto calculation values - only calculate if user has not opted to enter ther own values
        if (this.autoCalc.walk)
            this.details.move.walk = Number(this.details.move.value) * 2;

        if (this.autoCalc.run)
            this.details.move.run = Number(this.details.move.value) * 4;

    }
    computeSize() {
        let items = this.parent.itemTypes;
        // Find size based on Traits/Talents
        let size;
        let trait = items.trait.find(i => i.name == game.i18n.localize("NAME.Size") && i.system.enabled);
        if (trait)
            size = warhammer.utility.findKey(trait.specification.value, game.wfrp4e.config.actorSizes);
        if (!size) // Could not find specialization
        {
            let smallTalent = items.talent.find(i => i.name == game.i18n.localize("NAME.Small"));
            if (smallTalent)
                size = "sml";
            else
                size = "avg";
        }

        let args = { size };
        this.runScripts("calculateSize", args);

        // If the size has been changed since the last known value, update the value 
        this.details.size.value = args.size || "avg";
    }

    computeEncumbranceMax() {
        if (this.autoCalc.encumbrance) {
            this.status.encumbrance.max = this.characteristics.t.bonus + this.characteristics.s.bonus;

            // I don't really like hardcoding this TODO: put this in Large effect script?
            if (this.details.species.value?.toLowerCase() == game.i18n.localize("NAME.Ogre").toLowerCase()) {
                this.status.encumbrance.max *= 2;
            }
        }
    }

    computeEncumbranceState() {
        this.status.encumbrance.current = this.status.encumbrance.current;
        this.status.encumbrance.state = this.status.encumbrance.current / this.status.encumbrance.max;
    }


    computeArmour() {

        this.status.initializeArmour();
        
        let args = { AP : this.status.armour };

        this.runScripts("preAPCalc", args);

        this.parent.itemTags["armour"].filter(a => a.isEquipped).forEach(a => this.status.addArmourItem(a));
        this.parent.itemTags["weapon"].filter(i => i.properties.qualities.shield && i.isEquipped).forEach(i => this.status.addShieldItem(i));
        
        this.runScripts("APCalc", args);
    }

    /**
  * Calculates the wounds of an actor based on prepared items
  * 
  * Once all the item preparation is done (prepareItems()), we have a list of traits/talents to use that will
  * factor into Wonuds calculation. Namely: Hardy and Size traits. If we find these, they must be considered
  * in Wound calculation. 
  * 
  * @returns {Number} Max wound value calculated
  */
    computeWounds() {

        // Easy to reference bonuses
        let sb = this.characteristics.s.bonus + (this.characteristics.s.calculationBonusModifier || 0);
        let tb = this.characteristics.t.bonus + (this.characteristics.t.calculationBonusModifier || 0);
        let wpb = this.characteristics.wp.bonus + (this.characteristics.wp.calculationBonusModifier || 0);
        let multiplier = {
            sb: 0,
            tb: 0,
            wpb: 0,
        };

        if (this.autoCalc.criticals)
            this.status.criticalWounds.max = tb;

        let effectArgs = { sb, tb, wpb, multiplier, actor: this.parent };
        this.runScripts("preWoundCalc", effectArgs);
        ({ sb, tb, wpb } = effectArgs);

        let wounds = this.status.wounds.max;

        if (this.autoCalc.wounds) {
            switch (this.details.size.value) // Use the size to get the correct formula (size determined in prepare())
            {
                case "tiny":
                    wounds = 1 + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "ltl":
                    wounds = tb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "sml":
                    wounds = 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "avg":
                    wounds = sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "lrg":
                    wounds = 2 * (sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb);
                    break;

                case "enor":
                    wounds = 4 * (sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb);
                    break;

                case "mnst":
                    wounds = 8 * (sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb);
                    break;
            }
        }

        effectArgs = { wounds, actor: this.parent };
        this.runScripts("woundCalc", effectArgs);
        wounds = effectArgs.wounds;
        return wounds
    }

    checkWounds(force=false) {
        if (this.autoCalc.wounds || force) {
            let newMaxWounds = this.computeWounds();
            let updateCurrentWounds = this.status.wounds.value == this.status.wounds.max;

            if (this.status.wounds.max != newMaxWounds) // If change detected, reassign max and current wounds only if current == max
             {
                if (this.parent.compendium || !game.actors || !this.parent.inCollection) // Initial setup, don't send update
                {
                  this.status.wounds.max = newMaxWounds;
                  if (updateCurrentWounds)
                  {
                    this.status.wounds.value = newMaxWounds;
                  }   
                }
                else
                {
                    if (game.user.id == getActiveDocumentOwner(this.parent)?.id) 
                    {
                        this.parent.update({ 
                            "system.status.wounds.max": newMaxWounds, 
                            "system.status.wounds.value": updateCurrentWounds ? newMaxWounds : this.status.wounds.value }); // Only update current if unwounded
                    }
                }
            }
        }
    }


    async _handleGroupAdvantage(data, options) {
        if (!options.skipGroupAdvantage && foundry.utils.hasProperty(options.changed, "system.status.advantage.value") && game.settings.get("wfrp4e", "useGroupAdvantage")) {
            let combatant = game.combat?.getCombatantByActor(this.parent);

            if (!combatant) {
                ui.notifications.notify(game.i18n.localize("GroupAdvantageNoCombatant"));
            }
            // Don't send groupAdvantage updates if this update is from group advantage
            else if (!options.fromGroupAdvantage) {
                await WFRP_Utility.updateGroupAdvantage({ [`${this.parent.advantageGroup}`]: data.system.status.advantage.value });
                delete data.system.status.advantage.value; // Don't use this advantage update, as updating group advantage does it for us. This prevents a duplicate scrolling number on the token
            }
        }
    }

    _handleWoundsUpdate(data, options) {
        // Prevent wounds from exceeding max
        if (foundry.utils.hasProperty(data, "system.status.wounds.value")) {
            if (data.system.status.wounds.value > (foundry.utils.getProperty(data, "system.status.wounds.max") || this.status.wounds.max)) {
                data.system.status.wounds.value = this.status.wounds.max;
            }

            options.deltaWounds = data.system.status.wounds.value - this.status.wounds.value;
        }
    }

    _handleAdvantageUpdate(data, options) {
        if (foundry.utils.hasProperty(data, "system.status.advantage.value")) 
        {
            if (!game.settings.get("wfrp4e", "useGroupAdvantage")) {
                let maxAdvantage;
                if (game.settings.get("wfrp4e", "capAdvantageIB"))
                    maxAdvantage = this.characteristics.i.bonus;
                else
                    maxAdvantage = game.settings.get("wfrp4e", "advantagemax");

                if (data.system.status.advantage.value > maxAdvantage) {
                    data.system.status.advantage.value = this.status.advantage.max;
                }
            }

            options.deltaAdv = data.system.status.advantage.value - this.status.advantage.value;
        }
    }

    tokenSize() {
        let tokenData = {};
        let tokenSize = game.wfrp4e.config.tokenSizes[this.details.size.value];
        if (tokenSize < 1) {
            tokenData.texture = { scaleX: tokenSize, scaleY: tokenSize };
            tokenData.width = 1;
            tokenData.height = 1;
        }
        else {
            tokenData.height = tokenSize;
            tokenData.width = tokenSize;
        }
        return tokenData;
    }

    computeMount() {
        this.parent.flags;

        if (this.isMounted && !game.actors) {
            game.wfrp4e.postReadyPrepare.push(this);
        }
        else if (this.isMounted && this.status.mount.isToken && !canvas) {
            game.wfrp4e.postReadyPrepare.push(this);
        }
        else if (this.isMounted) {
            let mount = this.mount;

            if (mount) {
                if (mount.status.wounds.value == 0)
                    this.status.mount.mounted = false;
                else {

                    this.details.move.value = mount.details.move.value;

                    if (this.autoCalc.walk)
                        this.details.move.walk = mount.details.move.walk;

                    if (this.autoCalc.run)
                        this.details.move.run = mount.details.move.run;
                }
            }
        }
    }

    
      /**
   * Returns items for new actors: money and skills
   */
  async getInitialItems(prompt=false) {

    let basicSkills = await WFRP_Utility.allBasicSkills() || [];
    let moneyItems = ((await WFRP_Utility.allMoneyItems()) || [])
      .map(m => { // Set money items to descending in value and set quantity to 0
        m.system.quantity.value= 0;
        return m;
      })
      .sort((a, b) => (a.system.coinValue.value >= b.system.coinValue.value) ? -1 : 1)
      || [];

    if (!prompt)
    {
        return basicSkills.concat(moneyItems)
    }
    // If not a character, ask the user whether they want to add basic skills / money
    else
    {
        if (await foundry.applications.api.DialogV2.confirm({window : {title: game.i18n.localize("ACTOR.BasicSkillsTitle")}, content: `<p>${game.i18n.localize("ACTOR.BasicSkillsPrompt")}</p>`}))
        {
            return basicSkills.concat(moneyItems);
        }
        else 
        {
            return []
        }
    }
  }

    getOtherEffects() 
    {
        if (this.vehicle)
        {
            return super.getOtherEffects().concat(this.vehicle.system.crewEffects)
        }
        else return [];
    }

    get vehicle()
    {
        return game.actors.contents.find(i => i.type == "vehicle" && i.system.passengers.has(this.parent));
    }

    advance(career)
    {
        let adv = new Advancement(this.parent, career);
        adv.advance();
    }

    hasVehicleRole(role)
    {
        if (!this.vehicle)
        {
            return false;
        }
        else 
        {
            let passenger = this.vehicle.system.passengers.get(this.parent.id);
            return passenger.roles.some(r => r.name == role);
        }
    }

    get equipPointsUsed() {
        return this.parent.items
          .filter(item => item.system.isEquippable)
          .reduce((prev, current) => {
              if (current.system.isEquipped)
                prev += current.system.equipPoints;
              return prev;
            }, 0);
      }

    get isMounted() {
        return this.status.mount.mounted && this.status.mount.id
    }

    get autoCalc() {
        return this.settings.autoCalc;
    }

    get mount() {
        if (this.status.mount.isToken) {
            let scene = game.scenes.get(this.status.mount.tokenData.scene);
            if (canvas?.scene && canvas.scene.id != scene?.id)
            {
                return ui.notifications.error(game.i18n.localize("ErrorTokenMount"))
            }
            else if (!canvas?.scene)
            {
                return null;
            }
            let token = canvas.tokens.get(this.status.mount.tokenData.token);

            if (token)
                return token.actor
        }
        let mount = game.actors.get(this.status.mount.id);
        return mount
    }
}

class ActorSheetWFRP4eVehicle extends BaseWFRP4eActorSheet
{
    static DEFAULT_OPTIONS = {
        classes: ["vehicle"],
        position : {
          height: 750
        },
        actions: {
          configureMove : this._onConfigureMove,
          rollCharacteristic : this._onRollCharacteristic,
          configureCrew : this._onConfigureCrew,
          rollMorale : this._onRollMorale,
          configureMorale : this._onConfigureMorale,
          rollMood : this._onRollMood,
          configureMood : this._onConfigureMood,
          passengerQty : {buttons: [0, 2], handler : this._onPassengerQtyClick},
          rollExtendedTest : this._onExtendedTestSelect,
          rollCrewTest : this._onRollCrewTest,
          passengerClick : this._onPassengerClick,
          roleClick : this._onRoleClick,
          moodEventClick : this._onMoodEventsClick,
          rollTest : this._onRollTest,
          sellCargo : this._onSellCargo
        },
        window : {
          resizable : true
        },
      }

      static PARTS = {
        header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/actor/vehicle/vehicle-header.hbs', classes: ["sheet-header"] },
        tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/actor-tabs.hbs' },
        main: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/vehicle/vehicle-main.hbs'},
        cargo: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/vehicle/vehicle-cargo.hbs' },
        effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/vehicle/vehicle-effects.hbs' },
        description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/actor/vehicle/vehicle-description.hbs' },
      }

      static TABS = {
        main: {
          id: "main",
          group: "primary",
          label: "Main",
        },
        cargo: {
          id: "cargo",
          group: "primary",
          label: "Cargo",
        },
        effects: {
          id: "effects",
          group: "primary",
          label: "Effects",
        },
        description: {
          id: "description",
          group: "primary",
          label: "Description",
        }
      }

  async _handleEnrichment() 
  {
    let enrichment = {};
    enrichment["system.details.description.value"] = await foundry.applications.ux.TextEditor.implementation.enrichHTML(this.actor.system.details.description.value, { async: true, secrets: this.actor.isOwner, relativeTo: this.actor });
    enrichment["system.details.gmdescription.value"] = await foundry.applications.ux.TextEditor.implementation.enrichHTML(this.actor.system.details.gmdescription.value, { async: true, secrets: this.actor.isOwner, relativeTo: this.actor });

    return foundry.utils.expandObject(enrichment)
  }

  async _prepareContext(options) {
    let context = await super._prepareContext(options);
    context.system.crew = foundry.utils.deepClone(context.system.crew);
    context.system.crew.forEach(c => c.rolesDisplay = c.roles.map(i => `<a data-action="roleClick" data-role-id="${i.id}">${i.name}</a>`).join(", "));
    context.portStayEvents = game.wfrp4e.tables.findTable("port-stay-events");
    context.shipboardEvents = game.wfrp4e.tables.findTable("shipboard-events");
    this._addEncumbranceData(context);
    return context;
  }


  _addEncumbranceData(context) 
  {
    context.system.status.encumbrance.max = context.system.status.carries.max;
    context.system.status.encumbrance.pct = context.system.status.encumbrance.over / context.system.status.encumbrance.max * 100;
    context.system.status.encumbrance.carryPct = context.system.status.encumbrance.current / context.system.status.carries.max * 100;
    if (context.system.status.encumbrance.pct + context.system.status.encumbrance.carryPct > 100) {
      context.system.status.encumbrance.penalty = Math.floor(((context.system.status.encumbrance.carryPct + context.system.status.encumbrance.pct) - 100) / 10);
      context.system.status.encumbrance.message = game.i18n.format("VEHICLE.HandlingPenalty", { penalty: context.system.status.encumbrance.penalty });
      context.system.status.encumbrance.overEncumbered = true;
    }
    else {
      context.system.status.encumbrance.message = game.i18n.localize("VEHICLE.HandlingNoPenalty");
      if (context.system.status.encumbrance.pct + context.system.status.encumbrance.carryPct == 100 && context.system.status.encumbrance.carryPct)
        context.system.status.encumbrance.carryPct -= 1;
    }
    context.system.status.encumbrance.total = context.system.status.encumbrance.current + context.system.status.encumbrance.over;
    context.system.status.encumbrance.modMsg = game.i18n.format("VEHICLE.ModEncumbranceTT", { amt: context.system.status.encumbrance.over }),
      context.system.status.encumbrance.carryMsg = game.i18n.format("VEHICLE.CarryEncumbranceTT", { amt: Math.round(context.system.status.encumbrance.current * 10) / 10 });
  }

  async _onDropActor(data, event) {
    let document = await Actor.implementation.fromDropData(data);
    if (document?.system instanceof StandardActorModel) {
      if (document.pack) {
        return ui.notification.error("Cannot use Compendium Actors with Vehicles")
      }
    }
    this.actor.update(this.actor.system.passengers.add(document));
  }

  static _onPassengerClick(ev) {
    let id = this._getId(ev);
    this.actor.system.passengers.get(id)?.actor?.sheet.render(true);
  }

  static async _onRollCharacteristic(ev)
  {
    let test = await this.actor.setupCharacteristic("t");
    test.roll();
  }

  static async _onRollTest(ev, target) 
  {
    let type = target.dataset.type;

    if (type == "weapon") {
      let weapon = this._getDocument(ev);

      let vehicleSpeaker;
      if (this.actor.isToken)
        vehicleSpeaker = 
      {
          token: this.actor.token.id,
          scene: this.actor.token.parent.id
        };
      else
        vehicleSpeaker =
        {
          actor: this.actor.id
        };


      let actor = await this.actor.system.passengers.choose();

      let test = await actor.setupWeapon(weapon, { vehicle: vehicleSpeaker, ammo: this.actor.itemTags["ammunition"] });
      test.roll();
    }
    else {
      return super._onRollTest(ev, target);
    }
  }

  static _onSellCargo(ev)
  {
    let item = this._getDocument(ev);
    if (item?.type == "cargo")
    {
      game.wfrp4e.trade.attemptSell(item);
    }
  }

  static _onPassengerQtyClick(ev) {
    let multiplier = ev.button == 0 ? 1 : -1;
    multiplier = ev.ctrlKey ? multiplier * 10 : multiplier;
    let id = this._getId(ev);
    this.actor.update(this.actor.system.passengers.count(id,1 * multiplier ));
  }

  static _onRoleClick(ev, target) {
    let id = this._getId(ev);
    let actor = this.actor.system.passengers.get(id)?.actor;
    let role = this.actor.items.get(target.dataset.roleId);
    if (role && actor)
    {
      role.system.roll(actor);
    }
  }

  static _onConfigureMove(ev) {
    new VehicleMoveConfig(this.actor).render(true);
  }

  static _onConfigureCrew(ev)
  {
    new VehicleCrew(this.actor).render(true);
  }

  static async _onRollMorale(ev) 
  {
    new VehicleCumulativeModifiersConfig(this.actor, {key : "morale", roll: true}).render(true);
  }

  static async _onRollMood(ev) 
  {
    new VehicleCumulativeModifiersConfig(this.actor, {key : "mood", roll: true}).render(true);
  }

  static _onConfigureMorale(ev)
  {
    new VehicleCumulativeModifiersConfig(this.actor, {key : "morale"}).render(true);
  }

  static _onConfigureMood(ev)
  {
    new VehicleCumulativeModifiersConfig(this.actor, {key : "mood"}).render(true);
  }

  static _onMoodEventsClick(ev, target)
  {
    this.actor.system.status.mood.rollEvents(target.dataset.key);  
  }

  //#region Trappings
  _prepareCargoContext(context) {
    context.inventory = this.prepareInventory();
  }

  static async _onExtendedTestSelect(ev) {
    let item = this._getDocument(ev);
    let actor = await this.actor.system.passengers.choose();    
    actor.setupExtendedTest(item);
  }

  static async _onRollCrewTest(ev)
  {
    let test = this._getDocument(ev);
    if (test)
    {
      test.system.roll();
    }
  }
}

class CrewTest 
{
    constructor(item) {
        this.item = item;
        this.messageId = foundry.utils.randomID();
        this.roles = this.initializeRoles();

    }

    static fromData(data)
    {
        let test = new this(fromUuidSync(data.uuid));
        test.messageId = data.messageId;
        test.roles = data.roles;
        return test;
    }

    toData()
    {
        return {
            uuid : this.item.uuid,
            messageId : this.messageId,
            roles : this.roles
        }
    }

    initializeRoles()
    {
        let roles = {};
        let actor = this.item.actor;

        for(let role of this.item.system.roles.value.split(",").map(i => i.trim()))
        {
            let roleItem = actor.itemTypes.vehicleRole.find(i => i.name == role);

            if (roleItem)
            {
                roles[roleItem.id] = {
                    name : role,
                    messageId : null
                };
            }
            else 
            {
                // Won't be found
                roles[foundry.utils.randomID()] = {
                    name : role,
                    unknown : true
                };
            }
        }
        return roles;
    }


    updateRole(roleId, message)
    {
        if (this.roles[roleId])
        {
            this.roles[roleId].messageId = message._id;
        }
        this.renderChatPrompt();
    }

    get totalSL()
    {
        if (Object.values(this.roles).some(i => !i.messageId))
        {
            return "???"
        }

        let tests = Object.values(this.roles).map(i => game.messages.get(i.messageId)?.system.test).filter(i => i);

        let SL = tests.reduce((SL, test) => SL + test.result.crewTestSL, 0);

        return SL;
    }
    

    renderChatPrompt()
    {
        let actor = this.item.actor;
        if (!actor)
        {
            throw Error("Must be owned by an Actor to prompt a Crew Test")
        }

                
        let crew = actor.system.crew;
        let html = "";
        for(let id in this.roles)
        {
            let roleHTML = "";
            let roleData = this.roles[id];
            let role = roleData.name;
            let roleItem = actor.items.get(id);
            let crewWithRole = crew.filter(c => c.roles.find(i => i.name == role));
            if (roleItem)
            {

                let isVital = roleItem.system.isVitalFor(this.item);
                roleHTML += `<strong>${role}</strong>`;
                if (isVital)
                {                    roleHTML = `<em>${roleHTML}</em>`;
                }
                
                if (crewWithRole.length > 0)
                {
                    roleHTML = `<p>${roleHTML}: ${crewWithRole.map(c => c.actor.name).join(", ")}</p>`;
                }
                else 
                {
                    roleHTML = `<p>${roleHTML}: ${game.i18n.localize("CHAT.NoCrewWithRole")}</p>`;
                }
                roleHTML += `<a class="chat-button" data-action="crewTest" data-vital="${isVital}" data-uuid="${roleItem.uuid}">${roleItem.system.test} ${roleData.messageId ? '<i class="fa-solid fa-check"></i>' : ""}</a>`;
            }
            else 
            {
                roleHTML += `${game.i18n.format("CHAT.RoleNotFound", {role})}`;
            }
            html += roleHTML + "<hr>";
        }

        html += `<h3 style='border: none'>${game.i18n.localize("CHAT.TotalSL")}: <span class='sl-total'>${this.totalSL}</span></h3>`;


        let chatData = {
            _id : this.messageId,
            content : `
                <h3>${this.item.name}</h3>
                ${html}
            `,
            speaker : {
                alias : actor?.name,
            },
            flavor : game.i18n.localize("CHAT.CrewTest"),
            flags : {
                wfrp4e : {
                    crewTestData : this.toData()
                }
            }
        };


        if (this.message)
        {
            this.message.update(chatData);
        }
        else 
        {
            ChatMessage.create(chatData, {keepId: true});
        }
    }

    get message()
    {
        return game.messages.get(this.messageId);
    }
}

class TestWFRP extends WarhammerTestBase {
  constructor(data, actor) {
    super();
    if (!data)
      data = {};
    this.data = {
      preData: {
        SL: data.SL,
        roll: data.roll,
        target: data.target,
        rollClass: this.constructor.name,
        testModifier: data.modifier || 0,
        testDifficulty: (typeof data.difficulty == "string" ? game.wfrp4e.config.difficultyModifiers[data.difficulty] : data.difficulty) || 0,
        successBonus: data.successBonus || 0,
        slBonus: data.slBonus || 0,
        hitLocation: data.hitLocation != "none" && data.hitLocation || false,
        characteristic : data.characteristic,
        item: data.item,
        diceDamage: data.diceDamage,
        options: data.context || {},
        other: data.other || [],
        canReverse: data.canReverse || false,
        postOpposedModifiers: data.postOpposedModifiers || { modifiers: 0, SL: 0 },
        additionalDamage: data.additionalDamage || 0,
        selectedHitLocation : typeof data.hitLocation == "string" ? data.hitLocation : "", // hitLocation could be boolean
        hitLocationTable : data.hitLocationTable,
      },
      result: {
        roll: data.roll,
        description: "",
        tooltips: {}
      },
      context: {
        rollMode: data.rollMode,
        reroll: false,
        edited: false,
        speaker: data.speaker,
        title : data.context?.title,
        targets: data.targets,
        chatOptions: data.chatOptions,
        unopposed : data.unopposed,
        defending : data.defending,
        breakdown : foundry.utils.mergeObject({damage : {other : []}}, data.context?.breakdown || {}),

        messageId: data.messageId,
        opposedMessageIds : data.opposedMessageIds || [],
        fortuneUsedReroll: data.fortuneUsedReroll,
        fortuneUsedAddSL: data.fortuneUsedAddSL,
      }
    };

    if (this.context.speaker && this.actor.isOpposing && this.context.targets.length)
    {
      ui.notifications.notify(game.i18n.localize("TargetingCancelled"));
      this.context.targets = [];
    }

    if (!this.context.speaker && actor)
      this.context.speaker = actor.speakerData();
  }

  computeTargetNumber() {
    if (this.preData.target)
      this.data.result.target = this.preData.target;
    else
      this.data.result.target += this.targetModifiers;
  }

  async runPreEffects() {
    if (!this.context.unopposed)
    {
      await Promise.all(this.actor.runScripts("preRollTest", { test: this, chatOptions: this.context.chatOptions }));
      if (this.item instanceof Item)
      {
        await Promise.all(this.item.runScripts("preRollTest", { test: this, chatOptions: this.context.chatOptions }));
      }
    }
  }

  async runPostEffects() {
    if (!this.context.unopposed)
    {
      await Promise.all(this.actor.runScripts("rollTest", { test: this, chatOptions: this.context.chatOptions }));
      if (this.item instanceof Item)
      {
        await Promise.all(this.item.runScripts("rollTest", { test: this, chatOptions: this.context.chatOptions }));
      }
      Hooks.call("wfrp4e:rollTest", this, this.context.chatOptions);
    }
  }

  async roll() {
    await this.runPreEffects();

    this.reset();
    if (!this.preData.item)
      throw new Error(game.i18n.localize("ERROR.Property"))
    if (!this.context.speaker)
      throw new Error(game.i18n.localize("ERROR.Speaker"))

    await this.rollDices();
    await this.computeResult();
    this.computeTables();
    await this.runPostEffects();
    await this.postTest();

    // Do not render chat card or compute oppose if this is a dummy unopposed test
    if (!this.context.unopposed)
    {
      await this.renderRollCard();
      await this.handleOpposed();
    }

    warhammer.utility.log("Rolled Test: ", undefined, this);
    return this
  }

  async reroll() {
    this.context.previousResult = this.result;
    this.context.reroll = true;
    this.context.previousMessage = this.message.id;
    delete this.result.roll;
    delete this.result.hitloc;
    delete this.preData.hitloc;
    delete this.preData.roll;
    delete this.preData.SL;
    this.context.messageId = "";

    await this.roll();
  }

  addSL(SL) {
    this.context.previousResult = foundry.utils.duplicate(this.result);
    this.preData.SL = Math.trunc(this.result.SL) + SL;
    this.preData.slBonus = 0;
    this.preData.successBonus = 0;
    this.preData.roll = Math.trunc(this.result.roll);
    if (this.preData.hitLocation)
      this.preData.hitloc = this.result.hitloc.roll;

    this.roll();
  }

  edit(data)
  {
    foundry.utils.mergeObject(this.preData, data);

    // If changing hitloc, keep old roll;
    if (data.hitloc)
    {
      this.preData.roll = data.roll || this.result.roll;
    }
    else if (!data.hitloc && this.result.hitloc) // If not changing hitloc, keep old hitloc
    {
      this.preData.hitloc = this.result.hitloc.roll;
    }

    if (data.SL) // If changing SL keep both roll and hitloc
    {
      this.preData.roll = data.roll || this.result.roll;
      this.preData.slBonus = 0;
      this.preData.successBonus = 0;
      // If setting SL value, remove other bonuses
    }

    // If target was changed, keep old roll
    if (data.target)
    {
      this.preData.roll = data.roll || this.result.roll;
    }

    this.roll();
  }

  /**
     * Provides the basic evaluation of a test.
     * 
     * This function, when given the necessary data (target number, SL bonus, etc.) provides the
     * basic test evaluation - rolling the test (if not already given), determining SL, success, description, critical/fumble if needed.
     * 
     * @param {Object} this.data  Test info: target number, SL bonus, success bonus, (opt) roll, etc
     */
  async computeResult() {
    let automaticSuccess = game.settings.get("wfrp4e", "automaticSuccess");
    let automaticFailure = game.settings.get("wfrp4e", "automaticFailure");
    this.computeTargetNumber();
    let successBonus = this.preData.successBonus;
    let slBonus = this.preData.slBonus + this.preData.postOpposedModifiers.SL;
    let target = this.result.target;
    let outcome;

    let description = "";

    if (this.preData.canReverse) {
      let reverseRoll = this.result.roll.toString();
      if (this.result.roll >= automaticFailure || (this.result.roll > target && this.result.roll > automaticSuccess)) {
        if (reverseRoll.length == 1)
          reverseRoll = reverseRoll[0] + "0";
        else {
          reverseRoll = reverseRoll[1] + reverseRoll[0];
        }
        reverseRoll = Number(reverseRoll);
        if (reverseRoll <= automaticSuccess || reverseRoll <= target) {
          this.result.roll = reverseRoll;
          this.result.reversed = true;
          this.result.other.push(game.i18n.localize("ROLL.Reverse"));
        }
      }
    }


    let baseSL = (Math.floor(target / 10) - Math.floor(this.result.roll / 10));
    if (game.settings.get("wfrp4e", "SLMethod") == "dos")
    {
      baseSL = Math.floor(Math.abs(target - this.result.roll) / 10) * ((target - this.result.roll) < 0 ? -1 : 1);
    }
    let SL;
    if (this.preData.SL == 0)
      SL = this.preData.SL;
    else
      SL = this.preData.SL || baseSL + slBonus; // Use input SL if exists, otherwise, calculate from roll (used for editing a test result)


    // Test determination logic can be complicated due to SLBonus
    // SLBonus is always applied, but doesn't change a failure to a success or vice versa
    // Therefore, in this case, a positive SL can be a failure and a negative SL can be a success
    // Additionally, the auto-success/failure range can complicate things even more.
    // ********** Failure **********
    if (this.result.roll >= automaticFailure || (this.result.roll > target && this.result.roll > automaticSuccess)) {
      description = game.i18n.localize("ROLL.Failure");
      outcome = "failure";
      if (this.result.roll >= 96 && SL > -1)
        SL = -1;

      switch (Math.abs(Number(SL))) {
        case 6:
          description = game.i18n.localize("ROLL.AstoundingFailure");
          break;

        case 5:
        case 4:
          description = game.i18n.localize("ROLL.ImpressiveFailure");
          break;

        case 3:
        case 2:
          break;

        case 1:
        case 0:
          description = game.i18n.localize("ROLL.MarginalFailure");
          break;

        default:
          if (Math.abs(Number(SL)) > 6)
            description = game.i18n.localize("ROLL.AstoundingFailure");
      }
      if (SL > 0) {
        description = game.i18n.localize("ROLL.MarginalFailure");
        SL = "+" + SL.toString();
      }
      if (SL == 0)
        SL = "-" + SL.toString();


      if (this.options.engagedModifier) {
        let unmodifiedTarget = target - this.options.engagedModifier;
        if (this.result.roll <= unmodifiedTarget) {
          this.result.other.push(game.i18n.localize("ROLL.HitAnotherEngagedTarget"));
        }
      }
  
    }

    // ********** Success **********
    else if (this.result.roll <= automaticSuccess || this.result.roll <= target) {
      description = game.i18n.localize("ROLL.Success");
      outcome = "success";
      if (game.settings.get("wfrp4e", "SLMethod") == "fast") 
      {
        let rollString = this.result.roll.toString();
        if (rollString.length == 2)
          SL = Number(rollString.split('')[0]);
        else
          SL = 0;
        SL += slBonus;

        if (Number.isNumeric(this.preData.SL))
        {
          SL = this.preData.SL;
        }
      }
      SL += successBonus;
      if (this.result.roll <= automaticSuccess && SL < 1 && !this.context.unopposed)
        SL = 1;



      if (!game.settings.get("wfrp4e", "homebrew").mooRangedDamage) {
        // If size modifiers caused a success, SL becomes 0
        if (this.options.sizeModifier) {
          let unmodifiedTarget = target - this.options.sizeModifier;
          if (this.result.roll > unmodifiedTarget) {
            SL = 0;
            this.result.other.push(game.i18n.localize("ROLL.SizeCausedSuccess"));
          }
        }
      }

      switch (Math.abs(Number(SL))) {
        case 6:
          description = game.i18n.localize("ROLL.AstoundingSuccess");
          break;

        case 5:
        case 4:
          description = game.i18n.localize("ROLL.ImpressiveSuccess");
          break;

        case 3:
        case 2:
          break;

        case 1:
        case 0:
          description = game.i18n.localize("ROLL.MarginalSuccess");
          break;

        default:
          if (Math.abs(Number(SL)) > 6)
            description = game.i18n.localize("ROLL.AstoundingSuccess");
      }
      if (SL < 0)
        description = game.i18n.localize("ROLL.MarginalSuccess");

      // Add 1 SL for each whole 10 the target number is above 100 (120 target: +2 SL) if the option is selected
      if (game.settings.get("wfrp4e", "testAbove100")) {
        if (target > 100) {
          let addSL = Math.floor((target - 100) / 10);
          SL += addSL;
        }
      }

      // Add a + sign if succeeded
      if (SL >= 0)
        SL = "+" + SL.toString();

    }

    this.result.target = target;
    this.result.SL = SL;
    this.result.description = description;
    this.result.outcome = outcome;
    this.result.baseSL = baseSL;
    this.result.breakdown = this.context.breakdown;

    if (this.options.context) {
      if (this.options.context.general)
        this.result.other = this.result.other.concat(this.options.context.general);
      if (this.failed && this.options.context.failure)
        this.result.other = this.result.other.concat(this.options.context.failure);
      if (this.succeeded && this.options.context.success)
        this.result.other = this.result.other.concat(this.options.context.success);
    }


    if (this.preData.hitLocation) {

      // Called Shots
      if (this.preData.selectedHitLocation != "roll") // selectedHitLocation is possibly "none" but if so, preData.hitLocation would be false (see constructor) so this won't execute
      {
        this.result.hitloc = game.wfrp4e.tables.hitLocKeyToResult(this.preData.selectedHitLocation);
      }

      // Pre-set hitloc (e.g. editing a test)
      if (this.preData.hitloc)
      {
        if (Number.isNumeric(this.preData.hitloc))
          this.result.hitloc = await game.wfrp4e.tables.rollTable("hitloc", { lookup: this.preData.hitloc, hideDSN: true });
      }

      // No defined hit loc, roll for one
      if (!this.result.hitloc)
        this.result.hitloc = await game.wfrp4e.tables.rollTable("hitloc", { hideDSN: true });

      this.result.hitloc.roll = (0, eval)(this.result.hitloc.roll); // Cleaner number when editing chat card
      this.result.hitloc.description = game.i18n.localize(this.result.hitloc.description);

      // "rArm" and "lArm" from the table actually means "primary" and "secondary" arm
      // So convert the descriptions to match that. Opposed tests handle displaying
      // which arm was hit, as it is based on the actor's settings
      if (["lArm", "rArm"].includes(this.result.hitloc.result))
      {
        if (this.result.hitloc.result == "rArm")
        {
          this.result.hitloc.description = game.i18n.localize("Primary Arm");
        }
        if (this.result.hitloc.result == "lArm")
        {
          this.result.hitloc.description = game.i18n.localize("Secondary Arm");
        }
      }

      if (this.preData.selectedHitLocation && this.preData.selectedHitLocation != "roll")
      {
        this.result.hitloc.description = this.preData.hitLocationTable[this.preData.selectedHitLocation] + ` (${game.i18n.localize("ROLL.CalledShot")})`;
      }
      
    }

    this.result.roll;
    // If hit location is being ussed, we can assume we should lookup critical hits
    if (this.preData.hitLocation) {
      if (this.isCriticalFumble == "fumble") {
        this.result.color_red = true;
        this.result.fumble = game.i18n.localize("Fumble");
      }
      else if (this.isCriticalFumble == "critical") {
        this.result.color_green = true;
        this.result.critical = game.i18n.localize("Critical");
      }
    }

    // If optional rule of criticals/fumbles on all tessts - assign Astounding Success/Failure accordingly
    if (game.settings.get("wfrp4e", "criticalsFumblesOnAllTests") && !this.preData.hitLocation) {
      if (this.isCriticalFumble == "fumble") {
        this.result.color_red = true;
        this.result.description = game.i18n.localize("ROLL.AstoundingFailure");
      }
      else if (this.isCriticalFumble == "critical") {
        this.result.color_green = true;
        this.result.description = game.i18n.localize("ROLL.AstoundingSuccess");
      }
    }
    return this.result
  }

  get isCriticalFumble()
  {
    let roll = this.result.roll;
    let target = this.result.target;
    if ((roll > target && roll % 11 == 0) || roll == 100 || roll == 99)
    {
      return "fumble"
    }
    else if (roll <= target && roll % 11 == 0)
    {
      return "critical"
    }
    else 
    {
      return "";
    }
  }

  computeTables()
  {
    if (this.result.critical && this.result.hitloc)
    {
      this.result.tables.critical = {
        label : this.result.critical,
        class : "critical-roll",
        modifier : this.result.critModifier || 0,
        key: `crit${this.result.hitloc.result}`
      };
    }
    if (this.result.fumble)
    {
      this.result.tables.fumble = {
        label : this.result.fumble,
        class : "fumble-roll",
        key : "oops"
      };
    }
  }


  // Function that all tests should go through after the main roll
  async postTest() {

    if (this.result.critical && this.item.properties?.qualities.warpstone) {
      this.result.other.push(`@Corruption[minor]{Minor Exposure to Corruption}`);
    }
    
    //@HOUSE
    if (game.settings.get("wfrp4e", "homebrew").mooCriticalMitigation && this.result.critical) {
      game.wfrp4e.utility.logHomebrew("mooCriticalMitigation");
      try {
        let target = this.targets[0];
        if (target) {
          let AP = target.status.armour[this.result.hitloc.result].value;
          if (AP) {
            this.result.tables.critical.modifier = -10 * AP;
            this.result.other.push(`<a class="action-link" data-action="applyCriticalDeflection">Critical Mitigation: Damage AP</a>`);
          }
        }
      }
      catch (e) {
        warhammer.utility.log("Error applying homebrew mooCriticalMitigation: " + e);
      }
    }
    //@/HOUSE

    if (this.options.corruption) {
      await this.handleCorruptionResult();
    }
    if (this.options.mutate) {
      await this.handleMutationResult();
    }

    if (this.options.extended) {
      await this.handleExtendedTest();
    }

    if (this.options.income) {
      await this.handleIncomeTest();
    }

    if (this.options.crewTest)
    {
      this.result.crewTestSL = parseInt(this.result.SL);
      if (this.options.roleVital)
      {
        this.result.crewTestSL *= 2;
      }
    }

    if (this.options.rest) {
      this.result.woundsHealed = Math.max(Math.trunc(this.result.SL) + this.options.tb, 0);
      this.result.other.push(`${this.result.woundsHealed} ${game.i18n.localize("Wounds Healed")}`);
    }
  }

  async postTestGM(message)
  {
    if (!game.user.isGM)
    {
      return;
    }

    if (this.options.crewTest)
    {
      
      let crewTestMessage = game.messages.get(this.options.crewTestMessage);
      let crewTestData = crewTestMessage.getFlag("wfrp4e", "crewTestData");
      let crewTest = CrewTest.fromData(crewTestData);
      crewTest.updateRole(this.options.roleId, message);
    }
  }

  async handleSoundContext(chatOptions) 
  {
    
    try {
      let contextAudio = await WFRP_Audio.MatchContextAudio(WFRP_Audio.FindContext(this));
      chatOptions.sound = contextAudio.file || chatOptions.sound;
    }
    catch
    { }
  }

  /**
   * Handles opposed context - if actor has been targeted, roll defense. If this test has targets, roll attack
   * Test objects may have one or more opposed test message IDs. If these IDs exist, that means this test is
   * either rerolled, edited, etc. and the opposed result needs to know of the new test (via updating message ID). 
   * The opposed test may also need to be recalculated if the defender test exists
   */
  async handleOpposed() {

    // If the actor has been targeted - roll defense
    if (this.actor.isOpposing || this.context.defending)
    {
      let opposeMessage;
      if (this.context.defending) // Rehandling a previous defense roll
      {
        opposeMessage = this.opposedMessages[0];
      }
      else
      {
        this.context.defending = true; // If the test is handled again after the initial roll, the actor flag doesn't exist anymore, need a way to know we're still defending
        opposeMessage = game.messages.get(this.actor.flags.oppose.opposeMessageId);
        this.context.opposedMessageIds.push(opposeMessage.id); // Maintain a link to the opposed message
      }
      
      // Get oppose message, set this test's message as defender, compute result
      let handler = opposeMessage.system.opposedHandler;
      await handler.setDefender(this.message);
      await handler.computeOpposeResult();
      await this.actor.clearOpposed();
      await this.updateMessageData();
    }
    else // if actor is attacking - rerolling old test. 
    {
      if (this.opposedMessages.length)
      {
        for (let message of this.opposedMessages) {
          let handler = message.system.opposedHandler;
          await handler.setAttacker(this.message); // Make sure the opposed test is using the most recent message from this test
          if (handler.defenderTest) // If defender has rolled (such as if this test was rerolled or edited after the defender rolled) - recompute opposed test
            await handler.computeOpposeResult();
        }
      }
      else { // actor is attacking - new test
        // For each target, create opposed test messages, save those message IDs in this test.
        for (let token of this.context.targets.map(t => WFRP_Utility.getToken(t))) {
          await this.createOpposedMessage(token);
        }
      }
    }
  }

  async handleIncomeTest() {
    let { standing, tier } = this.options.income;
    let result = this.result;

    let {earned} = await game.wfrp4e.market.rollIncome(null, {standing, tier});

    // After rolling, determined how much, if any, was actually earned
    if (result.outcome == "success") {
      this.result.incomeResult = game.i18n.localize("INCOME.YouEarn") + " " + earned;
      switch (tier) {
        case "b":
          result.incomeResult += ` ${game.i18n.localize("NAME.BPPlural").toLowerCase()}.`;
          break;
        case "s":
          result.incomeResult += ` ${game.i18n.localize("NAME.SSPlural").toLowerCase()}.`;
          break;
        case "g":
          if (earned == 1)
            result.incomeResult += ` ${game.i18n.localize("NAME.GC").toLowerCase()}.`;
          else
            result.incomeResult += ` ${game.i18n.localize("NAME.GCPlural").toLowerCase()}.`;
          break;
      }
    }
    else if (Number(result.SL) > -6) {
      earned /= 2;
      result.incomeResult = game.i18n.localize("INCOME.YouEarn") + " " + earned;
      switch (tier) {
        case "b":
          result.incomeResult += ` ${game.i18n.localize("NAME.BPPlural").toLowerCase()}.`;
          break;
        case "s":
          result.incomeResult += ` ${game.i18n.localize("NAME.SSPlural").toLowerCase()}.`;
          break;
        case "g":
          if (earned == 1)
            result.incomeResult += ` ${game.i18n.localize("NAME.GC").toLowerCase()}.`;
          else
            result.incomeResult += ` ${game.i18n.localize("NAME.GCPlural").toLowerCase()}.`;
          break;
      }
    }
    else {
      result.incomeResult = game.i18n.localize("INCOME.Failure");
      earned = 0;
    }
    // let contextAudio = await WFRP_Audio.MatchContextAudio(WFRP_Audio.FindContext(test))
    // cardOptions.sound = contextAudio.file || cardOptions.sound
    result.earned = earned + tier;
  }


  async handleCorruptionResult() {
    let strength = this.options.corruption;
    let failed = this.failed;
    let corruption = 0; // Corruption GAINED
    switch (strength) {
      case game.i18n.localize("CORRUPTION.Minor").toLowerCase():
        if (failed)
          corruption++;
        break;

        case game.i18n.localize("CORRUPTION.Moderate").toLowerCase():
        if (failed)
          corruption += 2;
        else if (this.result.SL < 2)
          corruption += 1;
        break;

        case game.i18n.localize("CORRUPTION.Major").toLowerCase():
        if (failed)
          corruption += 3;
        else if (this.result.SL < 2)
          corruption += 2;
        else if (this.result.SL < 4)
          corruption += 1;
        break;
    }

    // Revert previous test if rerolled
    if (this.context.reroll || this.context.fortuneUsedAddSL) {
      let previousFailed = this.context.previousResult.outcome == "failure";
      switch (strength) {
        case game.i18n.localize("CORRUPTION.Minor").toLowerCase():
          if (previousFailed)
            corruption--;
          break;

        case game.i18n.localize("CORRUPTION.Moderate").toLowerCase():
          if (previousFailed)
            corruption -= 2;
          else if (this.context.previousResult.SL < 2)
            corruption -= 1;
          break;

        case game.i18n.localize("CORRUPTION.Major").toLowerCase():
          if (previousFailed)
            corruption -= 3;
          else if (this.context.previousResult.SL < 2)
            corruption -= 2;
          else if (this.context.previousResult.SL < 4)
            corruption -= 1;
          break;
      }
    }
    let newCorruption = Number(this.actor.system.status.corruption.value) + corruption;
    if (newCorruption < 0) newCorruption = 0;

    if (!this.context.reroll && !this.context.fortuneUsedAddSL)
      ChatMessage.create(WFRP_Utility.chatDataSetup(game.i18n.format("CHAT.CorruptionFail", { name: this.actor.name, number: corruption }), "gmroll", false));
    else
      ChatMessage.create(WFRP_Utility.chatDataSetup(game.i18n.format("CHAT.CorruptionReroll", { name: this.actor.name, number: corruption }), "gmroll", false));

    await this.actor.update({ "system.status.corruption.value": newCorruption });
  }

  async handleMutationResult() 
  {
    if (this.failed) 
    {
      let wpb = this.actor.system.characteristics.wp.bonus;
      let tableText = game.i18n.localize("CHAT.MutateTable") + "<br>" + game.wfrp4e.config.corruptionTables.map(t => `@Table[${t}]<br>`).join("");
      ChatMessage.create(WFRP_Utility.chatDataSetup(`
      <h3>${game.i18n.localize("CHAT.DissolutionTitle")}</h3> 
      <p>${game.i18n.localize("CHAT.Dissolution")}</p>
      <p>${game.i18n.format("CHAT.CorruptionLoses", { name: this.actor.name, number: wpb })}
      <p>${tableText}</p>`,
        "gmroll", false));  
      this.actor.update({ "system.status.corruption.value": Number(this.actor.system.status.corruption.value) - wpb }, {skipCorruption: true}); // Don't keep checking corruption, causes a possible loop of dialogs
    }
    else
      ChatMessage.create(WFRP_Utility.chatDataSetup(game.i18n.localize("CHAT.MutateSuccess"), "gmroll", false));

  }
  
  async handleExtendedTest() {
    let item = fromUuidSync(this.options.extended);
    let deleteTest = false;
    if (item)
    {
      let itemData = item.toObject();
      let SL = Number(this.result.SL);

      if (game.settings.get("wfrp4e", "extendedTests") && SL == 0)
      {
        this.result.SL = this.result.roll <= this.result.target ? 1 : -1;
      }

      if (itemData.system.failingDecreases.value) 
      {
        itemData.system.SL.current += SL;
        if (!itemData.system.negativePossible.value && itemData.system.SL.current < 0)
        {
          itemData.system.SL.current = 0;
        }
      }
      else if (SL > 0)
      {
        itemData.system.SL.current += SL;
      }

      let displayString = `${itemData.name} ${itemData.system.SL.current} / ${itemData.system.SL.target} ${game.i18n.localize("SuccessLevels")}`;

      if (itemData.system.SL.current >= itemData.system.SL.target) {

        if (foundry.utils.getProperty(itemData, "flags.wfrp4e.reloading")) {
          let actor;
          if (foundry.utils.getProperty(itemData, "flags.wfrp4e.vehicle"))
            actor = WFRP_Utility.getSpeaker(foundry.utils.getProperty(itemData, "flags.wfrp4e.vehicle"));

          actor = actor ? actor : this.actor;
          let weapon = actor.items.get(foundry.utils.getProperty(itemData, "flags.wfrp4e.reloading"));
          await weapon.update({ "flags.wfrp4e.-=reloading": null, "system.loaded.amt": weapon.loaded.max, "system.loaded.value": true });
        }

        if (itemData.system.completion.value == "reset")
        {
          itemData.system.SL.current = 0;
        }
        else if (itemData.system.completion.value == "remove") 
        {
          deleteTest = true;
        }
        displayString = displayString.concat(`<br><b>${game.i18n.localize("Completed")}</b>`);
      }

      this.result.other.push(displayString);

      if (deleteTest)
      {
        await item.delete();
      }
      else 
      { 
        await item.update(itemData);
      }
    }
  }


  // Create a test from already formed data
  static recreate(data) {
    let test = new game.wfrp4e.rolls[data.preData.rollClass]();
    test.data = data;
    test.computeTargetNumber();
    return test
  }

  /**
   * Start a dice roll
   * Used by the rollTest method and its overrides
   * @param {Object} testData
   */
  async rollDices() {
    if (isNaN(this.preData.roll)) {
      let roll = await new Roll("1d100").roll();
      await this._showDiceSoNice(roll, this.context.chatOptions.rollMode || "roll", this.context.speaker);
      this.result.roll = roll.total;
    }
    else
      this.result.roll = this.preData.roll;
  }

  reset() {
    this.data.result = foundry.utils.mergeObject({
      roll: undefined,
      description: "",
      tooltips: {},
      other: [],
      tables: {} // label, column, modifier, style, class, nulled
    }, this.preData);
  }

  /** Take roll data and display it in a chat card template.
 * @param {Object} chatOptions - Object concerning display of the card like the template or which actor is testing
 * @param {Object} testData - Test results, values to display, etc.
 * @param {Object} rerenderMessage - Message object to be updated, instead of rendering a new message
 */
  async renderRollCard({ newMessage = false } = {}) 
  {

    let messageData = foundry.utils.deepClone(this.context.chatOptions);

    await this.handleSoundContext(messageData);

    this.result.breakdown.formatted = this.formatBreakdown();

    if (game.modules.get("dice-so-nice") && game.modules.get("dice-so-nice").active && messageData.sound?.includes("dice"))
      messageData.sound = undefined;

    let templateData = {
      test: this,
      hideData: game.user.isGM,
    };


    if (this.context.targets.length) {
      templateData.title += ` - ${game.i18n.localize("Opposed")}`;
    }

    ChatMessage.applyRollMode(messageData, messageData.rollMode);

    let html = await foundry.applications.handlebars.renderTemplate(messageData.template, templateData);

    if (newMessage || !this.message) {

      messageData.content = html;
      if (messageData.sound)
        warhammer.utility.log(`Playing Sound: ${messageData.sound}`);

      messageData.system = {testData : this.data};
      messageData.type = "test";
      let message = await ChatMessage.create(messageData);

      this.context.messageId = message.id;
      await this.updateMessageData();
    }
    else // Update message 
    {
      messageData.content = html;

      // Update Message if allowed, otherwise send a request to GM to update
      if (game.user.isGM || this.message.isAuthor) {
        await this.message.update(messageData);
      }
      else {
        await SocketHandlers.call("updateMessage", { id: this.message.id, updateData : messageData }, "GM");
      }
      await this.updateMessageData();
    }
  }

  // Update message data without rerendering the message content
  async updateMessageData(updateData = {}) {
    let data = foundry.utils.mergeObject(this.data, updateData, { overwrite: true });
    let update = { "system.testData": data };
    
    if (this.message && game.user.isGM)
      await this.message.update(update);

    else if (this.message) {
      await SocketHandlers.call("updateMessage", { id: this.message.id, updateData : update }, "GM");
    }
  }


  async createOpposedMessage(token) {
    let oppose = new game.wfrp4e.opposedHandler();
    await oppose.setAttacker(this.message);
    let opposeMessageId = await oppose.startOppose(token);
    if (opposeMessageId) {
      this.context.opposedMessageIds.push(opposeMessageId);
    }
    await this.updateMessageData();
  }



  /**
   * Add support for the Dice So Nice module
   * @param {Object} roll 
   * @param {String} rollMode 
   */
  async _showDiceSoNice(roll, rollMode, speaker) {
    if (game.modules.get("dice-so-nice") && game.modules.get("dice-so-nice").active) {

      if (game.settings.get("dice-so-nice", "hideNpcRolls")) {
        let actorType = null;
        if (speaker.actor)
          actorType = game.actors.get(speaker.actor).type;
        else if (speaker.token && speaker.scene)
          actorType = game.scenes.get(speaker.scene).tokens.get(speaker.token).actor.type;
        if (actorType != "character")
          return;
      }

      let whisper = null;
      let blind = false;
      let sync = true;
      switch (rollMode) {
        case "blindroll": //GM only
          blind = true;
        case "gmroll": //GM + rolling player
          let gmList = game.users.filter(user => user.isGM);
          let gmIDList = [];
          gmList.forEach(gm => gmIDList.push(gm.id));
          whisper = gmIDList;
          break;
        case "selfroll":
          sync = false;
          break;
        case "roll": //everybody
          let userList = game.users.filter(user => user.active);
          let userIDList = [];
          userList.forEach(user => userIDList.push(user.id));
          whisper = userIDList;
          break;
      }
      await game.dice3d.showForRoll(roll, game.user, sync, whisper, blind);
    }
  }

  // @@@@@@@ Overcast functions placed in root class because it is used by both spells and prayers @@@@@@@
  async _overcast(choice) {
    let overcastData = this.result.overcast;

    if (!overcastData.available)
      return overcastData

    if (typeof overcastData.usage[choice].initial != "number")
      return overcastData

    switch (choice) {
      case "range":
        overcastData.usage[choice].current += overcastData.usage[choice].initial;
        break
      case "target":
        overcastData.usage[choice].current += overcastData.usage[choice].initial;
        break
      case "duration":
        overcastData.usage[choice].current += overcastData.usage[choice].initial;
        break
      case "other":
        if (overcastData.valuePerOvercast.type == "value")
          overcastData.usage[choice].current += overcastData.valuePerOvercast.value;
        else if (overcastData.valuePerOvercast.type == "SL")
          overcastData.usage[choice].current += (parseInt(this.result.SL) + (parseInt(this.item.system.computeSpellPrayerFormula(undefined, false, overcastData.valuePerOvercast.additional)) || 0));
        else if (overcastData.valuePerOvercast.type == "characteristic")
          overcastData.usage[choice].current += (overcastData.usage[choice].increment || 0); // Increment is specialized storage for characteristic data so we don't have to look it up
        break
    }
    overcastData.usage[choice].count++;
    let sum = 0;
    for (let overcastType in overcastData.usage)
      if (overcastData.usage[overcastType].count)
        sum += overcastData.usage[overcastType].count;

    overcastData.available = overcastData.total - sum;

    //@HOUSE 
    if (game.settings.get("wfrp4e", "homebrew").mooOvercasting && this.spell) {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");

      let spent = (game.settings.get("wfrp4e-eis", "dharRules") && game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") ? 1 : 2;
      this.result.SL = `+${this.result.SL - spent}`;
      await this.calculateDamage();
    }
    //@/HOUSE
    
    await this.updateMessageData();
    await this.renderRollCard();
  }

  async _overcastReset() {
    let overcastData = this.result.overcast;
    for (let overcastType in overcastData.usage) {
      if (overcastData.usage[overcastType].count) {
        overcastData.usage[overcastType].count = 0;
        overcastData.usage[overcastType].current = overcastData.usage[overcastType].initial;
      }
    }
    //@HOUSE 
    if (game.settings.get("wfrp4e", "homebrew").mooOvercasting) {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");
      let multiplier = (game.settings.get("wfrp4e-eis", "dharRules") && game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") ? 1 : 2;
      this.result.SL = `+${Number(this.result.SL) + (multiplier * (overcastData.total - overcastData.available))}`;
      await this.calculateDamage();
    }
    //@/HOUSE
    overcastData.available = overcastData.total;
    await this.updateMessageData();
    await this.renderRollCard();
  }

  _handleMiscasts(miscastCounter) {

    if(this.preData.unofficialGrimoire) {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      let controlIngredient = this.preData.ingredientMode == 'control'; 
      if (miscastCounter == 1) {
          if (this.hasIngredient && controlIngredient)
            this.result.nullminormis = game.i18n.localize("ROLL.MinorMis");
          else {
            this.result.minormis = game.i18n.localize("ROLL.MinorMis");
          }
        }
        else if (miscastCounter == 2) {
          if (this.hasIngredient && controlIngredient) {
            this.result.nullmajormis = game.i18n.localize("ROLL.MajorMis");
            this.result.minormis = game.i18n.localize("ROLL.MinorMis");
          }
          else {
            this.result.majormis = game.i18n.localize("ROLL.MajorMis");
          }
        }
        else if (miscastCounter == 3) {
          if (this.hasIngredient && controlIngredient) {
            this.result.nullcatastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
            this.result.majormis = game.i18n.localize("ROLL.MajorMis");
          }
          else
            this.result.catastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
         }
         else if (miscastCounter > 3) {
          this.result.catastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
         }
      } else {
      if (miscastCounter == 1) {
        if (this.hasIngredient)
          this.result.nullminormis = game.i18n.localize("ROLL.MinorMis");
        else {
          this.result.minormis = game.i18n.localize("ROLL.MinorMis");
        }
      }
      else if (miscastCounter == 2) {
        if (this.hasIngredient) {
          this.result.nullmajormis = game.i18n.localize("ROLL.MajorMis");
          this.result.minormis = game.i18n.localize("ROLL.MinorMis");
        }
        else {
          this.result.majormis = game.i18n.localize("ROLL.MajorMis");
        }
      }
      else if (!game.settings.get("wfrp4e", "homebrew").mooCatastrophicMiscasts && miscastCounter >= 3)
        this.result.majormis = game.i18n.localize("ROLL.MajorMis");
  
      //@HOUSE
      else if (game.settings.get("wfrp4e", "homebrew").mooCatastrophicMiscasts && miscastCounter >= 3) {
        game.wfrp4e.utility.logHomebrew("mooCatastrophicMiscasts");
        if (this.hasIngredient) {
          this.result.nullcatastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
          this.result.majormis = game.i18n.localize("ROLL.MajorMis");
        }
        else {
          this.result.catastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
        }
      }
      //@/HOUSE
    }
  }

  formatBreakdown()
  {
    let testBreakdown = "";
    let breakdown = this.result.breakdown;

    try {

      // @@@@@@@@@@@@@@@ Test @@@@@@@@@@@@@@@@@@
      testBreakdown += `<p><strong>${game.i18n.localize("Characteristic")}</strong>: ${breakdown.characteristic}</p>`;

      if (breakdown.skill)
      {
        testBreakdown += `<p><strong>${game.i18n.localize("Skill")}</strong>: ${breakdown.skill}</p>`;
      }

      testBreakdown += `<p><strong>${game.i18n.localize("Difficulty")}</strong>: ${game.wfrp4e.config.difficultyLabels[breakdown.difficulty]}</p>`;

      if (breakdown.modifier)
      {
        testBreakdown += `<p><strong>${game.i18n.localize("Modifier")}</strong>: ${foundry.applications.handlebars.numberFormat(breakdown.modifier, {hash :{sign: true}})}</p>`;
      }

      // No need to show SL value unless it's boosted by slBonus or successBonus
      if (breakdown.slBonus || (breakdown.successBonus && this.succeeded))
      {
        let SLstring = `<p><strong>${game.i18n.localize("SL")}</strong>: ${this.result.baseSL} (Base)`;
        
        if (breakdown.slBonus)
        {
          if (breakdown.slBonus > 0)
          {
            SLstring += ` + ${breakdown.slBonus}`;
          }
          else if (breakdown.slBonus < 0)
          {
            SLstring += ` - ${Math.abs(breakdown.slBonus)}`;
          }
          SLstring += ` (${game.i18n.localize("DIALOG.SLBonus")})`;
        }
        
        if (breakdown.successBonus && this.succeeded)
        {
          if (breakdown.successBonus > 0)
          {
            SLstring += ` + ${breakdown.successBonus}`;
          }
          else if (breakdown.successBonus < 0)
          {
            SLstring += `- ${Math.abs(breakdown.successBonus)}`;
          }
          SLstring += ` (${game.i18n.localize("DIALOG.SuccessBonus")})`;
        }
        testBreakdown += SLstring;
      }

      if (game.settings.get("wfrp4e", "SLMethod") != "default")
      {
        testBreakdown += "<p>SL Evaluated with " + (game.settings.get("wfrp4e", "SLMethod") == "fast" ? "Fast SL" : "Degrees of Success") + "</p>";
      }

      if (breakdown.modifier)
      {
        testBreakdown += `<p><strong>${game.i18n.localize("Modifier")}</strong>: ${foundry.applications.handlebars.numberFormat(breakdown.modifier, {hash :{sign: true}})}</p>`;
      }


      if (breakdown.modifiersBreakdown)
      {
        testBreakdown += `<hr><h4>${game.i18n.localize("CHAT.ModifiersBreakdown")}</h4>`;
        testBreakdown += breakdown.modifiersBreakdown;
      }

      // @@@@@@@@@@@@@@@@@@ Damage @@@@@@@@@@@@@@@@@@@@
      let damageBreakdown = "";

      damageBreakdown += `<p><strong>${game.i18n.localize("BREAKDOWN.Base")}</strong>: ${breakdown.damage.base}</p>`;
      if (breakdown.damage.item)
      {
        damageBreakdown += `<p><strong>${game.i18n.localize(CONFIG.Item.typeLabels[this.item?.type])}</strong>: ${breakdown.damage.item}</p>`;
      }

      for(let source of breakdown.damage.other)
      {
        damageBreakdown += `<p><strong>${source.label}</strong>: ${foundry.applications.handlebars.numberFormat(source.value, {hash: {sign : true}})}`;
      }

      return {test : testBreakdown, damage : damageBreakdown};
    }
    catch(e)
    {
      console.error(`Error generating formatted breakdown: ${e}`, this);
    }

  }



    /**
   * Use a fortune point from the actor to reroll or add sl to a roll
   * @param {String} type (reroll, addSL)
   */
    useFortune(type) {
      if (this.actor.system.status.fortune?.value > 0) 
      {
        let html = `<h3 class="center"><b>${game.i18n.localize("FORTUNE.Use")}</b></h3>`;
        //First we send a message to the chat
        if (type == "reroll")
          html += `${game.i18n.format("FORTUNE.UsageRerollText", { character: '<b>' + this.actor.name + '</b>' })}<br>`;
        else
          html += `${game.i18n.format("FORTUNE.UsageAddSLText", { character: '<b>' + this.actor.name + '</b>' })}<br>`;
  
        html += `<b>${game.i18n.localize("FORTUNE.PointsRemaining")} </b>${this.actor.system.status.fortune.value - 1}`;
        ChatMessage.create(WFRP_Utility.chatDataSetup(html, "gmroll"));
  
  
        if (type == "reroll") {
          this.context.fortuneUsedReroll = true;
          this.context.fortuneUsedAddSL = true;
          this.reroll();
  
        }
        else //add SL
        {
          this.context.fortuneUsedAddSL = true;
          this.addSL(1);
        }
        this.actor.update({ "system.status.fortune.value": this.actor.system.status.fortune.value - 1 });
      }
    }

      /**
   * Take a Dark Deal to reroll for +1 Corruption
   * @param {Object} message 
   */
  useDarkDeal() {
    let html = `<h3 class="center"><b>${game.i18n.localize("DARKDEAL.Use")}</b></h3>`;
    html += `${game.i18n.format("DARKDEAL.UsageText", { character: '<b>' + this.actor.name + '</b>' })}<br>`;
    
    let corruption = Math.trunc(this.actor.system.status.corruption.value) + 1;
    html += `<b>${game.i18n.localize("Corruption")}: </b>${corruption}/${this.actor.system.status.corruption.max}`;

    ChatMessage.create(WFRP_Utility.chatDataSetup(html, "gmroll"));
    this.actor.update({ "system.status.corruption.value": corruption });

    this.reroll();
  }

  get message() {
    return game.messages.get(this.context.messageId)
  }

  get isOpposed() {
    return this.context.opposedMessageIds.length > 0
  }
  get opposedMessages() {
    return this.context.opposedMessageIds.map(id => game.messages.get(id))
  }


  get fortuneUsed() {
    return { reroll: this.context.fortuneUsedReroll, SL: this.context.fortuneUsedAddSL }
  }
  

  get targetModifiers() {
    return this.preData.testModifier + this.preData.testDifficulty + (this.preData.postOpposedModifiers.target || 0)
  }

  get succeeded() {
    return this.result.outcome == "success"
  }

  get failed() {
    return this.result.outcome == "failure"
  }

  get isCritical() {
    return this.result.critical
  }

  get isFumble() {
    return this.result.fumble
  }

  get useMount() {
    return this.item.attackType == "melee" && this.actor.isMounted && this.actor.mount && this.result.charging
  }
  
  get target() { return this.data.result.target }
  get successBonus() { return this.data.preData.successBonus }
  get slBonus() { return this.data.preData.slBonus }
  get damage() { return this.data.result.damage }
  get hitloc() { return this.data.result.hitloc }
  get type() { return this.data.type }
  get size() { return this.useMount ? this.actor.mount.details.size.value : this.actor.details.size.value }
  get options() { return this.data.preData.options }
  get outcome() { return this.data.result.outcome }
  get result() { return this.data.result }
  get preData() { return this.data.preData }
  get context() { return this.data.context }
  get actor() { return WFRP_Utility.getSpeaker(this.context.speaker) }
  get token() { return WFRP_Utility.getToken(this.context.speaker) }

  get item() {
    if (typeof this.data.preData.item == "string")
      return this.actor.items.get(this.data.preData.item)
    else
      return new CONFIG.Item.documentClass(this.data.preData.item, { parent: this.actor })
  }

  get targets() {
    return this.context.targets.map(i => WFRP_Utility.getSpeaker(i))
  }

  get targetTokens() {
    return this.context.targets.map(i => game.scenes.get(i.scene)?.tokens.get(i.token))
  }

  get doesDamage() {
    return !!this.result.damage || !!this.result.diceDamage || !!this.result.additionalDamage
  }

  get DamageString() {
    let damageElements = [];
    if (this.result.damage) damageElements.push(this.result.damage);
    if (this.result.diceDamage) damageElements.push(`<span title=${this.result.diceDamage.formula}>${this.result.diceDamage.value}</span>`);

    return `(${damageElements.join(" + ")} ${game.i18n.localize("Damage")})`
  }

  get characteristicKey() { return this.preData.characteristic }

  get otherText() { return this.result.other?.length ? this.result.other.join("<br>") : null; }
}

class CharacteristicTest extends TestWFRP {
  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return

    if (this.actor.type == "vehicle")
      this.data.preData.item = "t";
      
    this.computeTargetNumber();
  }

  static fromData(...args)
  {
    return new this(...args);
  }

  computeTargetNumber() {
    this.data.result.target = this.item.value;
    super.computeTargetNumber();
  }

  get item() {
    return this.actor.characteristics[this.data.preData.item]
  }
  get characteristic() {
    return this.item
  }
}

class RollDialog extends WarhammerRollDialogV2 {

    static DEFAULT_OPTIONS = {
        position: {
            width: 600
        }
    };

    get tooltipConfig() 
    {
        return {
            modifier: {
                label: "Modifier",
                type: 1,
                path: "fields.modifier",
                hideLabel: true
            },
            slBonus: {
                label: "DIALOG.SLBonus",
                type: 1,
                path: "fields.slBonus"
            },
            successBonus: {
                label: "DIALOG.SuccessBonus",
                type: 1,
                path: "fields.successBonus"
            },
            difficulty: {
                label: "Difficulty",
                type: 0,
                path: "fields.difficulty"
            }
        }
    }
    
    static PARTS = {
        fields : {
            template : "systems/wfrp4e/templates/dialog/type/base-dialog.hbs",
            fields: true
        },
        modifiers : {
            template : "modules/warhammer-lib/templates/partials/dialog-modifiers.hbs",
            modifiers: true
        },
        specific : {
            template : "systems/wfrp4e/templates/dialog/type/default-dialog.hbs",
        },
        footer : {
            template : "templates/generic/form-footer.hbs"
        }
    };


    // /**
    //  * @override
    //  * Overide submit to handle creating the test with testClass
    //  * 
    //  * @param {Event|null} ev Triggering Event
    //  * @returns 
    //  */
    // static submit(ev) 
    // {
    //     ev?.preventDefault();
    //     ev?.stopPropagation();
        
    //     for(let script of this.data.scripts)
    //     {
    //         if (script.isActive)
    //         {
    //             script.submission(this);
    //         }
    //     }

    //     let test = new this.testClass(this._getSubmissionData(), this.actor)
        
    //     if (this.resolve)
    //     {
    //         this.resolve(test);
    //     }
    //     this.close();
    //     if (canvas.scene && !this.options.skipTargets)
    //     {
    //         game.canvas.tokens.setTargets([])
    //     }
    //     return test;
    // }

    // async bypass()
    // {
    //     let data = await super.bypass();
        
    //     let test = new this.testClass(data, this.actor)
    //     if (this.resolve)
    //     {
    //         this.resolve(test);
    //     }
    // }

    get title()
    {
        return this.context.title;
    }

    _getSubmissionData()
    {
        // if (!this.testClass)
        // {
        //     throw new Error("Only subclasses of RollDialog can be submitted")
        // }
        let data = super._getSubmissionData();

        data.chatOptions = this._setupChatOptions();
        data.chatOptions.rollMode = data.rollMode;

        return data
    }


    async computeFields() 
    {
        this._computeAdvantage();
        if (this.actor.attacker)
        {
            this._computeDefending(this.actor.attacker);
        }

        if (this.data.targets.length && !this.actor.attacker)
        {
            this._computeTargets(this.data.targets[0]);
        }
    }

    _computeAdvantage()
    {
        if (game.settings.get("wfrp4e", "autoFillAdvantage"))
        {
            this.tooltips.start(this);
            if (!game.settings.get("wfrp4e", "homebrew").mooAdvantage)
            {
                this.fields.modifier += (game.settings.get("wfrp4e", "homebrew").advantageBonus * this.actor.system.status.advantage.value);
            }
            else 
            {
                this.fields.successBonus += this.actor.system.status.advantage.value;
            }
            this.tooltips.finish(this, "Advantage");
        }
    }

    /**
     * Runs when the actor is being attacked
     * @abstract
     */
    _computeDefending(attacker)
    {

    }

    /** 
     * Runs if targeting an actor
     * @abstract
     */
    _computeTargets(target)
    {

    }

    async _onRender(options) 
    {
        await super._onRender(options);

        this.element.querySelector("[name='advantage']").addEventListener("change", this._onAdvantageChanged.bind(this));
    }

    _onFieldChange(ev) 
    {
        if (ev.currentTarget.name == "advantage")
        {
            return;
        }
        else return super._onFieldChange(ev);
    }


    _onAdvantageChanged(ev)
    {
        this.actor.update({"system.status.advantage.value" : Number(ev.currentTarget.value)}).then(a => this.render(true));
        ui.notifications.notify(game.i18n.localize("DIALOG.AdvantageUpdate"));
    }


    _defaultDifficulty()
    {
        let difficulty = "challenging";

        // Overrides default difficulty to Average depending on module setting and combat state
        if (game.settings.get("wfrp4e", "testDefaultDifficulty") && (game.combat != null))
            difficulty = game.combat.started ? "challenging" : "average";
        else if (game.settings.get("wfrp4e", "testDefaultDifficulty"))
            difficulty = "average";

        return difficulty;
    }
    _defaultFields() 
    {
        return foundry.utils.mergeObject({
            modifier : 0,
            successBonus : 0,
            slBonus : 0,
            difficulty : this._defaultDifficulty(),
        }, super._defaultFields());
    }

    createBreakdown()
    {
        let breakdown = {
            modifier: this.fields.modifier,
            difficulty : this.fields.difficulty,
            slBonus : this.fields.slBonus,
            successBonus : this.fields.successBonus,
            modifiersBreakdown : this.tooltips.getCollectedTooltips()
        };
        return breakdown;
    }
    
 /**
   * Ghat card options.
   *
   * All tests use the same chatOptions, but use the template member defined in each dialog class
   */
    _setupChatOptions() {
        let token = this.actor.token || this.actor.getActiveTokens()[0] || this.actor.prototypeToken;
        let chatOptions = {
            speaker: {
                alias: token.name,
                token: token.id,
                scene: token.parent?.id,
                actor: this.actor.id,
            },
            title: this.options.title,
            template: this.chatTemplate,
        };

        // If the test is coming from a token sheet
        if (this.actor.token) 
        {
            chatOptions.speaker.alias = this.actor.token.name; // Use the token name instead of the actor name
            chatOptions.speaker.token = this.actor.token.id;
            chatOptions.speaker.scene = canvas.scene.id;

            if (this.actor.token.hidden) 
            {
                chatOptions.speaker.alias = "???";
            }
        }
        else // If a linked actor - use the currently selected token's data if the actor id matches
        {
            let speaker = ChatMessage.getSpeaker();
            if (speaker.actor == this.actor.id) 
            {
                let token = speaker.token ? canvas.tokens.get(speaker.token) : null;
                chatOptions.speaker.alias = speaker.alias;
                chatOptions.speaker.token = speaker.token;
                chatOptions.speaker.scene = speaker.scene;
                if (token?.document.hidden) 
                {
                    chatOptions.speaker.alias = "???";
                }
            }
        }



        //Suppresses roll sound if the test has it's own sound associated
        foundry.utils.mergeObject(chatOptions,
        {
            user: game.user.id,
            sound: CONFIG.sounds.dice
        }, {overwrite : false});

        return chatOptions
    }

    /**
  * Creates the basic data that generally all dialogs use, such as formatting the speaker data and handling dialog scirpts
  * @param {Actor} actor Actor performing the test
  * @param {object} context Additional contextual flags for dialog, usually used by scripts
  * @returns {object} Basic dialog data shared by all types of dialogs
  */
    static _baseDialogData(actor, context, options) 
    {
        let dialogData = super._baseDialogData(actor, context, options);

        dialogData.data.other = []; // Container for miscellaneous data that can be freely added onto
        dialogData.data.speaker = CONFIG.ChatMessage.documentClass.getSpeaker({ actor });
        if (actor && !actor?.token) {
            // getSpeaker retrieves tokens even if this sheet isn't a token's sheet
            delete dialogData.data.speaker.scene;
        }

        if (dialogData.context.result) {
            if (typeof dialogData.context.result.general === "string")
                dialogData.context.result.general = [dialogData.context.result.general];
            if (typeof dialogData.context.result.success === "string")
                dialogData.context.result.success = [dialogData.context.result.success];
            if (typeof dialogData.context.result.failure === "string")
                dialogData.context.result.failure = [dialogData.context.result.failure];
        }
        
        return dialogData;
    }

    static getDefendingScripts(actor)
    {
        // Defending scripts are dialog scripts coming from the attacker and/or the weapon used in the attack.
        // e.g. "Dodge tests to defend against this attack have disadvantage"
        let attacker = actor.attacker;
        return attacker?.test?.actor ? ((attacker.test.actor.getScripts("dialog").concat(attacker.test?.item?.getScripts?.("dialog") || [])).filter(s => s.options?.defending)) : []
    }


    // Backwards compatibility for effects
    get prefillModifiers() 
    {
        return this.fields;
    }

    get type() 
    {

    }
}

class CharacteristicDialog extends RollDialog {
    chatTemplate = "systems/wfrp4e/templates/chat/roll/characteristic-card.hbs"
    get item()
    {
      return this.characteristic
    }

    get characteristic() 
    {
      return this.data.characteristic;
    }


    static async setupData(characteristic, actor, context={}, options={})
    {
        let dialogData = this._baseDialogData(actor, context, options);

        context.title = context.title || game.i18n.format("CharTest", {char: game.wfrp4e.config.characteristics[characteristic]});
        context.title += context.appendTitle || "";
        delete context.appendTitle;

        foundry.utils.mergeObject(dialogData, {data : {characteristic}, fields : context.fields || {}});

        let data = dialogData.data;
        
        data.hitloc = context.hitloc || ((characteristic == "ws" || characteristic == "bs") && !dialogData.context.reload);
        
        if (dialogData.context.reload)
        {
            data.scripts = data.scripts.concat(context.weapon?.ammo.getScripts("dialog").filter(s => !s.options.defending));
        }
            
        data.scripts = data.scripts.concat(data.actor.system.vehicle?.getScripts("dialog").filter(s => !s.options.defending) || []);
        data.scripts = data.scripts.concat(this.getDefendingScripts(data.actor));
        
        if (data.hitloc)
        {
            dialogData.fields.hitLocation = dialogData.fields.hitLocation || "roll";
            data.hitLocationTable = foundry.utils.mergeObject({none : game.i18n.localize("None"), roll : game.i18n.localize("Roll")}, game.wfrp4e.tables.getHitLocTable(data.targets[0]?.actor?.details?.hitLocationTable?.value || "hitloc"));
        }
        else
        {
            dialogData.fields.hitLocation = "none";
        }

        return dialogData;
        // TODO handle bypass
        /**
        return new Promise(resolve => {
            let dlg = new this(data, fields, context, options, resolve)
            if (options.bypass)
            {
                dlg.bypass()
            }
            else 
            {
                dlg.render(true);
            }
        })*/
    }

    async _prepareContext(options)
    {
        let context = await super._prepareContext(options);
        // context.data.hitLoc = ["ws", "bs"].includes(context.data.characteristic)
        return context;
    }
    
    _getSubmissionData()
    {
        let data = super._getSubmissionData();
        data.item = this.data.characteristic;
        return data;
    }

    
    computeFields() {
        super.computeFields();

        if (this.context.dodge && this.actor.isMounted) {
            this.fields.modifier -= 20;
            this.tooltips.add("modifier", -20, game.i18n.localize("EFFECT.DodgeMount"));
        }
    }


    _computeDefending(attacker)
    {
        if (attacker.test.item.properties?.flaws.slow) {
            if (!game.settings.get("wfrp4e", "homebrew").mooQualities || this.context.dodge) 
            {
                this.fields.slBonus += 1;
                this.tooltips.add("slBonus", 1, game.i18n.localize('CHAT.TestModifiers.SlowDefend'));
            }
        }

    }
    
    _defaultDifficulty() 
    {
        let difficulty = super._defaultDifficulty();
        if (this.context.corruption || this.context.mutate)
        {
            difficulty = "challenging";
        }

        if (this.context.rest || this.context.income)
        {
            difficulty =  "average";
        }
        return difficulty;
    }

    createBreakdown()
    {
        let breakdown = super.createBreakdown();
        if (this.characteristic)
        {
            breakdown.characteristic = `${this.actor.system.characteristics[this.characteristic].value} (${game.wfrp4e.config.characteristics[this.characteristic]})`;
        }
        return breakdown;
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "characteristic";
    }
}

class SkillTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.data.preData.options.characteristicToUse = data.characteristicToUse;
    this.data.preData.skillName = data.skillName;
    this.computeTargetNumber();
  }

  static fromData(...args)
  {
    return new this(...args);
  }

  computeTargetNumber() {

    // If unknown skill, defer until later, once skill is found
    if (this.preData.item == "unknown" && !this.context.unknownSkill)
      return 0

    try {
      // If skill is not owned by the actor, just use characteristic
      if (this.context.unknownSkill) {
        this.result.target = this.actor.characteristics[this.context.unknownSkill.system.characteristic.value].value;
      }
      else {


        // Use skill total if characteristics match, otherwise add the total up manually
        if (this.preData.options.characteristicToUse && this.preData.options.characteristicToUse != this.item.characteristic.key)
          this.result.target = this.actor.characteristics[this.preData.options.characteristicToUse].value + this.item.advances.value;
        else
          this.result.target = this.item.total.value;
      }
    }
    catch
    {
      this.result.target = this.item.total.value;
    }

    super.computeTargetNumber();
  }

  async roll() {

    // If skill id is unknown, meaning the actor doesn't have the skill, find the skill and use characteristic
    if (this.preData.item == "unknown") {
      let skill = await WFRP_Utility.findSkill(this.preData.skillName);
      if (skill) {
        this.context.unknownSkill = skill.toObject();
        this.computeTargetNumber();
      }
      else {
        throw new Error(game.i18n.localize("ERROR.Found", { name: this.skill }))
      }
    }


    await super.roll();
  }

  get skill() {
    return this.item
  }

  get item() {
    return this.unknownSkill ? this.unknownSkill : super.item || {}
  }
}

class SkillDialog extends CharacteristicDialog {

    chatTemplate = "systems/wfrp4e/templates/chat/roll/skill-card.hbs"

    get item()
    {
      return this.skill
    }

    get extendedTest() 
    {
        return fromUuidSync(this.options.extended);
    }

    get skill() 
    {
      return this.data.skill;
    }

    static PARTS = {
        fields : {
            template : "systems/wfrp4e/templates/dialog/type/base-dialog.hbs",
            fields: true
        },
        modifiers : {
            template : "modules/warhammer-lib/templates/partials/dialog-modifiers.hbs",
            modifiers: true
        },
        specific : {
            template : "systems/wfrp4e/templates/dialog/type/skill-dialog.hbs",
        },
        footer : {
            template : "templates/generic/form-footer.hbs"
        }
    };

    static async setupData(skill, actor, context={}, options={})
    {
        let characteristic;
        if (skill.id == "unknown")
        {
            try 
            {
                let compendiumSkill = await game.wfrp4e.utility.findSkill(skill.name);
                if (compendiumSkill)
                {
                    characteristic = compendiumSkill.system.characteristic.value;
                }
            }
            catch(e)
            {
                characteristic = skill.system.characteristic.value;
            }
        }
        else 
        {
            characteristic = skill.system.characteristic.value;
        }

        context.title = context.title || game.i18n.format("SkillTest", {skill: skill.name});
        context.title += context.appendTitle || "";
        delete context.appendTitle;
        let dialogData = await super.setupData(characteristic, actor, context, options);
        dialogData.fields.characteristic = characteristic;
        foundry.utils.mergeObject(dialogData.data, {skill});

        
        if (dialogData.context.reload)
        {
            dialogData.data.scripts = dialogData.data.scripts.concat(context.weapon?.ammo.getScripts("dialog").filter(s => !s.options.defending));
        }

        
        if (skill.id != "unknown")
        {
            dialogData.data.scripts = dialogData.data.scripts.concat(skill?.getScripts("dialog").filter(s => !s.options.defending));
        }

        if (skill.name == game.i18n.localize("NAME.Dodge"))    
        {
            dialogData.context.dodge = true;
        }
    
        return dialogData;
    }

    _getSubmissionData()
    {
        let data = super._getSubmissionData();
        data.skillName = this.data.skill?.name;
        data.item = this.data.skill?.id;
        data.characteristicToUse = this.data.characteristic;
        return data;
    }

    computeFields()
    {
        // While in a characteristic dialog, the characteristic is considered internal data
        // in a skill dialog, there's a field to change the characteristic used, so it's a field
        // Make sure the internal characteristic value matches the selected field value
        this.data.characteristic = this.fields.characteristic;
        super.computeFields();   
        this._computeArmour();
    }

    _computeArmour()
    {
        let stealthPenaltyValue = 0;

        // Armor type penalties do not stack, only apply if you wear any of that type
        let wearingMail = false;
        let wearingPlate = false;

        for (let a of this.actor.itemTags["armour"].filter(i => i.isEquipped)) {
            // For each armor, apply its specific penalty value, as well as marking down whether
            // it qualifies for armor type penalties (wearingMail/Plate)

            // Skip practical
            if (a.properties.qualities.practical) {
                continue;
            }

            if (a.armorType.value == "mail") {
                wearingMail = true;
            }
            if (a.armorType.value == "plate") {
                wearingPlate = true;
            }
        }

        // Apply armor type penalties at the end
        if (wearingMail || wearingPlate) {
            if (wearingMail) {
                stealthPenaltyValue += -10;
            }
            if (wearingPlate) {
                stealthPenaltyValue += -10;
            }

            if (this.item.name.includes(game.i18n.localize("NAME.Stealth"))) {
                if (stealthPenaltyValue) {
                    this.fields.modifier += stealthPenaltyValue;
                    this.tooltips.add("modifier", stealthPenaltyValue, game.i18n.localize("SHEET.ArmourPenalties"));
                }
            }
        }
    }

    createBreakdown()
    {
        let breakdown = super.createBreakdown();
        if (this.skill?.system)
        {
            let skillValue = (this.skill?.system.advances?.value + this.skill?.system.modifier?.value) || 0;
            if (skillValue)
            {
                breakdown.skill = `${this.skill.name} ${foundry.applications.handlebars.numberFormat(skillValue, {hash :{sign: true}})}`;
            }
        }
        return breakdown;
    }

    _defaultFields() 
    {
        return foundry.utils.mergeObject({
            characteristic : "ws",
        }, super._defaultFields());
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "skill";
    }
}

/** Creates and manages an Item posted to chat, retrievable by dragging and dropping from chat into an Actor sheet.
 *  If the item is physical, with quantity and price, it also tracks who has dragged and the amount it has been dragged
 *  If a "Post Quantity" is specified, then it can only be retrieved that many times before disallowing further dragging.
 */

class PostedItemMessageModel extends WarhammerMessageModel {
  static defineSchema() 
  {
      let schema = {};

      // Data used to display and create the Item on Actors
      schema.itemData = new foundry.data.fields.ObjectField();

      // How many times this item can be dragged from chat
      schema.postQuantity = new foundry.data.fields.NumberField({nullable : true});

      // Keep track of the original item data, currently only used for knowing what 10% of the base price is for haggling
      schema.originalItemData = new foundry.data.fields.ObjectField();

      // Track who has retrieved this item from chat
      schema.retrievedBy = new foundry.data.fields.ArrayField(new foundry.data.fields.StringField());
      return schema;
  }
  
  static get actions() {
    return foundry.utils.mergeObject(super.actions, {
      haggle : this._onHaggle,
      rollAvailability : this._onRollAvailability,
      pay : this._onPay,
      postItemProperty: this._postItemProperty
    });
  }

  /**
   * Make the message draggable and listen for drags
   * 
   * @param {HTMLElement} html HTML of the message
   */
  async onRender(html) {

    let post = html.querySelector(".post-item");
    post.draggable = true;

    post.addEventListener('dragstart', this._onDragItem.bind(this));
  }

  /**
   * When a Physical Item is retrieved from chat, decrease Post Quantity
   * and record who it was retrieved by 
   * 
   * @param {String} name Name of Actor who retrieved the Item
   */
  async decrementQuantity(name)  
  {
    if (this.postQuantity > 0)
    {
      let retrievedBy = this.retrievedBy.concat(name);
      let content = await this.constructor._renderHTMLFromItemData(this.itemData, this.postQuantity - 1, retrievedBy);
      this.parent.update({content, system : {postQuantity : this.postQuantity - 1, retrievedBy}});
    }
  }

  /**
   * Set the dataTransfer to the Item data, also record the message ID to know where they dragged it from
   * 
   * @param {DragEvent} ev The event triggering this listener
   * @returns 
   */
  async _onDragItem(ev)
  {
    let transfer = ev.dataTransfer.setData("text/plain", JSON.stringify({type : "Item", data : this.itemData, options: {fromMessage : this.parent.id}}));
    return transfer;
  }

  /**
   * Pays for the Item and adds it to the inventory
   * 
   * @param {Event} ev Click event 
   * @param {HTMLElement} target Button/element clicked
   */
  static async _onPay(ev, target)
  {
    
    let paid = await game.wfrp4e.market.handlePlayerPayment({payString : game.wfrp4e.market.amountToString(this.itemData.system.price), itemData : this.itemData});
    for(let actor of paid)
    {
      await actor.createEmbeddedDocuments("Item", [this.itemData], {fromMessage: this.parent.id});
      ui.notifications.notify(game.i18n.format("MARKET.ItemAdded", { item: this.itemData.name, actor : actor.name })); 
    }
  }

  /**
   * Calls the Market class to roll availability 
   * 
   * @param {Event} ev Click event 
   * @param {HTMLElement} target Button/element clicked
   */
  static async _onRollAvailability(ev, target)
  {
    await game.wfrp4e.market.generateSettlementChoice(this.itemData.system.availability.value, this.itemData.name);
  }

  /**
   * Increases or decreases the price of the item by 10%
   * Uses the original item price to find the haggle difference
   * Convert to BP, add/subrtact 10%, consolidate, rerender
   * 
   * @param {Event} ev Click event 
   * @param {HTMLElement} target Button/element clicked
   */
  static async _onHaggle(ev, target)
  {
    let multiplier = target.dataset.type == "up" ? 1 : -1;
    let currentPrice = foundry.utils.deepClone(this.itemData.system.price);
    let originalPrice = foundry.utils.deepClone(this.originalItemData.system.price);

    let originalBP = originalPrice.gc * 240 + originalPrice.ss * 12 + originalPrice.bp;
    let currentBP = currentPrice.gc * 240 + currentPrice.ss * 12 + currentPrice.bp;
    let haggledBP = currentBP + (Math.round((originalBP * .1)) * multiplier);

    let haggledPrice = game.wfrp4e.market.makeSomeChange(haggledBP, 0);

    let itemData = foundry.utils.deepClone(this.itemData);
    itemData.system.price = haggledPrice;

    let content = await this.constructor._renderHTMLFromItemData(itemData, this.postQuantity, this.retrievedBy);
    this.parent.update({content, "system.itemData" : itemData});
  }

  /**
   * Creates a PostedItem Message 
   * 
   * @param {ItemWFRP4e} item Item posted to chat
   * @param {number} quantity How many times the posted item can be dragged from chat
   * @param {*} mergeData 
   */
  static async create(item, quantity, mergeData = {}) 
  {
    if (quantity == undefined && (item.system.isPhysical))
    {
      quantity = await ValueDialog.create({title : game.i18n.localize("DIALOG.PostQuantity"), text : game.i18n.localize("DIALOG.PostQuantityContent")}) || undefined;
    }
    
    let itemData = foundry.utils.mergeObject(item.toObject(), mergeData);
    let content = await this._renderHTMLFromItemData(item, quantity);
    ChatMessage.create(ChatMessage.applyRollMode({
      type : "item",
      content,
      system : {itemData, originalItemData : itemData, postQuantity : quantity}
    }, game.settings.get("core", "rollMode")));

  }


  /**
   * Takes item data and contextual data to create HTML content for the Posted Item message
   * 
   * @param {Object} itemData Raw Item Data used for rendering
   * @param {Number} postQuantity Display the Post quantity, if available
   * @param {Array<string>} retrievedBy Show who's retrieved the item
   * @returns 
   */
  static async _renderHTMLFromItemData(itemData, postQuantity, retrievedBy=[])
  {
    let messageData = {
      item : itemData,
      img : itemData.img,
      properties : new Item.implementation(itemData).system.chatData(),
      postQuantity,
      retrievedBy : retrievedBy.join(", ")
    };

    if (messageData.img.includes("/blank.png"))
    {
      messageData.img = null;
    }


    return await foundry.applications.handlebars.renderTemplate('systems/wfrp4e/templates/chat/post-item.hbs', messageData);

  }

  static _postItemProperty(ev)
  {
    WFRP_Utility.postProperty(ev.target.text);
  }

}

/**
 * @extends Item
 * @mixes WarhammerItem
 * @category - Documents
 */
class ItemWFRP4e extends WarhammerItem
{
  async _preCreate(data, options, user) {
    let migration = game.wfrp4e.migration.migrateItemData(this);
    this.updateSource({effects : game.wfrp4e.migration.removeLoreEffects(data)}, {recursive : false});

    if (!foundry.utils.isEmpty(migration))
    {
      this.updateSource(migration);
      warhammer.utility.log("Migrating Item: " + this.name, true, migration);
    }

    if (options.fromTemplate)
    {
        this.updateSource({[`flags.${game.system.id}.fromTemplate`] : options.fromTemplate});
    }
    return await super._preCreate(data, options, user)
  }

  async _onCreate(data, options, user)
  {

    if (game.user.isUniqueGM && options.fromMessage && this.actor)
    {
      game.messages.get(options.fromMessage)?.system.decrementQuantity(this.actor.name);
    }
    if (game.user.id != user)
    {
        return;
    }
    await super._onCreate(data, options, user);

    if (this.isOwned)
    {
      await Promise.all(this.actor.runScripts("update", {data, context: "create"}));

      // Cannot simply call runScripts here because that would only be for Item effects
      // If an item has a transfered effect, it won't call "addItems" scripts because the effect's
      // onCreate method isn't called. Same reason handleImmediate scripts doesn't call runScripts
      let effects = Array.from(this.allApplicableEffects()).filter(effect => effect.system.transferData.type == "document" && ["Actor", "Item"].includes(effect.system.transferData.documentType));
      for(let effect of effects)
      {
        for(let script of effect.scripts.filter(s => s.trigger == "addItems"))
        {
          await script.execute({data, options, user});
        }
      }
    }

  }

  async _onUpdate(data, options, user)
  {
    await super._onUpdate(data, options, user);
    
    if (game.user.id != user)
    {
        return;
    }

    if (this.actor) {
      await Promise.all(this.actor.runScripts("update", {item : this, context: "update"}));
    }
  }

  async _onDelete(options, user) 
  {
    if (game.user.id != user)
    {
        return;
    }
    await super._onDelete(options, user);

    if (!options.skipDeletingItems)
    {
      for(let effect of this.effects)
      {
        await effect.deleteCreatedItems();
      }
    }

    for(let effect of this.effects)
    {
      for(let script of effect.scripts.filter(i => i.trigger == "deleteEffect"))
      {
          await script.execute({options, user});
      }
    }

    if (this.actor) {
      // TODO change this trigger
      await Promise.all(this.actor.runScripts("update", {item : this, context: "delete"}));
    }
  }

  // Conditions shouldn't be tied to the item. Add them to the actor independently.
  async _handleConditions(data, options)
  {
      if (options.condition)
      {
        return // options.condition as true avoids this process
      }

      let conditions = this.effects.filter(e => e.isCondition);

      // updateSource doesn't seem to work here for some reason: 
      // this.updateSource({effects : []})
      this._source.effects = this.effects.filter(e => !e.isCondition).filter(e => e.toObject());

      this.actor?.createEmbeddedDocuments("ActiveEffect", conditions);
  }

    // This function runs the immediate scripts an Item contains in its effects
    // when the Item is added to an Actor. 
    async handleImmediateScripts(data, options, user)
    {
        let effects = Array.from(this.allApplicableEffects()).filter(effect => 
            effect.system.transferData.type == "document" && 
            effect.system.transferData.documentType == "Actor"); // We're looking for actor because if the immediate script was for the Item, it would've been called when it was created. 

        for(let e of effects)
        {
            let keepEffect = await e.handleImmediateScripts(data, options, user);
            if (keepEffect == false) // Can't actually delete the effect because it's owned by an item in _preCreate. Change it to `other` type so it doesn't show in the actor
            {
                e.updateSource({"system.transferData.type" : "other"});
            }
        }

        // let scripts = effects.reduce((prev, current) => prev.concat(current.scripts.filter(i => i.trigger == "immediate")), []);

        // await Promise.all(scripts.map(s => s.execute()));
    }



  prepareBaseData()
  {
    this.system.computeBase();
    this.runScripts("prePrepareData", { item: this });
  }

  prepareDerivedData()
  {
    this.system.computeDerived();
    this.runScripts("prepareData", { item: this });
  }

  prepareOwnedData()
  {
    this.actor.runScripts("prePrepareItem", { item: this });
    this.system.computeOwned();
    this.actor.runScripts("prepareItem", { item: this });
    this.runScripts("prepareOwned", { item: this });

  }

  async addCondition(effect, value = 1, mergeData={}) {
    if (value == 0)
    {
      return;
    }
    if (typeof value == "string")
    {
      value = parseInt(value);
    }

    if (typeof (effect) === "string")
      effect = foundry.utils.duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
    if (!effect)
      return "No Effect Found"

    if (!effect.id)
      return "Conditions require an id field"


    let existing = this.hasCondition(effect.id);

    if (existing && !existing.isNumberedCondition)
      return existing
    else if (existing) 
    {
      return existing.update({"system.condition.value" : existing.conditionValue + value})
    }
    else if (!existing) {
      effect.name = game.i18n.localize(effect.name);

      if (effect.system.condition.numbered)
        effect.system.condition.value = value;
        
      effect["statuses"] = [effect.id];

      foundry.utils.mergeObject(effect, mergeData);

      delete effect.id;
      return this.createEmbeddedDocuments("ActiveEffect", [effect], {condition: true})
    }
  }

  async removeCondition(effect, value = 1) {
    if (typeof (effect) === "string")
      effect = foundry.utils.duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
    if (!effect)
      return "No Effect Found"

    if (!effect.id)
      return "Conditions require an id field"

    if (value == 0)
    {
      return;
    }
    if (typeof value == "string")
    {
      value = parseInt(value);
    }

    let existing = this.hasCondition(effect.id);

    if (existing && !existing.isNumberedCondition) 
    {
      return existing.delete();
    }
    else if (existing) 
    {
      await existing.update({"system.condition.value" : existing.conditionValue - value});
    }

    if (existing.conditionValue <= 0)
    {
      return existing.delete();
    }
  }


  /**
   * Posts this item to chat.
   * 
   * postItem() prepares this item's chat data to post it to chat, setting up 
   * the image if it exists, as well as setting flags so drag+drop works.
   * 
   */
  async postItem(quantity, mergeData={}) 
  {
    PostedItemMessageModel.create(this, quantity, mergeData);
  }

  //#endregion
   
  get mountDamage() {
    return this.system.mountDamage || this.system.Damage;
  }

  // Don't really like this, but I don't think I can change it easily (used by scripts)
  get characteristic() {
    if (!this.isOwned)
      return this.system.characteristic
    let char;
    if (this.type == "skill") {
      char = this.actor.characteristics[this.system.characteristic.value];
      char.key = this.system.characteristic.value;
    }
    if (this.type == "trait" && this.rollable.value) {
      char = this.actor.characteristics[this.system.rollable.rollCharacteristic];
      char.key = this.system.rollable.rollCharacteristic;
    }
    return char
  }

    // Used for item category display when in a container
  get trappingCategory() {
      if (this.type == "trapping")
        return game.wfrp4e.config.trappingCategories[this.trappingType.value];
      else
        return game.wfrp4e.config.trappingCategories[this.type];
  }

  get parenthesesText()
  {
    return game.wfrp4e.utility.extractParenthesesText(this.name)
  }

  get fromEffect() 
  {
    if (this.isOwned)
    {
      let applicableEffects = Array.from(this.actor.allApplicableEffects());
      
      return applicableEffects.find(i => i.id && i.id == this.getFlag("wfrp4e", "fromEffect"));
    }
  }

  // While I wish i could remove most of these, scripts use them and removing them would cause a lot of disruption
  // They made more sense in the `data.data` days
  get attackType()         { return this.system.attackType }
  get isMelee()            { return this.system.isMelee }
  get isRanged()           { return this.system.isRanged }
  get isEquipped()         { return this.system.isEquipped }
  get WeaponGroup()        { return this.system.WeaponGroup }
  get Reach()              { return this.system.Reach }
  get Max()                { return this.system.Max }
  get DisplayName()        { return this.system.DisplayName }
  get cost()               { return this.system.cost }
  get included()           { return !this.system.disabled } // not checking enabled because only traits have enabled getter
  get reachNum()           { return this.system.reachNum }   
  get ammo()               { return this.system.ammo }   
  get ammoList()           { return this.system.ammoList }   
  get ingredient()         { return this.system.ingredient }   
  get ingredientList()     { return this.system.ingredientList }   
  get skillToUse()         { return this.system.skillToUse }   
  get loading()            { return this.system.loading }   
  get repeater()           { return this.system.repeater }   
  get reloadingTest()      { return this.actor.items.get(foundry.utils.getProperty(this.data, "flags.wfrp4e.reloading")) }   
  get protects()           { return this.system.protects }   
  get properties()         { return this.system.properties }   
  get originalProperties() { return this.system.originalProperties }   
  get modified()           { return this.system.modified }   
  get Advances()           { return this.system.Advances }   
  get Qualities()          { return this.system.Qualities }   
  get UnusedQualities()    { return this.system.UnusedQualities }   
  get InactiveQualities()  { return this.system.InactiveQualities }   
  get Flaws()              { return this.system.Flaws }   
  get OriginalQualities()  { return this.system.OriginalQualities; }   
  get OriginalFlaws()      { return this.system.OriginalFlaws; }   
  get QualityGroups()      { return this.system.QualityGroups; }   
  get Target()             { return this.system.Target }   
  get Duration()           { return this.system.Duration }   
  get Range()              { return this.system.Range }   
  get Damage()             { return this.system.Damage }   
  get DamageString()       { return this.system.DamageString }  
  get Specification()      { return this.system.Specification }
  get SpecificationBonus() { return this.system.SpecificationBonus }
  get advanced()           { return this.system.advanced }
  get advances()           { return this.system.advances }
  get ammunitionGroup()    { return this.system.ammunitionGroup }
  get ammunitionType()     { return this.system.ammunitionType }
  get armorType()          { return this.system.armorType }
  get availability()       { return this.system.availability }
  get career()             { return this.system.career }
  get careergroup()        { return this.system.careergroup }
  get cargoType()          { return this.system.cargoType }
  get carries()            { return this.system.carries }
  get characteristics()    { return this.system.characteristics }
  get class()              { return this.system.class }
  get cn()                 { return this.system.cn }
  get coinValue()          { return this.system.coinValue }
  get complete()           { return this.system.complete }
  get completion()         { return this.system.completion }
  get consumesAmmo()       { return this.system.consumesAmmo }
  get contraction()        { return this.system.contraction }
  get countEnc()           { return this.system.countEnc }
  get current()            { return this.system.current }
  get currentAmmo()        { return this.system.currentAmmo }
  get currentAP()          { return this.system.currentAP }
  get currentIng()         { return this.system.currentIng }
  get damage()             { return this.system.damage }
  get damageToItem()       { return this.system.damageToItem }
  get description()        { return this.system.description }
  get duration()           { return this.system.duration }
  get encumbrance()        { return this.system.encumbrance }
  get equipped()           { return this.system.equipped }
  get failingDecreases()   { return this.system.failingDecreases }
  get flaws()              { return this.system.flaws }
  get gmdescription()      { return this.system.gmdescription }
  get god()                { return this.system.god }
  get grouped()            { return this.system.grouped }
  get hide()               { return this.system.hide }
  get incomeSkill()        { return this.system.incomeSkill }
  get incubation()         { return this.system.incubation }
  get ingredients()        { return this.system.ingredients }
  get level()              { return this.system.level }
  get loaded()             { return this.system.loaded }
  get location()           { return this.system.location }
  get lore()               { return this.system.lore }
  get magicMissile()       { return this.system.magicMissile }
  get max()                { return this.system.max }
  get AP()                 { return this.system.AP }
  get APdamage()           { return this.system.APdamage }
  get memorized()          { return this.system.memorized }
  get modeOverride()       { return this.system.modeOverride }
  get modifier()           { return this.system.modifier }
  get modifiesSkills()     { return this.system.modifiesSkills }
  get modType()            { return this.system.modType }
  get mutationType()       { return this.system.mutationType }
  get negativePossible()   { return this.system.negativePossible }
  get offhand()            { return this.system.offhand }
  get origin()             { return this.system.origin }
  get overcast()           { return this.system.overcast }
  get penalty()            { return this.system.penalty }
  get permanent()          { return this.system.permanent }
  get price()              { return this.system.price }
  get qualities()          { return this.system.qualities }
  get quality()            { return this.system.quality }
  get quantity()           { return this.system.quantity }
  get range()              { return this.system.range }
  get reach()              { return this.system.reach }
  get rollable()           { return this.system.rollable }
  get skill()              { return this.system.skill }
  get skills()             { return this.system.skills }
  get SL()                 { return this.system.SL }
  get special()            { return this.system.special }
  get specification()      { return this.system.specification }
  get spellIngredient()    { return this.system.spellIngredient }
  get status()             { return this.system.status }
  get symptoms()           { return this.system.symptoms }
  get talents()            { return this.system.talents }
  get target()             { return this.system.target }
  get test()               { return this.system.test }
  get tests()              { return this.system.tests }
  get total()              { return this.system.total }
  get trappings()          { return this.system.trappings }
  get trappingType()       { return this.system.trappingType }
  get twohanded()          { return this.system.twohanded }
  get prayerType()         { return this.system.type }
  get unitPrice()          { return this.system.unitPrice }
  get weaponGroup()        { return this.system.weaponGroup || "basic" }
  get wearable()           { return this.system.wearable }
  get wind()               { return this.system.wind }
  get worn()               { return this.system.worn }
  get wounds()             { return this.system.wounds }
  //#endregion
}

class AttackTest extends TestWFRP {


  async computeResult() {
    await super.computeResult();

    this.computeProperties();

    await this.calculateDamage();

    return this.result;
  }

  async postTest()
  {
    await super.postTest();
    let target = this.targets[0];
    if (target && target.type != "vehicle" && this.result.hitloc) 
    {
      let impenetrable = false;
      let AP = target.status.armour[this.result.hitloc.result];
      for(let layer of AP.layers)
      {
        if (layer.impenetrable)
          impenetrable = true;
      }
      if (this.result.critical && impenetrable && this.result.roll % 2 != 0) {
        if (this.result.tables.critical)
        {
          this.result.tables.critical.nulled = true;
          this.result.tables.critical.label = `${game.i18n.localize("CHAT.CriticalsNullified")} (${game.i18n.localize("PROPERTY.Impenetrable")})`;
        }
      }
    }
  }

  computeProperties()
  {
    if (this.failed) {
      // Dangerous weapons fumble on any failed tesst including a 9
      if (this.result.roll % 11 == 0 || this.result.roll == 100 || (this.item.properties.flaws.dangerous && this.result.roll.toString().includes("9"))) {
        this.result.fumble = game.i18n.localize("Fumble");
      }
      if (this.item.properties.flaws.unreliable)
        this.result.SL--;
      if (this.item.properties.qualities.practical)
        this.result.SL++;

      if (this.item.weaponGroup?.value == "throwing")
        this.result.scatter = game.i18n.localize("Scatter");
    }
    else // if success
    {
      if (this.result.roll % 11 == 0)
        this.result.critical = game.i18n.localize("Critical");

      // Impale weapons crit on 10s numbers
      if (this.item.properties.qualities.impale && this.result.roll % 10 == 0)
        this.result.critical = game.i18n.localize("Critical");

      if (this.result.critical && this.item.properties.qualities.slash)
      {
          this.result.other.push(`${game.i18n.format("PROPERTY.SlashAlert", {value : parseInt(this.item.properties.qualities.slash.value)})}`);
      }
    }
  }

  computeTables()
  {
    super.computeTables();
    if (this.result.scatter)
    {
      this.result.tables.scatter = {
        label : this.result.scatter,
        key : "scatter"
      };
    }
  }

  async calculateDamage(base)
  {
    let damageBreakdown = this.result.breakdown.damage;

    this.result.additionalDamage = this.preData.additionalDamage || 0;

    let damageToUse = base; // Start out normally, with SL being the basis of damage
    damageBreakdown.base = `${base} (${game.i18n.localize("SL")})`;
    
    if (this.useMount && this.actor.mount.characteristics.s.bonus > this.actor.characteristics.s.bonus)
    {
      let itemDamage = this.item.Damage;
      let mountDamage = this.item.mountDamage;

      this.result.damage = (0, eval)(mountDamage + Number(damageToUse));
      damageBreakdown.item = `+${itemDamage} (${this.item.system.damage?.value || this.item.system.specification.value})`;
      if (itemDamage != mountDamage)
      {
        damageBreakdown.other.push({label : game.i18n.localize("Mount"), value : mountDamage - itemDamage});
      }
    }
    else
    {
      this.result.damage = (0, eval)(this.item.Damage + Number(damageToUse));
      damageBreakdown.item = `+${this.item.Damage} (${this.item.system.damage?.value || this.item.system.specification.value})`;
    }

    if (this.result.charging && !this.result.other.includes(game.i18n.localize("Charging")))
    {
      this.result.other.push(game.i18n.localize("Charging"));
    }

    if ((this.item.properties.flaws.tiring && this.result.charging) || !this.item.properties.flaws.tiring) 
    {
      let unitValue = Number(this.result.roll.toString().split("").pop());
      unitValue = unitValue == 0 ? 10 : unitValue; // If unit value == 0, use 10

      if (this.item.properties.qualities.damaging && unitValue > Number(this.result.SL))
      {
        base = unitValue; // If damaging, instead use the unit value if it's higher
        damageBreakdown.base = `${unitValue} (${game.i18n.localize("Damaging")})`;
      }

      if (this.useMount && this.actor.mount.characteristics.s.bonus > this.actor.characteristics.s.bonus)
        this.result.damage = (0, eval)(this.item.mountDamage + Number(damageToUse));
      else
        this.result.damage = (0, eval)(this.item.Damage + Number(damageToUse));

      // Add unit die value to damage if impact
      if (this.item.properties.qualities.impact)
      {
        this.result.damage += unitValue;
        damageBreakdown.other.push({label : game.i18n.localize("PROPERTY.Impact"), value : unitValue});
      }
    }

    if (this.item.properties.qualities.spread)
    {
      let value = (Number(this.item.properties.qualities.spread.value) || 0);
      if (this.preData.options.rangeBand == game.i18n.localize("Point Blank"))
      {
        this.result.additionalDamage += value;        
        this.result.damage += value;
        damageBreakdown.other.push({label : `${game.i18n.localize("PROPERTY.Spread")} - ${game.i18n.localize("Point Blank")}` , value : value});
        this.preData.other.push(game.i18n.format("CHAT.SpreadPointBlank", {damage : value}));
      }
      else if (this.preData.options.rangeBand == game.i18n.localize("Extreme"))
      {
        this.result.additionalDamage -= value;        
        this.result.damage -= value;
        damageBreakdown.other.push({label : `${game.i18n.localize("PROPERTY.Spread")} - ${game.i18n.localize("Extreme")}` , value : -value});
        this.preData.other.push(game.i18n.format("CHAT.SpreadExtreme", {damage : value}));
      }
    }
  }

  get canUseCriticalDeflection() {
    let result = false;
    const hitLoc = this.data.result.hitloc.result;
    this.targets.forEach(target => {
      if (this.isCritical && !(game.settings.get("wfrp4e", "homebrew").mooCriticalMitigation) && target.physicalNonDamagedArmourAtLocation(hitLoc).length > 0) {
        result = true;
      }
    });
    return result;
  }
}

class WeaponTest extends AttackTest {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.preData.ammoId = data.ammo?.id; // TODO vehicle shit
    this.preData.charging = data.charging || false;
    this.preData.infighter = data.infighter || !!actor?.has(game.i18n.localize("NAME.Infighter"), "talent"); // I don't like this but it's really awkward to implement with scripts
    this.preData.resolute = data.resolute || 0;
    this.preData.dualWielding = data.dualWielding || false;

    this.computeTargetNumber();
  }

  static fromData(...args)
  {
    return new this(...args);
  }

  computeTargetNumber() {
    let skill = this.item.system.getSkillToUse(this.actor);
    if (!skill)
      this.result.target = this.item.system.attackType == "ranged" ? this.actor.system.characteristics.bs.value : this.actor.system.characteristics.ws.value;
    else
      this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollWeaponTest", this, this.context.chatOptions);
  }


  async roll() {

    if (this.options.dualWieldOffhand && this.options.offhandReverse)
      this.preData.roll = this.options.offhandReverse;

    await super.roll();
  }

  async computeResult()
  {
    await super.computeResult();
    this.computeMisfire();
    this.computeDualWielder();
  }


  async calculateDamage() {
    super.calculateDamage(this.result.SL);
    let weapon = this.weapon;

    if ((weapon.damage.dice || weapon.ammo?.damage.dice) && !this.result.additionalDamage) {
      let roll = await new Roll(weapon.damage.dice + `${weapon.ammo?.damage.dice ? "+" + weapon.ammo?.damage.dice : "" }`).roll({allowInteractive : false});
      this.result.diceDamage = { value: roll.total, formula: roll.formula };
      this.preData.diceDamage = this.result.diceDamage;
      this.result.additionalDamage += roll.total;
      this.context.breakdown.damage.other.push({label : game.i18n.format("BREAKDOWN.Dice"), value : roll.total});
      this.preData.additionalDamage  = this.result.additionalDamage;
    }

    //@HOUSE
    if (game.settings.get("wfrp4e", "homebrew").mooRangedDamage)
    {
      game.wfrp4e.utility.logHomebrew("mooRangedDamage");
      if (weapon.isRanged)
      {
        let damageMod = (Math.floor(this.targetModifiers / 10) || 0);
        this.result.damage -= damageMod;
        this.context.breakdown.damage.other.push({label : game.i18n.localize("BREAKDOWN.Moo"), value : -damageMod});
        if (this.result.damage < 0)
          this.result.damage = 0;
      }
    }
    //@/HOUSE
  }

  async postTest() {
    await super.postTest();

    await this.handleAmmo();

  }

  async handleAmmo()
  {
    // Only subtract ammo on the first run, so not when edited, not when rerolled
    if (this.item.system.ammo && this.item.system.consumesAmmo.value && !this.context.edited && !this.context.reroll) {
      await this.item.system.ammo.update({ "system.quantity.value": this.item.system.ammo.quantity.value - 1 });
    }
    else if (this.preData.ammoId && this.item.system.consumesAmmo.value && !this.context.edited && !this.context.reroll) {
      let ammo = this.actor.items.get(this.preData.ammoId);
      await ammo.update({ "system.quantity.value": this.actor.items.get(this.preData.ammoId).quantity.value - 1 });
    }


    if (this.item.system.loading && !this.context.edited && !this.context.reroll) {
      this.item.system.loaded.amt--;
      if (this.item.system.loaded.amt <= 0) {
        this.item.system.loaded.amt = 0;
        this.item.system.loaded.value = false;

        await this.item.update({ "system.loaded.amt": this.item.system.loaded.amt, "system.loaded.value": this.item.system.loaded.value });
      }
      else {
        await this.item.update({ "system.loaded.amt": this.item.system.loaded.amt });
      }
    }
  }

  computeDualWielder() 
  {
    this.result.canDualWield = !this.weapon.system.offhand.value && this.actor.has(game.i18n.localize("NAME.DualWielder"), "talent") && !this.actor.noOffhand && !this.context.edited;
  }

  computeMisfire() {
    let weapon = this.weapon;
    // Blackpowder/engineering/explosive weapons misfire on an even fumble
    if (this.result.fumble && 
      ["blackpowder", "engineering", "explosives"].includes(weapon.system.weaponGroup.value) && 
      this.result.roll % 2 == 0) 
    {
      this.result.misfire = game.i18n.localize("Misfire");
      this.result.misfireDamage = (0, eval)(parseInt(this.result.roll.toString().split('').pop()) + weapon.system.Damage);
    }
  }

  get weapon() {
    return this.item
  }

  get vehicle() {
    if (this.options.vehicle)
      return WFRP_Utility.getSpeaker(this.options.vehicle)
  }

  get item() {
    let actor = this.vehicle || this.actor;
    if (typeof this.preData.item == "string")
      return actor.items.get(this.preData.item)
    else
      return new CONFIG.Item.documentClass(this.preData.item, { parent: actor })
  }
}

class AttackDialog extends SkillDialog  
{
    get attackType() {
        return this.item.attackType;
    }


    computeFields()
    {
        super.computeFields();
        if (!["roll", "none"].includes(this.fields.hitLocation))
        {
            this.fields.modifier -= 20;
            this.tooltips.add("modifier", -20, game.i18n.localize('ROLL.CalledShot'));
        }
        if (game.settings.get("wfrp4e", "useGroupAdvantage"))
        {
          if (this.userEntry.charging)
          {
            this.fields.modifier += 10;
            this.tooltips.add("modifier", 10, game.i18n.localize('Charging'));
          }
        }
    }

    _computeDefending(attacker) 
    {
        super._computeDefending(attacker);
        let properties = this.item.properties;

        //if attacker is fast, and the defender is either 1. using a melee trait to defend, or 2. using a weapon without fast
        if (attacker.test.item.properties?.qualities.fast && this.item.attackType == "melee" && !properties?.qualities.fast) 
        {
            this.fields.modifier += -10;
            this.tooltips.add("modifier", -10, game.i18n.localize('CHAT.TestModifiers.FastWeapon'));
        }

        if (properties.flaws.unbalanced)
        {
            this.fields.slBonus -= 1;
            this.tooltips.add("slBonus", -1, game.i18n.localize("PROPERTY.Unbalanced"));
        }

        if(attacker.test.item.properties?.qualities?.wrap)
        {
            this.fields.slBonus -= 1;
            this.tooltips.add("slBonus", -1, game.i18n.localize('CHAT.TestModifiers.WrapDefend'));
        }

        //Size Differences
        let sizeDiff = game.wfrp4e.config.actorSizeNums[attacker.test.size] - this.actor.sizeNum;
        //Positive means attacker is larger, negative means defender is larger
        if (sizeDiff >= 1) {
            //Defending against a larger target with a weapon
            if (this.item.attackType == "melee") {
                let slBonus = (-2 * sizeDiff);
                this.fields.slBonus += slBonus;
                this.tooltips.add("slBonus", slBonus, game.i18n.localize('CHAT.TestModifiers.DefendingLarger'));
            }
        }
    }

    _computeTargets(target)
    {
        if (this.item.attackType == "ranged" && target.actor.statuses.has("engaged"))
        {
            this.fields.modifier -= 20;
            this.tooltips.add("modifier", -20, game.i18n.localize("EFFECT.ShootingAtEngagedTarget"));
            this.context.engagedModifier = -20;
        }


        let sizeDiff = this.actor.sizeNum - target.actor.sizeNum;
        let sizeModifier = 0;
        // Attacking a larger creature with melee
        if (sizeDiff < 0 && (this.item.attackType == "melee" || target.actor.sizeNum <= 3))
        {
          sizeModifier += 10;
          this.tooltips.add("modifier", 10, game.i18n.localize('CHAT.TestModifiers.AttackingLarger'));
        }
        // Attacking a larger creature with ranged
        else if (this.item.attackType === "ranged")
        {
          if (target.actor.details.size.value == "tiny")
            sizeModifier -= 30;
          if (target.actor.details.size.value == "ltl")
            sizeModifier -= 20;
          if (target.actor.details.size.value == "sml")
            sizeModifier -= 10;
          if (target.actor.details.size.value == "lrg")
            sizeModifier += 20;
          if (target.actor.details.size.value == "enor")
            sizeModifier += 40;
          if (target.actor.details.size.value == "mnst")
            sizeModifier += 60;

          if (sizeModifier) 
          {
            const text = (game.i18n.format('CHAT.TestModifiers.ShootingSizeModifier', { size: game.wfrp4e.config.actorSizes[target.actor.details.size.value] }));
            this.tooltips.add("modifier", sizeModifier, text);
          }
        }
        
        if (sizeModifier)
        {
          this.context.sizeModifier = sizeModifier;
          this.fields.modifier += sizeModifier;
        }


        // Attacking a smaller creature from a mount
        if (this.actor.isMounted && this.item.attackType == "melee") 
        {
            let mountSizeDiff = this.actor.mount.sizeNum - target.actor.sizeNum;
            if (target.actor.isMounted) 
            {                               // TODO this seems wrong
                mountSizeDiff = this.actor.mount.sizeNum - target.actor.sizeNum;
            }

            if (mountSizeDiff >= 1) 
            {
                this.fields.modifier += 20;
                this.tooltips.add("modifier", 20, game.i18n.localize('CHAT.TestModifiers.AttackerMountLarger'));
            }
        }
        // Attacking a creature on a larger mount
        else if (this.item.attackType == "melee" && target.actor.isMounted) 
        {
            let mountSizeDiff = target.actor.mount.sizeNum - this.actor.sizeNum;
            if (this.actor.isMounted) 
            {
                mountSizeDiff = target.sizeNum - this.actor.mount.sizeNum;
            }
            if (mountSizeDiff >= 1) 
            {
                if ((this.item.reachNum || 0) >= 5) 
                {
                    // TODO this tooltip won't show up because 0 value
                    this.tooltips.add("modifier", 0, `${game.i18n.localize('CHAT.TestModifiers.IgnoreDefenderMountLarger')}`);
                }
                else 
                {
                    this.tooltips.add("modifier", -10, game.i18n.localize('CHAT.TestModifiers.DefenderMountLarger'));
                    this.fields.modifier -= 10;
                }
            }
        }
    }

    async _onFieldChange(ev) 
    {
      if (ev.currentTarget.name == "charging")
      {
        if (!game.settings.get("wfrp4e", "useGroupAdvantage"))
        {
          let advantageField = ui.activeWindow.form.querySelector("[name='advantage']");
          
          if(ev.currentTarget.checked)
          {
            advantageField.value = Number(advantageField.value) + 1;
          }
          else 
          {
            advantageField.value = Math.max(0, Number(advantageField.value) - 1);
          }
          advantageField.dispatchEvent(new Event('change'));
        }
        else 
        {
          this.flags.charging = ev.currentTarget.checked;
        }
      }
        super._onFieldChange(ev);
    }
}

class WeaponDialog extends AttackDialog {


    chatTemplate = "systems/wfrp4e/templates/chat/roll/weapon-card.hbs"

    get item()
    {
      return this.data.weapon
    }

    get weapon() 
    {
      return this.item;
    }

    
    static PARTS = {
      fields : {
          template : "systems/wfrp4e/templates/dialog/type/base-dialog.hbs",
          fields: true
      },
      modifiers : {
          template : "modules/warhammer-lib/templates/partials/dialog-modifiers.hbs",
          modifiers: true
      },
      specific : {
          template : "systems/wfrp4e/templates/dialog/type/weapon-dialog.hbs",
      },
      footer : {
          template : "templates/generic/form-footer.hbs"
      }
  };


    static async setupData(weapon, actor, context={}, options={})
    {
      if (!weapon.id) 
      {
        weapon = new CONFIG.Item.documentClass(weapon, { parent: actor });
      }
      let skill = weapon.system.getSkillToUse(actor);
      let characteristic = skill?.system.characteristic.key || (weapon.attackType == "ranged" ? "bs" : "ws");
      
      context.title = context.title || game.i18n.localize("WeaponTest") + " - " + weapon.name;
      context.title += context.appendTitle || "";
      delete context.appendTitle;
      
      let dialogData;
      if (skill)
      {
        dialogData = await super.setupData(skill, actor, context, options);
      }
      else 
      {
        dialogData = await CharacteristicDialog.setupData(characteristic, actor, context, options);
      }
      let data = dialogData.data;
      data.weapon = weapon;
      data.hitloc = true;

      data.scripts = data.scripts.concat(data.weapon?.getScripts("dialog").filter(s => !s.options.defending) || []);


      if (weapon.attackType == "ranged") 
      {
        // If Ranged, default to Ballistic Skill, but check to see if the actor has the specific skill for the weapon
        // skillCharList.push({ char: true, key: "bs", name: game.i18n.localize("CHAR.BS") })
        if (weapon.consumesAmmo.value && weapon.ammunitionGroup.value != "none" && weapon.ammunitionGroup.value) 
        {
          // Check to see if they have ammo if appropriate
          if (context.ammo)
            data.ammo = context.ammo.find(a => a.id == weapon.currentAmmo.value);
          if (!data.ammo)
            data.ammo = actor.items.get(weapon.currentAmmo.value);

          if (!data.ammo || !weapon.currentAmmo.value || data.ammo.quantity.value == 0) {
            AudioHelper.play({ src: `${game.settings.get("wfrp4e", "soundPath")}no.wav` }, false);
            ui.notifications.error(game.i18n.localize("ErrorNoAmmo"));
            return
          }

        }
        else if (weapon.consumesAmmo.value && weapon.quantity.value == 0) 
        {
          // If this executes, it means it uses its own quantity for ammo (e.g. throwing), which it has none of
          AudioPlayer.play({ src: `${game.settings.get("wfrp4e", "soundPath")}no.wav` }, false);
          ui.notifications.error(game.i18n.localize("ErrorNoAmmo"));
          return;
        }
        else 
        {
          // If this executes, it means it uses its own quantity for ammo (e.g. throwing)
          data.ammo = weapon;
        }


        if (weapon.loading && !weapon.loaded.value) 
        {
          await actor.rollReloadTest(weapon);
          ui.notifications.notify(game.i18n.localize("ErrorNotLoaded"));
          return ({ abort: true })
        }
      }

      if (weapon.attackType == "melee") {
        data.chargingOption = true;
      }
      data.dualWieldingOption = !weapon.system.offhand.value && actor.has(game.i18n.localize("NAME.DualWielder"), "talent") && !actor.noOffhand;

      return dialogData;
    }

  _getSubmissionData()
  {
      let data = super._getSubmissionData();
      data.item = this.data.weapon.id || this.data.weapon.toObject();
      return data;
  }

  computeFields() 
  {
    super.computeFields();

    if (this.actor.flags.useless.rArm && this.item.system.usesHands.includes("rArm") || this.actor.flags.useless.lArm && this.item.system.usesHands.includes("lArm"))
    {
      this.abort = true;
      ui.notifications.error("ERROR.CannotUseArm", {localize : true});
    }

    if (this.item.offhand.value && !this.item.twohanded.value && !(this.item.weaponGroup.value == "parry" && this.item.properties.qualities.defensive)) 
    {
      this.computeAmbidextrous();
    }
  }

  computeAmbidextrous() {
    this.fields.modifier += -20;
    this.tooltips.add("modifier", -20, game.i18n.localize("SHEET.Offhand"));

    const ambiMod = Math.min(20, this.actor.flags.ambi * 10); // TODO could be handled by ambidextrous effect 
    this.fields.modifier += ambiMod;
    if (this.actor.flags.ambi) {
      this.tooltips.add("modifier", ambiMod, game.i18n.localize("NAME.Ambi"));
    }
  }

  _computeTargets(target) 
  {
    super._computeTargets(target);
    this._computeRangeModifiers(target);
  }

  _computeRangeModifiers(target) 
  {
    let weapon = this.weapon;

    let token = this.actor.getActiveTokens()[0];

    if (!game.settings.get("wfrp4e", "rangeAutoCalculation") || !token || !weapon.range?.bands)
      return 0

    let distance = canvas.grid.measurePath([{x: token.center.x, y: token.center.y }, { x: target.center.x, y: target.center.y }]).distance;
    let currentBand;

    for (let band in weapon.range.bands) 
    {
      if (distance >= weapon.range.bands[band].range[0] && distance <= weapon.range.bands[band].range[1]) 
      {
        currentBand = band;
        this.context.rangeBand = band;
        break;
      }
    }

    let engagedEffect = this.actor.statuses.has("engaged");
    if (engagedEffect) 
    {
      let engagedMod = Math.min(0, weapon.range.bands[currentBand]?.modifier || 0);
      if (engagedMod)
      {
        this.fields.modifier += engagedMod;
        this.tooltips.add("modifier", engagedMod, game.i18n.localize("EFFECT.ShooterEngaged"));
      }
    }
    else 
    {
      let rangeMod = weapon.range.bands[currentBand]?.modifier || 0;
      if (rangeMod) 
      {
        this.fields.modifier += rangeMod;
        this.tooltips.add("modifier", rangeMod, `${game.i18n.localize("Range")} - ${currentBand}`);
      }
    }
  }

  // Backwards compatibility for effects
  get type() 
  {
    return "weapon";
  }
}

class CastDialog extends SkillDialog {

    testClass = game.settings.get("wfrp4e", "useWoMOvercast") ? game.wfrp4e.rolls.WomCastTest : game.wfrp4e.rolls.CastTest
    chatTemplate = "systems/wfrp4e/templates/chat/roll/spell-card.hbs"


    get item()
    {
      return this.data.spell
    }

    get spell() 
    {
      return this.item;
    }

    
    static PARTS = {
        fields : {
            template : "systems/wfrp4e/templates/dialog/type/base-dialog.hbs",
            fields: true
        },
        modifiers : {
            template : "modules/warhammer-lib/templates/partials/dialog-modifiers.hbs",
            modifiers: true
        },
        specific : {
            template : "systems/wfrp4e/templates/dialog/type/spell-dialog.hbs",
        },
        footer : {
            template : "templates/generic/form-footer.hbs"
        }
    };



    static async setupData(spell, actor, context={}, options={})
    {
        let skill = spell.skillToUse;
        let characteristic = skill?.system?.characteristic?.key || "int";
        
        context.title = context.title || game.i18n.localize("CastingTest") + " - " + spell.name;
        context.title += context.appendTitle || "";
        delete context.appendTitle;

        context.hitloc = !!spell.system.damage.value;

        let dialogData;
        if (skill)
        {   
            dialogData = await super.setupData(skill, actor, context, options);
        }
        else
        {
            dialogData = await CharacteristicDialog.setupData(characteristic, actor, context, options);
        }

        let data = dialogData.data;
        data.spell = spell;

        data.scripts = data.scripts.concat(data.spell?.getScripts("dialog").filter(s => !s.options.defending));
    
        return dialogData;
    }

    _getSubmissionData()
    {
        let data = super._getSubmissionData();
        data.item = this.data.spell.id;
        return data;
    }
    
    _computeAdvantage()
    {
        // @HOUSE
        if (game.settings.get("wfrp4e", "homebrew").mooMagicAdvantage)
        {
            return 0;
        }
        else 
        {
            return super._computeAdvantage();
        }
    }
    
    _defaultFields() 
    {
        return foundry.utils.mergeObject({
            overchannelling : 0
        }, super._defaultFields());
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "cast";
    }
}

class ChannelTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return

    this.data.preData.malignantInfluence = data.malignantInfluence;
    this.data.preData.unofficialGrimoire = game.settings.get("wfrp4e", "homebrew").unofficialgrimoire;
    this.data.preData.ingredientMode = data.ingredientMode ?? "none";
    this.data.preData.skill = data.skill?.id;
    this.data.context.channelUntilSuccess = data.channelUntilSuccess;

    this.computeTargetNumber();
  }

  static fromData(...args)
  {
    return new this(...args);
  }

  computeTargetNumber() {
    let skill = this.actor.items.get(this.preData.skill);
    if (!skill)
      this.result.target = this.actor.system.characteristics[this.characteristicKey].value;
    else
      this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preChannellingTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preChannellingTest", { test: this, chatOptions: this.context.chatOptions }));

  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollChannellingTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollChannellingTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollChannelTest", this, this.context.chatOptions);
  }

  async computeResult() {
    await super.computeResult();
    let miscastCounter = 0;
    this.result.SL;
    this.result.tooltips.miscast = [];

    // Witchcraft automatically miscast
    if (this.item.lore.value == "witchcraft") {
      miscastCounter++;
      this.result.other.push(game.i18n.localize("CHAT.WitchcraftMiscast"));
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.AutoWitchcraftMiscast"));
    }

    // Test itself was failed
    if (this.failed) 
    {
      this.result.description = game.i18n.localize("ROLL.ChannelFailed");
      // Major Miscast on fumble
      if (this.result.roll % 11 == 0 ||
         (this.result.roll % 10 == 0 && !game.settings.get("wfrp4e", "useWoMChannelling")) || // If WoM channelling, 10s don't cause miscasts
          this.result.roll == 100)
      {

        this.result.color_red = true;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.FumbleMiscast"));
        //@HOUSE
        if (this.preData.unofficialGrimoire) 
        {
          game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
          miscastCounter += 1;
          if(this.result.roll == 100 || this.result.roll == 99) 
          {
            this.item.cn.value * (-1);
            miscastCounter += 1;
          }
        //@HOUSE
        } 
        else 
        {
          if (game.settings.get("wfrp4e", "useWoMChannelling")) // Fumble is only minor when using WoM Channelling
          {
            miscastCounter += 1;
          }
          else 
          {
            miscastCounter += 2;
          }

          //@HOUSE
          if (this.result.roll == 100 && game.settings.get("wfrp4e", "homebrew").mooCatastrophicMiscasts) {
            game.wfrp4e.utility.logHomebrew("mooCatastrophicMiscasts");
            miscastCounter++;
          }
          //@/HOUSE
        }
      }
    }
    else // Successs - add SL to spell for further use
    {
      this.result.description = game.i18n.localize("ROLL.ChannelSuccess");

      // Critical Channel - miscast and set SL gained to CN
      if (this.result.roll % 11 == 0) {
        this.result.color_green = true;
        this.result.criticalchannell = game.i18n.localize("ROLL.CritChannel");
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.CritChannelMiscast"));
        miscastCounter++;
        this.spell.flags.criticalchannell = true; // Locally apply the critical channell flag
      }
    }

    miscastCounter += this._checkInfluences() || 0;
    this._handleMiscasts(miscastCounter);
    this.result.tooltips.miscast = "<ul style='text-align: left'>" + this.result.tooltips.miscast.map(t => `<li>${t}</li>`).join("") + "</ul>";
  }

  computeTables()
  {
    super.computeTables();
    if (this.result.criticalchannell)
    {
      // Not really a table?
      this.result.tables.criticalchannell = {
        label : this.result.criticalchannell,
        class : "critical-roll",
      };
    }
    if (this.result.minormis)
    {
      this.result.tables.miscast = {
        label : this.result.minormis,
        class : "fumble-roll",
        key : "minormis"
      };
    }
    if (this.result.nullminormis)
    {
      this.result.tables.nullminormis = {
        label : this.result.nullminormis,
        class : "fumble-roll",
        key : "minormis",
        nulled : true
      };
    }
    if (this.result.majormis)
    {
      this.result.tables.miscast = {
        label : this.result.majormis,
        class : "fumble-roll",
        key : "majormis",
      };
    }
    if (this.result.nullmajormis)
    {
      this.result.tables.nullmajormis = {
        label : this.result.nullmajormis,
        class : "fumble-roll",
        key : "majormis",
        nulled : true
      };
    }
    if (this.result.catastrophicmis)
    {
      this.result.tables.miscast = {
        label : this.result.catastrophicmis,
        class : "fumble-roll",
        key : "catastrophicmis",
      };
    }
    if (this.result.nullcatastrophicmis)
    {
      this.result.tables.nullcatastrophicmis = {
        label : this.result.nullcatastrophicmis,
        class : "fumble-roll",
        key : "nullcatastrophicmis",
        nulled : true
      };
    }
    if (this.result.grimoiremiscast)
    {
      this.result.tables.grimoiremiscast = {
        label : this.result.grimoiremiscast,
        class : "fumble-roll",
        key : "grimoire-miscast",
      };
    }
  }


  _checkInfluences()
  {
    if (!this.preData.malignantInfluence) 
    {
      return 0
    }

    // If malignant influence AND roll has an 8 in the ones digit, miscast
    if (
      (Number(this.result.roll.toString().split('').pop()) == 8 && !game.settings.get("wfrp4e", "useWoMInfluences")) || 
      (this.failed && game.settings.get("wfrp4e", "useWoMInfluences"))) 
    {
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.MalignantInfluence"));
      return 1;
    }
  }

  async postTest() {
    //@/HOUSE

    
      if (this.preData.unofficialGrimoire) {
        game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
        if (this.preData.ingredientMode != 'none' && this.hasIngredient && this.item.ingredient?.quantity.value > 0 && !this.context.edited && !this.context.reroll) {
          await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
          this.result.ingredientConsumed = true;
          ChatMessage.create({ speaker: this.data.context.speaker, content: game.i18n.localize("ConsumedIngredient") });
        }
        //@/HOUSE
      } 
      else if (game.settings.get("wfrp4e", "homebrew").channellingIngredients)
      {
        // Find ingredient being used, if any
        if (this.hasIngredient && this.item.ingredient?.quantity.value > 0 && !this.context.edited && !this.context.reroll)
          await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
      }

    let SL = Number(this.result.SL);

    if (this.succeeded)
    {
      // Optional Rule: If SL in extended test is -/+0, counts as -/+1
      if (Number(SL) == 0 && game.settings.get("wfrp4e", "extendedTests"))
        SL = 1;

      }
      else // If outcome == failure 
      {
        // Optional Rule: If SL in extended test is -/+0, counts as -/+1
        if (Number(SL) == 0 && game.settings.get("wfrp4e", "extendedTests"))
        SL = -1;
      }

    //@HOUSE
    if(this.preData.unofficialGrimoire && this.preData.ingredientMode == 'power' && this.result.ingredientConsumed && this.succeeded) {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      SL = Number(SL) * 2;
    }
    //@HOUSE

    // Optional Rule: If SL in a channel attempt SL is negative, set SL to 0
    // This is tested after the previous rule so:
    // SL == 0 triggers previous rule and sets SL to -1, SL == -1 triggers this rule and sets SL 0
    // SL < 0 doesn't trigger previous rule, SL < 0 triggers this rule and sets SL 0 
    // In both cases SL resolves to 0 as expected by this rule.
    // "SL < 0" is used over "SL <= 0" since if previous rule isn't True SL 0 resolves no channel progress
    if (Number(SL) < 0 && game.settings.get("wfrp4e", "homebrew").channelingNegativeSLTests)
      SL = 0;

    // // If channelling test was edited, make sure to adjust the SL accordingly
    // if (this.context.previousResult?.previousChannellingSL > 0)
    // {
    //   channellDelta = SL - parseInt(this.context.previousResult.SL)
    // }

    

    //@HOUSE
    if(this.preData.unofficialGrimoire && (this.item.cn.SL + SL) > this.item.cn.value) {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire-overchannelling");
      this.result.overchannelling = this.item.cn.SL + SL - this.item.cn.value;
    }
    //@HOUSE

    this.result.channelledSL = SL;

    if (game.settings.get("wfrp4e", "useWoMChannelling"))
    {
      if (this.result.criticalchannell)
      {
        this.result.channelledSL += this.actor.system.characteristics.wp.bonus;
      }
    }
    else 
    {

      if (this.result.criticalchannell)
      {
        this.result.channelledSL = this.item.cn.value;
      }
    }

    let SLdelta = this.result.channelledSL - (this.context.previousResult?.channelledSL || 0) + (this.context.previousResult?.pastSL || 0);

    if(SL > 0) {
      this.result.SL = "+" + SL;
    } else {
      this.result.SL = SL.toString();
    }

    let newSL = this.updateChannelledItems(SLdelta);   
    this.result.channelledDisplay = newSL.toString();
    if (!game.settings.get("wfrp4e", "useWoMChannelling"))
    {
      this.result.channelledDisplay += " / " + this.item.cn.value.toString();
    }

    if (this.result.miscastModifier) {
      if (this.result.minormis)
        this.result.minormis += ` (${this.result.miscastModifier})`;
      if (this.result.majormis)
        this.result.majormis += ` (${this.result.miscastModifier})`;
      if (this.result.catastrophicmis)
        this.result.catastrophicmis += ` (${this.result.miscastModifier})`;
    }
  }

  get hasIngredient() {

    // If channelling with ingredients isn't allowed, always return false 
    // HOWEVER: Witchcraft specifies: "channeling or casting spells from this Lore automatically require a roll on the Minor Miscast table unless cast with an ingredient"
    // This doesn't make any sense. So what I'm doing is if it's a witchcraft spell, and has a valid ingredient assigned, still count it, as it will have to be assumed it's used in the eventual cast?
    if (!game.settings.get("wfrp4e", "homebrew").channellingIngredients && this.item.lore.value != "witchcraft")
    {
      return false 
    }
    else 
    {
      return this.item.ingredient && this.item.ingredient.quantity.value > 0
    }
  }


  // Channelling should not show any effects to apply 
  get damageEffects() 
  {
      return [];
  }

  get targetEffects() 
  {
      return [];
  }

  get areaEffects() 
  {
      return [];
  }

  get spell() {
    return this.item
  }

  updateChannelledItems(slDelta) 
  {
    let item = this.item.toObject();
    item.system.cn.SL += slDelta;
    let computedCN = item.system.memorized.value ? item.system.cn.value : item.system.cn.value * 2;

    // THIS WHOLE PROCESS CAN GO TO HELL
    // Cap SL to CN if WoM channelling is disabled
    if (!game.settings.get("wfrp4e", "useWoMChannelling")) {
      this.result.pastSL = item.system.cn.SL - computedCN; // Needed to accurately account for edits and change in SL
      item.system.cn.SL = Math.min(computedCN, item.system.cn.SL);
    }
    if (item.system.cn.SL < 0) {
      this.result.pastSL = item.system.cn.SL;
    }
    item.system.cn.SL = Math.max(0, item.system.cn.SL);

    this.actor.updateEmbeddedDocuments("Item", [item]);
    return item.system.cn.SL
  }

}

class ChannellingDialog extends SkillDialog {

    chatTemplate = "systems/wfrp4e/templates/chat/roll/channel-card.hbs"
    testClass = ChannelTest



    get item()
    {
      return this.data.spell
    }

    get spell() 
    {
      return this.item;
    }

    static PARTS = {
        fields : {
            template : "systems/wfrp4e/templates/dialog/type/base-dialog.hbs",
            fields: true
        },
        modifiers : {
            template : "modules/warhammer-lib/templates/partials/dialog-modifiers.hbs",
            modifiers: true
        },
        specific : {
            template : "systems/wfrp4e/templates/dialog/type/channel-dialog.hbs",
        },
        footer : {
            template : "templates/generic/form-footer.hbs"
        }
    };

    static async setupData(spell, actor, context={}, options={})
    {

        let skill;
        if (spell.system.wind && spell.system.wind.value) 
        {
            skill = actor.itemTags["skill"].find(i => i.name.toLowerCase() == spell.system.wind.value.toLowerCase());
        }
        else if (spell.system.lore.value == "witchcraft")
        {
            skill = actor.itemTags["skill"].find(x => x.name.toLowerCase().includes(game.i18n.localize("NAME.Channelling").toLowerCase()));
        }
        else 
        {
            skill = actor.itemTags["skill"].find(x => x.name.includes(game.wfrp4e.config.magicWind[spell.system.lore.value]));
        }

        if (!skill)
        {
            skill = {
                name : `${game.i18n.localize("NAME.Channelling")} (${game.wfrp4e.config.magicWind[spell.system.lore.value]})`,
                id : "unknown",
                system : {
                    characteristic : {
                        value : "wp"
                    }
                }
            };
        }
                
        context.title = context.title || game.i18n.localize("ChannellingTest") + " - " + spell.name;
        context.title += context.appendTitle || "";
        delete context.appendTitle;

        let dialogData = await super.setupData(skill, actor, context, options);
        let data = dialogData.data;
        data.spell = spell;
        data.scripts = data.scripts.concat(spell.getScripts("dialog").filter(s => !s.options.defending));

        return dialogData;
    }

    _getSubmissionData()
    {
        let data = super._getSubmissionData();
        data.item = this.data.spell.id;
        return data;
    }

    _computeAdvantage()
    {
        // @HOUSE
        if (game.settings.get("wfrp4e", "homebrew").mooMagicAdvantage)
        {
            return super._computeAdvantage();
        }
        else 
        {
            return 0;
        }
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "channelling";
    }
}

class TraitTest extends AttackTest {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.preData.charging = data.charging || false;
    this.preData.options.characteristicToUse = data.characteristicToUse;
    this.computeTargetNumber();
  }

  static fromData(...args)
  {
    return new this(...args);
  }

  computeTargetNumber() {

    try {
      // Use skill total if characteristics match, otherwise add the total up manually
      if (this.preData.options.characteristicToUse && this.preData.options.characteristicToUse != this.item.rollable.rollCharacteristic)
        this.result.target = this.actor.characteristics[this.preData.options.characteristicToUse].value;
      else
        this.result.target = this.actor.characteristics[this.item.rollable.rollCharacteristic].value;

      let skill = this.item.system.getSkillToUse(this.actor);

      if (skill)
        this.result.target = skill.total.value;
    }
    catch
    {
      this.result.target == skill.total.value;
    }

    super.computeTargetNumber();
  }
  
  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollTraitTest", this, this.context.chatOptions);
  }

  async calculateDamage() {
    try {
      // If the specification of a trait is a number, it's probably damage. (Animosity (Elves) - not a number specification: no damage)
      if (this.item.rollable.damage) {
        let damageBreakdown = this.result.breakdown.damage;
        this.result.additionalDamage = this.preData.additionalDamage || 0;

        await super.calculateDamage(this.item.rollable.SL ? Number(this.result.SL) : 0);
        damageBreakdown.item = `+${this.item.Damage} (${[this.item.system.specification.value, game.wfrp4e.config.characteristicsAbbrev[this.item.system.rollable.bonusCharacteristic]].filter(i => i).join(" + ")})`;

        if (this.item.rollable.dice && !this.result.additionalDamage) {
          let roll = await new Roll(this.item.rollable.dice).roll({allowInteractive : false});
          this.result.diceDamage = { value: roll.total, formula: roll.formula };
          this.preData.diceDamage = this.result.diceDamage;
          damageBreakdown.other.push({label : game.i18n.localize("BREAKDOWN.Dice"), value : roll.total});
          this.result.additionalDamage += roll.total;
          this.preData.additionalDamage  = this.result.additionalDamage;
        }

        //@HOUSE
        if (game.settings.get("wfrp4e", "homebrew").mooRangedDamage)
        {
          game.wfrp4e.utility.logHomebrew("mooRangedDamage");
          if (this.item.isRanged)
          {
            let damageMod = (Math.floor(this.targetModifiers / 10) || 0);
            this.result.damage -= damageMod;
            damageBreakdown.other.push({label : game.i18n.localize("BREAKDOWN.Moo"), value : - damageMod});
            if (this.result.damage < 0)
              this.result.damage = 0;
          }
        }
        //@/HOUSE

      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("CHAT.DamageError") + " " + error);
    } // If something went wrong calculating damage, do nothing and still render the card

  }

  get trait() {
    return this.item
  }

}

class TraitDialog extends AttackDialog {

    testClass = TraitTest
    chatTemplate = "systems/wfrp4e/templates/chat/roll/weapon-card.hbs"

    get item()
    {
      return this.data.trait
    }

    get trait() 
    {
      return this.item;
    }

    static PARTS = {
      fields : {
          template : "systems/wfrp4e/templates/dialog/type/base-dialog.hbs",
          fields: true
      },
      modifiers : {
          template : "modules/warhammer-lib/templates/partials/dialog-modifiers.hbs",
          modifiers: true
      },
      specific : {
          template : "systems/wfrp4e/templates/dialog/type/trait-dialog.hbs",
      },
      footer : {
          template : "templates/generic/form-footer.hbs"
      }
  };

    static async setupData(trait, actor, context={}, options={})
    {
      if (!trait.system.rollable.value)
      {
        return ui.notifications.notify("Non-rollable trait");
      }

      else if (!(trait instanceof Item))
      {
        trait = new Item.implementation(trait);
      }

      // TODO account for skill 
      context.title = context.title || game.wfrp4e.config.characteristics[trait.system.rollable.rollCharacteristic] + ` ${game.i18n.localize("Test")} - ` + trait.name;
      context.title += context.appendTitle || "";
      delete context.appendTitle;
      
      let dialogData;

      let skill;
      if (trait.system.rollable.skill)
      {
        skill = actor.itemTags["skill"].find(sk => sk.name == trait.system.rollable.skill);
        if (!skill)
          {
            skill = {
              name : trait.system.rollable.skill,
              id : "unknown",
              system : {
                characteristic : {
                  value : ""
                }
              }
            };
          }

          dialogData = await super.setupData(skill, actor, context, options);

      }
      else if (trait.system.rollable.rollCharacteristic)
      {
        dialogData = await CharacteristicDialog.setupData(trait.system.rollable.rollCharacteristic, actor, context, options);
      }

      let data = dialogData.data;
      data.trait = trait;
      data.skill = skill;
      data.characteristic = trait.system.rollable.rollCharacteristic;
      dialogData.fields.characteristic = trait.system.rollable.rollCharacteristic;

      if (trait.attackType == "melee")
      {
        data.chargingOption = true;
      }

      data.scripts = data.scripts.concat(data.trait?.getScripts("dialog").filter(s => !s.options.defending), skill?.getScripts?.("dialog").filter(s => !s.options.defending) || []);


      return dialogData;
    }


    _getSubmissionData()
    {
        let data = super._getSubmissionData();
        data.item = this.data.trait.id || this.data.trait.toObject();
        data.characteristicToUse = this.data.characteristic;
        return data;
    }
  
    

    _defaultDifficulty()
    {
        return this.item.system.rollable.defaultDifficulty || super._defaultDifficulty()
    }

    // Backwards compatibility for effects
    get type() 
    {
      return "trait";
    }
}

class PrayerTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.computeTargetNumber();

  }

  static fromData(...args)
  {
    return new this(...args);
  }

  computeTargetNumber() {
    let skill = this.item.system.getSkillToUse(this.actor);
    if (!skill)
      this.result.target = this.actor.characteristics.fel.value;
    else
      this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollPrayerTest", this, this.context.chatOptions);
  }

  async computeResult() {
    await super.computeResult();
    let SL = this.result.SL;
    let currentSin = this.actor.status.sin.value;
    this.result.overcast = foundry.utils.duplicate(this.item.overcast);

    // Test itself failed
    if (this.failed) {
      this.result.description = game.i18n.localize("ROLL.PrayRefused");

      // Wrath of the gads activates if ones digit is equal or less than current sin
      let unitResult = Number(this.result.roll.toString().split('').pop());
      if (unitResult == 0)
        unitResult = 10;
      if (this.result.roll % 11 == 0 || unitResult <= currentSin) {
        if (this.result.roll % 11 == 0)
          this.result.color_red = true;

        this.result.wrath = game.i18n.localize("ROLL.Wrath");
        this.result.wrathModifier = Number(currentSin) * 10;
      }
    }
    // Test succeeded
    else {
      this.result.description = game.i18n.localize("ROLL.PrayGranted");

      // Wrath of the gads activates if ones digit is equal or less than current sin      
      let unitResult = Number(this.result.roll.toString().split('').pop());
      if (unitResult == 0)
        unitResult = 10;
      if (unitResult <= currentSin) {
        this.result.wrath = game.i18n.localize("ROLL.Wrath");
        this.result.wrathModifier = Number(currentSin) * 10;
      }
    }

    this.result.overcasts = Math.max(0, Math.floor(SL / 2)); // For allocatable buttons
    this.result.overcast.total = this.result.overcasts;
    this.result.overcast.available = this.result.overcast.total;

    await this.calculateDamage();
  }


  async calculateDamage() {
    let damageBreakdown = this.result.breakdown.damage;
    this.result.additionalDamage = this.preData.additionalDamage || 0;
    // Calculate damage if prayer specifies
    try {
      if (this.item.DamageString && this.succeeded)
      {
        this.result.damage = Number(this.item.Damage);
        damageBreakdown.base = `${this.item.Damage} (Prayer)`;
      }
      if (this.item.damage.addSL)
      {
        this.result.damage = Number(this.result.SL) + (this.result.damage || 0);
        damageBreakdown.other.push({label : game.i18n.localize(`SL`), value : this.result.SL});
      }

      if (this.item.damage.dice && !this.result.additionalDamage) {
        let roll = await new Roll(this.item.damage.dice).roll({allowInteractive : false});
        this.result.diceDamage = { value: roll.total, formula: roll.formula };
        this.preData.diceDamage = this.result.diceDamage;
        this.result.additionalDamage += roll.total;
        damageBreakdown.other.push({label : game.i18n.localize("BREAKDOWN.Dice"), value : roll.total});
        this.preData.additionalDamage = this.result.additionalDamage;
      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("ErrorDamageCalc") + ": " + error);
    } // If something went wrong calculating damage, do nothing and still render the card
  }

  computeTables()
  {
    super.computeTables();
    if (this.result.wrath)
    {
      this.result.tables.wrath = {
        label : this.result.wrath,
        class : "fumble-roll",
        modifier : this.result.wrathModifier,
        key : "wrath"
      };
    }
  }

  async postTest() {
    if (this.result.wrath) {
      let sin = this.actor.status.sin.value - 1;
      if (sin < 0) sin = 0;
      this.actor.update({ "system.status.sin.value": sin });
      ui.notifications.notify(game.i18n.localize("SinReduced"));
    }
  }

  
  // @@@@@@@ Overcast functions placed in root class because it is used by both spells and prayers @@@@@@@
  async _overcast(choice) {
    if (this.result.overcast.usage[choice].AoE && !this.item.system.target.extendableAoE) {
      ui.notifications.error(game.i18n.localize("ERROR.PrayerAoEOvercast"));
    } else {
      await super._overcast(choice);
    }
  }

  get prayer() {
    return this.item
  }
}

class PrayerDialog extends SkillDialog {

    testClass = PrayerTest
    chatTemplate = "systems/wfrp4e/templates/chat/roll/prayer-card.hbs"


    get item()
    {
      return this.data.prayer
    }

    get prayer() 
    {
      return this.item;
    }

    static async setupData(prayer, actor, context={}, options={})
    {
        let skill = actor.itemTags["skill"].find(i => i.name.toLowerCase() == game.i18n.localize("NAME.Pray").toLowerCase());

        if (!skill)
        {
            skill = {
                name : game.i18n.localize("NAME.Pray"),
                id : "unknown",
                system : {
                    characteristic : {
                        value : "fel"
                    }
                }
            };
        }
        
        context.title = context.title || game.i18n.localize("PrayerTest") + " - " + prayer.name;
        context.title += context.appendTitle || "";
        delete context.appendTitle;

        context.hitloc = !!(prayer.damage.value || prayer.damage.dice || prayer.damage.addSL);
        
        let dialogData = await super.setupData(skill, actor, context, options);
        let data = dialogData.data;

        data.prayer = prayer;

        data.scripts = data.scripts.concat(prayer.getScripts("dialog").filter(s => !s.options.defending));
        return dialogData;
    }

    _getSubmissionData()
    {
        let data = super._getSubmissionData();
        data.item = this.data.prayer.id;
        return data;
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "prayer";
    }
}

class ActiveEffectWFRP4e extends WarhammerActiveEffect
{

    constructor(data, context)
    {
        _migrateEffect(data);
        super(data, context);
    }
    
    async resistEffect()
    {
        let result = await super.resistEffect();
        if (result === false || result === true)
        {
            return result;
        }

        let test;
        let avoidTest = this.system.transferData.avoidTest;
        if (avoidTest.value == "custom")
        {
            let options = {
                appendTitle : " - " + this.name,
                skipTargets: true
            };
            if (avoidTest.skill)
            {
                options.fields = {difficulty : avoidTest.difficulty};
                options.characteristic = avoidTest.characteristic;
                test = await this.actor.setupSkill(avoidTest.skill, options);
            }
            else if (avoidTest.characteristic)
            {
                options.fields = {difficulty : avoidTest.difficulty};
                test = await this.actor.setupCharacteristic(avoidTest.characteristic, options);
            }

            await test.roll();

            if (!avoidTest.reversed)
            {
                // If the avoid test is marked as opposed, it has to win, not just succeed
                if (avoidTest.opposed && this.sourceTest)
                {
                    return parseInt(test.result.SL) > parseInt(this.sourceTest.result?.SL);
                }
                else 
                {
                    return test.succeeded;
                }
            }
            else  // Reversed - Failure removes the effect
            {
                // If the avoid test is marked as opposed, it has to win, not just succeed
                if (avoidTest.opposed && this.sourceTest)
                {
                    return parseInt(test.result.SL) < parseInt(this.sourceTest.result?.SL);
                }
                else 
                {
                    return !test.succeeded;
                }
            }
        }
    }


    // To be applied, some data needs to be changed
    // Convert type to document, as applying should always affect the document being applied
    // Set the origin as the actor's uuid
    // convert name to status so it shows up on the token
    convertToApplied(test)
    {
        let effect = super.convertToApplied(test);

        // An applied targeted aura should stay as an aura type, but it is no longer targeted
        if (effect.system.transferData.type == "aura" && test)
        {
            effect.system.transferData.area.radius = effect.system.transferData.area.radius || test.result.overcast.usage.target.current?.toString();
        }

        if (this.item?.type == "spell")
        {
            // Spells define their diameter
            effect.system.transferData.area.radius += " / 2";
        }
    
        let item = test?.item;

        if (test)
        {
            effect.system.sourceData.test = test;
        }

        let duration;
        if (test && test.result.overcast && test.result.overcast.usage.duration) {
            duration = test.result.overcast.usage.duration.current;
        } else if(item?.Duration) {
            duration = parseInt(item.Duration);
        }
    
        if (duration) {
            if (item.duration.value.toLowerCase().includes(game.i18n.localize("Seconds")))
            effect.duration.seconds = duration;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Minutes")))
            effect.duration.seconds = duration * 60;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Hours")))
            effect.duration.seconds = duration * 60 * 60;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Days")))
            effect.duration.seconds = duration * 60 * 60 * 24;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Round")))
            effect.duration.rounds = duration;
        }

        return effect;
    }

    
    get sourceTest() 
    {
        let testData = this.system.sourceData.test.data;
        let message = game.messages.get(testData.context?.messageId);
        if (testData)
        {
            return message ? message.system.test : TestWFRP.recreate(testData);    
        }
    }

    get show() {
        if (game.user.isGM || !this.getFlag("wfrp4e", "hide"))
          return true
        else 
          return false
      }

    get displayLabel() {
        if (this.count > 1)
            return this.name + ` (${this.count})`
        else return this.name
    }

    get conditionId(){
        return this.key
    }

    get isNumberedCondition() {
        return this.system.condition.numbered
    }

    get conditionValue() 
    {
        return this.system.condition.value ?? this.getFlag("wfrp4e", "value");
    }

    get testIndependent()
    {
        return this.system.transferData.testIndependent
    }

    get isTargetApplied()
    {
        return this.system.transferData.type == "target" || (this.system.transferData.type == "aura" && this.system.transferData.area.aura.transferred)
    }

    get isAreaApplied()
    {
        return this.system.transferData.type == "area"
    }

    get isCrewApplied()
    {
        return this.system.transferData.type == "crew";
    }

    get radius()
    {
        let sizeMod = 0;
        if (this.actor)
        {
            let size = game.wfrp4e.config.tokenSizes[this.actor.system.details.size.value];
            if (size > 1)
            {
                sizeMod = size;
            }
        }
        return super.radius + sizeMod
    }

    static _triggerMigrations(trigger)
    {
        let migrations = {
            "invoke" : "manual",
            "oneTime" : "immediate",
            "addItems" : "immediate",
            "dialogChoice" : "dialogChoice",
            "prefillDialog" : "dialog",
            "targetPrefillDialog" : "dialog"
        };
        return migrations[trigger] || trigger;
    }
}


function _migrateEffect(data, context)
{
    let flags = foundry.utils.getProperty(data, "flags.wfrp4e");

    if (!flags || flags._legacyData || flags.scriptData || flags.applicationData)
    {
        return;
    }


    flags.applicationData = {};
    flags.scriptData = [];
    let newScript = {
        label : data.name,
        trigger : _triggerMigrations(flags.effectTrigger),
    };

    if (flags.effectTrigger == "targetPrefillDialog")
    {
        foundry.utils.setProperty(newScript, "options.dialog.targeter", true);
    }

    if (flags.script)
    {
        // Previously scripts could reference the source test with a janky {{path}} statement
        // Now, all scripts have a `this.effect` reference, which has a `sourceTest` getter
        let script = flags.script;
        let regex = /{{(.+?)}}/g;
        let matches = [...script.matchAll(regex)];
        matches.forEach(match => {
            script = script.replace(match[0], `this.effect.sourceTest.data.result.${match[1]}`);
        });
        newScript.script = script;

        
        if (flags.effectTrigger == "prefillDialog")
        {
            // Old prefill triggers always ran for every dialog with conditional logic inside to add modifiers or not
            // To reflect that, migrated prefill tiggers need to always be active in the dialog
            foundry.utils.setProperty(newScript, "options.dialog.activateScript", "return true");
        }

    }
    else if (flags.effectTrigger == "dialogChoice")
    {
        newScript.label = flags.effectData.description || newScript.label;
        newScript.script = `
        args.prefillModifiers.modifier += ${flags.effectData.modifier || 0};
        args.prefillModifiers.slBonus += ${flags.effectData.SLBonus || 0};
        args.prefillModifiers.successBonus += ${flags.effectData.successBonus || 0};
        `;
        // Missing difficultyBonus?
    }
    if (newScript.trigger)
    {
        flags.scriptData.push(newScript);
    }

    switch(flags.effectApplication)
    {
        case "actor":
            flags.applicationData.type = "document";                
            flags.applicationData.documentType = "Actor";                
            flags.applicationData.equipTransfer = false;
            break;
        case "item":
            flags.applicationData.type = "document";                
            flags.applicationData.documentType = "Item";                
            break;
        case "equipped":
            flags.applicationData.type = "document";                
            flags.applicationData.documentType = "Actor";  
            flags.applicationData.equipTransfer = true;
            break;
        case "apply" : 
            flags.applicationData.type = "target";                
            break;
        case "damage" : 
            flags.applicationData.type = "document"; // Not sure about this
            flags.applicationData.documentType = "Item";
            break;
    }

    if (flags.itemChoice)
    {
        flags.applicationData.filter = flags.itemChoice;
    }
    if (flags.promptChoice)
    {
        flags.applicationData.prompt = true;
    }

    
    flags._legacyData = {
        effectApplication : flags.effectApplication,
        effectTrigger : flags.effectTrigger,
        preventDuplicateEffects : flags.preventDuplicateEffects,
        script : flags.script
    };
    delete flags.effectApplication;
    delete flags.effectTrigger;
    delete flags.preventDuplicateEffects;
    delete flags.script;
}

function _triggerMigrations(trigger)
{
    let migrations = {
        "invoke" : "manual",
        "oneTime" : "immediate",
        "addItems" : "immediate",
        "dialogChoice" : "dialog",
        "prefillDialog" : "dialog",
        "targetPrefillDialog" : "dialog"
    };
    return migrations[trigger] || trigger;
}

class CastTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return

    this.preData.itemData = data.itemData || this.item.toObject(); // Store item data to avoid rerolls being affected by changed channeled SL
    this.preData.malignantInfluence = data.malignantInfluence;
    this.preData.unofficialGrimoire = game.settings.get("wfrp4e", "homebrew").unofficialgrimoire;
    this.preData.overchannelling = data.overchannelling;
    this.preData.ingredientMode = data.ingredientMode ?? "none";

    this.data.context.templates = data.templates || [];

    this.computeTargetNumber();
  }

  static fromData(...args)
  {
    return new this(...args);
  }

  computeTargetNumber() {

      let skill = this.item.system.getSkillToUse(this.actor);
      if (!skill)
        this.result.target = this.actor.characteristics.int.value;
      else
        this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollCastTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollCastTest", { test: this, chatOptions: this.context.chatOptions }));

    //@HOUSE
    if (this.preData.unofficialGrimoire && this.preData.ingredientMode == 'power' && this.hasIngredient) { 
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      this.preData.canReverse = true;
    }
    //@HOUSE
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollCastTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollCastTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollCastTest", this, this.context.chatOptions);
  }

  async computeResult() {
    await super.computeResult();

    let miscastCounter = 0;
    let CNtoUse = this.item.cn.value;
    this.result.overcast = foundry.utils.duplicate(this.item.overcast);
    this.result.tooltips.miscast = [];
    
    //@HOUSE
    if (this.preData.unofficialGrimoire && this.result.other.indexOf(game.i18n.localize("ROLL.Reverse")) != -1) {
      if (this.data.result.roll.toString()[this.data.result.roll.toString().length -1] == '8') {
        game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
        miscastCounter++;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.PowerIngredientMiscast"));
      }
    }
    //@HOUSE

    // Partial channelling - reduce CN by SL so far
    if (game.settings.get("wfrp4e", "homebrew").partialChannelling || game.settings.get("wfrp4e", "useWoMChannelling")) {
      CNtoUse -= this.preData.itemData.system.cn.SL;
      if (CNtoUse < 0)
      {
        CNtoUse = 0;
      }
    }
    // Normal Channelling - if SL has reached CN, CN is considered 0
    else if (this.preData.itemData.system.cn.SL >= this.item.cn.value) {
      CNtoUse = 0;
    }



    // Witchcraft automatically miscast
    if (this.item.lore.value == "witchcraft") {
      miscastCounter++;
      this.result.other.push(game.i18n.localize("CHAT.WitchcraftMiscast"));
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.AutoWitchcraftMiscast"));
    }

    // slOver is the amount of SL over the CN achieved
    let slOver = (Number(this.result.SL) - CNtoUse);

    // Test itself was failed
    if (this.failed) 
    {
      this.result.castOutcome = "failure";
      this.result.description = game.i18n.localize("ROLL.CastingFailed");
      if (this.preData.itemData.system.cn.SL) {
        miscastCounter++;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.ChannellingMiscast"));
      }
      // Miscast on fumble
      if (this.result.roll % 11 == 0 || this.result.roll == 100) {
        this.result.color_red = true;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.FumbleMiscast"));
        if (!this.item.system.memorized.value && this.item.system.lore.value != "petty" && game.wfrp4e.tables.findTable("grimoire-miscast"))
        {
          this.result.grimoiremiscast = game.i18n.localize("CHAT.GrimoireMiscast");
        }
        miscastCounter++;
        //@HOUSE
        if (this.result.roll == 100 && game.settings.get("wfrp4e", "homebrew").mooCatastrophicMiscasts) {
          game.wfrp4e.utility.logHomebrew("mooCatastrophicMiscasts");
          miscastCounter++;
        }
        //@/HOUSE
      }
      //@/HOUSE
      if (this.preData.unofficialGrimoire && this.preData.overchannelling > 0) { 
        game.wfrp4e.utility.logHomebrew("overchannelling");
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.OverchannellingMiscast"));
        miscastCounter++;
      }
      //@/HOUSE
    }
    else if (slOver < 0) // Successful test, but unable to cast due to not enough SL
    {
      this.result.castOutcome = "failure";
      this.result.description = game.i18n.localize("ROLL.CastingFailed");
      //@/HOUSE
      if (this.preData.unofficialGrimoire && this.preData.overchannelling > 0) { 
        game.wfrp4e.utility.logHomebrew("overchannelling");
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.OverchannellingMiscast"));
        miscastCounter++;
      }
      //@/HOUSE
      // Critical Casting - succeeds only if the user chooses Total Power option (which is assumed)
      if (this.result.roll % 11 == 0) {
        this.result.color_green = true;
        this.result.castOutcome = "success";
        this.result.description = game.i18n.localize("ROLL.CastingSuccess");
        this.result.critical = game.i18n.localize("ROLL.TotalPower");
        this.result.totalPower = true;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.TotalPowerMiscast"));
        miscastCounter++;
      }
    }

    else // Successful test, casted - determine overcast
    {
      this.result.castOutcome = "success";
      this.result.description = game.i18n.localize("ROLL.CastingSuccess");
      //@/HOUSE
      if (this.preData.unofficialGrimoire && this.preData.overchannelling > 0) {
        game.wfrp4e.utility.logHomebrew("overchannelling");
        slOver += this.preData.overchannelling;
        this.result.SL = "+" + slOver;
      }
      //@/HOUSE

      if (this.result.roll % 11 == 0) {
        this.result.critical = game.i18n.localize("ROLL.CritCast");
        this.result.color_green = true;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.CritCastMiscast"));
        if (this.preData.totalPower)
        {
          this.result.critical = game.i18n.localize("ROLL.TotalPower");
          this.result.totalPower = true;
        }
        miscastCounter++;
      }

      //@HOUSE
      if (game.settings.get("wfrp4e", "homebrew").mooCriticalChannelling) {
        game.wfrp4e.utility.logHomebrew("mooCriticalChannelling");
        if (this.spell.flags.criticalchannell && CNtoUse == 0) {
          this.result.SL = "+" + Number(this.result.SL) + this.item._source.system.cn.value;
          this.result.other.push(game.i18n.localize("MOO.CriticalChanelling"));
        }
      }
      //@/HOUSE
    }
    //@HOUSE
    if (this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.quickcasting && miscastCounter > 0) { 
      game.wfrp4e.utility.logHomebrew("quickcasting");
      this.result.other.push(game.i18n.localize("CHAT.Quickcasting"));
      miscastCounter++;
    }
    //@/HOUSE
    
    miscastCounter += this._checkInfluences() || 0;
    this._calculateOverCast(slOver);
    this._handleMiscasts(miscastCounter);
    await this.calculateDamage();
    this.result.slOver = slOver;

    // TODO handle all tooltips (when they are added) in one place
    // TODO Fix weird formatting in tooltips (indenting)
    this.result.tooltips.miscast = "<ul style='text-align: left'>" + this.result.tooltips.miscast.map(t => `<li>${t}</li>`).join("") + "</ul>";

    return this.result;
  }

  _checkInfluences()
  {
    if (!this.preData.malignantInfluence) 
    {
      return 0
    }

    // If malignant influence AND roll has an 8 in the ones digit, miscast
    if (
      (Number(this.result.roll.toString().split('').pop()) == 8 && !game.settings.get("wfrp4e", "useWoMInfluences")) || 
      (this.failed && game.settings.get("wfrp4e", "useWoMInfluences"))) 
    {
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.MalignantInfluence"));
      return 1;
    }
  }

  _calculateOverCast(slOver) {
    this.result.overcasts = Math.max(0, Math.floor(slOver / 2));
    this.result.overcast.total = this.result.overcasts;
    this.result.overcast.available = this.result.overcasts;
  }

  async calculateDamage() {
    let damageBreakdown = this.result.breakdown.damage;
    this.result.additionalDamage = this.preData.additionalDamage || 0;
    // Calculate Damage if the this.item has it specified and succeeded in casting
    try {
      if (this.item.Damage && this.result.castOutcome == "success")
      {
        this.result.damage = Number(this.result.SL) + Number(this.item.Damage);
        damageBreakdown.base = `${this.item.Damage} (${game.i18n.localize("Spell")})`;
        damageBreakdown.other.push({label : game.i18n.localize("SL"), value : this.result.SL });
      }

      if (this.item.damage.dice && !this.result.additionalDamage) {
        let roll = await new Roll(this.item.damage.dice).roll({allowInteractive : false});
        this.result.diceDamage = { value: roll.total, formula: roll.formula };
        this.preData.diceDamage = this.result.diceDamage;
        this.result.additionalDamage += roll.total;
        damageBreakdown.other.push({label : game.i18n.localize("BREAKDOWN.Dice"), value : roll.total});
      this.preData.additionalDamage = this.result.additionalDamage;
      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("ErrorDamageCalc") + ": " + error);
    } // If something went wrong calculating damage, do nothing and continue

  }

  
  async moveVortex() 
  {
    for (let id of this.context.templates) {
      let template = canvas.scene.templates.get(id);
      if (template) {

        let tableRoll = (await game.wfrp4e.tables.rollTable("vortex", {}, "map"));
        let dist = (await new Roll("2d10").roll({allowInteractive : false})).total;
        let pixelsPerYard = canvas.scene.grid.size / canvas.scene.grid.distance;
        let straightDelta = dist * pixelsPerYard;
        let diagonalDelta = straightDelta / Math.sqrt(2);
        tableRoll.result = tableRoll.result.replace("[[2d10]]", dist);

        if (tableRoll) {
          let { x, y } = template || {};
          ChatMessage.create({ content: tableRoll.result, speaker: { alias: this.item.name } });
          if (tableRoll.roll == 1) {
            await template?.delete();
            this.context.templates = this.context.templates.filter(i => i != id);
            await this.updateMessageData();
            continue;
          }
          else if (tableRoll.roll == 2) {
            y -= straightDelta;
          }
          else if (tableRoll.roll == 3) {
            y -= diagonalDelta;
            x += diagonalDelta;
          }
          else if (tableRoll.roll == 4) {
            x += straightDelta;
          }
          else if (tableRoll.roll == 5) ;
          else if (tableRoll.roll == 6) {
            y += diagonalDelta;
            x += diagonalDelta;
          }
          else if (tableRoll.roll == 7) {
            y += straightDelta;
          }
          else if (tableRoll.roll == 8) {
            y += diagonalDelta;
            x -= diagonalDelta;
          }
          else if (tableRoll.roll == 9) {
            x -= straightDelta;
          }
          else if (tableRoll.roll == 10) {
            y -= diagonalDelta;
            x -= diagonalDelta;
          }
          template.update({ x, y }).then(template => {
            // AbilityTemplate.updateAOETargets(template);
          });
        }
      }
    }
  }

  computeTables()
  {
    super.computeTables();
    if (this.result.minormis)
    {
      this.result.tables.miscast = {
        label : this.result.minormis,
        class : "fumble-roll",
        key : "minormis"
      };
    }
    if (this.result.nullminormis)
    {
      this.result.tables.nullminormis = {
        label : this.result.nullminormis,
        class : "fumble-roll",
        key : "minormis",
        nulled : true
      };
    }
    if (this.result.majormis)
    {
      this.result.tables.miscast = {
        label : this.result.majormis,
        class : "fumble-roll",
        key : "majormis",
      };
    }
    if (this.result.nullmajormis)
    {
      this.result.tables.nullmajormis = {
        label : this.result.nullmajormis,
        class : "fumble-roll",
        key : "majormis",
        nulled : true
      };
    }
    if (this.result.catastrophicmis)
    {
      this.result.tables.miscast = {
        label : this.result.catastrophicmis,
        class : "fumble-roll",
        key : "catastrophicmis",
      };
    }
    if (this.result.nullcatastrophicmis)
    {
      this.result.tables.nullcatastrophicmis = {
        label : this.result.nullcatastrophicmis,
        class : "fumble-roll",
        key : "nullcatastrophicmis",
        nulled : true
      };
    }
    if (this.result.grimoiremiscast)
    {
      this.result.tables.grimoiremiscast = {
        label : this.result.grimoiremiscast,
        class : "fumble-roll",
        key : "grimoire-miscast",
      };
    }
  }


  async postTest() {
    //@/HOUSE
    if (this.preData.unofficialGrimoire) {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      if (this.preData.ingredientMode != 'none' && this.hasIngredient && this.item.ingredient?.quantity.value > 0 && !this.context.edited && !this.context.reroll) {
        await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
        ChatMessage.create({ speaker: this.context.speaker, content: game.i18n.localize("ConsumedIngredient") });
      }
    //@/HOUSE
    } else {
      // Find ingredient being used, if any
      if (this.hasIngredient && this.item.ingredient?.quantity.value > 0 && !this.context.edited && !this.context.reroll)
        await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
    }

    // Set initial extra overcasting options to SL if checked
    if (this.result.overcast.enabled) {
      if (this.item.system.overcast.initial.type == "SL") {
        foundry.utils.setProperty(this.result, "overcast.usage.other.initial", parseInt(this.result.SL) + (parseInt(this.item.system.computeSpellPrayerFormula("", false, this.spell.system.overcast.initial.additional)) || 0));
        foundry.utils.setProperty(this.result, "overcast.usage.other.current", parseInt(this.result.SL) + (parseInt(this.item.system.computeSpellPrayerFormula("", false, this.spell.system.overcast.initial.additional)) || 0));
      }
    }

    if (this.result.miscastModifier) {
      if (this.result.minormis)
        this.result.minormis += ` (${this.result.miscastModifier})`;
      if (this.result.majormis)
        this.result.majormis += ` (${this.result.miscastModifier})`;
      if (this.result.catastrophicmis)
        this.result.catastrophicmis += ` (${this.result.miscastModifier})`;
    }

    //@HOUSE
    if (this.item.cn.SL > 0) {

      if (this.result.castOutcome == "success" || !game.settings.get("wfrp4e", "homebrew").mooCastAfterChannelling)
      {
        let items = [this.item];

        // If WoM Channelling, SL of spells are shared, so remove all channelled SL of spells with the same lore
        if (game.settings.get("wfrp4e", "useWoMChannelling"))
        {
          items = this.actor.items.filter(s => s.type == "spell" && s.system.lore.value == this.spell.system.lore.value).map(i => i.toObject());
          items.forEach(i => i.system.cn.SL = 0);
          await this.actor.updateEmbeddedDocuments("Item", items);
        }
        else 
        {
          await this.item.update({ "system.cn.SL": 0 });
        }
      }

      else if (game.settings.get("wfrp4e", "homebrew").mooCastAfterChannelling) {
        game.wfrp4e.utility.logHomebrew("mooCastAfterChannelling");
        if (this.item.cn.SL > 0 && this.result.castOutcome == "failure")
          this.result.other.push(game.i18n.localize("MOO.FailedCast"));
      }
    }
    //@/HOUSE
  }

  get hasIngredient() {
    return this.item.ingredient && this.item.ingredient.quantity.value > 0
  }

  get spell() {
    return this.item
  }
}

class WomCastTest extends CastTest {


  static fromData(...args)
  {
    return new this(...args);
  }
  // WoM overcasts need to check availability per usage option
  // Look at each usage's first option and see if the cost can be paid
  // If not, it is not available
  _calculateOverCast(slOver) {

    this.result.overcasts = Math.max(0, slOver) + (this.result.totalPower ? parseInt(Math.floor(this.result.roll / 10)) : 0);    
    this.result.overcast.total = this.result.overcasts;
    this.result.overcast.available = this.result.overcasts;
    let overCastTable = game.wfrp4e.config.overCastTable(this.spell.lore.value);

    // Since SL is spent by overcasts, need to keep track of original
    this.result.overcast.originalSL = Number(this.result.SL); 

    if (this.result.overcast.usage.range) {
      this.result.overcast.usage.range.available = this.result.overcast.available >= overCastTable.range[0].cost;
    }
    if (this.result.overcast.usage.target) {
      if(this.result.overcast.usage.target.AoE) {
        this.result.overcast.usage.target.available = this.result.overcast.available >= overCastTable.AoE[0].cost;
      } else {
        this.result.overcast.usage.target.available = this.result.overcast.available >= overCastTable.target[0].cost;
      }
    }
    if (this.result.overcast.usage.duration) {
      this.result.overcast.usage.duration.available = this.result.overcast.available >= overCastTable.duration[0].cost;
    }
    if (this.result.overcast.usage.damage) {
      this.result.overcast.usage.damage.available = this.result.overcast.available >= overCastTable.damage[0].cost;
    }
    if (this.result.overcast.usage.other) {
      this.result.overcast.usage.other.available = this.result.overcast.available >= 2;
    }
  }

  async calculateDamage() {
    let damageBreakdown = this.result.breakdown.damage;
    this.result.additionalDamage = this.preData.additionalDamage || 0;
    let overCastTable = game.wfrp4e.config.overCastTable(this.spell.lore.value);
    // Calculate Damage if the this.item has it specified and succeeded in casting
    try {
      if (this.item.Damage && this.result.castOutcome == "success") {
        this.result.damage = Number(this.item.Damage);
        damageBreakdown.base = `${this.item.Damage} (${game.i18n.localize("Spell")})`;

        if (this.result.overcast.usage.damage && this.result.overcast.usage.damage.count > 0) {
          let overcastDamage = overCastTable.damage[this.result.overcast.usage.damage.count - 1].value;
          this.result.additionalDamage += overcastDamage;
          damageBreakdown.other.push({label : game.i18n.localize("Overcast"), value : overcastDamage});
          this.result.damage += this.result.additionalDamage;
        }
      }
      if (this.item.damage.dice && !this.result.additionalDamage) {
        let roll = await new Roll(this.item.damage.dice).roll({allowInteractive : false});
        this.result.diceDamage = { value: roll.total, formula: roll.formula };
        this.preData.diceDamage = this.result.diceDamage;
        this.result.additionalDamage += roll.total;
        damageBreakdown.other.push({label : game.i18n.localize("BREAKDOWN.Dice"), value : roll.total});
        this.preData.additionalDamage = this.result.additionalDamage;
      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("ErrorDamageCalc") + ": " + error);
    } // If something went wrong calculating damage, do nothing and continue
  }


  // @@@@@@@ Overcast functions placed in root class because it is used by both spells and prayers @@@@@@@
  async _overcast(choice) {
    if (!game.settings.get("wfrp4e", "useWoMOvercast")) {
      await super._overcast(choice);
    } else {
      const overCastTable = game.wfrp4e.config.overCastTable(this.spell.lore.value);

      let otherCost = overCastTable.other[0].cost;
      const overcastData = this.result.overcast;

      if (!overcastData.available)
        return overcastData

      if (typeof overcastData.usage[choice].initial != "number")
        return overcastData

      const count = overcastData.usage[choice].count;

      // If no table entry, or costs more than SL available, do nothing
      // AoE is separate column from target, so must be tested separately 
      if (choice == "target" && overcastData.usage.target.AoE) {
        if (!overCastTable["AoE"][count] || overCastTable["AoE"][count].cost > overcastData.available) {
          return overcastData;
        }
      }
      else if (choice == "other") {
        if (overcastData.valuePerOvercast.cost) {
          otherCost = parseInt(eval(overcastData.valuePerOvercast.cost
                          .replace("{{current}}", overcastData.usage[choice].current)
                          .replace("{{count}}", overcastData.usage[choice].count)));
        }
        if (otherCost > overcastData.available) {
          return overcastData
        }
      }
      else {
        if (!overCastTable[choice][count] || overCastTable[choice][count].cost > overcastData.available) {
          return overcastData;
        }
      }

      // Set current value based on overcast choice
      switch (choice) {
        case "range":
          if (overCastTable[choice][count] && overCastTable[choice][count].cost <= overcastData.available) {
            overcastData.usage[choice].current = overCastTable[choice][count].value * overcastData.usage[choice].initial;
          }
          break
        case "target":
          if (overcastData.usage["target"].AoE) {
            if (overCastTable[choice][count] && overCastTable["AoE"][count].cost <= overcastData.available) {
              overcastData.usage[choice].current = overCastTable["AoE"][count].value * overcastData.usage[choice].initial;
            }
          } else {
            if (overCastTable[choice][count] && overCastTable["target"][count].cost <= overcastData.available) {
              overcastData.usage[choice].current = overCastTable["target"][count].value + overcastData.usage[choice].initial;
            }
          }
          break
        case "duration":
          if (overCastTable[choice][count] && overCastTable[choice][count].cost <= overcastData.available) {
            overcastData.usage[choice].current = overCastTable[choice][count].value * overcastData.usage[choice].initial;
          }
          break
        case "damage": 
        if (overCastTable[choice][count] && overCastTable[choice][count].cost <= overcastData.available) {
          overcastData.usage[choice].current = overCastTable[choice][count].value + overcastData.usage[choice].initial;
        }
          break
        case "other":
          if (overcastData.valuePerOvercast.type == "value")
            overcastData.usage[choice].current += overcastData.valuePerOvercast.value;
          else if (overcastData.valuePerOvercast.type == "SL")
            overcastData.usage[choice].current += (parseInt(this.result.SL) + (parseInt(this.item.system.computeSpellPrayerFormula(undefined, false, overcastData.valuePerOvercast.additional)) || 0));
          else if (overcastData.valuePerOvercast.type == "characteristic")
            overcastData.usage[choice].current += (overcastData.usage[choice].increment || 0); // Increment is specialized storage for characteristic data so we don't have to look it up
          break
      }


      // Subtract cost of overcasting from available SL
      // AoE is separate column from target, so must be tested separately 
      if (choice == "target" && overcastData.usage.target.AoE) {
        overcastData.available = overcastData.available - overCastTable["AoE"][count].cost;
      } 
      else if (choice == "other") {
        overcastData.available = overcastData.available - otherCost;
      }
      else {
        overcastData.available = overcastData.available - overCastTable[choice][count].cost;
      }

      overcastData.usage[choice].count++;

      // Check if options are still available for more overcasting (now that count is incremented)
      // It is not available if 1). no more entries in the table or 2). not enough available SL
      if (overcastData.usage.range) {
        overcastData.usage.range.available = overCastTable.range[overcastData.usage.range.count] && overcastData.available >= overCastTable.range[overcastData.usage.range.count].cost;
      }
      if (overcastData.usage.target) {
        if (overcastData.usage.target.AoE) {
          overcastData.usage.target.available = overCastTable.AoE[overcastData.usage.target.count] && overcastData.available >= overCastTable.AoE[overcastData.usage.target.count].cost;
        } else {          
          overcastData.usage.target.available = overCastTable.target[overcastData.usage.target.count] && overcastData.available >= overCastTable.target[overcastData.usage.target.count].cost;
        }
      }
      if (overcastData.usage.duration) {
        overcastData.usage.duration.available = overCastTable.duration[overcastData.usage.duration.count] && overcastData.available >= overCastTable.duration[overcastData.usage.duration.count].cost;
      }
      if (overcastData.usage.damage) {
        overcastData.usage.damage.available = overCastTable.damage[overcastData.usage.damage.count] && overcastData.available >= overCastTable.damage[overcastData.usage.damage.count].cost;
      }

      // Subtract SL by the amount spent on overcasts
      // Math.max is for preventing negative SL, this occurs with Dhar overcast rules from, which don't really work well with WoM overcast
      this.data.result.SL = `+${Math.max(0, overcastData.originalSL - (overcastData.total - overcastData.available))}`;
      await this.calculateDamage();
      await this.updateMessageData();
      this.renderRollCard();
    }
  }

  async _overcastReset() {
    if (!game.settings.get("wfrp4e", "useWoMOvercast")) {
      await super._overcastReset();
    } else {
      let overcastData = this.result.overcast;
      overcastData.available = overcastData.total;
      let overCastTable = game.wfrp4e.config.overCastTable(this.spell.lore.value);

      // For each usage option, set count to 0, reset current value to initial, and check availability
      for (let overcastType in overcastData.usage) {
        if (overcastData.usage[overcastType]) {
          overcastData.usage[overcastType].count = 0;
          overcastData.usage[overcastType].current = overcastData.usage[overcastType].initial;

          if (overcastType == "other") {
            if (overcastData.valuePerOvercast.cost) {
              let otherCost = parseInt(eval(overcastData.valuePerOvercast.cost
                              .replace("{{current}}", overcastData.usage["other"].current)
                              .replace("{{count}}", overcastData.usage["other"].count)));
              overcastData.usage[overcastType].available = overcastData.available >= otherCost;
            } else {
              overcastData.usage[overcastType].available = overcastData.available >= overCastTable.other[0].cost;
            }
          }
          else if(overcastType == "target" && overcastData.usage.target.AoE) {
            overcastData.usage[overcastType].available = overcastData.available >= overCastTable.AoE[0].cost;
          } 
          else {
            overcastData.usage[overcastType].available = overcastData.available >= overCastTable[overcastType][0].cost;
          }
        }
      }

      this.data.result.additionalDamage = this.preData.additionalDamage || 0;
      this.data.result.SL = `+${overcastData.originalSL}`;
      await this.calculateDamage();
      this.renderRollCard();
    }
  }
}

/**
 * Provides the main Actor data computation and organization.
 *
 * ActorWFRP4e contains all the preparation data and methods used for preparing an actor:
 * going through each Owned Item, preparing them for display based on characteristics.
 * Additionally, it handles all the different types of roll requests, setting up the
 * test dialog, how each test is displayed, etc.
 *
 * @extends Actor
 * @mixes WarhammerActor
 * @category - Documents
 *
 * @see   ActorSheetWFRP4e - Base sheet class
 * @see   ActorSheetWFRP4eCharacter - Character sheet class
 * @see   ActorSheetWFRP4eNPC - NPC sheet class
 * @see   ActorSheetWFRP4eCreature - Creature sheet class
 */
class ActorWFRP4e extends WarhammerActor
{

  _itemTags = null;
  /**
   *
   * Set initial actor data based on type
   * 
   * @param {Object} data        Barebones actor data which this function adds onto.
   * @param {Object} options     (Unused) Additional options which customize the creation workflow.
   *
   */
  async _preCreate(data, options, user) {

    let migration = game.wfrp4e.migration.migrateActorData(this);
    this.updateSource({ effects: game.wfrp4e.migration.removeLoreEffects(data) }, { recursive: false });

    if (!foundry.utils.isEmpty(migration)) {
      this.updateSource(migration);
      warhammer.utility.log("Migrating Actor: " + this.name, true, migration);
    }

    await super._preCreate(data, options, user);
    let preCreateData = {};

    if (!data.items?.length && !options.skipItems && this.type != "vehicle")
      preCreateData.items = await this.system.getInitialItems(this.type != "character");
    else
      preCreateData.items = this.items.map(i => foundry.utils.mergeObject(i.toObject(), game.wfrp4e.migration.migrateItemData(i), { overwrite: true }));

    if (data.effects?.length)
      preCreateData.effects = this.effects.map(i => foundry.utils.mergeObject(i.toObject(), game.wfrp4e.migration.migrateEffectData(i), { overwrite: true }));

    this.updateSource(preCreateData);
  }


  async _onUpdate(data, options, user) {
    await super._onUpdate(data, options, user);

    if (options.deltaWounds > 0)
    {
      TokenHelpers.displayScrollingText("+" + options.deltaWounds, this, {fill: "0x00FF00", direction : CONST.TEXT_ANCHOR_POINTS.TOP});
    }
    else if (options.deltaWounds < 0)
    {
      TokenHelpers.displayScrollingText(options.deltaWounds, this, {fill: "0xFF0000", direction : CONST.TEXT_ANCHOR_POINTS.BOTTOM});
    }

    if (options.deltaAdv > 0)
    {
      TokenHelpers.displayScrollingText("+" + options.deltaAdv, this, {fill: "0x6666FF", direction : CONST.TEXT_ANCHOR_POINTS.TOP});
    }
    else if (options.deltaAdv < 0)
    {
      TokenHelpers.displayScrollingText(options.deltaAdv, this, {fill: "0x6666FF", direction : CONST.TEXT_ANCHOR_POINTS.BOTTOM});
    }
  }

  _onUpdateDescendantDocuments(...args)
  {
      super._onUpdateDescendantDocuments(...args);
      // If an owned item (trait specifically) is disabled, check auras
      if (args[1] == "items" && args[3].some(update => (foundry.utils.hasProperty(update, "system.disabled"))))
      {
          TokenHelpers.updateAuras(this.getActiveTokens()[0]?.document);
      }
  }  

  prepareBaseData()
  {
      this._itemTags = null;
      super.prepareBaseData();
  }

  
  /**
   * @override 
   */
  prepareDerivedData() {
    this.system.computeDerived();
  }


  //#region Rolling

  async setupCharacteristic(characteristic, context = {}, options) {
    return this._setupTest(CharacteristicDialog, CharacteristicTest, characteristic, context, options, false)
  }

  /**
   * Setup a Skill Test.
   *
   *
   * @param {Object} skill    The skill item being tested. Skill items contain the advancements and the base characteristic, see template.json for more information.
   */
  async setupSkill(skill, context = {}, options) {
    if (typeof (skill) === "string") {
      let skillName = skill;
      skill = this.itemTags["skill"].find(sk => sk.name.toLowerCase() == skill.toLowerCase());
      if (!skill)
      {
        // Skill not found, find later and use characteristic
        skill = {
          name : skillName,
          id : "unknown",
          system : {
            characteristic : {
              value : ""
            }
          }
        };
      }
    }
    return this._setupTest(SkillDialog, SkillTest, skill, context, options, false)
  }

  /**
   * Setup a Weapon Test.
   *
   *
   * @param {Object} weapon   The weapon Item being used.
   * @param {bool}   event    The event that called this Test, used to determine if attack is melee or ranged.
   */
  async setupWeapon(weapon, context = {}, options) {

    return this._setupTest(WeaponDialog, WeaponTest, weapon, context, options, false)
  }


  /**
   * Setup a Casting Test.
   *
   *
   * @param {Object} spell    The spell Item being Casted. The spell item has information like CN, lore, and current ingredient ID
   *
   */
  async setupCast(spell, context = {}, options) {

    return this._setupTest(CastDialog, game.settings.get("wfrp4e", "useWoMOvercast") ? WomCastTest : CastTest, spell, context, options, false)
  }

  /**
   * Setup a Channelling Test.
   *
   *
   * @param {Object} spell    The spell Item being Channelled. The spell item has information like CN, lore, and current ingredient ID
   * This spell SL will then be updated accordingly.
   *
   */
  async setupChannell(spell, context = {}, options) 
  {
    return this._setupTest(ChannellingDialog, ChannelTest, spell, context, options, false)
  }

  /**
   * Setup a Prayer Test.
   *
   *
   * @param {Object} prayer    The prayer Item being used, compared to spells, not much information
   * from the prayer itself is needed.
   */
  async setupPrayer(prayer, context = {}, options) 
  {
    return this._setupTest(PrayerDialog, PrayerTest, prayer, context, options, false)
  }

  /**
   * Setup a Trait Test.
   *
   * Some traits are rollable, and so are assigned a rollable characteristic, this is where
   * rolling those characteristics is setup. Additonally, sometimes these traits have a
   * "Bonus characteristic" which in most all cases means what characteristic bonus to add
   * to determine damage. See the logic in traitTest.
   *
   * @param {Object} trait   The trait Item being used, containing which characteristic/bonus characteristic to use
   */
  async setupTrait(trait, context = {}, options) 
  {
    return this._setupTest(TraitDialog, TraitTest, trait, context, options, false)
  }

  setupItem(id, context={}, options)
  {
    let item = this.items.get(id);
    switch(item?.type)
    {
      case "skill":
        return this.setupSkill(item, context, options);
      case "weapon":
        return this.setupWeapon(item, context, options);
      case "trait":
        return this.setupTrait(item, context, options);
      case "spell":
        return this.setupCast(item, context, options);
      case "prayer":
        return this.setupPrayer(item, context, options);
    }
  }


  async setupExtendedTest(item, context = {}, options) {

    let defaultRollMode = item.hide.test || item.hide.progress ? "gmroll" : "roll";

    if (item.SL.target <= 0)
      return ui.notifications.error(game.i18n.localize("ExtendedError1"))

    context.extended = item.uuid;
    context.hitLocation = false;
    context.fields = {difficulty : item.system.difficulty.value || "challenging", rollMode : context.fields?.rollMode || defaultRollMode};

    let characteristic = warhammer.utility.findKey(item.test.value, game.wfrp4e.config.characteristics);
    if (characteristic) {
      let test = await this.setupCharacteristic(characteristic, context, options);
      await test.roll();
    }
    else {
      let skill = this.itemTags["skill"].find(i => i.name == item.test.value);
      if (skill) {
        let test = await this.setupSkill(skill, context, options);
        await test.roll();
      } 
      else {
        ui.notifications.error(`${game.i18n.format("ExtendedError2", { name: item.test.value })}`);
      }
    }
  }


  async rollReloadTest(weapon, options) {
    let testId = weapon.getFlag("wfrp4e", "reloading");
    let extendedTest = weapon.actor.items.get(testId);
    if (!extendedTest) {

      //ui.notifications.error(game.i18n.localize("ITEM.ReloadError"))
      await this.checkReloadExtendedTest(weapon, this);
      return
    }
    await this.setupExtendedTest(extendedTest, { reload: true, weapon, appendTitle: " - " + game.i18n.localize("ITEM.Reloading") }, options);
  }


  /**
   * Deprecated - only used for compatibility with existing effects
   * As shown in the functions, just call `roll()` on the test object to compute the tests
   */
  async basicTest(test, context = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async weaponTest(test, context = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async castTest(test, context = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async channelTest(test, context = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async prayerTest(test, context = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async traitTest(test, context = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }

  //#endregion



  /**
 * Adds all missing basic skills to the Actor.
 *
 * This function will add all mising basic skills, used when an Actor is created (see create())
 * as well as from the right click menu from the Actor directory.
 *
 */
  async addBasicSkills() {
    let ownedBasicSkills = this.itemTags["skill"].filter(i => i.advanced.value == "bsc");
    let allBasicSkills = await WFRP_Utility.allBasicSkills();

    // Filter allBasicSkills with ownedBasicSkills, resulting in all the missing skills
    let skillsToAdd = allBasicSkills.filter(s => !ownedBasicSkills.find(ownedSkill => ownedSkill.name == s.name));

    // Add those missing basic skills
    this.createEmbeddedDocuments("Item", skillsToAdd, {skipSpecialisationChoice : true});
  }

  /**
   * Apply damage to an actor, taking into account armor, size, and weapons.
   *
   * applyDamage() is typically called at the end of an oppposed tests, where you can
   * right click the chat message and apply damage. This function goes through the
   * process of calculating and reducing damage if needede based on armor, toughness,
   * size, armor qualities/flaws, and weapon qualities/flaws
   *
   * @param {Object} victim       id of actor taking damage
   * @param {Object} opposedData  Test results, all the information needed to calculate damage
   * @param {var}    damageType   enum for what the damage ignores, see config.js
   */
  async applyDamage(opposedTest, damageType = game.wfrp4e.config.DAMAGE_TYPE.NORMAL) {
    if (!opposedTest.result.damage)
      return `<b>Error</b>: ${game.i18n.localize("CHAT.DamageAppliedError")}`
    // If no damage value, don't attempt anything
    if (!opposedTest.result.damage.value)
      return game.i18n.localize("CHAT.DamageAppliedErrorTiring");
    // Get actor/tokens for those in the opposed test
    let actor = this;
    let attacker = opposedTest.attacker;
    let soundContext = { item: {}, action: "hit" };

    // Start wound loss at the damage value
    let totalWoundLoss = opposedTest.result.damage.value;
    let newWounds = actor.status.wounds.value;
    let applyAP = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let applyTB = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let AP = foundry.utils.deepClone(actor.status.armour[opposedTest.result.hitloc.value]);
    let ward = actor.status.ward.value;
    let wardRoll = Math.ceil(CONFIG.Dice.randomUniform() * 10);
    let abort = false;

    // Start message update string
    let updateMsg = `<b>${game.i18n.localize("CHAT.DamageApplied")}</b><span class = 'hide-option'>: `;

    let modifiers = {
      tb : 0,
      ap : {
        value : 0,
        used : 0,
        ignored : 0,
        metal : 0, // Not used here, but convenient for scripts
        nonmetal : 0, // Not used here, but convenient for scripts
        magical : 0, // Not used here, but convenient for scripts
        shield : 0,
        details : []
      },
      other : [], // array of {label : string, value : number, details : string},
      minimumOne : false // whether minimumOne was triggered (used for the tooltip)
    };
    let extraMessages = [];

    let weaponProperties = opposedTest.attackerTest.item?.properties || {};
    // If weapon is undamaging
    let undamaging = false;
    // If weapon has Hack
    let hack = false;
    // If weapon has Impale
    let impale = false;
    // If weapon has Penetrating
    let penetrating = false;

    let zzap = false;

    let args = { actor, attacker, opposedTest, damageType, weaponProperties, applyAP, applyTB, totalWoundLoss, AP, modifiers, extraMessages, ward, wardRoll, abort};
    await Promise.all(actor.runScripts("preTakeDamage", args));
    await Promise.all(attacker.runScripts("preApplyDamage", args));
    await Promise.all(opposedTest.attackerTest.item?.runScripts("preApplyDamage", args));
    damageType = args.damageType;
    applyAP = args.applyAP; 
    applyTB = args.applyTB;
    ward = args.ward;
    abort = args.abort;
    totalWoundLoss = args.totalWoundLoss;

    if (abort)
    {
      return `${abort}`
    }

    let vehicleTBTooltip = "";
    // Reduce damage by TB
    if (applyTB) 
    {
      if (this.type == "vehicle" && attacker.type != "vehicle" && opposedTest.attackerTest.item?.system.isMelee)
      {
        let tbModifier = game.wfrp4e.config.vehicleActorSizeComparison[this.system.details.size.value][attacker.system.details.size.value];

        if (tbModifier > 0)
        {
          modifiers.tb += actor.characteristics.t.bonus * tbModifier;
          vehicleTBTooltip = game.i18n.format("CHAT.VehicleTBTooltipMultiply", {number : tbModifier});
        }
        else if(tbModifier < 0)
        {
          vehicleTBTooltip = game.i18n.format("CHAT.VehicleTBTooltipSubtract", {number : Math.abs(tbModifier)});
          modifiers.tb += actor.characteristics.t.bonus + tbModifier;
        }
        else return game.i18n.localize("CHAT.AttackerTooSmallDamage")
      }
      else 
      {
        modifiers.tb += actor.characteristics.t.bonus;
      }
    }

    // Determine its qualities/flaws to be used for damage calculation
    penetrating = weaponProperties?.qualities?.penetrating;
    undamaging = weaponProperties?.flaws?.undamaging && !opposedTest.result.damaging;
    hack = weaponProperties?.qualities?.hack;
    impale = weaponProperties?.qualities?.impale;
    weaponProperties?.qualities?.pummel;
    zzap = weaponProperties?.qualities?.zzap;
    
    // see if armor flaws should be triggered
    let ignorePartial = opposedTest.attackerTest.result.roll % 2 == 0 || opposedTest.attackerTest.result.critical;
    let ignoreWeakpoints = opposedTest.attackerTest.result.critical && impale;
    let zzapIgnored = zzap ? 1 : 0; // start zzap out at 1;

    // Mitigate damage with armor one layer at a time
    for (let layer of AP.layers) {
      modifiers.ap.value += layer.value;
      zzapIgnored = zzap ? 1 : 0; // start zzap out at 1

      if (ignoreWeakpoints && layer.weakpoints) {
        modifiers.ap.details.push(game.i18n.format("BREAKDOWN.Weakpoints", {ignored: layer.value, item: layer.source.name}));
        modifiers.ap.ignored += layer.value;
        layer.ignored = true;
      }
      else if (ignorePartial && layer.partial) {
        modifiers.ap.details.push(game.i18n.format("BREAKDOWN.Partial", {ignored: layer.value, item: layer.source.name}));
        modifiers.ap.ignored += layer.value;
        layer.ignored = true;
      }
      else if (zzap && layer.metal) // ignore 1 AP and all metal AP 
      {
          zzapIgnored += layer.value;
          layer.ignored = true;
      }
      else if (penetrating && layer.source?.type == "armour") // If penetrating - ignore 1 or all armor depending on material
      {
        if (!game.settings.get("wfrp4e", "homebrew").mooPenetrating)
        {
          let penetratingIgnored = layer.metal ? 1 : layer.value;
          modifiers.ap.details.push(game.i18n.format("BREAKDOWN.Penetrating", {ignored: penetratingIgnored, item: layer.source.name}));
          modifiers.ap.ignored += penetratingIgnored;
          if (layer.metal)
          {
            modifiers.ap.metal += layer.value - 1;
            if (layer.magical)
            {
              modifiers.ap.magical += layer.value - 1;
            }
          }
          else 
          {
            layer.ignored = true;
          }
        }
      }
      else // If nothing is modifying or ignoring, record AP 
      {
        if (layer.metal)
        {
          modifiers.ap.metal += layer.value;
        }
        else 
        {
          modifiers.ap.nonmetal += layer.value;
        }

        if (layer.magical)
        {
          modifiers.ap.magical += layer.value;
        }
      }
      // if (opposedTest.attackerTest.result.roll % 2 != 0 && layer.impenetrable) {
      //   impenetrable = true;
      //   soundContext.outcome = "impenetrable"
      // }

      // Prioritize plate over chain over leather for sound
      if (layer.value) {
        if (layer.armourType == "plate")
          soundContext.item.armourType = layer.armourType;
        else if (!soundContext.item.armourType || (soundContext.item.armourType && (soundContext.item.armourType.includes("leather")) && layer.armourType == "mail")) // set to chain if there isn't an armour type set yet, or the current armor type is leather
          soundContext.item.armourType = layer.armourType;
        else if (!soundContext.item.armourType)
          soundContext.item.armourType = "leather";
      }
    }

    modifiers.ap.ignored += zzapIgnored;
    if (zzapIgnored)
    {
      modifiers.ap.details.push(game.i18n.format("BREAKDOWN.Zzap", {ignored: zzapIgnored}));
    }

    //@HOUSE
    if (penetrating && game.settings.get("wfrp4e", "homebrew").mooPenetrating) 
    {
      game.wfrp4e.utility.logHomebrew("mooPenetrating");
      let penetratingIgnored = penetrating.value || 2;
      modifiers.ap.details.push(game.i18n.format("BREAKDOWN.PenetratingMoo", {ignored: penetratingIgnored}));
      modifiers.ap.ignored += penetratingIgnored;
    }
    //@/HOUSE

    // If using a shield, add that AP as well
    if (game.settings.get("wfrp4e", "uiaShields") && !opposedTest.defenderTest.context.unopposed) // UIA shields don't need to be used, just equipped
    {
      modifiers.ap.shield = this.status.armour.shield;
    }
    else if (opposedTest.defenderTest.weapon) // RAW Shields required the shield to be used
    {
      if (opposedTest.defenderTest.weapon.properties.qualities.shield)
      {
        modifiers.ap.shield = this.status.armour.shield;
      }
    }


    // Not really a comprehensive fix 
    if (modifiers.ap.shield && penetrating && !game.settings.get("wfrp4e", "homebrew").mooPenetrating)
    {
        modifiers.ap.details.push(game.i18n.format("BREAKDOWN.Penetrating", {ignored: modifiers.ap.shield, item: "Shield"}));
        modifiers.ap.ignored += modifiers.ap.shield;
        modifiers.ap.shield = 0;
    }
    
    //@HOUSE
    if (game.settings.get("wfrp4e", "homebrew").mooShieldAP && opposedTest.defenderTest.failed && modifiers.ap.shield) {
      game.wfrp4e.utility.logHomebrew("mooShieldAP");
      modifiers.ap.details.push(game.i18n.format("BREAKDOWN.ShieldMoo", {ignored: modifiers.ap.shield}));
      modifiers.ap.shield = 0;
    }
    //@/HOUSE

    await Promise.all(actor.runScripts("computeTakeDamageModifiers", args));
    await Promise.all(attacker.runScripts("computeApplyDamageModifiers", args));
    await Promise.all(opposedTest.attackerTest.item?.runScripts("computeApplyDamageModifiers", args));

    modifiers.ap.used = Math.max(0, modifiers.ap.value - modifiers.ap.ignored);
    if (undamaging && modifiers.ap.used)
    {
      modifiers.ap.details.push(game.i18n.format("BREAKDOWN.Undamaging", {originalAP: modifiers.ap.used, modifiedAP: modifiers.ap.used * 2}));
      modifiers.ap.used *= 2;
    }

    // Reduce damage done by AP
    if (!applyAP)
    {
      modifiers.ap.used = 0;
      modifiers.ap.shield = 0;
    }
    
    modifiers.total = -modifiers.tb - modifiers.ap.used - modifiers.ap.shield + modifiers.other.reduce((acc, current) => acc + current.value, 0);
    totalWoundLoss += modifiers.total;

    // Minimum 1 wound if not undamaging
    if (!undamaging && totalWoundLoss <= 0)
    {
      args.modifiers.minimumOne = true;
      totalWoundLoss = totalWoundLoss <= 0 ? 1 : totalWoundLoss;
    }
    else
    {
      totalWoundLoss = totalWoundLoss <= 0 ? 0 : totalWoundLoss;
    }

    try {
      if (opposedTest.attackerTest.weapon.attackType == "melee") {
        if ((opposedTest.attackerTest.weapon.Qualities.concat(opposedTest.attackerTest.weapon.Flaws)).every(p => [game.i18n.localize("PROPERTY.Pummel"), game.i18n.localize("PROPERTY.Slow"), game.i18n.localize("PROPERTY.Damaging")].includes(p)))
          soundContext.outcome = "warhammer"; // special sound for warhammer :^)
        else if (AP.used) {
          soundContext.item.type = "armour";
          if (applyAP && totalWoundLoss <= 1)
            soundContext.outcome = "blocked";
          else if (applyAP)
            soundContext.outcome = "normal";
          if (impenetrable)
            soundContext.outcome = "impenetrable";
          if (hack)
            soundContext.outcome = "hack";
        }
        else {
          soundContext.item.type = "hit";
          soundContext.outcome = "normal";
          if (impale || penetrating) {
            soundContext.outcome = "normal_slash";
          }
        }
      }
    }
    catch (e) { warhammer.utility.log("Sound Context Error: " + e, true); } // Ignore sound errors
    let scriptArgs = { actor, attacker, opposedTest, totalWoundLoss, AP, applyAP, applyTB, damageType, updateMsg, modifiers, ward, wardRoll, extraMessages, abort };
    await Promise.all(actor.runScripts("takeDamage", scriptArgs));
    await Promise.all(attacker.runScripts("applyDamage", scriptArgs));
    await Promise.all(opposedTest.attackerTest.item?.runScripts("applyDamage", scriptArgs));
    Hooks.call("wfrp4e:applyDamage", scriptArgs);
    ward = scriptArgs.ward;
    abort = scriptArgs.abort;
    totalWoundLoss = scriptArgs.totalWoundLoss;

    if (abort)
    {
      return `${abort}`
    }

    newWounds -= totalWoundLoss;
    updateMsg += "</span>";
    updateMsg += " " + totalWoundLoss;

    let tooltip = `<p><strong>${game.i18n.localize("Damage")}</strong>: ${opposedTest.result.damage.value}</p><hr>`;

    if (modifiers.tb)
    {
      tooltip += `<p><strong>${game.i18n.localize("TBRed")}</strong>: -${modifiers.tb} ${vehicleTBTooltip ? `(${vehicleTBTooltip})` : ""}</p>`;
    }

    if (!applyTB)
    {
      tooltip += `<p><strong>${game.i18n.localize("TBRed")}</strong>: ${game.i18n.localize("BREAKDOWN.Ignored")}</p>`;
    }

    if (applyAP)
    {
      if (modifiers.ap.used != modifiers.ap.value)
      {
        tooltip += `<p><strong>${game.i18n.localize("AP")}</strong>: -${modifiers.ap.used}`;
        if (modifiers.ap.ignored)
        {
          tooltip += ` (${modifiers.ap.ignored} ${game.i18n.localize("BREAKDOWN.Ignored").toLowerCase()})`;
        }
        tooltip += "</p>";
      }
      else 
      {
        tooltip += `<p><strong>${game.i18n.localize("AP")}</strong>: -${modifiers.ap.used}</p>`;
      }

      if (modifiers.ap.shield)
      {
        tooltip += `<p><strong>${game.i18n.localize("CHAT.DamageShield")}</strong>: -${modifiers.ap.shield}</p>`;
      }

      if (modifiers.ap.details.length)
      {
        tooltip += `<p style='margin-left : 20px'>${modifiers.ap.details.join("</p><p style='margin-left : 20px'>")}</p>`;
      }
    }
    else if (!applyAP)
    {
        tooltip += `<p><strong>${game.i18n.localize("AP")}</strong>: ${game.i18n.localize("BREAKDOWN.Ignored")}</p>`;
    }

    if (modifiers.other.length)
    {
      tooltip += `<p>${modifiers.other.filter(i => i.value != 0).map(i => `<strong>${i.label}</strong>: ${i.details ? i.details : ""} (${(i.value > 0 ? "+" : "") + i.value})`).join("</p><p>")}</p>`;
    }
    if (modifiers.minimumOne)
    {
      tooltip += `<p>${game.i18n.localize("BREAKDOWN.Minimum1")}</p>`;
    }
    tooltip += `<hr><p><strong>${game.i18n.localize("Wounds")}</strong>: ${totalWoundLoss}</p>`;

    updateMsg += ` <a data-tooltip="${tooltip}" style="opacity: 0.5" data-tooltip-direction="LEFT"><i class="fa-solid fa-circle-info"></i></a>`;

    WFRP_Audio.PlayContextAudio(soundContext);

    // If damage taken reduces wounds to 0, show Critical
    if (newWounds <= 0) {
      //WFRP_Audio.PlayContextAudio(opposedTest.attackerTest.weapon, {"type": "hit", "equip": "crit"})
      let critAmnt = game.settings.get("wfrp4e", "homebrew").uiaCritsMod;
      if (game.settings.get("wfrp4e", "uiaCrits") && critAmnt && (Math.abs(newWounds)) > 0) {
        let critModifier = (Math.abs(newWounds)) * critAmnt;
        updateMsg += `<br><a data-action="clickTable" class="action-link critical-roll" data-modifier=${critModifier} data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")} +${critModifier}</a>`;
      }
      //@HOUSE
      else if (game.settings.get("wfrp4e", "homebrew").mooCritModifiers) {
        game.wfrp4e.utility.logHomebrew("mooCritModifiers");
        let critModifier = (Math.abs(newWounds) - actor.characteristics.t.bonus) * critAmnt;
        if (critModifier)
          updateMsg += `<br><a data-action="clickTable" class="action-link critical-roll" data-modifier=${critModifier} data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")} ${critModifier > 0 ? "+" + critModifier : critModifier}</a>`;
        else
          updateMsg += `<br><a data-action="clickTable" class="action-link critical-roll" data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")}</a>`;
      }
      //@/HOUSE
      else if (Math.abs(newWounds) < actor.characteristics.t.bonus && !game.settings.get("wfrp4e", "uiaCrits"))
        updateMsg += `<br><a data-action="clickTable" class="action-link critical-roll" data-modifier="-20" data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")} (-20)</a>`;
      else
        updateMsg += `<br><a data-action="clickTable" class="action-link critical-roll" data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")}</a>`;
    }
    if (hack)
    {
      updateMsg += `<br><button data-action="applyHack">${game.i18n.localize('CHAT.ApplyHack')}</button>`;
    }

    if (newWounds <= 0)
      newWounds = 0; // Do not go below 0 wounds


    let item = opposedTest.attackerTest.item;
    if (item?.properties && item?.properties.qualities.slash && updateMsg.includes("critical-roll"))
    {
      updateMsg += `<br>${game.i18n.format("PROPERTY.SlashAlert", {value : parseInt(item?.properties.qualities.slash.value)})}`;
    }

    if (ward > 0) 
    {

      if (wardRoll >= ward) {
        updateMsg = `<span style = "text-decoration: line-through">${updateMsg}</span><br>${game.i18n.format("OPPOSED.Ward", { roll: wardRoll })}`;
        return updateMsg;
      }
      else {
        updateMsg += `<br>${game.i18n.format("OPPOSED.WardRoll", { roll : wardRoll })}`;
      }
    }

    if (extraMessages.length > 0)
    {
      updateMsg += `<p>${extraMessages.join(`</p><p>`)}</p>`;
    }

    if (totalWoundLoss > 0)
    {
      let damageEffects = opposedTest.attackerTest?.damageEffects;
      let filtered = [];
      for(let effect of damageEffects)
      {
        if (await effect.runPreApplyScript())
        {
          filtered.push(effect);
        }
      }
      await actor.applyEffect({effectUuids: filtered.map(i => i.uuid), messageId : opposedTest.attackerTest.message.id});
    }

    // Update actor wound value
    actor.update({ "system.status.wounds.value": newWounds });

    return updateMsg;
  }



  /**
   * Unlike applyDamage(), which is for opposed damage calculation, this function just takes a number and damage type and applies the damage.
   * 
   * @param {Number} damage Amount of damage
   * @param {Object} options Type of damage, minimum 1
   */
  async applyBasicDamage(damage, { damageType = game.wfrp4e.config.DAMAGE_TYPE.NORMAL, minimumOne = true, loc = "body", suppressMsg = false, hideDSN=false } = {}) 
  {
    let owningUser = getActiveDocumentOwner(this);

    if (owningUser?.id != game.user.id)
    {
        return SocketHandlers.call("applyDamage", {damage, options : {damageType, minimumOne, loc, suppressMsg, hideDSN}, actorUuid : this.uuid}, owningUser.id);
    }

    let newWounds = this.status.wounds.value;
    let modifiedDamage = damage;
    let applyAP = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let applyTB = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let msg = game.i18n.format("CHAT.ApplyDamageBasic", { name: this.prototypeToken.name });


    if (loc == "roll")
    {
      loc = (await game.wfrp4e.tables.rollTable("hitloc", {hideDSN})).result;
    }

    if (applyAP) {
      modifiedDamage -= this.status.armour[loc].value;
      msg += ` (${this.status.armour[loc].value} ${game.wfrp4e.config.locations[loc]} ${game.i18n.localize("AP")}`;
      if (!applyTB)
        msg += ")";
      else
        msg += " + ";
    }

    if (applyTB) {
      modifiedDamage -= this.characteristics.t.bonus;
      if (!applyAP)
        msg += " (";
      msg += `${this.characteristics.t.bonus} ${game.i18n.localize("TBRed")})`;
    }

    if (minimumOne && modifiedDamage <= 0)
      modifiedDamage = 1;
    else if (modifiedDamage < 0)
      modifiedDamage = 0;

    msg = msg.replace("@DAMAGE", modifiedDamage);

    newWounds -= modifiedDamage;
    if (newWounds < 0)
      newWounds = 0;
    await this.update({ "system.status.wounds.value": newWounds });

    if (!suppressMsg)
      await ChatMessage.create({ content: msg });
    return msg;
  }


  async corruptionDialog(strength, skill) {
    skill = skill?.toLowerCase();
    if (![game.i18n.localize("NAME.Cool").toLowerCase(), game.i18n.localize("NAME.Endurance").toLowerCase()].includes(skill))
    {

      skill = await foundry.applications.api.DialogV2.wait({
        window : {
          title: game.i18n.localize("DIALOG.CorruptionTitle"),
        },
        content: `<p>${game.i18n.format("DIALOG.CorruptionContent", { name: this.name })}</p>`,
        buttons: [
          {
            action : game.i18n.localize("NAME.Endurance"),
            label: game.i18n.localize("NAME.Endurance")
          },
          {
            action : game.i18n.localize("NAME.Cool"),
            label: game.i18n.localize("NAME.Cool")
          },
        ]
      });
    }

    if (skill)
    {
      let test = await this.setupSkill(skill, { title: game.i18n.format("DIALOG.CorruptionTestTitle", { test: skill.capitalize() }), corruption: strength, skipTargets: true });
      await test.roll();
      return test;
    }
  }


  has(traitName, type = "trait") {
    return this.itemTags[type].find(i => i.name == traitName && i.included)
  }

  /**
   * Checks the status of reloading the provided weapon. If weapon is empty, create an extended test, if test is complete, deleted extended test and load weapon
   * 
   * 
   * @param {Item} weapon - Weapon whose reload status is being checked
   * @param {Actor} actor - Actor whose skills to use (pertinent for vehicles)
   * @returns 
   */
  async checkReloadExtendedTest(weapon, actor) {

    if (!weapon.loading)
      return

    actor = actor || this.actor;

    let reloadingTest = weapon.actor.items.get(weapon.getFlag("wfrp4e", "reloading"));

    if (weapon.loaded.amt > 0) {
      if (reloadingTest) {
        await reloadingTest.delete();
        await weapon.update({ "flags.wfrp4e.-=reloading": null });
        ui.notifications.notify(game.i18n.localize("ITEM.ReloadFinish"));
        return;
      }
    }
    else {
      let reloadExtendedTest = foundry.utils.duplicate(game.wfrp4e.config.systemItems.reload);

      reloadExtendedTest.name = game.i18n.format("ITEM.ReloadingWeapon", { weapon: weapon.name });
      if (weapon.system.getSkillToUse(actor))
        reloadExtendedTest.system.test.value = weapon.system.getSkillToUse(actor).name;
      else
        reloadExtendedTest.system.test.value = game.i18n.localize("CHAR.BS");
      reloadExtendedTest.flags.wfrp4e.reloading = weapon.id;

      reloadExtendedTest.system.SL.target = weapon.properties.flaws.reload?.value || 1;

      if (weapon.actor.type == "vehicle") {
        let vehicleSpeaker;
        if (weapon.actor.isToken)
          vehicleSpeaker = {
            token: weapon.actor.token.id,
            scene: weapon.actor.token.parent.id
          };
        else
          vehicleSpeaker = {
            actor: weapon.actor.id
          };
        reloadExtendedTest.flags.wfrp4e.vehicle = vehicleSpeaker;
      }

      if (reloadingTest)
        await reloadingTest.delete();

      // use weapon.actor in case the weapon is owned by a vehicle
      let item = await weapon.actor.createEmbeddedDocuments("Item", [reloadExtendedTest]);
      ui.notifications.notify(game.i18n.format("ITEM.CreateReloadTest", { weapon: weapon.name }));
      await weapon.update({ "flags.wfrp4e.reloading": item[0].id });
    }
  }


  /** 
   * @override
   * 
   * Not ideal, but if overlay is true, that means it was right clicked, so if numbered condition, increase or decrease if left or right clicked
   */
  async toggleStatusEffect(statusId, {active, overlay=false}={}) {
    const effect = await ActiveEffect.fromStatusEffect(statusId);

    if (effect.isNumberedCondition)
    {
      if (overlay == true)
      {
        this.removeCondition(statusId);
      }
      else 
      {
        this.addCondition(statusId);
      }
    }

    else super.toggleStatusEffect(statusId, {active, overlay});
  }

  setAdvantage(val) {
    return this.update({ "system.status.advantage.value": val })
  }
  modifyAdvantage(val) {
    return this.setAdvantage(this.status.advantage.value + val)
  }

  setWounds(val) {
    return this.update({ "system.status.wounds.value": val })
  }
  modifyWounds(val) {
    return this.setWounds(this.status.wounds.value + val)
  }

  get isMounted() {
    return this.system.isMounted
  }

  get mount() {
    return this.system.mount;

  }

  async addCondition(effect, value = 1, mergeData={}) {
    if (value == 0)
    {
      return;
    }
    if (typeof value == "string")
    {
      value = parseInt(value);
    }

    if (typeof (effect) === "string")
      effect = foundry.utils.duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
    if (!effect)
      return "No Effect Found"

    if (!effect.id)
      return "Conditions require an id field"


    let existing = this.hasCondition(effect.id);

    if (existing && !existing.isNumberedCondition)
      return existing
    else if (existing) 
    {
      existing._displayScrollingStatus(true);
      mergeData["system.condition.value"] = existing.conditionValue + value;
      return existing.update(mergeData);
    }
    else if (!existing) {
      if (game.combat && (effect.id == "blinded" || effect.id == "deafened"))
      {
        foundry.utils.setProperty(effect, "flags.wfrp4e.roundReceived", game.combat.round);
      }
      effect.name = game.i18n.localize(effect.name);
      effect.description = game.i18n.localize(effect.description);

      if (effect.system.condition.numbered)
        effect.system.condition.value = value;
        
      effect["statuses"] = [effect.id];
      if (effect.id == "dead")
        effect["flags.core.overlay"] = true;
      if (effect.id == "unconscious")
        await this.addCondition("prone");

      foundry.utils.mergeObject(effect, mergeData);

      if (effect.system.condition.numbered)
      {
        foundry.utils.setProperty(effect, "flags.core.overlay", false); // Don't let numeric conditions be overlay
      }

      delete effect.id;
      return this.createEmbeddedDocuments("ActiveEffect", [effect], {condition: true})
    }
  }

  async removeCondition(effect, value = 1) {
    if (typeof (effect) === "string")
      effect = foundry.utils.duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
    if (!effect)
      return "No Effect Found"

    if (!effect.id)
      return "Conditions require an id field"

    if (value == 0)
    {
      return;
    }
    if (typeof value == "string")
    {
      value = parseInt(value);
    }

    let existing = this.hasCondition(effect.id);

    if (existing && !existing.isNumberedCondition) {
      if (effect.id == "unconscious")
        await this.addCondition("fatigued");
      return existing.delete();
    }
    else if (existing) {
      await existing.update({"system.condition.value" : existing.conditionValue - value});
      if (existing.conditionValue) // Only display if there's still a condition value (if it's 0, already handled by effect deletion)
        existing._displayScrollingStatus(false);
      //                                                                                                                   Only add fatigued after stunned if not already fatigued
      if (existing.conditionValue == 0 && (effect.id == "bleeding" || effect.id == "poisoned" || effect.id == "broken" || (effect.id == "stunned" && !this.hasCondition("fatigued")))) {
        if (!game.settings.get("wfrp4e", "homebrew").mooConditions || !effect.id == "broken") // Homebrew rule prevents broken from causing fatigue
          await this.addCondition("fatigued");
      }

      if (existing.conditionValue <= 0)
        return existing.delete();
    }
  }

  applyFear(value, name = undefined) {
    value = value || 0;
    let fear = foundry.utils.duplicate(game.wfrp4e.config.systemItems.fear);
    fear.system.SL.target = value;

    foundry.utils.setProperty(fear, "flags.wfrp4e.fearName", name);

    return this.createEmbeddedDocuments("Item", [fear], {condition: true}).then(items => {
      this.setupExtendedTest(items[0], {appendTitle : ` - ${items[0].name}`});
    });
  }


  async applyTerror(value, name = undefined) {
    value = value || 1;
    let terror = foundry.utils.duplicate(game.wfrp4e.config.systemItems.terror);
    foundry.utils.setProperty(terror, "flags.wfrp4e.terrorValue", value);
    let scripts = new ActiveEffectWFRP4e(terror, {parent: this}).scripts;
    for (let s of scripts) {
      await s.execute({ actor: this });
    }
  }

  async checkSystemEffects() {
    if (game.user.id != getActiveDocumentOwner(this)?.id)
    {
      return
    }
    let encumbrance = this.status.encumbrance.state;
    let state;

    if (encumbrance > 3) {
      state = "enc3";
      if (!this.hasSystemEffect(state)) {
        await this.addSystemEffect(state);
        return
      }
      await this.removeSystemEffect("enc2");
      await this.removeSystemEffect("enc1");
    }
    else if (encumbrance > 2) {
      state = "enc2";
      if (!this.hasSystemEffect(state)) {
        await this.addSystemEffect(state);
        return
      }
      await this.removeSystemEffect("enc1");
      await this.removeSystemEffect("enc3");
    }
    else if (encumbrance > 1) {
      state = "enc1";
      if (!this.hasSystemEffect(state)) {
        await this.addSystemEffect(state);
        return
      }
      await this.removeSystemEffect("enc2");
      await this.removeSystemEffect("enc3");
    }
    else {
      await this.removeSystemEffect("enc1");
      await this.removeSystemEffect("enc2");
      await this.removeSystemEffect("enc3");
    }

  }


  async addSystemEffect(key) {
    let systemEffects = game.wfrp4e.utility.getSystemEffects(this.type == "vehicle");
    let effect = systemEffects[key];
    if (effect) {
      await this.createEmbeddedDocuments("ActiveEffect", [effect]);
    }
  }

  async removeSystemEffect(key) {
    let effects = this.effects.filter(e => e.statuses.has(key));
    if (effects.length)
      await this.deleteEmbeddedDocuments("ActiveEffect", effects.map(i => i.id));
  }

  hasSystemEffect(key) {
    return this.hasCondition(key) // Same function so just reuse
  }

  async clearOpposed() {
    return (await this.update({ "flags.-=oppose": null }));
  }

  /**
   * 
   * @inheritdoc
   * @param {object} config Configuration for embedding behavior.
   * @param {string} config.token Use token image instead of actor image
   * @param {string} config.image Set false to have no image 
   * @param {string} config.float Set to right or left to float that direction instead of centered
   * @param {string} config.heading Set to h1, h2, h3, etc. Default p
   * @param {string} config.size height/width for image 
   * @param {string} config.noToc Set to true to prevent heading from showing in journal TOC
   * @param {string} config.description Set to true to include the actor's description
   * @param {string} config.style Customized styling for entitre embed block
   * @param {string} config.label Label for actor link 
   */
  async toEmbed(config, options={})
  {
    let html = "";
    let image = this.img;
    if (config.token)
    {
        image = this.prototypeToken.texture.src;
    }

    if (config.image != false)
    {
      let imageAlignment = "centered";
      if (config.float)
      {
        imageAlignment = `float-${config.float}`;
      }
      html += `<div class="journal-image ${imageAlignment}" ><img src="${image}" width="${config.size || 200}" height="${config.size || 200}"></div>`;
    }
    let heading = config.heading ? config.heading : `p style="text-align:center"`;
    let noToc = config.noToc ? "no-toc" : "";
    html += `<${heading} class="${noToc}">@UUID[${this.uuid}]{${config.label || this.name}}</${heading.split(" ")[0]}>`;
    if (config.description)
    {
        if (game.user.isGM)
        {
            html += this.system.details.gmnotes?.value || this.system.details.gmdescription?.value ||"";
        }
        html += this.system.details.biography?.value || this.system.details.description?.value || "";
    }
    if (options.relativeTo)
    {    
      html = html.replaceAll(new RegExp(`<.{1,2}>@UUID\\[${options.relativeTo.uuid}.+?\\].+?<\/.>`, "gm"), "");
    }
    return $(await foundry.applications.ux.TextEditor.implementation.enrichHTML(`<div style="${config.style || ""}">${html}</div>`, {relativeTo : this, async: true, secrets : options.secrets}))[0];
  }

  get itemTags() {
    if (!this._itemTags) 
    {
      let tags = new Set(game.documentTypes.Item);
      let items = this.items.contents;
      for (const item of items) 
      {
        tags = tags.union(item.system.tags || new Set());
      }
      this._itemTags = tags.toObject().reduce((obj, tag) => 
      {
        obj[tag] = items.filter(i => i.system.tags?.has(tag)).sort((a, b) => a.sort - b.sort);
        return obj;
      }, {});
    }

    return this._itemTags;
  }

  // @@@@@@@@ BOOLEAN GETTERS

  get inCollection() {
    return game.actors && game.actors.get(this.id)
  }

  get hasSpells() {
    return !!this.itemTags["spell"].length > 0
  }

  get hasPrayers() {
    return !!this.itemTags["prayer"].length > 0
  }

  get noOffhand() {
    return !this.itemTags["weapon"].find(i => i.offhand.value)
  }

  get isOpposing() {
    return !!this.flags.oppose
  }

  get mainArmLoc() 
  {
    return (this.system.details.mainHand || "r") + "Arm"
  }

  get secondaryArmLoc() 
  {
    return (this.system.details.mainHand == "r" ? "l" : "r") + "Arm"
  }

  /**
   * When a test is rolled, it may roll "rArm" or "lArm" 
   * However, a test doesn't necessarily know who it's attacking, so this
   * actually means "primary" and "secondary" arm respectively.
   * 
   * This function makes the conversion. If a character's main arm is their left, and a test
   * rolled "rArm" as the hit location, that actually means they hit the left arm, as "rArm" means
   * main arm, and their main arm is left
   * 
   * @param {string} hitloc "rArm" or "lArm"
   */
  convertHitLoc(hitloc)
  {
    if (hitloc == "rArm")
    {
      return this.mainArmLoc
    }
    else if (hitloc == "lArm")
    {
      return this.secondaryArmLoc;
    }
    return hitloc
  }


  speakerData(token) {
    if (this.isToken || token) {
      return {
        token: token?.id || this.token.id,
        scene: token?.parent.id || this.token.parent.id
      }
    }
    else {
      return {
        actor: this.id,
        token: token?.id,
        scene: token?.parent.id
      }
    }
  }

  // async _buildEmbedHTML(config, options={}) {
  //   if (this.system.toEmbed)
  //   {
  //     return this.system.toEmbed(config, options)
  //   }
  // }

  // @@@@@@@@@@@ COMPUTED GETTERS @@@@@@@@@
  get Species() {
    let species = game.wfrp4e.config.species[this.details.species.value] || this.details.species.value;
    if (this.details.species.subspecies && game.wfrp4e.config.subspecies[this.details.species.value] && game.wfrp4e.config.subspecies[this.details.species.value][this.details.species.subspecies])
      species += ` (${game.wfrp4e.config.subspecies[this.details.species.value][this.details.species.subspecies].name})`;
    else if (this.details.species.subspecies)
      species += ` (${this.details.species.subspecies})`;

    return species
  }

  get sizeNum() {
    return game.wfrp4e.config.actorSizeNums[this.details.size.value]
  }

  get currentCareer() {
    return this.system.currentCareer
  }

  get attacker() {
    try {
      if (this.flags.oppose) {
        let opposeMessage = game.messages.get(this.flags.oppose.opposeMessageId); // Retrieve attacker's test result message
        let handler = opposeMessage.system.opposedHandler;
        let attackerMessage = handler.attackerMessage;
        // Organize attacker/defender data
        if (opposeMessage)
          return {
            speaker: attackerMessage.speaker,
            test: attackerMessage.system.test,
            messageId: attackerMessage.id,
            img: WFRP_Utility.getSpeaker(attackerMessage.speaker).img
          };
        else
          this.update({ "flags.-=oppose": null });
      }
    }
    catch (e) {
      console.error("Error finding attacker, removing flags." + e);
      this.update({ "flags.-=oppose": null });
    }

  }

  // Filter out disabled traits
  get auraEffects() 
  {
      return this.items.filter(i => i.type != "trait" || !i.system.disabled).reduce((acc, item) => acc.concat(item.effects.contents), []).concat(this.effects.contents).filter(e => e.system.transferData.type == "aura" && !e.system.transferData.area.aura.transferred).filter(i => i.active);
  }


  // Used with Group Advantage
  // Actor is considered in the "Players" group if it is owned by a player or has a Friendly token disposition
  // Otherwise, it is considered in the "Enemies" group
  get advantageGroup() {
    if (this.hasPlayerOwner)
      return "players"
    else if (this.token)
      return this.token.disposition == CONST.TOKEN_DISPOSITIONS.FRIENDLY ? "players" : "enemies"
    else 
      return this.prototypeToken.disposition == CONST.TOKEN_DISPOSITIONS.FRIENDLY ? "players" : "enemies"
  }

  // @@@@@@@@@@@ DATA GETTERS @@@@@@@@@@@@@
  get characteristics() { return this.system.characteristics }
  get status() { return this.system.status }
  get details() { return this.system.details }
  get excludedTraits() { return this.system.excludedTraits }
  get roles() { return this.system.roles }

  // @@@@@@@@@@ DERIVED DATA GETTERS
  get armour() { return this.status.armour }

  physicalNonDamagedArmourAtLocation(location) {
    return this.armour[location]?.layers.filter(a => a.value > 0 && a.source instanceof ItemWFRP4e).map(a => a.source);
  }

  static compendiumBrowserTypes({chosen = new Set()} = {}) {
    // @todo let systems define categories in data models and change this to generate categories more dynamically
    const [generalTypes, standardTypes] = getSortedTypes(Actor).reduce(([g, s], t) => {
      if (t !== CONST.BASE_DOCUMENT_TYPE) {
        if (CONFIG.Actor.dataModels[t]?.metadata?.isStandard) s.push(t);
        else g.push(t);
      }

      return [g, s];
    }, [[], []]);

    const makeChoices = (types, categoryChosen) => types.reduce((obj, type) => {
      obj[type] = {
        label: CONFIG.Actor.typeLabels[type],
        chosen: chosen.has(type) || categoryChosen
      };
      return obj;
    }, {});

    const choices = makeChoices(generalTypes);

    if (standardTypes.length) {
      choices.standard = {
        label: game.i18n.localize("ITEM.Standard"),
        children: makeChoices(standardTypes, chosen.has("standard"))
      };
    }

    return new SelectChoices(choices);
  }
}

function passengerRender(token) {
    if (!token.document?.flags.wfrp4e?.hidePassengers && token.actor && token.actor.type == "vehicle")
    {
      if (token.passengers)
      {
        token.passengers.destroy();
      }
      let passengerIconSize = canvas.dimensions.size / 3.3333;
      let rowSize = 3;
      let colSize = 3;
      let container = new PIXI.Container();
      let imgCount = 0;
      if (token.actor.system.passengers.list.length > 9)
      {
        passengerIconSize = canvas.dimensions.size / 4;
        rowSize = 4;
        colSize = 4;
      }
      passengerIconSize *= token.document.width;
      for (let img of token.actor.system.passengers.list.map(p => p.img))
      {
        if (!img)
        continue
        let sp = PIXI.Sprite.from(img);
        sp.width = passengerIconSize;
        sp.height = passengerIconSize;
        sp.x = passengerIconSize * (imgCount % rowSize);
        sp.y = passengerIconSize * Math.floor(imgCount / colSize);
        container.addChild(sp);
        imgCount++;
        if (imgCount > 9)
        break;
        token.passengers = token.addChild(container);
      }
    }
}

class WFRPTokenHUD extends foundry.applications.hud.TokenHUD {


  _onToggleEffect = function (event, { overlay = false } = {}) {
    event.preventDefault();
    event.stopPropagation();
    let img = event.currentTarget;

    let actor = this.object?.actor;
    if (!actor) return;

    if (event.button == 0)
    {
        return actor.addCondition(img.dataset.statusId)
    }
    if (event.button == 2)
    {
        if (this.object?.actor.hasCondition(img.dataset.statusId))
        {
            return actor.removeCondition(img.dataset.statusId)
        }
        else 
        {
            return actor.addCondition(img.dataset.statusId, 1, {"flags.core.overlay": true})
        }
    }
    //return this.object.toggleEffect(effect, {overlay});
  }

    activateListeners(html)
    {   
        super.activateListeners(html);
        const effectsTray = html.find(".status-effects");

        effectsTray.off("click", ".effect-control");
        effectsTray.off("contextmenu", ".effect-control");
        
        effectsTray.on("click", ".effect-control", this._onToggleEffect.bind(this));
        effectsTray.on("contextmenu", ".effect-control", event => this._onToggleEffect(event, {overlay: true}));

    }
}

function canvas$1() {

  Hooks.on("canvasReady", (canvas) => {

    if (!(game.modules.get("fxmaster") && game.modules.get("fxmaster").active)) {
      let morrsliebActive = canvas.scene.getFlag("wfrp4e", "morrslieb");
      if (morrsliebActive) {
        if (!canvas.primary.filters)
          canvas.primary.filters = [];
        canvas.primary.filters.push(CONFIG.Morrslieb);
      } 
      else if (canvas.primary.filters?.length)
      {
        // If morrslieb is not active, remove any morrslieb filters
        canvas.primary.filters = canvas.primary.filters.filter(i => !i.morrslieb);
      }
    }

    canvas.hud.token = new WFRPTokenHUD();
  });
}

function controlButtons() {
  /**
   * Add Status right click option for combat tracker combatants
   */
  Hooks.on("getSceneControlButtons", (buttons) => {
    buttons.lighting.tools.morrslieb = {
      button: true,
      icon: "fas fa-circle",
      name: "morrslieb",
      title: game.canvas.scene?.getFlag("wfrp4e", "morrslieb") ? "Morrslieb - Currently On " : "Morrslieb - Currently Off",
      onClick: WFRP_Utility.toggleMorrslieb
    };
  });
}

function settings() {
    Hooks.on("updateSetting", (setting) => {


        // Centralized handling of group advantage updates
        // If group advantage is updated, update advantage of all combatants in the current combat
        // Then, make sure that change is reflected in the counter on the combat tracker (if the update was made by a different user)
        if (setting.key == "wfrp4e.groupAdvantageValues")
        {
            ui.notifications.notify(game.i18n.format("GroupAdvantageUpdated", {players : setting.value.players, enemies : setting.value.enemies}));
            if (game.user.isGM && game.combat)
            {
                // This sorta sucks because there isn't a way to update both actors and synthetic actors in one call
                game.combat.combatants.forEach(c => {
                    if (c.actor.status.advantage.value != setting.value[c.actor.advantageGroup])
                        c.actor.update({"system.status.advantage.value" : setting.value[c.actor.advantageGroup]}, {fromGroupAdvantage : true});
                });
            }
            // Update counter values, can't just use ui.combat because there might be popped out combat trackers
            [ui.combat].concat(foundry.applications.instances.get("combat-popout") || []).forEach(tracker => {
                tracker.element.querySelectorAll(".advantage-group input").forEach((input) => {
                    let group = input.dataset.group;
                    input.value = setting.value[group];
                });
            });
        }
    });

  
}

function i18n () {
    Hooks.on("i18nInit", () => {
        // Localize strings in the  game.wfrp4e.config.object
        for (let obj of game.wfrp4e.config.toTranslate) {
                for (let el in game.wfrp4e.config[obj]) {
                    if (typeof game.wfrp4e.config[obj][el] === "string") {
                        game.wfrp4e.config[obj][el] = game.i18n.localize(game.wfrp4e.config[obj][el]);
                    }
                }
        }

        // System items are created localized, so must be created here
        game.wfrp4e.config.PrepareSystemItems();
    });
}

/**
 * Specialized class to consume and generate from a large list of human name options extracted from
 * http://www.windsofchaos.com/wp-content/uploads/encroachment/book-of-imperial-names.pdf
 * See the `names` folder in the system directory to examine the list of names and options.
 */


class NameGenWfrp {
  static _loadNames() {
    warhammer.utility.log("Loading Names...", true);

    // Surname option 1
    fetch("systems/wfrp4e/names/human_surnames.txt").then(r => r.text()).then(async nameText => {
      this.surnames = [];
      nameText.split("\n").forEach((nameGroup) => this.surnames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Surname option 2 - prefix
    fetch("systems/wfrp4e/names/human_surnames_prefix.txt").then(r => r.text()).then(async nameText => {
      this.surnamePrefixes = [];
      nameText.split("\n").forEach((nameGroup) => this.surnamePrefixes.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Surname option 2 - suffix
    fetch("systems/wfrp4e/names/human_surnames_suffix.txt").then(r => r.text()).then(async nameText => {
      this.surnameSuffixes = [];
      nameText.split("\n").forEach((nameGroup) => this.surnameSuffixes.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Male forenames
    fetch("systems/wfrp4e/names/male_human_forenames.txt").then(r => r.text()).then(async nameText => {
      this.human_male_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.human_male_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Female forenames
    fetch("systems/wfrp4e/names/female_human_forenames.txt").then(r => r.text()).then(async nameText => {
      this.human_female_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.human_female_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // @@@@@@@@@@ DWARF @@@@@@@@@@@@@
    // male forenames
    fetch("systems/wfrp4e/names/male_dwarf_forenames.txt").then(r => r.text()).then(async nameText => {
      this.dwarf_male_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.dwarf_male_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Female forenames
    fetch("systems/wfrp4e/names/female_dwarf_forenames.txt").then(r => r.text()).then(async nameText => {
      this.dwarf_female_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.dwarf_female_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // @@@@@@@@@@ ELF @@@@@@@@@@@@@
    // elf forenames
    fetch("systems/wfrp4e/names/elf_forenames.txt").then(r => r.text()).then(async nameText => {
      this.elf_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    fetch("systems/wfrp4e/names/elf_surnames.txt").then(r => r.text()).then(async nameText => {
      this.elf_surnames = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_surnames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // elf start
    fetch("systems/wfrp4e/names/elf_start.txt").then(r => r.text()).then(async nameText => {
      this.elf_start = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_start.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // elf connector
    fetch("systems/wfrp4e/names/elf_connectors.txt").then(r => r.text()).then(async nameText => {
      this.elf_connectors = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_connectors.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // female elf element
    fetch("systems/wfrp4e/names/male_elf_element.txt").then(r => r.text()).then(async nameText => {
      this.elf_male_element = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_male_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // male elf element
    fetch("systems/wfrp4e/names/female_elf_element.txt").then(r => r.text()).then(async nameText => {
      this.elf_female_element = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_female_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // wood elf end
    fetch("systems/wfrp4e/names/elf_wood_end.txt").then(r => r.text()).then(async nameText => {
      this.elf_wood_end = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_wood_end.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // high elf end
    fetch("systems/wfrp4e/names/elf_high_end.txt").then(r => r.text()).then(async nameText => {
      this.elf_high_end = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_high_end.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // @@@@@@@@@@ Halfling @@@@@@@@@@@@@
    // Halfling start
    fetch("systems/wfrp4e/names/halfling_start.txt").then(r => r.text()).then(async nameText => {
      this.halfling_start = [];
      nameText.split("\n").forEach((nameGroup) => this.halfling_start.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Male ending
    fetch("systems/wfrp4e/names/male_halfling_element.txt").then(r => r.text()).then(async nameText => {
      this.male_halfling_element = [];
      nameText.split("\n").forEach((nameGroup) => this.male_halfling_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Female ending
    fetch("systems/wfrp4e/names/female_halfling_element.txt").then(r => r.text()).then(async nameText => {
      this.female_halfling_element = [];
      nameText.split("\n").forEach((nameGroup) => this.female_halfling_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Halfling surnames
    fetch("systems/wfrp4e/names/halfling_surnames.txt").then(r => r.text()).then(async nameText => {
      this.halfling_surnames = [];
      nameText.split("\n").forEach((nameGroup) => this.halfling_surnames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Halfling nicknames
    fetch("systems/wfrp4e/names/halfling_nicknames.txt").then(r => r.text()).then(async nameText => {
      this.halfling_nicknames = [];
      nameText.split("\n").forEach((nameGroup) => this.halfling_nicknames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
  }

  static human = {
    forename(gender = "male") {
      let names = game.wfrp4e.names[`human_${gender}_Forenames`];
      let size = names.length;
      let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
      let nameGroup = names[roll];

      let base = nameGroup[0];
      let option;
      roll = Math.floor(CONFIG.Dice.randomUniform()*nameGroup.length);
      if (roll != 0)
        option = nameGroup[roll].substr(1);

      return game.wfrp4e.names.evaluateNamePartial(base) + (game.wfrp4e.names.evaluateNamePartial(option || ""));
    },
    surname() {
      if (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1) // Don't use prefix - suffix
      {
        let size = game.wfrp4e.names.surnames.length;
        let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
        let nameGroup = game.wfrp4e.names.surnames[roll];

        let base = nameGroup[0];
        let option;
        roll = Math.floor(CONFIG.Dice.randomUniform()*nameGroup.length);
        if (roll != 0)
          option = nameGroup[roll].substr(1);

        return game.wfrp4e.names.evaluateNamePartial(base) + (game.wfrp4e.names.evaluateNamePartial(option || ""));
      }
      else // Use prefix and suffix surname
      {
        let prefixSize = game.wfrp4e.names.surnamePrefixes.length;
        let suffixSize = game.wfrp4e.names.surnameSuffixes.length;

        let prefixChoice = game.wfrp4e.names.surnamePrefixes[Math.floor(CONFIG.Dice.randomUniform()*prefixSize)][0];
        let suffixChoice = game.wfrp4e.names.surnameSuffixes[Math.floor(CONFIG.Dice.randomUniform()*suffixSize)][0];

        return game.wfrp4e.names.evaluateNamePartial(prefixChoice) + game.wfrp4e.names.evaluateNamePartial(suffixChoice)
      }
    }
  }
  static dwarf = {
    forename(gender = "male") {
      let names = game.wfrp4e.names[`dwarf_${gender}_Forenames`];
      let size = names.length;
      let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
      let nameGroup = names[roll];

      let base = nameGroup[0];
      let option;
      roll = Math.floor(CONFIG.Dice.randomUniform()*(nameGroup.length));
      if (roll != 0)
        option = nameGroup[roll].substr(1);

      return game.wfrp4e.names.evaluateNamePartial(base) + (game.wfrp4e.names.evaluateNamePartial(option || ""));
    },
    surname(gender = "male") {
      let base = this.forename(gender);
      let suffix = "";
      if (gender == "male") {
        suffix = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "snev" : "sson");
      }
      else {
        suffix = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "sniz" : "sdottir");
      }
      return base + suffix;
    }
  }
  static helf = {
    forename(gender="male", type = "helf") {
      let source = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "forename" : "generate");
      if (source == "forename") {
        let names = game.wfrp4e.names[`elf_Forenames`];
        let size = names.length;
        let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
        return names[roll][0];
      }
      else {
        /**
         * 110
         * 010
         * 101
         * 001
         */
        let useConnector = false, useElement = false, useEnd = false;

        switch (Math.floor(CONFIG.Dice.randomUniform() * 4 + 1) == 1) {
          case 1:
            useConnector = true;
            useElement = true;
            break;
          case 2:
            useElement = true;
            break;
          case 3:
            useConnector = true;
            useEnd = true;
            break;
          case 4:
            useEnd = true;
        }


        let start = game.wfrp4e.names.RollArray("elf_start");

        let connector = useConnector ? game.wfrp4e.names.RollArray("elf_connectors") : "";
        let element = useElement ? game.wfrp4e.names.RollArray(`elf_${gender}_element`) : "";

        let elfType = type.includes("h") ? "high" : "wood";
        let end = useEnd ? game.wfrp4e.names.RollArray(`elf_${elfType}_end`) : "";
        return start + connector + element + end;
      }
    },
    surname(){
      return game.wfrp4e.names.RollArray("elf_surnames")
    }
  }

  static welf = {
    forename(gender="male", type="welf"){
      return game.wfrp4e.names.helf.forename(gender, type)
    },
    surname(){
      return game.wfrp4e.names.RollArray("elf_surnames")
    }
  }

  static halfling = {
    forename(gender="male"){
      let nickname = Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? `(${game.wfrp4e.names.RollArray("halfling_nicknames")})` : "";
      return `${game.wfrp4e.names.RollArray("halfling_start")}${game.wfrp4e.names.RollArray(`${gender}_halfling_element`)} ${nickname}`
    },
    surname(){
      return game.wfrp4e.names.RollArray("halfling_surnames")
    }
  }

  /**
   * Generate a Forename + Surname
   * 
   * @param {Object} options species, gender
   */
  static generateName(options = { species: "human" }) {
    if (!options.species) {
      options.species = "human";
    }
    if (options.species)
      options.species = options.species.toLowerCase();
    if (options.gender)
      options.gender = options.gender.toLowerCase();

    if (options.gender == game.i18n.localize("CHARGEN.Details.Male").toLowerCase())
      options.gender = "male";
    else if (options.gender == game.i18n.localize("CHARGEN.Details.Female").toLowerCase())
      options.gender = "female";

    // If gender not recognize, remove it (roll male or female names randomly)
    if (!["male", "female"].includes(options.gender))
      delete options.gender;

    if (!options.gender) // Generate male/female randomly
      options.gender = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "male" : "female");

    return this[options.species].forename(options.gender) + " " + this[options.species].surname(options.gender)
  }

  /**
   * Parses down a name the partials given.
   * 
   * Name partial example: "Bar(f)sheim(er)" - randomly decide what to include within parentheses.
   * 
   * @param {String} namePartial A name partial is the inner choices
   */
  static evaluateNamePartial(namePartial) {
    var options = Array.from(namePartial.matchAll(/\((.+?)\)/g));
    for (let option of options) {
      if (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1) {
        namePartial = namePartial.replace(option[0], this.evaluateChoices(option[1]));
      }
      else {
        namePartial = namePartial.replace(option[0], "");
      }
    }
    return this.evaluateChoices(namePartial)
  }

  /**
   * A name is typically followed by choices of suffixes to use, separated by a comma.
   * 
   * Example of choices - "Aver, -land(er), -lund(er)" - Aver is not a choice, the other two are choices, however at least one of them is required.
   * 
   * @param {String} choiceString String of name chocies
   */
  static evaluateChoices(choiceString) {
    if (!choiceString)
      return choiceString
    let choices = Array.from(choiceString.matchAll(/(\w+)[\/]*/g));
    let choice = Math.floor(CONFIG.Dice.randomUniform()*choices.length);
    return choices[choice][1]
  }

  static RollArray(arrayName) {
    let elements = this[arrayName];
    let size = elements.length;
    let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
    return elements[roll][0]
  }
}

class TableSettings extends HandlebarsApplicationMixin(ApplicationV2)
{
    static DEFAULT_OPTIONS = {
        tag: "form",
        classes: ["warhammer", "standard-form", "table-settings"],
        window: {
            title: "Table Settings Configuration",
            resizable : true,
        },
        position : {
            width: 400
        },
        form: {
            submitOnChange: true,
            handler: this._onSubmit
        }
    }

    /** @override */
    static PARTS = {
        form: {
            template: "systems/wfrp4e/templates/apps/table-settings.hbs",
            scrollable: [""]
        }
    };

    static #schema = new foundry.data.fields.SchemaField({
        species : new foundry.data.fields.StringField({initial : "FM6ASUoNX21MHuWa", label : "SETTINGS.TABLE_species"}),
        minormis : new foundry.data.fields.StringField({initial : "iPVwX0ul6lHVbKSX", label : "SETTINGS.TABLE_minormis"}),
        majormis : new foundry.data.fields.StringField({initial : "we8Vo5GC3ZsDI7aA", label : "SETTINGS.TABLE_majormis"}),
        mutatephys : new foundry.data.fields.StringField({initial : "YQ5XdjikeSiwo8fn", label : "SETTINGS.TABLE_mutatephys"}),
        mutatemental : new foundry.data.fields.StringField({initial : "5HKnpyOk4XDPdZ7V", label : "SETTINGS.TABLE_mutatemental"}),
        oops : new foundry.data.fields.StringField({initial : "MWkeER1iuwAJASNo", label : "SETTINGS.TABLE_oops"}),
        wrath : new foundry.data.fields.StringField({initial : "CcKYnmbQyRzGkrFy", label : "SETTINGS.TABLE_wrath"}),
        doom : new foundry.data.fields.StringField({initial : "led1vSPKcqMpS6jp", label : "SETTINGS.TABLE_doom"}),
        critarm : new foundry.data.fields.StringField({initial : "JYX8E8WgNb2em8g3", label : "SETTINGS.TABLE_critarm"}),
        critleg : new foundry.data.fields.StringField({initial : "j2joGAVBNJgS1G1g", label : "SETTINGS.TABLE_critleg"}),
        crithead : new foundry.data.fields.StringField({initial : "7KReueNRjaI6dVLk", label : "SETTINGS.TABLE_crithead"}),
        critbody : new foundry.data.fields.StringField({initial : "CUIX4e2hiHdSoJ64", label : "SETTINGS.TABLE_critbody"}),
    })

    static get schema()
    {
        Hooks.call("wfrp4e.tableSettingsSchema", this.#schema);
        return this.#schema
    }

    async _prepareContext(options) {
        let context = await super._prepareContext(options);
        let settings = game.settings.get("wfrp4e", "tableSettings");
        context.settings = {};

        for (let setting in settings)
        {
            context.settings[setting] = {
                field : this.constructor.schema.fields[setting],
                value : settings[setting],
                choices : this.getTableChoices(setting)
            };
        }

        return context
    }

    getTableChoices(key)
    {
        let choices = {};
        let tables = game.tables.filter(i => i.getFlag("wfrp4e", "key") == key);


        // Add tables without a column 
        for(let t of tables.filter(i => !i.getFlag("wfrp4e", "column")))
        {
            choices[t.id] = t.name;
        }

        let columns = tables.filter(i => i.getFlag("wfrp4e", "column"));
        if (columns.length)
        {
            choices[columns.map(i => i.id).join(",")] = columns[0].name.split("-")[0];
        }
        return choices
    }


    static async _onSubmit(event, form, formData) {
        return game.settings.set("wfrp4e", "tableSettings", formData.object)
    }

  

}

foundry.data.fields;

class WFRP4eThemeConfig extends HandlebarsApplicationMixin(ApplicationV2)
{
  static DEFAULT_OPTIONS = {
    id: "theme-config",
    tag: "form",
    window: {
      title: "WH.Theme.Config",
      contentClasses: ["standard-form"]
    },
    form: {
      closeOnSubmit: true,
      handler: this.onSubmit
    },
    position: { width: 540 },
    actions: {
      reset: this.onReset
    }
  };

  /** @override */
  static PARTS = {
    form: {
      template: "systems/wfrp4e/templates/apps/theme-config.hbs",
      scrollable: [""]
    },
    footer: {
      template: "templates/generic/form-footer.hbs"
    }
  };

  static get schema() {
    return WFRP4eThemeConfig.#schema;
  }

  static #schema = new foundry.data.fields.SchemaField({

    actor: new foundry.data.fields.SchemaField({
      enabled: new foundry.data.fields.BooleanField({ initial: true }),
      font: new foundry.data.fields.StringField({ required: true, initial: "classic", choices: { "classic": "WH.Theme.Font.Classic", "readable": "WH.Theme.Font.Readable" } })
    }),
    item: new foundry.data.fields.SchemaField({
      enabled: new foundry.data.fields.BooleanField({ initial: true }),
      font: new foundry.data.fields.StringField({ required: true, initial: "classic", choices: { "classic": "WH.Theme.Font.Classic", "readable": "WH.Theme.Font.Readable" } })
    }),
    journal: new foundry.data.fields.SchemaField({
      enabled: new foundry.data.fields.BooleanField({ initial: true }),
      font: new foundry.data.fields.StringField({ required: true, initial: "classic", choices: { "classic": "WH.Theme.Font.Classic", "readable": "WH.Theme.Font.Readable" } })
    }),
    sidebar: new foundry.data.fields.SchemaField({
      enabled: new foundry.data.fields.BooleanField({ initial: true }),
      font: new foundry.data.fields.StringField({ required: true, initial: "classic", choices: { "classic": "WH.Theme.Font.Classic", "readable": "WH.Theme.Font.Readable" } })
    }),
    apps: new foundry.data.fields.SchemaField({
      enabled: new foundry.data.fields.BooleanField({ initial: true }),
      font: new foundry.data.fields.StringField({ required: true, initial: "classic", choices: { "classic": "WH.Theme.Font.Classic", "readable": "WH.Theme.Font.Readable" } })
    }),

  });

  /**
   * The current setting value
   * @type {GameUIConfiguration}
   */
  #setting;

  /**
   * Track whether the schema has already been localized.
   * @type {boolean}
   */
  static #localized = false;

  /* -------------------------------------------- */

  /** @inheritDoc */
  async _preFirstRender(_context, _options) {
    await super._preFirstRender(_context, _options);
    if (!WFRP4eThemeConfig.#localized) {
      foundry.helpers.Localization.localizeDataModel({ schema: WFRP4eThemeConfig.#schema }, {
        prefixes: ["WH.Theme"],
          prefixPath: "wfrp4e.theme."
      });
      WFRP4eThemeConfig.#localized = true;
    }
  }

  /* -------------------------------------------- */

  /** @override */
  async _prepareContext(options) {
    if (options.isFirstRender) this.#setting = await game.settings.get("wfrp4e", "theme");
    return {
      setting: this.#setting,
      fields: WFRP4eThemeConfig.#schema.fields,
      buttons: [
        { type: "reset", label: "Reset", icon: "fa-solid fa-undo", action: "reset" },
        { type: "submit", label: "Save Changes", icon: "fa-solid fa-save" }
      ]
    };
  }

  _onChangeForm(_formConfig, _event) {
    const formData = new foundry.applications.ux.FormDataExtended(this.form);
    this.#setting = WFRP4eThemeConfig.#cleanFormData(formData);
    this.setThemeOnActiveSheets();
    this.render();
  }

  /** @inheritDoc */
  _onClose(options) {
    super._onClose(options);
    if (!options.submitted) game.configureUI(this.#setting);
  }

  setThemeOnActiveSheets()
  {
    Array.from(foundry.applications.instances).map(i => i[1]).filter(i => i instanceof WarhammerActorSheetV2 || i instanceof WarhammerItemSheetV2).forEach(sheet => {
      sheet.setTheme(this.#setting);
    });

    Array.from(foundry.applications.instances).map(i => i[1]).filter(i => i.element.classList.contains("journal-sheet")).forEach(sheet => {
      this.setThemeOnElement(sheet.element, this.#setting.journal);
    });

    this.setThemeOnElement(ui.sidebar.element, this.#setting.sidebar);
    // Consider chat notifications to be part of sidebar
    this.setThemeOnElement(document.body.querySelector("#chat-notifications"), this.#setting.sidebar);
    
    this.setThemeOnElement(document.body, this.#setting.apps);
  }

  setThemeOnElement(element, theme)
  {
    if (theme.enabled)
    {
      element.classList.remove("no-theme");

      if (theme.font == "classic")
      {
        element.classList.add("classic-font");
      }
      else
      {
        element.classList.remove("classic-font");
      }
    }
    else
    {
      element.classList.add("no-theme");
      element.classList.remove("classic-font");
    }
  }

  /**
   * Clean the form data, accounting for the field names assigned by game.settings.register on the schema.
   * @param {FormDataExtended} formData
   * @returns {GameUIConfiguration}
   */
  static #cleanFormData(formData) {
    return WFRP4eThemeConfig.#schema.clean(foundry.utils.expandObject(formData.object).wfrp4e.theme);
  }

  /**
   * Submit the configuration form.
   * @this {UIConfig}
   * @param {SubmitEvent} event
   * @param {HTMLFormElement} form
   * @param {FormDataExtended} formData
   * @returns {Promise<void>}
   */
  static async onSubmit(event, form, formData) {
    await game.settings.set("wfrp4e", "theme", this.#setting);
  }
}

class HomebrewConfig extends HandlebarsApplicationMixin(ApplicationV2)
{
    static DEFAULT_OPTIONS = {
        tag: "form",
        classes: ["warhammer", "standard-form", "homebrew-config"],
        window: {
            title: "Homebrew Settings Configuration",
            resizable : true,
        },
        position : {
            width: 400
        },
        form: {
            submitOnChange: true,
            handler: this._onSubmit
        }
    }


    static #schema = new foundry.data.fields.SchemaField({

        channelingNegativeSLTests : new foundry.data.fields.BooleanField({label : "SETTINGS.ChannelingNegativeSL", hint : "SETTINGS.ChannelingNegativeSLHint"}),
        advantageBonus : new foundry.data.fields.NumberField({initial : 10, label : "SETTINGS.AdvantageBonus", hint : "SETTINGS.AdvantageBonusHint"}),
        uiaCritsMod : new foundry.data.fields.NumberField({initial: 10, label : "SETTINGS.UIACritsMod", hint : "SETTINGS.UIACritsModHint"}),
        partialChannelling : new foundry.data.fields.BooleanField({label : "SETTINGS.PartialChannelling", hint : "SETTINGS.MooAdvantageHint"}),
        channellingIngredients : new foundry.data.fields.BooleanField({label : "SETTINGS.ChannellingIngredients", hint : "SETTINGS.MooDifficultyHint"}),
        unofficialgrimoire : new foundry.data.fields.BooleanField({label : "SETTINGS.UnofficialGrimoire", hint : "SETTINGS.MooCritsFumblesHint"}),
        
        mooAdvantage : new foundry.data.fields.BooleanField({label : "SETTINGS.MooAdvantage", hint : "SETTINGS.MooAdvantageHint"}),
        mooDifficulty : new foundry.data.fields.BooleanField({label : "SETTINGS.MooDifficulty", hint : "SETTINGS.MooDifficultyHint"}),
        // mooCritsFumbles : new foundry.data.fields.BooleanField({label : "SETTINGS.MooCritsFumbles", hint : "SETTINGS.MooCritsFumblesHint"}),
        mooConditions : new foundry.data.fields.BooleanField({label : "SETTINGS.MooConditions", hint : "SETTINGS.MooConditionsHint"}),
        mooConditionTriggers : new foundry.data.fields.BooleanField({label : "SETTINGS.MooConditionTriggers", hint : "SETTINGS.MooConditionTriggersHint"}),
        mooCritModifiers : new foundry.data.fields.BooleanField({label : "SETTINGS.MooCritModifiers", hint : "SETTINGS.MooCritModifiersHint"}),
        mooSLDamage : new foundry.data.fields.BooleanField({label : "SETTINGS.MooSLDamage", hint : "SETTINGS.MooSLDamageHint"}),
        mooRangedDamage : new foundry.data.fields.BooleanField({label : "SETTINGS.MooRangedDamage", hint : "SETTINGS.MooRangedDamageHint"}),
        mooMagicAdvantage : new foundry.data.fields.BooleanField({label : "SETTINGS.MooMagicAdvantage", hint : "SETTINGS.MooMagicAdvantageHint"}),
        mooOvercasting : new foundry.data.fields.BooleanField({label : "SETTINGS.MooOvercasting", hint : "SETTINGS.MooOvercastingHint"}),
        mooCatastrophicMiscasts : new foundry.data.fields.BooleanField({label : "SETTINGS.MooCatastrophicMiscasts", hint : "SETTINGS.MooCatastrophicMiscastsHint"}),
        mooCriticalChannelling : new foundry.data.fields.BooleanField({label : "SETTINGS.MooCriticalChannelling", hint : "SETTINGS.MooCriticalChannellingHint"}),
        mooCastAfterChannelling : new foundry.data.fields.BooleanField({label : "SETTINGS.MooCastAfterChannelling", hint : "SETTINGS.MooCastAfterChannellingHint"}),
        mooPenetrating : new foundry.data.fields.BooleanField({label : "SETTINGS.MooPenetrating", hint : "SETTINGS.MooPenetratingHint"}),
        mooQualities : new foundry.data.fields.BooleanField({label : "SETTINGS.MooQualities", hint : "SETTINGS.MooQualitiesHint"}),
        mooShieldAP : new foundry.data.fields.BooleanField({label : "SETTINGS.MooShieldAP", hint : "SETTINGS.MooShieldAPHint"}),
        mooCriticalMitigation : new foundry.data.fields.BooleanField({label : "SETTINGS.MooCriticalMitigation", hint : "SETTINGS.MooCriticalMitigationHint"}),
        mooRangeBands : new foundry.data.fields.BooleanField({label : "SETTINGS.MooRangeBands", hint : "SETTINGS.MooRangeBandsHint"}),
        mooSizeDamage : new foundry.data.fields.BooleanField({label : "SETTINGS.MooSizeDamage", hint : "SETTINGS.MooSizeDamageHint"}),
        mooHomebrewItemChanges : new foundry.data.fields.BooleanField({label : "SETTINGS.MooHomebrewItems", hint : "SETTINGS.MooHomebrewItemHint"})
    })

    /** @override */
    static PARTS = {
        form: {
            template: "systems/wfrp4e/templates/apps/homebrew-settings.hbs",
            scrollable: [""]
        }
    };

    static get schema()
    {
        return this.#schema
    }

    async _prepareContext(options) {
        let context = await super._prepareContext(options);
        context.source = game.settings.get("wfrp4e", "homebrew");
        context.schema = this.constructor.schema;
        return context;
    }


    static async _onSubmit(event, form, formData) 
    {
        game.settings.set("wfrp4e", "homebrew", formData.object);
    }

}

/**
 * This fully supports movement actions: walk, climb, crawl, fly, swim, blink and displace
 *
 * @todo Potentially in the future it could be worth considering extending the
 *      {@link foundry.data.regionBehaviors.ModifyMovementCostRegionBehaviorType} region behaviour to define a "biome"
 *      or "terrain type" (additional <select> input on top of sliders) and letting traits and talents "ignore" the terrain.
 */
class TokenRulerWFRP extends foundry.canvas.placeables.tokens.TokenRuler {
  static STYLES = {
    immobile: {color: 0x220000, alpha: 0.6},
    move: {color: 0x009900},
    stride: {color: 0xaaaa00},
    exceed: {color: 0x990000},
  };

  /** @override */
  static WAYPOINT_LABEL_TEMPLATE = "systems/wfrp4e/templates/hud/waypoint-label.hbs";

  /** @override */
  _getWaypointLabelContext(waypoint, state) {
    const context = super._getWaypointLabelContext(waypoint, state);
    if (!context) return;

    if (!this.token.actor) return context;

    const iterateStatuses = (id, label, icon, cssClass) => {
      if (!this.token.document.hasStatusEffect(id)) return;

      const status = CONFIG.statusEffects.find(s => s.id === id);
      if (!context.additional) {
        context.additional = {
          label: game.i18n.localize(label),
          imgs: [],
          icon,
          cssClass,
        };
      }

      context.additional.imgs.push(status.img);
    };

    const immobileStatuses = ["surprised", "entangled", "unconscious"];
    const reminderStatuses = ["prone", "engaged", "stunned"];

    for (const id of immobileStatuses)
      iterateStatuses(id, "TOKEN.MOVEMENT.Status.immobile", "fas fa-ban", "error");

    if (!context.additional)
      for (const id of reminderStatuses)
        iterateStatuses(id, "TOKEN.MOVEMENT.Status.restricted", "fas fa-triangle-exclamation", "warning");

    return context;
  }

  /** @override */
  _getGridHighlightStyle(waypoint, offset) {
    const style = super._getGridHighlightStyle(waypoint, offset);
    if (!this.token.actor) return style;
    if (["blink", "displace"].includes(waypoint.action)) return style;

    const movement = this.token.actor.system.movementDistance[waypoint.action] || 0;
    const maxMovement = typeof movement === "object" ? movement[1] : movement;

    const cost = waypoint.measurement.cost;

    if (cost === 0) return style;
    if (maxMovement <= 0) return this.constructor.STYLES.immobile;
    if (maxMovement < cost) return this.constructor.STYLES.exceed;

    // 2-step gradient
    let color = this.constructor.STYLES.move;
    if (Array.isArray(movement) && movement[0] < cost)
      color = this.constructor.STYLES.stride;

    return foundry.utils.mergeObject(style, color);
  }

  /** @override */
  _getSegmentStyle(waypoint) {
    const scale = canvas.dimensions.uiScale;
    if  (canvas.scene.grid.type != 0) {
	   return {width: 4 * scale, color: game.user.color, alpha: 1};
    } else {
      const movement = this.token.actor.system.movementDistance[waypoint.action] || 0;
      const maxMovement = typeof movement === "object" ? movement[1] : movement;
      const cost = waypoint.measurement.cost;

      // 2-step gradient, different color for immobile, blink and displace
      let color = this.constructor.STYLES.move.color;
      if (movement[0] < cost && cost <= maxMovement )
        color = this.constructor.STYLES.stride.color;
      else if (maxMovement < cost)
        color = this.constructor.STYLES.exceed.color;
      if  (maxMovement <= 0)
        color = this.constructor.STYLES.immobile.color;
      if (["blink", "displace"].includes(waypoint.action))
        color = 0x0000aa;
	  return {width: 4 * scale, color: color, alpha: 1};
      }
    }
}

let debounceReload = foundry.utils.debounce(() => {
  window.location.reload();
}, 100);

function init() {
  /**
   * Init function loads tables, registers settings, and loads templates
   */
  Hooks.once("init", () => {

    TravelDistanceWFRP4e.loadTravelData();

    game.settings.register("wfrp4e", "systemMigrationVersion", {
      name: "System Migration Version",
      scope: "world",
      config: false,
      type: String,
      default: 0
    });

    
    game.settings.registerMenu("wfrp4e", "themeConfig", {
      name: "WH.Theme.Config",
      label : "WH.Theme.ConfigButton",
      hint : "WH.Theme.ConfigHint",
      icon: "fa-solid fa-table-layout",
      scope: "user",
      config: true,
      type: WFRP4eThemeConfig
    });


    game.settings.registerMenu("wfrp4e", "homebrewConfig", {
      name: "SETTINGS.Menu.HouseRules",
      label: "SETTINGS.Menu.HouseRulesLabel",
      hint: "SETTINGS.Menu.HouseRulesHint",
      icon: "fa-solid fa-gears",
      type: HomebrewConfig,
      restricted: true
  });

  game.settings.registerMenu("wfrp4e", "tableSettings", {
    name: "SETTINGS.Menu.TableSettings",
    label: "SETTINGS.Menu.TableSettingsLabel",
    hint: "SETTINGS.Menu.TableSettingsHint",
    icon: "fa-solid fa-list",
    type: TableSettings,
    restricted: true
});

    game.settings.register("wfrp4e", "theme", {
      name: "Theme",
      scope: "client",
      config: false,
      type: WFRP4eThemeConfig.schema
    });

    game.settings.register("wfrp4e", "homebrew", {
      name: "Hombrew Settings",
      scope: "world",
      config: false,
      type: HomebrewConfig.schema
    });


    // Register initiative rule
    game.settings.register("wfrp4e", "initiativeRule", {
      name: "SETTINGS.InitRule",
      hint: "SETTINGS.InitHint",
      scope: "world",
      config: true,
      default: "default",
      type: String,
      choices: {
        "default": "SETTINGS.InitDefault",
        "sl": "SETTINGS.InitSL",
        "d10Init": "SETTINGS.InitD10",
        "d10InitAgi": "SETTINGS.InitD10Agi"
      },
      onChange: rule => _setWfrp4eInitiative(rule)
    });
    _setWfrp4eInitiative(game.settings.get("wfrp4e", "initiativeRule"));


    function _setWfrp4eInitiative(initMethod) {
      let formula;
      switch (initMethod) {
        case "default":
          formula = "@characteristics.i.value + @characteristics.ag.value/100";
          break;

        case "sl":
          formula = "(floor(@characteristics.i.value / 10) - floor(1d100/10))";
          break;

        case "d10Init":
          formula = "1d10 + @characteristics.i.value";
          break;

        case "d10InitAgi":
          formula = "1d10 + @characteristics.i.bonus + @characteristics.ag.bonus";
          break;
      }

      let decimals = (initMethod == "default") ? 2 : 0;
      CONFIG.Combat.initiative = {
        formula: formula,
        decimals: decimals
      };
    }

    // Register Advantage Cap
    game.settings.register("wfrp4e", "advantagemax", {
      name: "SETTINGS.AdvantageMax",
      hint: "SETTINGS.AdvantageMaxHint",
      scope: "world",
      config: true,
      default: 10,
      type: Number
    });

    // Register Advantage cap
    game.settings.register("wfrp4e", "capAdvantageIB", {
      name: "SETTINGS.CapAdvIB",
      hint: "SETTINGS.CapAdvIBHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Automatic Success threshold
    game.settings.register("wfrp4e", "automaticSuccess", {
      name: "SETTINGS.AutomaticSuccess",
      hint: "SETTINGS.AutomaticSuccessHint",
      scope: "world",
      config: true,
      default: 5,
      type: Number
    });

    // Register Automatic Success threshold
    game.settings.register("wfrp4e", "automaticFailure", {
      name: "SETTINGS.AutomaticFailure",
      hint: "SETTINGS.AutomaticFailureHint",
      scope: "world",
      config: true,
      default: 96,
      type: Number
    });

    // Register Fast SL rule
    game.settings.register("wfrp4e", "SLMethod", {
      name: "SETTINGS.SLMethod",
      hint: "SETTINGS.SLMethodHint",
      scope: "world",
      config: true,
      default: "default",
      choices: {
        "default": "SETTINGS.SLDefault",
        "fast": "SETTINGS.SLFast",
        "dos": "SETTINGS.SLDOS",
      },
      type: String
    });


    // // Register Fast SL rule
    // game.settings.register("wfrp4e", "fastSL", {
    //   name: "SETTINGS.FastSL",
    //   hint: "SETTINGS.FastSLHint",
    //   scope: "world",
    //   config: true,
    //   default: false,
    //   type: Boolean
    // });

    // Register Tests above 100% Rule
    game.settings.register("wfrp4e", "testAbove100", {
      name: "SETTINGS.TestsAbove100",
      hint: "SETTINGS.TestsAbove100Hint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Criticals/Fumbles on all tests
    game.settings.register("wfrp4e", "criticalsFumblesOnAllTests", {
      name: "SETTINGS.CriticalsFumblesAllTests",
      hint: "SETTINGS.CriticalsFumblesAllTestsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });


    // Register Extended Tests
    game.settings.register("wfrp4e", "extendedTests", {
      name: "SETTINGS.ExtendedTests",
      hint: "SETTINGS.ExtendedTestsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });
    // Limit Equipped Items
    game.settings.register("wfrp4e", "limitEquippedWeapons", {
      name: "SETTINGS.LimitEquippedWeapons",
      hint: "SETTINGS.LimitEquippedWeaponsHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Test auto-fill
    game.settings.register("wfrp4e", "autoFillAdvantage", {
      name: "SETTINGS.AutoFillAdv",
      hint: "SETTINGS.AutoFillAdvHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register default test difficulty
    game.settings.register("wfrp4e", "testDefaultDifficulty", {
      name: "SETTINGS.TestDialogDefaultDifficulty",
      hint: "SETTINGS.TestDialogDefaultDifficultyHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Round Summary
    game.settings.register("wfrp4e", "displayRoundSummary", {
      name: "SETTINGS.RoundSummary",
      hint: "SETTINGS.RoundSummaryHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Focus on Turn Start
    game.settings.register("wfrp4e", "focusOnTurnStart", {
      name: "SETTINGS.FocusTurnStart",
      hint: "SETTINGS.FocusTurnStartHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Hiding Test Data
    game.settings.register("wfrp4e", "hideTestData", {
      name: "SETTINGS.HideTestData",
      hint: "SETTINGS.HideTestDataHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    game.settings.register("wfrp4e", "weaponLength", {
      name: "SETTINGS.WeaponLength",
      hint: "SETTINGS.WeaponLengthHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    game.settings.register("wfrp4e", "rangeAutoCalculation", {
      name: "SETTINGS.RangeAutoCalculation",
      hint: "SETTINGS.RangeAutoCalculationHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    game.settings.register("wfrp4e", "playerBrowser", {
      name: "SETTINGS.PlayerBrowser",
      hint: "SETTINGS.PlayerBrowserHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "playerExperienceEditing", {
      name: "SETTINGS.PlayerExperienceEditing",
      hint: "SETTINGS.PlayerExperienceEditingHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    // Register Advantage cap
    game.settings.register("wfrp4e", "soundPath", {
      name: "SETTINGS.SoundEffects",
      hint: "SETTINGS.SoundEffectsHint",
      scope: "world",
      config: true,
      default: "systems/wfrp4e/sounds/",
      type: String
    });

    game.settings.register("wfrp4e", "customCursor", {
      name: "SETTINGS.CustomCursor",
      hint: "SETTINGS.CustomCursorHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    game.settings.register("wfrp4e", "throwMoney", {
      name: "SETTINGS.ThrowMoney",
      hint: "SETTINGS.ThrowMoneyHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });
    game.settings.register("wfrp4e", "uiaCrits", {
      name: "SETTINGS.UIACrits",
      hint: "SETTINGS.UIACritsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });
    game.settings.register("wfrp4e", "uiaShields", {
      name: "SETTINGS.UIAShields",
      hint: "SETTINGS.UIAShieldsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "uiaBleeding", {
      name: "SETTINGS.UIABleeding",
      hint: "SETTINGS.UIABleedingHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "tables", {
      scope: "world",
      config: false,
      default: {},
      type: Object
    });

    game.settings.register("wfrp4e", "bugReportName", {
      scope: "world",
      config: false,
      default: "",
      type: String
    });

    game.settings.register("wfrp4e", "tableVisibility", {
      scope: "world",
      config: false,
      default: {},
      type: Object
    });


    game.settings.register("wfrp4e", "tableRollMode", {
      scope: "client",
      config: false,
      default: {},
      type: Object
    });

    game.settings.register("wfrp4e", "useGroupAdvantage", {
      name: "SETTINGS.UseGroupAdvantage",
      hint: "SETTINGS.UseGroupAdvantageHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean, 
      onChange: debounceReload,
    });

    game.settings.register("wfrp4e", "groupAdvantageValues", {
      scope: "world",
      config: false,
      default: {players: 0, enemies : 0},
      type: Object
    });



    game.settings.register("wfrp4e", "useWoMOvercast", {
      name: "SETTINGS.useWoMOvercast",
      hint: "SETTINGS.useWoMOvercastHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "useWoMChannelling", {
      name: "SETTINGS.useWoMChannelling",
      hint: "SETTINGS.useWoMChannellingHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "useWoMInfluences", {
      name: "SETTINGS.useWoMInfluences",
      hint: "SETTINGS.useWoMInfluencesHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "grudges", {
      name: "Grudges",
      scope: "world",
      config: false,
      default: [],
      type: Array
    });

    game.settings.register("wfrp4e", "tableSettings", {
      name: "SETTINGS.TableSettings",
      hint: "SETTINGS.TableSettings",
      scope: "world",
      config: false,
      type: TableSettings.schema

    });

    // Pre-load templates
    foundry.applications.handlebars.loadTemplates([
      "systems/wfrp4e/templates/sheets/partials/container-contents.hbs",
      "systems/wfrp4e/templates/partials/armour-location.hbs",
      "systems/wfrp4e/templates/partials/item-container.hbs",
      "systems/wfrp4e/templates/partials/qualities-flaws.hbs",
      "systems/wfrp4e/templates/partials/overcasts.hbs",
      "systems/wfrp4e/templates/partials/wom-overcasts.hbs",
      "systems/wfrp4e/templates/partials/manual-scripts.hbs",
      "systems/wfrp4e/templates/partials/list-effect.hbs",
      "systems/wfrp4e/templates/chat/roll/test-card.hbs",
      "systems/wfrp4e/templates/chat/help/chat-command-display-info.hbs",
    ]);

    foundry.applications.handlebars.loadTemplates({
      sheetButtons: "systems/wfrp4e/templates/sheets/partials/sheet-effect-buttons.hbs",
      aspects: "systems/wfrp4e/templates/partials/aspect-list.hbs",
      aspectsV2: "systems/wfrp4e/templates/sheets/partials/aspect-list.hbs",
      meleeWeapons: "systems/wfrp4e/templates/sheets/partials/melee-weapons.hbs",
      rangedWeapons: "systems/wfrp4e/templates/sheets/partials/ranged-weapons.hbs",
      armourLocation: "systems/wfrp4e/templates/sheets/partials/armour-location.hbs",
      creatureArmour: "systems/wfrp4e/templates/sheets/partials/creature-armour.hbs",
      vehicleArmour: "systems/wfrp4e/templates/sheets/partials/vehicle-armour.hbs",
      itemProperties: "systems/wfrp4e/templates/sheets/partials/item-properties.hbs",
      extraOvercast: "systems/wfrp4e/templates/sheets/partials/extra-overcast.hbs",
      "chargen.species.preview": 'systems/wfrp4e/templates/apps/chargen/partials/species-preview.hbs'
    });

    // Load name construction from files
    NameGenWfrp._loadNames();

      CONFIG.Morrslieb = new PIXI.filters.AdjustmentFilter({ green: 0.5, red: 0.25, blue: 0.25, morrslieb: true });
      CONFIG.MorrsliebObject = {
        color: { value:"#4cb53a", apply: true },
        gamma: 1.0,
        contrast: 1.0,
        brightness: 1.0,
        saturation: 0.2
    };

    CONFIG.fontDefinitions.CaslonAntique = {editor : true, fonts : []};

    CONFIG.canvasTextStyle = new PIXI.TextStyle({
      fontFamily: "CaslonAntique",
      fontSize: 36,
      fill: "#FFFFFF",
      stroke: '#111111',
      strokeThickness: 1,
      dropShadow: true,
      dropShadowColor: "#000000",
      dropShadowBlur: 4,
      dropShadowAngle: 0,
      dropShadowDistance: 0,
      align: "center",
      wordWrap: false
    });

    // Keep a list of actors that need to prepareData after 'ready' (generally those that rely on other actor data - passengers/mounts)
    game.wfrp4e.postReadyPrepare = [];

    // Token Ruler data
    delete CONFIG.Token.movement.actions.burrow;
    delete CONFIG.Token.movement.actions.jump;
    delete CONFIG.Token.movement.actions.climb.getCostFunction;
    delete CONFIG.Token.movement.actions.crawl.getCostFunction;
    CONFIG.Token.movement.actions.climb.canSelect = (token) => token?.actor?.system.canClimb;
    CONFIG.Token.movement.actions.crawl.canSelect = (token) => token?.actor?.system.canCrawl;
    CONFIG.Token.movement.actions.fly.canSelect = (token) => token?.actor?.system.canFly;
    CONFIG.Token.movement.actions.swim.canSelect = (token) => token?.actor?.system.canSwim;
    CONFIG.Token.rulerClass = TokenRulerWFRP;
  });
}

function FoundryOverrides () {

  // Modify the initiative formula depending on whether the actor has ranks in the Combat Reflexes talent
  Combatant.prototype._getInitiativeFormula = function () {
    const actor = this.actor;
    let initiativeFormula = CONFIG.Combat.initiative.formula || game.system.initiative;

    if (!actor) return initiativeFormula;



    let args = { initiative: initiativeFormula };
    actor.runScripts("getInitiativeFormula", args);

    return args.initiative;
  };

    /**
   * Draw the active effects and overlay effect icons which are present upon the Token
   */
     foundry.canvas.placeables.Token.prototype._drawEffects = async function()
     {
        this.effects.renderable = false;

        // Clear Effects Container
        this.effects.removeChildren().forEach(c => c.destroy());
        this.effects.bg = this.effects.addChild(new PIXI.Graphics());
        this.effects.bg.zIndex = -1;
        this.effects.overlay = null;
    
        // Categorize effects
        const activeEffects = this.actor?.temporaryEffects || [];
        const overlayEffect = activeEffects.findLast(e => e.img && e.getFlag("core", "overlay"));
    
        // Draw effects
        const promises = [];
        for ( const [i, effect] of activeEffects.entries() ) {
          if ( !effect.img ) continue;
          const promise = effect === overlayEffect
            ? this._drawOverlay(effect.img, effect.tint)
            : this._drawEffect(effect.img, effect.tint, effect.system.condition.value);
          promises.push(promise.then(e => {
            if ( e ) e.zIndex = i;
          }));
        }
        await Promise.allSettled(promises);
    
        this.effects.sortChildren();
        this.effects.renderable = true;
        this.renderFlags.set({refreshEffects: true});
       };
    
    /* -------------------------------------------- */

    /**
     * Draw a status effect icon
     * @param {string} src
     * @param {number|null} tint
     * @returns {Promise<PIXI.Sprite|undefined>}
     * @protected
     */
    foundry.canvas.placeables.Token.prototype._drawEffect = async function(src, tint, value) {
      if ( !src ) return;
      const tex = await foundry.canvas.loadTexture(src, {fallback: "icons/svg/hazard.svg"});
      const icon = new PIXI.Sprite(tex);
      icon.tint = tint ?? 0xFFFFFF;
      // Add WFRPE Counter
      if(value)
      {
        let text = new foundry.canvas.containers.PreciseText(value, game.wfrp4e.config.effectTextStyle);
        text.x = icon.x + icon.width * 0.1;
        text.y = icon.y + icon.height * 0.05;
        text.scale.x = 20;
        text.scale.y = 20;
        icon.addChild(text);
      }
      return this.effects.addChild(icon);
    };
}

function MooHouseRules () {

  let config = game.wfrp4e.config;


  if (game.settings.get("wfrp4e", "homebrew").mooDifficulty) {

    config.difficultyModifiers["veasy"] = 40;
    config.difficultyModifiers["easy"] = 30;
    config.difficultyModifiers["average"] = 20;
    config.difficultyModifiers["challenging"] = 0;
    config.difficultyModifiers["difficult"] = -20;
    config.difficultyModifiers["hard"] = -30;
    config.difficultyModifiers["vhard"] = -40;

    config.difficultyLabels["veasy"] = game.i18n.localize ("DIFFICULTY.MooVEasy");
    config.difficultyLabels["easy"] = game.i18n.localize ("DIFFICULTY.MooEasy");
    config.difficultyLabels["average"] = game.i18n.localize ("DIFFICULTY.Average");
    config.difficultyLabels["challenging"] = game.i18n.localize ("DIFFICULTY.Challenging");
    config.difficultyLabels["difficult"] = game.i18n.localize ("DIFFICULTY.MooDifficult");
    config.difficultyLabels["hard"] = game.i18n.localize ("DIFFICULTY.MooHard");
    config.difficultyLabels["vhard"] = game.i18n.localize ("DIFFICULTY.MooVHard");

    if (config.difficultyModifiers["futile"]) {
      config.difficultyLabels["futile"] = game.i18n.localize ("DIFFICULTY.MooFutile");
      config.difficultyModifiers["futile"] = -50;

      config.difficultyLabels["impossible"] = game.i18n.localize ("DIFFICULTY.MooImpossible");
      config.difficultyModifiers["impossible"] = -60;
    }
  }

  if (game.settings.get("wfrp4e", "homebrew").mooConditions)
  {
    config.conditionDescriptions["prone"] += game.i18n.localize ("MOO.Prone");
    config.conditionDescriptions["broken"] = game.i18n.localize ("MOO.Broken");
    config.conditionDescriptions["bleeding"] = game.i18n.localize ("MOO.Bleeding");
  }

  if (game.settings.get("wfrp4e", "homebrew").mooConditionTriggers)
  {
    config.statusEffects.forEach(e => {
      if (e.system.condition.trigger == "endRound")
        e.system.condition.trigger = "endTurn";
    });

    config.conditionDescriptions.bleeding = config.conditionDescriptions.bleeding.replace("Round", "Turn");
    config.conditionDescriptions.bleeding = config.conditionDescriptions.bleeding.replace("Round", "Turn");
    config.conditionDescriptions.poisoned = config.conditionDescriptions.poisoned.replace("Round", "Turn");
    config.conditionDescriptions.ablaze = config.conditionDescriptions.ablaze.replace("Round", "Turn");

  }

  if (game.settings.get("wfrp4e", "homebrew").mooPenetrating)
  {
    config.propertyHasValue.penetrating = true;
    config.qualityDescriptions.penetrating = game.i18n.localize ("MOO.Penetrating");
  }

  if (game.settings.get("wfrp4e", "homebrew").mooQualities)
  {
    config.weaponQualities.simple = game.i18n.localize ("Simple");
    config.qualityDescriptions.simple = game.i18n.localize ("MOO.Simple");
    config.propertyHasValue.simple = false;

    config.weaponQualities.momentum = game.i18n.localize ("Momentum");
    config.qualityDescriptions.momentum = game.i18n.localize ("MOO.Momentum");
    config.propertyHasValue.momentum = true;
  }

  if (game.settings.get("wfrp4e", "homebrew").mooHomebrewItemChanges)
  {
    fetch("systems/wfrp4e/moo/items.json").then(r => r.json()).then(async records => {
      for (let id in records)
      {
        let data = records[id];
        try {
          let item = await fromUuid(id);
          if (item)
          {
            item.updateSource(data);
            game.wfrp4e.utility.logHomebrew("mooHomebrewItemChanges: " + id + ` (${item.name})`);
          }
        }
        catch {
          warhammer.utility.log("Could not find item " + id);
        }
      }
      warhammer.utility.log("Compendium changes will revert if homebrew items is deactivated and the game is refreshed");
    });
    if (game.user.isGM)
    {
      ui.notifications.notify(game.i18n.localize ("MOO.Items"));
    }
  }

}

// Override various socket handling

var socketHandlers = {
    morrslieb: function (payload) {
        canvas.draw();
    },

    target: async function (payload) {
        let scene = game.scenes.get(payload.scene);
        let token = scene.tokens.get(payload.target);
        return await token.actor.update({ "flags.oppose": payload.opposeFlag });
    },

    updateMessage: async function (payload) {
        const msg = game.messages.get(payload.id);
        await msg.update(payload.updateData);
        return "success"
    },

    deleteMessage: async function (payload) {
        return await game.messages.get(payload.id)?.delete()
    },

    applyDamage: async function ({ damage, options, actorUuid }) {
        let result = await fromUuidSync(actorUuid)?.applyBasicDamage(damage, options);
        return result;
    },

    changeGroupAdvantage: async function (payload) {
        if (game.user.isUniqueGM) {
            let advantage = game.settings.get("wfrp4e", "groupAdvantageValues");
            advantage.players = payload.players;
            await game.settings.set("wfrp4e", "groupAdvantageValues", advantage);
        }
        return game.settings.get("wfrp4e", "groupAdvantageValues");
    },

    createActor: async function (payload) {
        let id = payload.id;
        let actorData = payload.data;

        // Give ownership to requesting actor
        actorData.ownership = {
            default: 0,
            [id]: 3
        };
        let actor = await Actor.implementation.create(actorData, payload.options || {});
        return actor.id;
    }
};

function ready () {
  Hooks.on("ready", async () => {

    let theme = game.settings.get("wfrp4e", "theme");
    if (!theme.apps.enabled)
    {
      document.body.classList.add("no-theme");
    }
    else if (theme.apps.font == "classic")
    {
      if (theme.apps.font == "classic")
      {
        document.body.classList.add("classic-font");
      }
    }

    if (!theme.sidebar.enabled)
    {
      ui.sidebar.element.classList.add("no-theme");
      document.body.querySelector("#chat-notifications").classList.add("no-theme");
    }
    else if (theme.sidebar.font == "classic")
    {
      if (theme.sidebar.font == "classic")
      {
        ui.sidebar.element.classList.add("classic-font");
        document.body.querySelector("#chat-notifications").classList.add("classic-font");
      }
    }

    SocketHandlers.register(socketHandlers);

    Object.defineProperty(game.user, "isUniqueGM", {
      get: function () { return game.user.id == game.users.activeGM.id }
    });

    // Automatically disable Auto Fill Advantage if group advantage is enabled
    if (game.settings.get("wfrp4e", "useGroupAdvantage") && game.user.isGM && game.settings.get("wfrp4e", "autoFillAdvantage"))
    {
      ui.notifications.info("AutoFillAdvantageDisabled", {localize: true, permanent : true});
      game.settings.set("wfrp4e", "autoFillAdvantage", false);
    }

    const MIGRATION_VERSION = 11;
    let currentMigration = game.settings.get("wfrp4e", "systemMigrationVersion");
    let needMigration = foundry.utils.isNewerVersion(MIGRATION_VERSION, currentMigration);
    if (needMigration && game.user.isGM) {
      ChatMessage.create({content: `
      <hr>
      <h1>New Users - Read This!</h1>
      <p>Welcome! Before you dive in, it may be best to browse the Wiki, below are some important topics:</p>
      <ul>
      <li><p><a href="https://moo-man.github.io/WFRP4e-FoundryVTT/pages/faq.html">FAQ</a></p></li>
      <li><p><a href="https://moo-man.github.io/WFRP4e-FoundryVTT/pages/basics/basics.html">Basics</a></p></li>
      <li><p><a href="https://moo-man.github.io/WFRP4e-FoundryVTT/pages/premium.html">Premium Content</a> (this will tell you how to use any official content you've purchased!</p></li>
      <li><p><a href="https://moo-man.github.io/WFRP4e-FoundryVTT/pages/troubleshooting.html">Troubleshooting</a></p></li>
      </ul>
      <p><strong>Note</strong>: Documentation is always a work in progress, some things may be incomplete, if you have questions, see the Discords linked in the home page</p>
      <p><strong>Also Note</strong>: While Character creation should be functional, it may be rather ugly until it gets updated to use the new features in V13</p>
      <hr>
      <h1>WFRP4e in Foundry V13</h1>
      <p>As Foundry itself progresses in its adoption of its new application framework, so too has the WFRP system. <em>Tens of thousands</em> of lines of code, styling, and html dating back from the system's earliest renditions (2020ish) have been removed and rewritten.</p>
      <p>However, the longbeards grumble that what's new is unproven and untested, so please be patient if issues arise as I try to bring the new sheets and menus up to match all the functionality of the old ones (particularly character creation!).</p>
      <p>In brief, the most notable changes are
      <ul>
      <li><p>The <em>monolithic</em> CSS file for the system's styling has been completely removed. Not to worry, this has been replaced with a much more flexible, cleaner, and customizable version. If you want to customize your WFRP theme, check out the <strong>Theme Config</strong> in the system settings</p></li>
      <li><p>Actor and Item Sheets in V2 have had their <em>right click</em> functionalities greatly expanded. You can right click any owned Item or Active Effect to see a context menu for various actions.</p></li>
      <li><p>Module Initialization has been centralized in the System settings, check the wiki link above!</p></li>
      </ul>
        `,
      speaker : {alias : "INFO"}}
        );

      if (currentMigration != 10) // No need to actually migrate if coming from 10, just display message
      {
        game.wfrp4e.migration.migrateWorld();
      }
    }
    game.settings.set("wfrp4e", "systemMigrationVersion", MIGRATION_VERSION);




    // Some entities require other entities to be loaded to prepare correctly (vehicles and mounts)
    for (let e of game.wfrp4e.postReadyPrepare)
      e.prepareData();

    CONFIG.statusEffects = game.wfrp4e.config.statusEffects;

    MooHouseRules();

    game.wfrp4e.tags.createTags();
  });

  FoundryOverrides();
}

class OpposedTest {
  constructor(attackerTest = undefined, defenderTest = undefined, opposeResult = {
      modifiers: {
        attacker: {
          target: 0,
          SL: 0
        },
        defender: {
          target: 0,
          SL: 0
        },
        message: []
      }
    }) {
      
    this.data = {
      attackerTestData: attackerTest?.data,
      defenderTestData: defenderTest?.data,
      opposeResult
    };

    this.attackerTest = attackerTest;
    this.defenderTest = defenderTest;
  }
  get opposeResult() { return this.data.opposeResult }
  get result() { return this.data.opposeResult }
  get attacker() { return this.attackerTest.actor }
  get defender() { return this.defenderTest.actor }

  static recreate(data)
  {
    let opposedTest = new OpposedTest();
    opposedTest.data = data;
    opposedTest.createAttackerTest(data.attackerTestData);
    opposedTest.createDefenderTest(data.defenderTestData);
    return opposedTest;
  }

  _createTest(testData) {
    if (!testData)
      return testData
    let test = game.wfrp4e.rolls.TestWFRP.recreate(testData);
    test.data = testData;
    return test
  }

  createAttackerTest(testData) {
    this.attackerTest = this._createTest(testData);
    this.data.attackerTestData = testData;
  }

  createDefenderTest(testData) {
    this.defenderTest = this._createTest(testData);
    this.data.defenderTestData = testData;
  }

  createUnopposedDefender(actor) {
    this.defenderTest = new game.wfrp4e.rolls.CharacteristicTest({
      item: "ws",
      SL: 0,
      target: 0,
      roll: 0,
      unopposedTarget: true,
    }, actor);
    this.defenderTest.data.context.unopposed = true;
    this.data.defenderTestData = this.defenderTest.data;
  }


  /*Known Bugs: attempting to reroll causes it to not reroll at all, actually. Manually editing cards causes a duplicate result card at the end.
*
*
*
*/
  checkPostModifiers(modifiers) {

    // Things to Check:
    // Weapon Length DONE
    // Fast Weapon Property DONE
    // Size 
    // Done - Weapon Defending: You suﬀer a penalty of –2 SL for each step larger your opponent is when using Melee to defend an Opposed Test
    // Done - To Hit Modifiers: +10 Bonus if smaller
    // Done - Ranged to Hit Modifiers : You gain a hefty bonus when shooting at larger targets (Ex. +40 to hit Enormous).
    //Shooting at smaller targets?

    if (game.settings.get("wfrp4e", "weaponLength") && this.attackerTest.weapon && this.defenderTest.weapon && this.attackerTest.weapon.attackType == "melee" && this.defenderTest.weapon.attackType == "melee") {
      let attackerReach = this.attackerTest.item.reachNum;
      let defenderReach = this.defenderTest.item.reachNum;
      if (defenderReach > attackerReach && !this.attackerTest.result.infighter) {
        modifiers.message.push(game.i18n.format(game.i18n.localize('CHAT.TestModifiers.WeaponLength'), { defender: this.defenderTest.actor.prototypeToken.name, attacker: this.attackerTest.actor.prototypeToken.name }));
        modifiers.attacker.target += -10;
      }
    }

    return modifiers;
  }

  /**
    * Main Opposed test evaluation logic. Takes attacker and defender test data and 
    * determines who won, by how much, etc. Displays who won accordingly, with different
    * logic for manual and targeted opposed tests
    * 
    * @param {Object} attacker Attacker data
    * @param {Object} defender Defender Data
    * @param {Object} options Targeted?
    */
  async evaluate() {
    try {
      let opposeResult = this.result;
      let attackerTest = this.attackerTest;
      let defenderTest = this.defenderTest;

      let soundContext = {};
      opposeResult.other = [];


      let attacker = this.attackerTest.actor;
      let defender = this.defenderTest.actor;

      let originalModifiers = foundry.utils.deepClone(opposeResult.modifiers);

      await Promise.all(attacker.runScripts("preOpposedAttacker", { attackerTest, defenderTest, opposedTest: this }));
      await Promise.all(attackerTest.item?.runScripts?.("preOpposedAttacker", { attackerTest, defenderTest, opposedTest: this }) ?? []);
      await Promise.all(defender.runScripts("preOpposedDefender", { attackerTest, defenderTest, opposedTest: this }));
      await Promise.all(defenderTest.item?.runScripts?.("preOpposedDefender", { attackerTest, defenderTest, opposedTest: this }) ?? []);

      this.checkPostModifiers(opposeResult.modifiers);
      
      // Redo the test with modifiers
      if (opposeResult.modifiers.attacker.target != originalModifiers.attacker.target
        || opposeResult.modifiers.attacker.SL != originalModifiers.attacker.SL) {
        attackerTest.preData.roll = attackerTest.result.roll;
        attackerTest.preData.postOpposedModifiers = opposeResult.modifiers.attacker;
        attackerTest.preData.hitloc = attackerTest.result.hitloc?.roll;

        attackerTest.context.breakdown.slBonus += opposeResult.modifiers.attacker.SL;
        defenderTest.context.breakdown.modifiersBreakdown += "<p>" + opposeResult.modifiers.message.join("<br/>") + "</p>";

        await attackerTest.computeResult();
        await attackerTest.renderRollCard();
      } 
      if (opposeResult.modifiers.defender.target != originalModifiers.defender.target
        || opposeResult.modifiers.defender.SL != originalModifiers.defender.SL) {
        defenderTest.preData.roll = defenderTest.result.roll;
        defenderTest.preData.postOpposedModifiers = opposeResult.modifiers.defender;
        defenderTest.preData.hitloc = defenderTest.result.hitloc?.roll;

        defenderTest.context.breakdown.slBonus += opposeResult.modifiers.defender.SL;
        defenderTest.context.breakdown.modifiersBreakdown += "<p>" + opposeResult.modifiers.message.join("<br/>") + "</p>";
        
        await defenderTest.computeResult();
        await defenderTest.renderRollCard();
      }
      if (defenderTest.context.unopposed)
      {
        await defenderTest.roll();
      }

      opposeResult.other = opposeResult.other.concat(opposeResult.modifiers.message);

      let attackerSL = parseInt(attackerTest.result.SL ?? 0);
      let defenderSL = parseInt(defenderTest.result.SL ?? 0);
      opposeResult.differenceSL = 0;

      // If attacker has more SL OR the SLs are equal and the attacker's target number is greater than the defender's, then attacker wins. 
      // Note: I know this isn't technically correct by the book, where it states you use the tested characteristic/skill, not the target number, i'll be honest, I don't really care.
      if (attackerSL > defenderSL || (attackerSL === defenderSL && (attackerTest.target > defenderTest.target || (attackerTest.outcome == "success" && defenderTest.context.unopposed)))) {
        opposeResult.winner = "attacker";
        opposeResult.differenceSL = attackerSL - defenderSL;
        opposeResult.showDualWielding = attackerTest.result.canDualWield;

        // If Damage is a numerical value
        if (Number.isNumeric(attackerTest.damage)) {
          let damage = await this.calculateOpposedDamage();
          opposeResult.damage = {
            description: `<b>${game.i18n.localize("Damage")}</b>: ${damage}`,
            value: damage
          };
        }
        // If attacker is using a weapon or trait but there wasn't a numerical damage value, output unknown
        else if (attackerTest.weapon || attackerTest.trait) {
          opposeResult.damage = {
            description: `<b>${game.i18n.localize("Damage")}</b>: ?`,
            value: null
          };
        }
        if (attackerTest.hitloc) 
        {
          await this.findHitLocation();
        }

        if (opposeResult.breakdown) {
          opposeResult.breakdown.formatted = this.formatBreakdown();
        }

        try // SOUND
        {
          if (attackerTest.weapon.weaponGroup.value === "bow"
            || attackerTest.weapon.weaponGroup.value === "crossbow") {
            soundContext = { item: attackerTest.weapon, action: "hit" };
          }
          if (attackerTest.weapon.weaponGroup.value == "throwing") {
            soundContext.item = { type: "throw" };
            if (attackerTest.weapon.properties.qualities.hack) {
              soundContext.item = { type: "throw_axe" };
            }
          }
        }
        catch (e) { warhammer.utility.log("Sound Context Error: " + e, true); } // Ignore sound errors
      }
      else // Defender won
      {
        try {
          if (attackerTest.weapon
            && (attackerTest.weapon.weaponGroup.value === "bow"
              || attackerTest.weapon.weaponGroup.value === "crossbow"
              || attackerTest.weapon.weaponGroup.value === "blackpowder"
              || attackerTest.weapon.weaponGroup.value === "engineering")) {
            soundContext = { item: attackerTest.weapon, action: "miss" };
          }
          if (defenderTest.weapon && defenderTest.weapon.properties.qualities.shield) {
            if (attackerTest.weapon.attackType == "melee") {
              soundContext = { item: { type: "shield" }, action: "miss_melee" };
            }
            else {
              if (attackerTest.weapon.weaponGroup.value === "bow"
                || attackerTest.weapon.weaponGroup.value === "sling"
                || attackerTest.weapon.weaponGroup.value === "throwing"
                || attackerTest.weapon.weaponGroup.value === "crossbow") {
                soundContext = { item: { type: "shield" }, action: "miss_ranged" };
              }
            }
          }
        }
        catch (e) { warhammer.utility.log("Sound Context Error: " + e, true); } // Ignore sound errors

        opposeResult.winner = "defender";
        opposeResult.differenceSL = defenderSL - attackerSL;
      }

      await Promise.all(attacker.runScripts("opposedAttacker", { opposedTest: this, attackerTest, defenderTest }));
      await Promise.all(attackerTest.item?.runScripts?.("opposedAttacker", { opposedTest: this, attackerTest, defenderTest }) ?? []);
      if (defender) {
        await Promise.all(defender.runScripts("opposedDefender", { opposedTest: this, attackerTest, defenderTest}));
        await Promise.all(defenderTest.item?.runScripts?.("opposedDefender", { opposedTest: this, attackerTest, defenderTest }) ?? []);
      }

      Hooks.call("wfrp4e:opposedTestResult", this, attackerTest, defenderTest);
      WFRP_Audio.PlayContextAudio(soundContext);
      return opposeResult
    }
    catch (err) {
      ui.notifications.error(`${game.i18n.localize("ErrorOpposed")}: ` + err);
      console.error("Could not complete opposed test: " + err);
    }
  }

  async calculateOpposedDamage() {
    // Calculate size damage multiplier 
    let damageMultiplier = 1;
    let sizeDiff;
    let breakdown = {other : []};

    if (this.attackerTest.actor.type == "vehicle" || this.defenderTest.actor.type == "vehicle")
      sizeDiff = 0;
    else 
      sizeDiff = game.wfrp4e.config.actorSizeNums[this.attackerTest.size] - game.wfrp4e.config.actorSizeNums[this.defenderTest.size];

    if (this.attackerTest.actor.has(game.i18n.localize("NAME.Swarm")) || this.defenderTest.actor.has(game.i18n.localize("NAME.Swarm")))
      sizeDiff = 0;

    if (game.settings.get("wfrp4e", "homebrew").mooSizeDamage)
      sizeDiff = 0;

    damageMultiplier = sizeDiff >= 2 ? sizeDiff : 1;


    let opposedSL = Number(this.attackerTest.result.SL ?? 0) - Number(this.defenderTest.result.SL ?? 0);
    let item = this.attackerTest.item;

    if (item?.system.damage?.hasOwnProperty("addSL") && !item.system.damage.addSL)
    {
      opposedSL = 0;
    }

    let damage;
    if (this.attackerTest.useMount)
      damage = item.mountDamage;
    else
      damage = item.Damage;

    //@HOUSE
    if (game.settings.get("wfrp4e", "homebrew").mooSLDamage) {
      game.wfrp4e.utility.logHomebrew("mooSLDamage");
      opposedSL = Number(this.attackerTest.result.SL);
    }
    //@/HOUSE

    breakdown.base = damage + this.attackerTest.result.additionalDamage; 
    breakdown.opposedSL = opposedSL;

    // Winds of Magic overcast
    if (this.attackerTest instanceof WomCastTest) {	
      damage += (this.attackerTest.result.additionalDamage || 0);	
    } else {	
      damage += (opposedSL + (this.attackerTest.result.additionalDamage || 0));	
    }

    //@HOUSE
    if (game.settings.get("wfrp4e", "homebrew").mooRangedDamage)
    {
      game.wfrp4e.utility.logHomebrew("mooRangedDamage");
      if (this.attackerTest.item && this.attackerTest.item.isRanged)
      {
        damage -= (Math.floor(this.attackerTest.targetModifiers / 10) || 0);
        if (damage < 0)
          damage = 0;
      }
    }
    //@/HOUSE



    let effectArgs = { damage, damageMultiplier, sizeDiff, opposedTest: this, addDamaging : false, addImpact : false, breakdown };
    await Promise.all(this.attackerTest.actor.runScripts("calculateOpposedDamage", effectArgs));
    await Promise.all(this.attackerTest.item?.runScripts("calculateOpposedDamage", effectArgs));
    ({ damage, damageMultiplier, sizeDiff } = effectArgs);

    let addDamaging = effectArgs.addDamaging || false;
    let addImpact = effectArgs.addImpact || false;
    if (this.attackerTest.trait) {
      if (sizeDiff >= 1)
        addDamaging = true;
      if (sizeDiff >= 2)
        addImpact = true;
    }

    let hasDamaging = false;
    let hasImpact = false;
    if (this.attackerTest.item.properties) {
      hasDamaging = this.attackerTest.item.properties.qualities.damaging;
      hasImpact = this.attackerTest.item.properties.qualities.impact;

      if (this.attackerTest.item.properties.qualities.hullbreaker && this.defender.type == "vehicle")
      {
        addDamaging = true;
        damage += 2;
        breakdown.other.push({label : game.i18n.localize("PROPERTY.Hullbreaker"), value : 2});
      }

      if (this.attackerTest.result.charging || !this.attackerTest.item.properties.flaws.tiring) {
        if (hasDamaging)
          addDamaging = true;
        if (hasImpact)
          addImpact = true;
      }

      if (sizeDiff >= 1)
        addDamaging = true;
      if (sizeDiff >= 2)
        addImpact = true;
    }

    if (addDamaging) {
      let unitValue = Number(this.attackerTest.result.roll.toString().split("").pop());
      if (unitValue === 0)
        unitValue = 10;

      if (unitValue > opposedSL) {
        breakdown.damaging = unitValue;
        damage = damage - opposedSL + unitValue; // replace opposedSL with unit value
      }
    }
    if (addImpact) {
      let unitValue = Number(this.attackerTest.result.roll.toString().split("").pop());
      if (unitValue === 0)
        unitValue = 10;
      damage += unitValue;
      breakdown.impact = unitValue;
    }
    this.result.damaging = hasDamaging || addDamaging;
    this.result.impact = hasImpact || addImpact;

    breakdown.multiplier = damageMultiplier;
    this.result.breakdown = breakdown;
    return damage * damageMultiplier
  }

  async findHitLocation()
  {
      // If an attacker's test hit location is "rArm" this actually means "primary arm"
      // So convert "rArm" to "rArm" or "lArm" depending on the actor's settings 
      let attackerHitloc = foundry.utils.deepClone(this.attackerTest.hitloc);
      attackerHitloc.result = this.defender.convertHitLoc(attackerHitloc.result);
      attackerHitloc.description = game.wfrp4e.config.locations[attackerHitloc.result];

      let hitlocToUse;

      // Remap the hit location roll to the defender's hit location table, note the change if it is different
      let remappedHitLoc = await game.wfrp4e.tables.rollTable(this.defender.details.hitLocationTable.value, { lookup: attackerHitloc.roll, hideDSN: true });

      if (remappedHitLoc && this.defender.details.hitLocationTable.value != "hitloc") // Only remap if using a different hitloc table, this prevents Primary Arm -> Right Arm -> Primary Arm (Remapped)
      {
        if (remappedHitLoc.result != attackerHitloc.result) {
          remappedHitLoc.description = game.i18n.localize(remappedHitLoc.description) + " (Remapped)";
          remappedHitLoc.remapped = true;
        }
        hitlocToUse = remappedHitLoc;
      }
      else
      {
        hitlocToUse = attackerHitloc;
      }

      this.result.hitloc = {
        description: `<b>${game.i18n.localize("ROLL.HitLocation")}</b>: ${hitlocToUse.description}`,
        value: hitlocToUse.result
      };
  }

  async swap(label)
  {
      let temp = foundry.utils.duplicate(this.defenderTest.data);
      this.defenderTest = game.wfrp4e.rolls.TestWFRP.recreate(this.attackerTest.data);
      this.attackerTest = game.wfrp4e.rolls.TestWFRP.recreate(temp);
      this.data.attackerTestData = this.attackerTest.data;
      this.data.defenderTestData = this.defenderTest.data;
      let damage = await this.calculateOpposedDamage();
      this.result.damage = {
        description: `<b>${game.i18n.localize("Damage")} (${label})</b>: ${damage}`,
        value: damage
      };
      await this.findHitLocation();
      this.result.swapped = true;
  }

  formatBreakdown()
  {
    let string = "";
    try 
    {
      let breakdown = this.result.breakdown;
      let accumulator = Number(breakdown.base);

      string += `<p><strong>${game.i18n.localize("BREAKDOWN.AttackerBase")}</strong>: ${breakdown.base}</p>`;
      if (breakdown.damaging) 
      {
        accumulator += Number(breakdown.damaging);
        string += `<p><strong>${game.i18n.localize("PROPERTY.Damaging")}</strong>: +${breakdown.damaging} (${accumulator})</p>`;
      }
      else if (breakdown.opposedSL) 
      {
        accumulator += Number(breakdown.opposedSL);
        string += `<p><strong>${game.i18n.localize("BREAKDOWN.OpposedSL")}</strong>: +${breakdown.opposedSL} (${accumulator})</p>`;
      }
      if (breakdown.impact) 
      {
        accumulator += Number(breakdown.impact);
        string += `<p><strong>${game.i18n.localize("PROPERTY.Impact")}</strong>: +${breakdown.impact} (${accumulator})</p>`;
      }

      for (let source of breakdown.other) 
      {
        accumulator += Number(source.value);
        string += `<p><strong>${source.label}</strong>: ${foundry.applications.handlebars.numberFormat(source.value, { hash: { sign: true } })} (${accumulator})</p>`;
      }

      if (breakdown.multiplier > 1) 
      {
        accumulator *= breakdown.multiplier;
        string += `<p><strong>${game.i18n.localize("BREAKDOWN.Multiplier")}</strong>: ×${breakdown.multiplier} (${accumulator})</p>`;
      }
    }
    catch (e) 
    {
      console.error(`Error generating formatted breakdown: ${e}`, this);
    }

    return string;
  }

}

let fields$y = foundry.data.fields;
class OpposedTestMessage extends WarhammerMessageModel 
{
    static defineSchema() 
    {
        let schema = {};
        schema.opposedTestData = new fields$y.ObjectField();
        schema.handlerId = new fields$y.StringField();
        return schema;
    }

    get opposedTest() 
    {
        return OpposedTest.recreate(this.opposedTestData);
    }

    static async create(opposedTest, options, handler)
    {
      let opposeData = opposedTest.data;
      let opposeResult = opposedTest.result;

      let html = await foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/roll/opposed-result.hbs", opposeResult);
      let chatOptions = {
        user: game.user.id,
        type : "opposed",
        content: html,
        system : {
          opposedTestData: opposeData,
          handlerId: handler.message.id,
        },
        speaker : {alias : "Opposed Result"},
        author : getActiveDocumentOwner(opposedTest.defender)?.id,
        whisper: options.whisper,
        blind: options.blind,
      };
      return await ChatMessage.create(chatOptions);
    }

    async renderMessage()
    {
      let content = await foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/roll/opposed-result.hbs", this.opposedTest.result);
      return await this.parent.update({content})
    }

    async onRender(html)
    {
      warhammer.utility.replacePopoutTokens(html);
    }

    static get actions() 
    { 
        return foundry.utils.mergeObject(super.actions, {
            applyDamage : this.onApplyDamage,
            applyHack : this.onApplyHack,
            rollDualWielder : this.onRollDualWielder
        });
    }

    static async onApplyDamage(ev)
    {
      let opposedTest = this.opposedTest;
  
      if (!opposedTest.defenderTest.actor.isOwner)
        return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))
  
      let damageMsg = await opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
      this.updateResultMessage(damageMsg);
    }
  
    static async onApplyHack(ev)
    {
        let opposedTest = this.opposedTest;
        const type = ev.target.innerText;
  
      if (!opposedTest.defenderTest.actor.isOwner)
        return ui.notifications.error("ErrorArmourDamagePermission", {localize : true})
  
      let loc = opposedTest.result.hitloc.value;
      let armour = opposedTest.defenderTest.actor.physicalNonDamagedArmourAtLocation(loc);
      if (armour.length)
      {
        let chosen = await ItemDialog.create(armour, 1, {text : "Choose Armour to damage", title : type});
        if (chosen[0])
        {
          chosen[0].system.damageItem(1, [loc]);
          ChatMessage.create({content: `<p>1 Damage applied to @UUID[${chosen[0].uuid}]{${chosen[0].name}} (${type})</p>`, speaker : ChatMessage.getSpeaker({actor : opposedTest.attackerTest.actor})});
        }
      }
      else 
      {
        return ui.notifications.error("ErrorNoArmourToDamage", {localize : true})
      }
    }

    static async onRollDualWielder(event)
    {
      let attackerTest = this.opposedTest.attackerTest;
  
      let offHandData = foundry.utils.duplicate(attackerTest.preData);
  
      if (!attackerTest.actor.hasSystemEffect("dualwielder")) 
      {
        await attackerTest.actor.addSystemEffect("dualwielder");
      }
  
      let targets = null;
      if (game.user.targets.size)
      {
        targets = Array.from(game.user.targets);
      }
      else 
      {
        targets = attackerTest.targetTokens.map(i => i.object);
        ui.notifications.info("No Targets - Directing offhand attack at the same target as the primary attack");
      }
  
      let offhandWeapon = attackerTest.actor.itemTags["weapon"].find(w => w.offhand.value);
      if (attackerTest.result.roll % 11 == 0 || attackerTest.result.roll == 100) {
        delete offHandData.roll;
      }
      else 
      {
        let offhandRoll = attackerTest.result.roll.toString();
        if (offhandRoll.length == 1)
        {
          offhandRoll = offhandRoll[0] + "0";
        }
        else
        {
          offhandRoll = offhandRoll[1] + offhandRoll[0];
        }
        offHandData.roll = Number(offhandRoll);
      }
  
      attackerTest.actor.setupWeapon(offhandWeapon, { appendTitle: ` (${game.i18n.localize("SHEET.Offhand")})`, dualWieldOffhand: true, offhandReverse: offHandData.roll, targets}).then(test => test.roll());
    }

    // Update starting message with result
    async updateResultMessage(damageConfirmation) {
        this.opposedTestData.opposeResult.confirmation = damageConfirmation;
        await this.parent.update({"system.opposedTestData.opposeResult.confirmation" : damageConfirmation});
        this.renderMessage();
    }
}

/**
 * Represents an opposed test. This object is stored in the "targeting" messages and is used as a central manager of a single opposed test.
 * - Stores targeting message id, attacker message id, defender message id, and result message ID
 * - Actors who have been targeted are flagged with the targeting message ID (messageId)
 * - @see TestWFRP - Tests have a list of opposedMessageIds, that being messageId
 **/
class OpposedHandler {

  constructor(data = {}, message) 
  {
    this.data = {
      messageId: data.messageId,
      attackerMessageId: data.attackerMessageId,
      defenderMessageId: data.defenderMessageId,
      resultMessageId: data.resultMessageId,
      targetSpeakerData: data.targetSpeakerData,
      options: data.options || {},
      unopposed: data.unopposed
    };

    this._message = message;
  }

  get message() {
    return this._message || game.messages.get(this.data.messageId);
  }

  get resultMessage() {
    return game.messages.get(this.data.resultMessageId);
  }

  get target() {
    return WFRP_Utility.getToken(this.data.targetSpeakerData);
  }

  get attackerMessage() {
    return game.messages.get(this.data.attackerMessageId);
  }

  get defenderMessage() {
    return game.messages.get(this.data.defenderMessageId);
  }

  get attackerTest() {
    return this.attackerMessage?.system.test;
  }

  get defenderTest() {
    if (this.unopposed) {
      return new game.wfrp4e.rolls.CharacteristicTest({
        item: "ws",
        SL: 0,
        target: 0,
        roll: 0,
        unopposed: true,
      }, this.target.actor)
    }
    else
      return this.defenderMessage?.system.test;
  }

  get attacker() {
    return this.attackerTest?.actor
  }

  get defender() {
    return this.defenderTest ? this.defenderTest.actor : WFRP_Utility.getSpeaker(this.data.targetSpeakerData) // If opposed test isn't complete, use targetSPeakerData
  }

  get options() {
    return this.data.options;
  }

  get unopposed() {
    return this.data.unopposed;
  }

  async startOppose(targetToken) {
    this.data.targetSpeakerData = targetToken.actor.speakerData(targetToken);
    await this.renderMessage();
    await this._addOpposeFlagsToDefender(targetToken);
    return this.message?.id
  }

  async setAttacker(message) {
    this.data.attackerMessageId = typeof message == "string" ? message : message.id;
    this.data.options = {
      whisper: message.whisper,
      blind: message.blind
    };
    if (this.message)
      await this.updateMessageData();
  }

  async setDefender(message) {
    this.data.defenderMessageId = typeof message == "string" ? message : message.id;
    if (this.message)
      await this.updateMessageData();
  }

  async computeOpposeResult() {
    if (!this.attackerTest || !this.defenderTest)
      throw new Error(game.i18n.localize("ERROR.Opposed"))

    this.opposedTest = new OpposedTest(this.attackerTest, this.defenderTest);

    await this.opposedTest.evaluate();
    this.formatOpposedResult();
    await this.renderOpposedResult();
    await this.renderMessage();
  }

  async renderMessage() {
    let attacker = game.canvas.tokens.get(this.attackerTest.context.chatOptions.speaker.token)?.document ?? this.attacker.prototypeToken;
    let defender;

    // Support opposed start messages when defender is not set yet - allows for manual opposed to use this message
    if (this.target)
      defender = this.target;
    else if (this.defenderTest)
      defender = WFRP_Utility.getToken(this.defenderTest.context.speaker) || this.defender.prototypeToken;


    let attackerName = (attacker.hidden) ? "???" : attacker.name;
    let attackerImg = (attacker.hidden) ? "systems/wfrp4e/tokens/unknown.png" : attacker.texture.src;

    let defenderName = defender ? defender.name : "???";
    let defenderImg = defender ? defender.texture.src : "systems/wfrp4e/tokens/unknown.png";

    let winner = this.resultMessage?.system.opposedTest?.result?.winner;

    let content = await foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/roll/opposed-handler.hbs", {attackerName, attackerImg, defenderName, defenderImg, winner, opposedOptions : this.getOpposedOptions(defender?.actor)});

    // Ranged weapon opposed tests automatically lose no matter what if the test itself fails
    if (this.attackerTest.item && this.attackerTest.item.isRanged && this.attackerTest.failed) {
      await ChatMessage.create({ speaker: this.attackerMessage.speaker, content: game.i18n.localize("OPPOSED.FailedRanged") });
      return;
    }
    let chatData = {
        type : "handler",
        user: game.user.id,
        content: content,
        speaker: { alias: game.i18n.localize("CHAT.OpposedTest") },
        whisper: this.options.whisper,
        blind: this.options.blind,
        author : getActiveDocumentOwner(defender?.actor)?.id,
        system : {
          opposedData : this.data
        }
    };

    if (this.message) {
        await this.message.update(chatData);
        return this.data.messageId;
    }
    else {
        // Create the Opposed starting message
        let msg = await ChatMessage.create(chatData);
        this.data.messageId = msg.id;
        await this.updateMessageData();
        return msg.id;
    }
  }

  getOpposedOptions(actor)
  {
    if (!actor)
    {
      return [];
    }
    let options = [
      { id : "unopposed", tooltip : game.i18n.localize("Unopposed"), icon : "fa-arrow-down" },
      { id : "dodge", tooltip : game.i18n.localize("NAME.Dodge"), icon : "fa-reply" },
    ];

    if (actor)
    {
      // Use first weapon equipped
      let mainWeapon = actor.itemTypes.weapon.find(i => i.system.isMelee && i.system.isEquipped && !i.system.offhand.value);
      let offhandWeapon = actor.itemTypes.weapon.find(i => i.system.isMelee && i.system.isEquipped && i.system.offhand.value);
      let firstTrait = actor.itemTypes.trait.find(i => i.system.isMelee);

      if (mainWeapon)
      {
        options.push({id : mainWeapon.id, tooltip : mainWeapon.name, icon : "fa-sword"});
      }
      if (offhandWeapon)
      {
        options.push({id : offhandWeapon.id, tooltip : offhandWeapon.name, icon : "fa-shield"});
      }
      if (firstTrait)
      {
        options.push({id : firstTrait.id, tooltip : firstTrait.DisplayName, icon : "fa-paw-claws"});
      }
    }

    return options;
  }

  async updateMessageData() {
    let updateData = { "system.opposedData": this.data };
    if (this.message && game.user.isGM) {
      await this.message.update(updateData);
    }
    else if (this.message) {
      await SocketHandlers.call("updateMessage", { id: this.message.id, updateData }, "GM");
    }
  }



  async renderOpposedResult() 
  {
    let message = await OpposedTestMessage.create(this.opposedTest, this.options, this);  
    this.data.resultMessageId = message.id;
  }

  formatOpposedResult() {

    let opposeResult = this.opposedTest.opposeResult;
    let attackerAlias = this.attackerTest.message.speaker.alias;

    // Account for unopposed tests not having a defender message
    let defenderAlias = this.defenderMessage ? this.defenderMessage.speaker.alias : this.defenderTest.actor.prototypeToken.name;

    if (opposeResult.winner == "attacker") {
      opposeResult.result = game.i18n.format("OPPOSED.AttackerWins", {
        attacker: attackerAlias,
        defender: defenderAlias,
        SL: opposeResult.differenceSL
      });
      opposeResult.img = this.attackerMessage.flags.img;
    }
    else if (opposeResult.winner == "defender") {
      opposeResult.result = game.i18n.format("OPPOSED.DefenderWins", {
        defender: defenderAlias,
        attacker: attackerAlias,
        SL: opposeResult.differenceSL
      });
      opposeResult.img = this.defenderMessage ? this.defenderMessage.flags.img : this.defenderTest.actor.prototypeToken.texture.src;
    }

    return opposeResult;
  }

  async colorWinnerAndLoser() 
  {
    try {
      let winner = this.opposedTest.opposeResult.winner;

      // The loser is "attacker" or "defender"
      let loser = winner == "attacker" ? "defender" : "attacker";

      // Replace "attacker" with "attacker winner" or "defender" with "defender winner" to apply the color coded borders
      let content = this.message.content;
      content = content.replace(winner, `${winner} winner`);
      content = content.replace(loser, `${loser} loser`);

      if (!game.user.isGM)
        await SocketHandlers.call("updateMessage", { id: this.message.id, updateData: {content} }, "GM");
      else
        await this.message.update({content});
    }
    catch(e) {
      console.error(`Error color coding winner and loser: ${e}`);
    }
  }


  async _addOpposeFlagsToDefender(target) {
    if (!game.user.isGM) {
      const payload = {
        target: target.id,
        scene: canvas.scene.id,
        opposeFlag: { opposeMessageId: this.data.messageId }
      };
      await SocketHandlers.call("target", payload, "GM");
    }
    else {
      // Add oppose data flag to the target
      await target.actor.update({ "flags.oppose": { opposeMessageId: this.data.messageId } });
    }
  }


  async resolveUnopposed() {
    this.data.unopposed = true;
    await this.computeOpposeResult();
    await this.defender.clearOpposed();
  }

  async resolveOpposed(id)
  {
    if (this.defender)
    {
      let test;
      if (id == "unopposed")
      {
        return this.resolveUnopposed();
      }
      else if (id == "dodge")
      {
        test = await this.defender.setupSkill(game.i18n.localize("NAME.Dodge"), {skipTargets: true});
      }
      else 
      {
        test = await this.defender.setupItem(id, {skipTargets: true});
      }
      test?.roll();
    }
  }
}

function chat() {


  /**
 * Searches each message and adds drag and drop functionality and hides certain things from players
 */

  Hooks.on("renderChatMessageHTML", async (app, html) => {

    // Hide test data from players (35 vs 50) so they don't know the enemy stats
    if (game.settings.get("wfrp4e", "hideTestData") && !game.user.isGM && html.querySelector(".chat-card")?.dataset.hide === "true") {
      html.querySelector(".hide-option")?.remove();
    }
    // Hide chat card edit buttons from non-gms
    if (!game.user.isGM) {
      html.querySelector(".chat-button-gm")?.remove();
      // Hide these if actor is not owned by the player
      if (!app.speaker.actor || (app.speaker.actor && !game.actors.get(app.speaker.actor).isOwner))
      {
        html.querySelector(".chat-button-player")?.remove();
        html.querySelector(".test-breakdown")?.remove();
        html.querySelector(".damage-breakdown")?.remove();
        html.querySelector(".hide-spellcn")?.remove();
      }
      if (!app.system.opposedHandler?.defender?.isOwner)
      {
        html.querySelector(".opposed-options")?.remove();
      }
    }
    else {
      html.querySelector(".chat-button-player")?.remove();
    }


    // Do not display "Blind" chat cards to non-gm
    if (html.classList.contains("blind") && !game.user.isGM) {
      html.querySelector(".message-header")?.remove(); // Remove header so Foundry does not attempt to update its timestamp
      html.style.display = "none";
    }

    // Add drag and drop to character generation results
    let woundsHealed = html.querySelector(".wounds-healed-drag");
    if (woundsHealed) 
    {
      woundsHealed.draggable = true;
      woundsHealed.addEventListener('dragstart', ev => {
        let dataTransfer = {
          type : "custom",
          custom : "wounds",
          wounds : app.system.test.result.woundsHealed
        };
        ev.dataTransfer.setData("text/plain", JSON.stringify(dataTransfer));
      });
    }

    // Add drag and drop to character generation results
    let generation = html.querySelector(".char-gen");
    if (generation) {
      generation.draggable = true;
      generation.addEventListener('dragstart', ev => {
        ev.dataTransfer.setData("text/plain", app.flags.transfer);
      });
    }


    // Add drag and drop to money from income rolls
    html.querySelectorAll(".money-drag").forEach(el => {
      el.draggable = true;
      el.addEventListener('dragstart', ev => {
        let dataTransfer = {
          type : "Income",
          amount: ev.target.dataset.amt
        };
        ev.dataTransfer.setData("text/plain", JSON.stringify(dataTransfer));
      });
    });

    // if (app.getFlag("wfrp4e", "roleTests"))
    // {
    //   let tests = app.getFlag("wfrp4e", "roleTests").map(i => game.messages.get(i)?.system.test).filter(i => i);
    //   let SL = tests.reduce((sl, test) => sl + test.result.crewTestSL, 0); 
    //   let slCounter = html.querySelector(".sl-total")[0]
    //   slCounter.innerText = slCounter.innerText.replace("%SL%", SL);
    // }

  });

  Hooks.on("deleteChatMessage", async (message) => {
    let targeted = message.flags.unopposeData; // targeted opposed test
    let manual = message.flags.opposedStartMessage; // manual opposed test
    if (!targeted && !manual)
      return;

    if (targeted) {
      let target = canvas.tokens.get(message.flags.unopposeData.targetSpeaker.token);
      await target.actor.clearOpposed();
    }
    if (manual && !message.flags.opposeResult && OpposedHandler.attackerMessage) {
      await OpposedHandler.attackerMessage.update(
        {
          "flags.data.isOpposedTest": false
        });
      await OpposedHandler.attacker.clearOpposed();
    }
    ui.notifications.notify(game.i18n.localize("ROLL.CancelOppose"));
  });

}

class CombatHelpersWFRP {


    static registerHelpers() 
    {
        CombatHelpers.startCombat = [CombatHelpersWFRP.checkFearTerror];
        CombatHelpers.endCombat = [CombatHelpersWFRP.clearCombatantAdvantage, CombatHelpersWFRP.checkCorruption, CombatHelpersWFRP.checkInfection, CombatHelpersWFRP.checkDiseases];
        CombatHelpers.startTurn = [CombatHelpersWFRP.checkStartTurnConditions];
        CombatHelpers.endTurn = [CombatHelpersWFRP.checkEndTurnConditions];
        CombatHelpers.endRound = [CombatHelpersWFRP.checkEndRoundConditions, CombatHelpersWFRP.fearReminders];
    }


    static async checkStartTurnConditions(combat) {
        if (!game.user.isUniqueGM)
            return

        
        let combatant = combat.combatant;
        console.log("start turn conditions " + combatant.name);
        if (combatant) {
            if (combatant.actor.hasSystemEffect("dualwielder")) {
                await combatant.actor.removeSystemEffect("dualwielder");
            }

            if (game.settings.get("wfrp4e", "focusOnTurnStart")) {
                canvas.tokens.get(combatant.token.id).control();
                canvas.tokens.cycleTokens(1, true);
            }

            let msgContent = "";
            let startTurnConditions = combatant.actor.effects.contents.filter(e => e.system.condition.trigger == "startTurn");
            for (let cond of startTurnConditions) {
                    let conditionName = game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]);
                    if (Number.isNumeric(cond.system.condition.value))
                        conditionName += ` ${cond.system.condition.value}`;
                    msgContent = `
                <h2>${conditionName}</h2>
                <a class="chat-button" data-action="conditionScript" data-combatant-id="${combatant.id}" data-cond-id="${cond.conditionId}">${game.i18n.format("CONDITION.Apply", { condition: conditionName })}</a>`;
                    await ChatMessage.create({ content: msgContent, speaker: { alias: combatant.token.name } });
            }

        }
        WFRP_Audio.PlayContextAudio({ item: { type: 'round' }, action: "change" });
    }

    static async checkEndTurnConditions(combat) {
        if (!game.user.isUniqueGM)
            return
        let combatant = combat.combatants.get(combat.previous.combatantId);
        console.log("end turn conditions " + combatant.name);
        if (combatant) {
            let msgContent = "";
            let endTurnConditions = combatant.actor.effects.contents.filter(e => e.system.condition.trigger == "endTurn");
            for (let cond of endTurnConditions) {
                    let conditionName = game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]);
                    if (Number.isNumeric(cond.system.condition.value))
                        conditionName += ` ${cond.system.condition.value}`;
                    msgContent = `
                <h2>${conditionName}</h2>
                <a class="chat-button" data-action="conditionScript" data-combatant-id="${combatant.id}" data-cond-id="${cond.conditionId}">${game.i18n.format("CONDITION.Apply", { condition: conditionName })}</a>`;
                    await ChatMessage.create({ content: msgContent, speaker: { alias: combatant.token.name } });
            }
        }
    }

    static async endCombat(combat) {
        if (!game.user.isUniqueGM)
            return

        let content = "";
        let scriptResult = "";
        for (let script of CombatHelpersWFRP.scripts.endCombat) {
            scriptResult = await script(combat);
            if (scriptResult) {
                content += scriptResult + "<br><br>";
            }
        }
        if (content) {
            content = `<h2>${game.i18n.localize("CHAT.EndCombat")}</h3>` + content;
            ChatMessage.create({ content, whisper: ChatMessage.getWhisperRecipients("GM") });
        }
        for (let turn of combat.turns) {
            await Promise.all(turn.actor.runScripts("endCombat", {combat}, true));
            Hooks.callAll("wfrp4e:endCombat", combat);
        }
    }

    static async checkFearTerror(combat) {
        if (!game.user.isUniqueGM)
            return

        let fearCounters = [];
        let terrorCounters = [];
        for (let turn of combat.turns) {
            try {

            let fear = turn.actor.has(game.i18n.localize("CHAT.Fear"));
            if (fear)
                fearCounters.push({ name: turn.name, value: `@Fear[${fear.specification.value},${turn.name}]` });

            let terror = turn.actor.has(game.i18n.localize("CHAT.Terror"));
            if (terror)
                terrorCounters.push({ name: turn.name, value: `@Terror[${terror.specification.value},${turn.name}]` });

            }
            catch (e) {
                console.log(e);
            }
        }
        let msg = "";
        if (fearCounters.length || terrorCounters.length) {
            if (fearCounters.length)
                msg += `<h2>${game.i18n.localize("CHAT.Fear")}</h2>${fearCounters.map(f => `<b>${f.name}</b> - ${f.value}`).join("<br>")}`;
            if (terrorCounters.length)
                msg += `<h2>${game.i18n.localize("CHAT.Terror")}</h2>${terrorCounters.map(t => `<b>${t.name}</b> - ${t.value}`).join("<br>")}`;

        }

        msg += CombatHelpersWFRP.checkSizeFearTerror(combat);

        if (msg)
            await ChatMessage.create(game.wfrp4e.utility.chatDataSetup(msg, "gmroll"));
    }

    static checkSizeFearTerror(combat) {
        let sizeMap = {};
        let msg = "";
        for (let turn of combat.turns) 
        {
            sizeMap[turn.id] = turn.actor?.sizeNum || 3;
        }
        for (let id in sizeMap) {
            let combatant = combat.combatants.get(id);
            let size = sizeMap[id];
            let smallerBy = {
                1: [],
                2: [],
                3: [],
                4: [],
                5: [],
                6: []
            };

            for (let otherCombatantId in sizeMap) {
                let otherCombatant = combat.combatants.get(otherCombatantId);
                let bothFriendly =  (combatant.token?.disposition == otherCombatant.token?.disposition == 1);
                if (otherCombatantId == id || bothFriendly)
                {
                    continue
                }
                try 
                {
                    if (size > sizeMap[otherCombatantId])
                    {
                        smallerBy[size - sizeMap[otherCombatantId]].push(otherCombatant.name);
                    }
                }
                catch (e) {

                }
            }

            let actor = combatant.name;
            if (smallerBy[1].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Fear[${1}, ${actor}]`, actor: actor, target: smallerBy[1].join(", ")});

            if (smallerBy[2].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${2}, ${actor}]`, actor: actor, target: smallerBy[2].join(", ")});

            if (smallerBy[3].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${3}, ${actor}]`, actor: actor, target: smallerBy[3].join(", ")});

            if (smallerBy[4].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${4}, ${actor}]`, actor: actor, target: smallerBy[4].join(", ")});

            if (smallerBy[5].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${5}, ${actor}]`, actor: actor, target: smallerBy[5].join(", ")});

            if (smallerBy[6].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${6}, ${actor}]`, actor: actor, target: smallerBy[6].join(", ")});

            if (Object.values(smallerBy).some(list => list.length)) {
                msg += "<br>";
            }
        }
        if (msg) {
            msg = `<br><h2>${game.i18n.localize("Size")}</h2>${msg}`;
        }
        return msg
    }

    static async checkCorruption(combat) {
        if (!game.user.isUniqueGM)
            return

        let corruptionCounters = [];

        for (let turn of combat.turns) {
            let corruption = turn.actor.has(game.i18n.localize("NAME.Corruption"));
            if (corruption) {
                let existing = corruptionCounters.find(c => c.type == corruption.specification.value);
                if (existing)
                    existing.counter++;
                else
                    corruptionCounters.push({ counter: 1, type: corruption.specification.value });
            }
        }

        let content = "";

        if (corruptionCounters.length) {
            content += `<h3><b>${game.i18n.localize("Corruption")}</b></h3>`;
            for (let corruption of corruptionCounters) {
                content += `${corruption.counter} ${corruption.type}<br>`;
            }
            content += game.i18n.localize("CHAT.CorruptionTest");
            content += `<br>@Corruption[Minor]<br>@Corruption[Moderate]<br>@Corruption[Major]`;
        }
        return content
    }

    static async checkInfection(combat) {
        if (!game.user.isUniqueGM)
            return

        let minorInfections = combat.getFlag("wfrp4e", "minorInfections") || [];
        let content = "";
        if (minorInfections.length) {
            content += `<h3><b>${game.i18n.localize("Minor Infections")}</b></h3>${game.i18n.localize("CHAT.InfectionReminder")}<br>`;
            for (let actor of minorInfections) {
                content += `<br><b>${actor}</b>`;
            }
        }
        return content
    }

    static async checkDiseases(combat) {
        if (!game.user.isUniqueGM)
            return

        let diseaseCounters = [];

        for (let turn of combat.turns) {
            let disease = turn.actor.has(game.i18n.localize("NAME.Disease"));
            if (disease) {
                let existing = diseaseCounters.find(d => d.type == disease.specification.value);
                if (existing)
                    existing.counter++;
                else
                    diseaseCounters.push({ counter: 1, type: disease.specification.value });
            }
        }
        let content = "";

        if (diseaseCounters.length) {
            content += `<h3><b>${game.i18n.localize("Diseases")}</b></h3>`;
            for (let disease of diseaseCounters)
                content += `${disease.counter} <a class="item-lookup" data-type="disease" data-open="sheet">${disease.type}</a><br>`;

            content += game.i18n.localize("CHAT.DiseasesRules");
        }
        return content
    }

    static async checkEndRoundConditions(combat) {
        if (!game.user.isUniqueGM)
            return

        let removedConditions = [];
        let msgContent = "";
        for (let turn of combat.turns) {
            let endRoundConditions = turn.actor.effects.contents.filter(e => e.system.condition.trigger == "endRound");
            for (let cond of endRoundConditions) {
                let conditionName = game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]);
                if (Number.isNumeric(cond.system.condition.value))
                    conditionName += ` ${cond.system.condition.value}`;
                msgContent = `
            <h2>${conditionName}</h2>
            <a class="chat-button" data-action="conditionScript" data-combatant-id="${turn.id}" data-cond-id="${cond.conditionId}">${game.i18n.format("CONDITION.Apply", { condition: conditionName })}</a>`;
                await ChatMessage.create({ content: msgContent, speaker: { alias: turn.token.name } });
            }

            let conditions = turn.actor.effects.contents.filter(e => e.isCondition);
            for (let cond of conditions) {
                // I swear to god whoever thought it was a good idea for these conditions to reduce every *other* round...
                if (cond.conditionId == "deafened" || cond.conditionId == "blinded" && Number.isNumeric(cond.flags.wfrp4e.roundReceived)) {
                    if ((combat.round) % 2 == cond.flags.wfrp4e.roundReceived % 2) {
                        await turn.actor.removeCondition(cond.conditionId);
                        removedConditions.push(
                            game.i18n.format("CHAT.RemovedConditions", {
                                condition: game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]),
                                name: turn.actor.token?.name || turn.actor.prototypeToken.name
                            }));
                    }
                }
            }
        }
        if (removedConditions.length)
            await ChatMessage.create({ content: removedConditions.join("<br>") });
    }

    static async fearReminders(combat) {
        let chatData = { content: game.i18n.localize("CHAT.FearReminder") + "<br><br>", speaker: { alias: game.i18n.localize("CHAT.Fear") } };
        let fearedCombatants = combat.turns.filter(t => t.actor.hasCondition("fear"));
        if (!fearedCombatants.length)
            return

        fearedCombatants.forEach(c => {
            let fear = c.actor.hasCondition("fear");
            chatData.content += `<b>${c.name}</b>`;
            if (fear.flags.wfrp4e.fearName)
                chatData.content += ` (${fear.flags.wfrp4e.fearName})`;
            chatData.content += "<br>";
        });
        await ChatMessage.create(chatData);
    }

    static async clearCombatantAdvantage(combat) {
        if (!game.user.isUniqueGM)
            return

        if (game.settings.get("wfrp4e","useGroupAdvantage")) {
            await WFRP_Utility.updateGroupAdvantage({players : 0, enemies : 0});
        } 

        for (let turn of combat.turns) {
            await turn.actor.update({ "system.status.advantage.value": 0 }, {skipGroupAdvantage: true});
        }
    }
}

function combat() {


  Hooks.on("preCreateCombatant", (combatant, data) => {
    combatant.updateSource({img : warhammer.utility.replacePopoutPath(combatant.token.texture.src)});
  });

  Hooks.on("createCombatant", combatant => {
    if (game.settings.get("wfrp4e", "useGroupAdvantage") && game.user.isGM) {
      let advantage = game.settings.get("wfrp4e", "groupAdvantageValues");
      combatant.actor.update({"system.status.advantage.value" : advantage[combatant.actor.advantageGroup]}, {fromGroupAdvantage : true});
    }
    let mask = combatant.token.hidden;
    if (mask && game.user.isGM) {
      let data = {};
      data.img = "systems/wfrp4e/tokens/unknown.png";
      data.name = "???";
      combatant.update(data);
    }
  });

  Hooks.on("updateToken", function(scene, tokenData, diffData, options, userId) {
    if (game.combat?.active && game.user.isGM) {
      let combatant = game.combat.turns.find(x => x.tokenId == tokenData._id);
      let token = game.canvas.tokens.getDocuments().find(x => x._id == tokenData._id);
      if(!token || !combatant) return;
      let mask = token.hidden;
      let data = null;
      if (combatant && mask && !combatant.hidden && combatant.name != "???") {
        data = {};
        data.img = "systems/wfrp4e/tokens/unknown.png";
        data.name = "???";
      }
      else if (combatant && !mask && !combatant.hidden && combatant.name == "???") {
        data = {};
        data.img = token.texture.src;
        data.name = token.name;
      }
      if (data) {
        combatant.update(data);
      }
    }
  });


  /* Custom Combat Carousel */
  Hooks.on('renderCombatCarousel', () => {
    addClassByQuerySelector("wfrp4e", "#combat-carousel");
    let carouselSize = game.settings.get('combat-carousel', 'carouselSize');
    if (carouselSize !== "") {
      addClassByQuerySelector(carouselSize, "#combat-carousel");
    }
  });
  
  function addClassByQuerySelector(className, selector) {
    let navigation = document.querySelector(selector);
    navigation.classList.add(className);
  }

  Hooks.on("renderCombatTracker", (app, html, options) => {
    warhammer.utility.replacePopoutTokens(app.element); // Combat tracker shows tokens, replace popout versions with normal

    if (game.settings.get("wfrp4e", "useGroupAdvantage") && !html.querySelector(".advantage-groups"))
    {
      let advantage = game.settings.get("wfrp4e", "groupAdvantageValues");
      let element = 
      $(`
      <div class="advantage-groups">
      <div class="advantage-group">
      <label>${game.i18n.localize("Players")}</label>
      <input data-group="players" type="number" value=${advantage.players}>
      </div>

      <div class="advantage-group">
      <label>${game.i18n.localize("Enemies")}</label>
      <input data-group="enemies" ${game.user.isGM ? "" : "disabled"} type="number" value=${advantage.enemies}>
      </div>
      </div>
      `);


      element.find("input").on("focus", ev => {
        ev.target.select();
      });

      element.find("input").on("change", async ev => {
        let group = ev.currentTarget.dataset.group;
        let value = Number(ev.currentTarget.value || 0);
        WFRP_Utility.updateGroupAdvantage({[`${group}`] : value});
      });

      element.insertAfter(html.querySelector(".combat-tracker-header"));
    }
  });
}

function hotbarDrop () {
  // Needs to be syncrhonous to return false
  Hooks.on("hotbarDrop", (bar, data, slot) => {
    if (data.type == "Item" || data.type == "Actor") {
      handleMacroCreation(bar, data, slot);
      return false;
    }
  });
}

async function handleMacroCreation(bar, data, slot) {
  let document = await fromUuid(data.uuid);

  if (!document)
    return

  let macro;
  if (document.documentName == "Item") {
    if (document.type != "weapon" && document.type != "spell" && document.type != "prayer" && document.type != "trait" && document.type != "skill")
      return
    if (!document)
      return false;

    let command = `game.wfrp4e.utility.rollItemMacro("${document.name}", "${document.type}");`;
    macro = game.macros.contents.find(m => (m.name === document.name) && (m.command === command) && m.canExecute);
    if (!macro) {
      macro = await Macro.create({
        name: document.name,
        type: "script",
        img: document.img,
        command: command
      }, {displaySheet: false});
    }
  } else if (document.documentName == "Actor") {
    let command = `Hotbar.toggleDocumentSheet("${document.uuid}")`;
    macro = game.macros.contents.find(m => (m.name === document.name) && (m.command === command));
    if (!macro) {
      macro = await Macro.create({
        name: "Display " + document.name,
        type: "script",
        img: document.prototypeToken.texture.src,
        command: command
      }, {displaySheet: false});
    }
  }

  game.user.assignHotbarMacro(macro, slot);
}

function journal() {
  Hooks.on("renderJournalEntrySheet", (sheet, html, options, context) => {
    if (context.isFirstRender === true)
    {
      GenericActions.addEventListeners(html, this);
    }

    let theme = game.settings.get("wfrp4e", "theme");
    if (!theme.journal.enabled)
    {
      html.classList.add("no-theme");
      html.classList.remove("classic-font");
    }
    else
    {
      html.classList.remove("no-theme");

      if (theme.journal.font == "classic")
      {
        html.classList.add("classic-font");
      }
      else
      {
        html.classList.remove("classic-font");
      }
    }
  });
}

class ChargenStage extends FormApplication {
  active = false;
  html = "";
  data = {};
  context = {};
  journalId = ""

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.id = "chargen-stage";
    options.classes = options.classes.concat("wfrp4e", "chargen");
    options.width = 1000;
    options.height = 600;
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.Title");
    options.scrollY = [".chargen-content"];
    options.cannotResubmit = false;
    return options;
  }

  
  _getHeaderButtons() {
    let buttons = super._getHeaderButtons();
      buttons.unshift(
        {
          class: "help",
          icon: "fa-solid fa-circle-question",
          onclick: async ev => this.renderJournalPage()
        });
    return buttons
  }

  async renderJournalPage()
  {
    let journalPage = await fromUuid(this.journalId);

    if (journalPage)
    {
      await journalPage.parent.sheet._render(true);
      journalPage.parent.sheet.goToPage(journalPage.id);
    }
  }

  constructor(object, options) {
    super(object, options);
    this.data = object;
  }

  async getData() {
    return { data: this.data, context: this.context };
  }

  async validate() {

    let valid = !this.options.cannotResubmit || !this.options.isCompleted; 
    if (!valid)
    {
      this.showError("StageAlreadySubmitted");
    }
    return valid
  }

  showError(key, args)
  {
    ui.notifications.error(game.i18n.format("CHARGEN.ERROR." + key, args));
  }


  updateMessage(key, args={}, string = null)
  {
    args.user = game.user.name;
    if (this.options.message)
    {
      let content = this.options.message.content;

      if (string)
        content += string;
      else
        content += game.i18n.format("CHARGEN.Message." + key, args);

     return this.options.message.update({content})
    }

  }



  // HTML to add to the char gen application
  async addToDisplay() {
    return null
  }

  static stageData() 
  {
    return {
      class: this,
      key: "stage",
      title: null,
      dependantOn: [],
      app: null,
      complete: false
    }
  }

  _updateObject(event, formData) {
    this.options.complete(this.options.index);
  }

   async _onSubmit(...args) {
    args[0].preventDefault();
    if (await this.validate())
    {
      this.options.isCompleted = true;
      super._onSubmit(...args);
    }
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.on("click", '.chargen-button, .chargen-button-nostyle', this.onButtonClick.bind(this));
    html.on("click", '.item-lookup', this._onItemLookupClicked.bind(this));

    // Autoselect entire text 
    html.find("input").on("focusin", ev => {
      ev.target.select();
    });
  }


  onButtonClick(ev) {
    let type = ev.currentTarget.dataset.button;
    if (typeof this[type] == "function") {
      this[type](ev);
    }
  }

  async _onItemLookupClicked(ev) {
    let itemType = $(ev.currentTarget).attr("data-type");
    let openMethod = $(ev.currentTarget).attr("data-open") || "sheet"; // post or sheet
    let name = $(ev.currentTarget).attr("data-name") || ev.currentTarget.text; // Use name attribute if available, otherwis, use text clicked.
    let item;
    if (name)
      item = await WFRP_Utility.find(name, itemType);

    if (item) {
      if (openMethod == "sheet")
        item.sheet.render(true);

      else
        item.postItem();
    }
  }



}

class SpeciesStage extends ChargenStage {

  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.l0f11ypRjH9sR48Q"

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 450;
    options.height = 550;
    options.classes.push("species");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageSpecies");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageSpecies"); }


  get template() {
    return "systems/wfrp4e/templates/apps/chargen/species.hbs";
  }


  context = {
    species: "",
    subspecies: "",
    exp: 0
  };


  async getData() {
    let data = await super.getData();

    data.context = this.context;

    let speciesTable = game.wfrp4e.tables.findTable("species");

    if (!speciesTable)
    {
      ui.notifications.error("CHARGEN.ERROR.SpeciesTable", {localize: true, permanent: true});
      throw new Error (game.i18n.localize("CHARGEN.ERROR.SpeciesTable"))
    }

    data.species = {};

    for (let result of speciesTable.results)
    {
      let speciesKey = warhammer.utility.findKey(result.name, game.wfrp4e.config.species);
      if (speciesKey)
      {
        data.species[speciesKey] = result.name;
      }
    }

    data.speciesDisplay = game.wfrp4e.config.species[this.context.species];

    if (this.context.species && game.wfrp4e.config.subspecies[this.context.species]) {
      data.subspeciesChoices = game.wfrp4e.config.subspecies[this.context.species];
    }

    if (this.context.subspecies) {
      data.speciesDisplay += ` (${game.wfrp4e.config.subspecies[this.context.species][this.context.subspecies]?.name})`;
    }

    if (this.context.species) {
      data.preview = {
        characteristics: game.wfrp4e.config.subspecies[this.context.species]?.[this.context.subspecies]?.characteristics ?? game.wfrp4e.config.speciesCharacteristics[this.context.species],
        movement: game.wfrp4e.config.subspecies[this.context.species]?.[this.context.subspecies]?.movement ?? game.wfrp4e.config.speciesMovement[this.context.species],
        fate: game.wfrp4e.config.subspecies[this.context.species]?.[this.context.subspecies]?.fate ?? game.wfrp4e.config.speciesFate[this.context.species],
        resilience: game.wfrp4e.config.subspecies[this.context.species]?.[this.context.subspecies]?.resilience ?? game.wfrp4e.config.speciesRes[this.context.species],
        extra: game.wfrp4e.config.subspecies[this.context.species]?.[this.context.subspecies]?.extra ?? game.wfrp4e.config.speciesExtra[this.context.species],
        ...WFRP_Utility.speciesSkillsTalents(this.context.species, this.context.subspecies)
      };

      for (let i in data.preview.talents) {
        if (Number.isNumeric(data.preview.talents[i])) {
          data.preview.randomTalents.talents = Number(data.preview.talents[i]);
        }
      }

      const or = game.i18n.localize("SkillsOr");
      data.preview.talents = data.preview.talents.filter(t => !Number.isNumeric(t)).map(t => t.replace(', ', ` <em>${or}</em> `));
      data.preview.skills = data.preview.skills.map(t => t.replace(', ', ' <em>or</em> '));

      let talents = [];

      for (let [key, value] of Object.entries(data.preview.randomTalents)) {
        let table = game.wfrp4e.tables.findTable(key);

        talents.push({
          name: table.name,
          count: Number(value)
        });
      }

      data.preview.randomTalents = talents;
    }

    if (game.wfrp4e.config.extraSpecies.length)
    {
      data.extraSpecies = game.wfrp4e.config.extraSpecies.reduce((extra, species) => {
        extra[species] = game.wfrp4e.config.species[species];
        return extra;
      }, {});
    }

    return data;
  }


  async validate() {
    let valid = super.validate();
    if (!this.context.species)
    {
      this.showError("SpeciesSubmit");
      valid = false;
    }
    return valid
  }


  /**
   * The user is allowed to freely click and choose species, but can only roll for it one time.
   * After species is rolled, user can click and choose a different species, but cannot go back and roll again
   */
  activateListeners(html) {
    super.activateListeners(html);
    html.on("click", '.species-select', this.onSelectSpecies.bind(this));
    html.on("click", '.subspecies-select', this.onSelectSubspecies.bind(this));
  }


  // Set roll, unselect whatever user has chosen
  async onRollSpecies(event) {
    event.stopPropagation();
    this.context.exp = 20;
    this.context.roll = await game.wfrp4e.tables.rollTable("species");
    this.context.choose = false;
    this.updateMessage("Rolled", {rolled : this.context.roll.name});
    this.setSpecies(findKey(this.context.roll.name, game.wfrp4e.config.species));
  }

  // Set chosen species, but don't unset "roll" (prevents users from rolling again after they've rolled once)
  onSelectSpecies(event) {
    this.context.exp = 0;
    this.context.choose = event.currentTarget.dataset.species;
    this.updateMessage("Chosen", {chosen : game.wfrp4e.config.species[this.context.choose]});
    this.setSpecies(this.context.choose);
  }


  onSelectSubspecies(event) {
    this.setSpecies(this.context.species, event.currentTarget.dataset.subspecies);
  }


  _updateObject(event, formData) {
    this.data.species = this.context.species;
    this.data.subspecies = this.context.subspecies;
    this.data.exp.species = this.context.exp;
    super._updateObject(event, formData);

  }


  setSpecies(species, subspecies) {
    this.context.species = species;
    if (subspecies) {
      this.context.subspecies = subspecies;
    }
    else {
      this.context.subspecies = "";
    }
    this.render(true);
  }
}

class CareerStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.bS2sxusEp1FEqmRk"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 400;
    options.height = 670;
    options.classes.push("career");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageCareer");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageCareer"); }

  constructor(...args) {
    super(...args);
    this.careers = this.loadCareers();
    this.context.step = 0;
    this.context.careers = [];
    this.context.replacements = [];
    this.context.career = null;
    this.context.exp = 0;
  }


  get template() {
    return "systems/wfrp4e/templates/apps/chargen/career.hbs";
  }


  async onRollCareer(event) {
    this.context.step++;

    // First step, roll 1 career
    if (this.context.step == 1) {
      this.context.exp = 50;
      await this.addCareerChoice();
      // QoL: Upon the first career roll, automatically set the selected career to it
      this.context.career = this.context.careers[0];
    }
    // Second step, Roll 2 more careers
    if (this.context.step == 2) {
      this.context.exp = 25;
      await this.addCareerChoice(2);
    }
    // Third step, keep rolling careers
    if (this.context.step >= 3) {
      this.context.exp = 0;
      await this.addCareerChoice();
    }
  }

  // Career selected, move on to the next step
  async onSelectCareer(ev) {
    let careerItem = await this.findT1Careers(ev.currentTarget.dataset.career);
    if (careerItem) {
      this.context.career = careerItem[0];
      this.updateMessage("Chosen", {chosen : this.context.career.name});

    }
    else {
      throw new Error(gam.i18n.format("CHARGEN.ERROR.CareerItem", {career : ev.currentTarget.dataset.career}));
    }
    this.render(true);
  }

  _updateObject(event, formData) {
    this.data.items.career = this.context.career.toObject();
    this.data.exp.career = this.context.exp;

    this.data.items.career.system.current.value = true;
    super._updateObject(event, formData);

  }

  async getData() {
    let data = await super.getData();
    for (let c of this.context.careers.concat(this.context.replacements)) {
      c.enriched = await foundry.applications.ux.TextEditor.implementation.enrichHTML(c.system.description.value, { async: true });
    }
    data.showChooseButton = this.context.replacements.length + this.context.careers.length > 1;
    return data
  }


  async _onDrop(ev) {
    let dragData = JSON.parse(ev.dataTransfer.getData("text/plain"));

    if (dragData.type == "Item") {
      let career = await Item.implementation.fromDropData(dragData);

      if (career.type != "career")
        return

      // If career level is not T1, find the T1 career and use that instead
      else if (career.system.level.value > 1)
      {
        let careerT1 = await this.findT1Careers(career.system.careergroup.value);
        if (careerT1[0])
          career = careerT1[0];
      }

      this.context.step = 4;
      this.context.exp = 0;
      this.context.careers.push(career);
      this.context.career = career;
      this.updateMessage("Chosen", {chosen : career.name});
    }
    this.render(true);
  }

  async validate() {
    let valid = super.validate();
    if (!this.context.career)
    {
      this.showError("CareerSubmit");
      valid = false;
    }
    return valid
  }

  async addCareerChoice(number = 1) {
    let rollSpecies = this.data.species;

    // If subspecies has defined specific table, and it's found, use that
    let subspeciesCareerTable = this.data.subspecies && game.wfrp4e.config.subspecies[this.data.species][this.data.subspecies]?.careerTable || null;
    if (subspeciesCareerTable && game.wfrp4e.tables.findTable("career", subspeciesCareerTable))
      rollSpecies = game.wfrp4e.config.subspecies[this.data.species][this.data.subspecies]?.careerTable;
    // If subspecies table is found, use that
    else if (this.data.subspecies && game.wfrp4e.tables.findTable("career", rollSpecies + "-" + this.data.subspecies))
      rollSpecies += "-" + this.data.subspecies;
    

    // If Human (no subspecies) and no "human" career table exists, use `human-reiklander` if it exists
    // This is backwards compatibility (human-reiklander table changed to just human)
    if (this.data.species == "human" && !game.wfrp4e.tables.findTable("career", "human") && game.wfrp4e.tables.findTable("career", "human-reiklander"))
    {
      rollSpecies = "human-reiklander";
    }

    for (let i = 0; i < number; i++) {
      let careerResult = await this.rollCareerTable(rollSpecies);
      let careerName = careerResult.text;

      // Some books that add careers define replacement options, such as (If you roll career X you can use this new career Y (e.g. Soldier to Ironbreaker))
      // If there's a replacement option for a given career, add that replacement career too
      let replacementOptions = game.wfrp4e.config.speciesCareerReplacements[this.data.species]?.[careerName] || [];
      replacementOptions = replacementOptions.concat(game.wfrp4e.config.speciesCareerReplacements[`${this.data.species}-${this.data.subspecies}`]?.[careerName] || []);

      let t1Careers = await this.findT1Careers(careerName);
      
      this.context.careers = this.context.careers.concat(t1Careers);
      if (replacementOptions.length > 0)
      {
        let replacements = await this.findT1Careers(replacementOptions);
        this.context.replacements = this.context.replacements.concat(replacements);
      }

      this.updateMessage("Rolled", {rolled : t1Careers.map(i => i.name).join(", ")});
    }
    this.render(true);
  }

  /**
   * Rolls on a career table based on provided species
   * Separated into its own function to cleanly overwrite in modules
   * 
   * @param {String} species Species table to roll on
   * @returns 
   */
  async rollCareerTable(species)
  {
    return await game.wfrp4e.tables.rollTable("career", {}, species);
  }

  /**
   * Given a career name, find the T1 item for that career
   * "Witch Hunter" -> Interrogator Item
   *
   * @param {String} careerName Name of career to be posted
   */
  async findT1Careers(careerNames) {

    let careers = await this.careers;
    let careersFound = [];
    
    if (typeof careerNames == "string")
      careerNames = [careerNames];

    // Find the tier 1 rank that corresponds with the career name
    for (let c of careers) {
      if (careerNames.includes(c.system.careergroup.value) && c.system.level.value == 1)
        careersFound.push(c);
      if (careersFound.length == careerNames.length)
        break;
    }

    if (careerNames.length != careersFound.length)
      this.showError("CareerItems", {num : careerNames.length - careersFound.length, careers : careerNames.toString()});
    return careersFound;
  }

  async loadCareers()
  {
    let packs = game.wfrp4e.tags.getPacksWithTag("career");
    let careers = game.items.filter(i => i.type == "career");

    let counter = 1;
    let num = packs.length;
    for (let pack of packs)
    {
      foundry.applications.ui.SceneNavigation.displayProgressBar({label: game.i18n.localize("CHARGEN.Career.LoadingCareers"), pct: Math.round((counter / num) * 100) });
      counter++;
      careers = careers.concat((await pack.getDocuments()).filter(i => i.type == "career"));
    }

    return careers;
  }

  
  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new foundry.applications.ux.DragDrop.implementation({
      dropSelector: '.chargen-content',
      permissions: { drop: () => true },
      callbacks: { drop: this._onDrop.bind(this) },
    });

    dragDrop.bind(html[0]);
  }
}

const Step = {NOT_STARTED : 0, FIRST_ROLL : 1, SWAPPING : 2, REROLL : 3, ALLOCATING : 4};

class AttributesStage extends ChargenStage {

  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.GaZa9sU4KjKDswMr"
  static get defaultOptions() {
  const options = super.defaultOptions;
    options.resizable = true;
    options.width = 400;
    options.height = 785;
    options.classes.push("career");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageAttributes");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageAttributes"); }
  get template() { return "systems/wfrp4e/templates/apps/chargen/attributes.hbs"; }



  constructor(...args) {
    super(...args);

    // Step 1: First roll, Step 2: Swapping, Step 3: Reroll, Step 4: Allocating 
    this.context.step = Step.NOT_STARTED;
    this.context.characteristics = {
      ws: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      bs: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      s: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      t: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      i: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      ag: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      dex: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      int: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      wp: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      fel: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
    },
      this.context.allocation = {
        total: 100,
        spent: 0
      };
    this.context.meta = {
      fate: { base: 0, allotted: 0, total: 0 },
      resilience: { base: 0, allotted: 0, total: 0 },
      extra: 0,
      left: 0
    };
    this.context.move = 4;
    this.context.exp = 50;
  }

  async getData() {
    let data = await super.getData();
    this.calculateTotals();

    if (this.context.step <= Step.FIRST_ROLL) {
      this.context.exp = 50;
    }
    else if (this.context.step == Step.SWAPPING && !this.context.hasRerolled) {
      this.context.exp = 25;
    }

    else
      this.context.exp = 0;

    return data;
  }

  async rollAttributes(ev, step) {
    if (step)
      this.context.step = step;
    else
      this.context.step++;

    if (this.context.step == Step.FIRST_ROLL)
    {
      await this.updateMessage("RolledCharacteristics");
    }
    else if (this.context.step == Step.REROLL)
    {
      await this.updateMessage("ReRolledCharacteristics");
    }

    let species = this.data.species;
    let subspecies = this.data.subspecies;

    let characteristicFormulae = game.wfrp4e.config.speciesCharacteristics[species];
    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].characteristics)
      characteristicFormulae = game.wfrp4e.config.subspecies[species][subspecies].characteristics;

    for (let ch in this.context.characteristics) {
      let [roll, bonus] = characteristicFormulae[ch].split("+").map(i => i.trim());
      roll = roll || "2d10";
      bonus = bonus || 0;
      this.context.characteristics[ch].formula = characteristicFormulae[ch];
      this.context.characteristics[ch].roll = (await new Roll(roll).roll({allowInteractive : false})).total;
      this.context.characteristics[ch].add = bonus;
      this.context.characteristics[ch].allocated = 0;
    }

    this.context.rolledCharacteristics = foundry.utils.duplicate(this.context.characteristics); // Used to restore roll if user goes back a step

    this.context.movement = game.wfrp4e.config.subspecies[species]?.[subspecies]?.movement ?? game.wfrp4e.config.speciesMovement[species];
    this.context.meta.fate.base = game.wfrp4e.config.subspecies[species]?.[subspecies]?.fate ?? game.wfrp4e.config.speciesFate[species];
    this.context.meta.resilience.base = game.wfrp4e.config.subspecies[species]?.[subspecies]?.resilience ?? game.wfrp4e.config.speciesRes[species];
    this.context.meta.extra = game.wfrp4e.config.subspecies[species]?.[subspecies]?.extra ?? game.wfrp4e.config.speciesExtra[species];

    this.calculateTotals();

    this.updateMessage(undefined, undefined, `
    <div class="flexcol" style="text-align: center">
      <div class="flexrow">
        <div>
          ${Object.keys(this.context.characteristics)
            .map(i => game.wfrp4e.config.characteristicsAbbrev[i])
            .join("</div><div>")
          }
        </div>
      </div>
      <div class="flexrow">
        <div>
        ${Object.values(this.context.characteristics)
          .map(i => i.total)
          .join("</div><div>")
        }
        </div>
      </div>
    </div>
    `);

    this.render();
  }

  calculateTotals() {
    this.context.allocation.spent = 0;
    this.context.advances = 0;
    for (let ch in this.context.characteristics) {
      let characteristic = this.context.characteristics[ch];
      let base = this.context.step == Step.ALLOCATING ? characteristic.allocated : characteristic.roll;
      characteristic.initial = base + Number(characteristic.add);
      characteristic.total = characteristic.initial + Number(characteristic.advances);
      this.context.allocation.spent += characteristic.allocated;
      this.context.advances += Number(characteristic.advances); // Used for validation, cannot be above 5
    }
    let fate = this.context.meta.fate;
    let resilience = this.context.meta.resilience;
    fate.total = fate.base + fate.allotted;
    resilience.total = resilience.base + resilience.allotted;
    this.context.meta.left = this.context.meta.extra - (resilience.allotted + fate.allotted);
  }

  validateTotals() {
    this.calculateTotals();
    let valid = true;
    if (this.context.meta.left < 0)
    {
      this.showError("MetaAllocation");
      valid = false;
    }
    if (this.context.allocation.spent > 100)
    {
      this.showError("CharacteristicAllocation");
      valid = false;
    }

    if (this.context.advances > 5)
    {
      this.showError("CharacteristicAdvances");
      valid = false;
    }

    if (this.context.step == Step.ALLOCATING)
    {
      let inBounds = true;
      for (let ch in this.context.characteristics) {
        let characteristic = this.context.characteristics[ch];
        if (characteristic.allocated < 4 || characteristic.allocated > 18)
          inBounds = false;
      }

      if(!inBounds)
      {
        this.showError("CharacteristicAllocationBounds");
        valid = false;
      }
    }


    return valid
  }

  validate() {
    return super.validate() && this.validateTotals();
  }

  swap(ch1, ch2) {
    if (this.context.step < Step.SWAPPING)
      this.context.step = Step.SWAPPING;

    let ch1Roll = foundry.utils.duplicate(this.context.characteristics[ch1].roll);
    let ch2Roll = foundry.utils.duplicate(this.context.characteristics[ch2].roll);

    this.context.characteristics[ch1].roll = ch2Roll;
    this.context.characteristics[ch2].roll = ch1Roll;

    this.updateMessage("SwappedCharacteristics", {ch1 : game.wfrp4e.config.characteristics[ch1], ch2: game.wfrp4e.config.characteristics[ch2]});

    this.render(true);
  }

  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new foundry.applications.ux.DragDrop.implementation({
      dragSelector: '.ch-drag',
      dropSelector: '.ch-drag',
      permissions: { dragstart: () => true, drop: () => true },
      callbacks: { drop: this.onDropCharacteristic.bind(this), dragstart: this.onDragCharacteristic.bind(this) },
    });

    dragDrop.bind(html[0]);


    html.find(".meta input").on("change", (ev) => {
      // Bind value to be nonnegative
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      this.context.meta[ev.currentTarget.dataset.meta].allotted = Number(ev.currentTarget.value);
      this.render(true);
    });

    html.find(".ch-allocate").on("change", (ev) => {
      // Bind value to be nonnegative
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      if (ev.currentTarget.value > 18 || ev.currentTarget.value < 4)
      {
        this.showError("CharacteristicAllocationBounds");
        ev.currentTarget.value = 0;
        return 
      }
      this.context.characteristics[ev.currentTarget.dataset.ch].allocated = Number(ev.currentTarget.value);
      this.render(true);
    });

    html.find(".ch-advance").on("change", ev => {
      // Bind value to be nonnegative
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      this.context.characteristics[ev.currentTarget.dataset.ch].advances = Number(ev.currentTarget.value);
      this.render(true);
    });
  }

  reroll(ev) {
    this.context.hasRerolled = true;
    // Set to step 3
    this.rollAttributes(ev, 3);
  }

  allocate(ev) {
    this.context.step = Step.ALLOCATING;
    this.updateMessage("AllocateCharacteristics");

    this.render(true);
  }

  rearrange(ev)
  {
    this.context.step = Step.SWAPPING;
    this.render(true);
  }

  // Cancel allocation or swapping, restore to the last rolled characteristic
  cancel(ev)
  {
    if (this.context.hasRerolled)
    this.context.step = Step.REROLL;
    else 
      this.context.step = Step.FIRST_ROLL;
    this.context.characteristics = foundry.utils.duplicate(this.context.rolledCharacteristics);
    this.render(true);
  }

  _updateObject(ev, formData) {
    for (let ch in this.context.characteristics) {
      this.data.characteristics[ch] = { initial: this.context.characteristics[ch].initial, advances: this.context.characteristics[ch].advances };
    }
    this.data.fate.base = this.context.meta.fate.base;
    this.data.fate.allotted = this.context.meta.fate.allotted;
    this.data.resilience.base = this.context.meta.resilience.base;
    this.data.resilience.allotted = this.context.meta.resilience.allotted;
    this.data.move = game.wfrp4e.config.speciesMovement[this.data.species];
    this.data.exp.characteristics = this.context.exp;
    super._updateObject(ev, formData);
  }

  onDragCharacteristic(ev) {
    ev.dataTransfer.setData("text/plain", JSON.stringify({ ch: ev.currentTarget.dataset.ch }));
  }

  onDropCharacteristic(ev) {
    if (ev.currentTarget.dataset.ch) {
      let ch = JSON.parse(ev.dataTransfer.getData("text/plain")).ch;
      this.swap(ev.currentTarget.dataset.ch, ch);
    }
  }
}

class SkillsTalentsStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.f5Y4XenZVtDU2GUo"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 450;
    options.height = 850;
    options.classes.push("skills-talents");
    options.minimizable = true;
    options.cannotResubmit = true;
    options.title = game.i18n.localize("CHARGEN.StageSkillsTalents");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageSkillsTalents"); }


  constructor(...args) {
    super(...args);
    let { skills, talents, randomTalents, talentReplacement, traits } = WFRP_Utility.speciesSkillsTalents(this.data.species, this.data.subspecies);

    for (let [key, value] of Object.entries(randomTalents)) {
      let table = game.wfrp4e.tables.findTable(key);

      if (!(table instanceof RollTable)) {
        ui.notifications.error(game.i18n.format("CHARGEN.ERROR.TalentsTableNotFound", {key, species: this.data.species, subspecies: this.data.subspecies}));
        continue;
      }

      this.context.speciesTalents.randomTalents[key] = {
        key: key,
        name: table.name,
        count: Number(value),
        left: Number(value),
        rolled: false,
        talents: []
      };
    }

    for (let skill of skills) {
      this.context.speciesSkills[skill] = 0;
    }

    for (let talent of talents) {

      // Set random talent count
      if (Number.isNumeric(talent)) {
        this.context.speciesTalents.randomTalents.talents.count = Number(talent);
      }

      // Comma means it's a choice
      else if (talent.includes(",")) {
        this.context.speciesTalents.choices.push(talent);
        this.context.speciesTalents.chosen.push("");
      }

      else
        this.context.speciesTalents.normal.push(talent);
    }

    for (let skill of this.data.items.career.system.skills) {
      this.context.careerSkills[skill] = 0;
    }

    for (let talent of this.data.items.career.system.talents) {
      this.context.careerTalents[talent] = false;
    }

    this.context.talentReplacement = talentReplacement;
    this.context.speciesTraits = traits;
  }

  get template() {
    return "systems/wfrp4e/templates/apps/chargen/skills-talents.hbs";
  }

  context = {
    speciesSkills: {},
    speciesTalents: {
      normal: [],
      chosen: [],
      choices: [],
      randomTalents: {}
    },
    speciesTraits : [],
    careerSkills: {},
    careerTalents: {},
  };

  async getData() {
    let data = await super.getData();

    data.speciesSkillAllocation = {
      0: [],
      3: [],
      5: []
    };

    /**#region species talents*/

    data.talents = {
      normal: this.context.speciesTalents.normal,
      random: this.#prepareRandomTalentData(),
      chosen: this.context.speciesTalents.chosen,

      // Separate choices ("Savvy,Suave") into {name : Suave, chosen : true/false}, {name : Savvy, chosen : true/false}
      choices: this.context.speciesTalents.choices.map((choice, index) => {
        return choice.split(",").map(i => {
          let name = i.trim();
          let tooltip = null;
          // matches `random[x]` and `random[x][key]` where `x` is a digit and `key` is a string
          let regex = /random\[(\d)](?:\[?([a-zA-Z-_]+)])?/i;
          let [match, amount, key] = name.match(regex) ?? [];
          amount = Number(amount);

          // Check if talent is an additional random (syntax => random[x] where x is the number of random talents to roll)
          if (match) {
            if (amount === 1)
              name = game.i18n.localize("CHARGEN.AdditionalRandomTalent");
            else
              name = game.i18n.format("CHARGEN.XAdditionalRandomTalents", { x: amount });

            // if table key was not specified, fall back to default table
            if (!key)
              key = 'talents';

            tooltip = this.context.speciesTalents.randomTalents[key]?.name;
          }

          let chosen = this.context.speciesTalents.chosen[index] === name;

          // If random is selected, add number to random talents to roll
          let table = this.context.speciesTalents.randomTalents[key];
          if (table && chosen) {
            table.left += Number(amount);
          }

          return {
            name,
            chosen,
            tooltip
          };
        });
      })
    };

    /**#endregion species talents*/

    // Sort into arrays
    for (let skill in this.context.speciesSkills) {
      data.speciesSkillAllocation[this.context.speciesSkills[skill]].push(skill);
    }

    // This case happens when user chose to roll an additional random talent, then changed their mind. Remove the extra talents
    for (let dataTable of data.talents.random) {
      if (dataTable.left < 0) {
        let table = this.context.speciesTalents.randomTalents[dataTable.key];
        let spliceIndex = table.talents.length - Math.abs(dataTable.left);
        table.talents.splice(spliceIndex);                    // Remove talents in context
        dataTable.talents.splice(spliceIndex);                // Reflect removed talents in template data
        dataTable.left = table.count - table.talents.length;  // Should be 0
      }
    }

    data.careerSkills = this.context.careerSkills;
    data.careerTalents = this.context.careerTalents;
    data.traits = this.context.speciesTraits;
    data.pointsAllocated = 40 - Object.values(this.context.careerSkills).reduce((prev, current) => prev + current, 0);
    
    return data;
  }

  /**
   * Prepare random talents data to be displayed in template, also check for duplicates
   *
   * @return {{key:string,name:string,count:number,left:number,rolled:boolean,talents:array}[]}
   */
  #prepareRandomTalentData() {
    // Convert table data from Map to Array for Handlebars
    let tablesArray = this.#getTalentTablesArray();
    let tables = tablesArray.map(t => {
      t.left = t.count - t.talents.length;
      t.talents = t.talents.map(i => {
        if (typeof i === 'object') return i;

        return {
          name : i,
          duplicate: false
        };
      });

      return t;
    });

    // Create a reference array of all talents across all tables for easy duplicate checking
    let allTalents = this.#reduceRandomTalents();
    // Add chosen talents (if they were chosen = not empty)
    allTalents.push(...this.context.speciesTalents.chosen.filter(t => t));

    // Check and mark duplicates
    tables.forEach(table => table.talents.forEach(talent => talent.duplicate = allTalents.filter(t => t === talent.name).length >= 2));

    return tables;
  }

  /**
   * Converts Random Talents Table Map to Array for easier mass operation handling
   *
   * @return {{key:string,name:string,count:number,left:number,rolled:boolean,talents:array}[]}
   */
  #getTalentTablesArray() {
    return Object.values(this.context.speciesTalents.randomTalents);
  }

  async _updateObject(ev, formData) {
    // Merge career/species skill advances into data
    for (let skill in this.context.speciesSkills) {
      if (isNaN(this.data.skillAdvances[skill]))
        this.data.skillAdvances[skill] = 0;
      this.data.skillAdvances[skill] += this.context.speciesSkills[skill];
    }
    for (let skill in this.context.careerSkills) {
      if (isNaN(this.data.skillAdvances[skill]))
        this.data.skillAdvances[skill] = 0;
      this.data.skillAdvances[skill] += this.context.careerSkills[skill];
    }

    let careerTalent;
    for (let talent in this.context.careerTalents) {
      if (this.context.careerTalents[talent])
        careerTalent = talent;
    }

    let allTalents = [
      ...this.context.speciesTalents.normal,
      ...this.context.speciesTalents.chosen,
      ...this.#reduceRandomTalents(),
      careerTalent
    ];

    let talents = await Promise.all(allTalents.map(async i => {
      try {
        return await WFRP_Utility.findTalent(i);
      } catch(error) {
        // Ignore not found.
        // This is mainly important because when a user chooses "Additional Random Talent" as a talent, it won't be found
        warhammer.utility.log(`Talent ${i} was not found`, {error, context: this.context});
      }
    }));

    let traits = await Promise.all(this.context.speciesTraits.map(async i => {
      try {
        return await WFRP_Utility.findItem(i, "trait");
      } catch(error) {
        // Ignore not found.
        // This is mainly important because when a user chooses "Additional Random Talent" as a talent, it won't be found
        warhammer.utility.log(`Trait ${i} was not found`, {error, context: this.context});
      }
    }));

    this.data.items.talents = talents.filter(i => i);
    this.data.items.traits = traits.filter(i => i);
    super._updateObject(ev, formData);

  }

  /**
   * Reduces all random table data from complex Map to simple one-dimensional Array of Talent names
   *
   * @return {string[]}
   */
  #reduceRandomTalents() {
    let tables = this.#getTalentTablesArray();

    return tables.reduce((talents, table) => {
      talents.push(...table.talents.map(talent => talent.name));
      return talents;
    }, []);
  }

  async validate() {
    let valid = super.validate();

    if (!this.validateSkills())
      valid = false;

    if (!this.#validateRandomSpeciesTalents()) {
      this.showError("SpeciesTalentsNotRolled");
      valid = false;
    }

    if (this.context.speciesTalents.chosen.filter(i => i).length < this.context.speciesTalents.choices.length) {
      this.showError("SpeciesTalentsNotChosen");
      valid = false;
    }

    if (Object.values(this.context.careerTalents).every(i => i == false)) {
      this.showError("CareerTalentNotChosen");
      valid = false;
    }

    if (Object.values(this.context.careerSkills).reduce((prev, current) => prev + current, 0) > 40) {
      this.showError("CareerSkillAllocation");
      valid = false;
    }

    return valid
  }

  #validateRandomSpeciesTalents() {
    return !this.#getTalentTablesArray().some(table => table.left > 0 || (table.count > 0 && table.rolled === false));
  }

  validateSkills() {
    let skills = Object.values(this.context.speciesSkills);
    let threes = skills.filter(i => i == 3).length;
    let fives = skills.filter(i => i == 5).length;

    if (threes > 3 || fives > 3) {
      this.showError("SpeciesSkillAdvancements");
      return false
    }
    else return true
  }



  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new foundry.applications.ux.DragDrop.implementation({
      dragSelector: '.drag-skill',
      dropSelector: '.drag-area',
      permissions: { dragstart: () => true, drop: () => true },
      callbacks: { drop: this.onDropSkill.bind(this), dragstart: this.onDragSkill.bind(this) },
    });

    dragDrop.bind(html[0]);


    html.find(".talent-choice input").click(ev => {
      let target = ev.currentTarget.name?.split("-")[1];

      if (target == "career") {
        for (let talent of this.data.items.career.system.talents) {
          this.context.careerTalents[talent] = (talent == ev.currentTarget.value);
        }
      }
      else {
        this.context.speciesTalents.chosen[target] = ev.currentTarget.value;
      }

      this.render(true);

    });

    html.find(".career-skills input").change(ev => {
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      if (ev.currentTarget.value > 10) {
        ev.currentTarget.value = 0;
        this.showError("CareerSkillAllocationBounds");
      }
      this.context.careerSkills[ev.currentTarget.dataset.skill] = Number(ev.currentTarget.value);
      this.render(true);
    });

    html.find(".reroll-duplicate").click(async ev => {
      ev.stopPropagation();
      let index = Number(ev.currentTarget.dataset.index);
      let key = ev.currentTarget.dataset.table;
      let table = this.context.speciesTalents.randomTalents[key];

      let talent = await game.wfrp4e.tables.rollTable(table.key);
      talent = await this.checkTalentReplacement(talent.text);
      table.talents[index] = talent;
      this.updateMessage("RerolledDuplicateTalent", { rolled: talent });
      this.render(true);
    });
  }


  onDropSkill(ev) {
    let skill = JSON.parse(ev.dataTransfer.getData("text/plain")).skill;
    this.context.speciesSkills[skill] = Number(ev.currentTarget.dataset.advance);
    if (!this.validateSkills()) {
      this.context.speciesSkills[skill] = 0;
    }

    this.render(true);
  }

  onDragSkill(ev) {
    ev.dataTransfer.setData("text/plain", JSON.stringify({ skill: ev.currentTarget.textContent.trim() }));
  }

  async rollRandomTalents(ev) {
    let number = Number(ev.currentTarget.dataset.number) || 0;
    let key = ev.currentTarget.dataset.table || "talents";
    let table = this.context.speciesTalents.randomTalents[key];
    if (!table) return;

    for (let i = 0; i < number; i++) {
      let talent = await game.wfrp4e.tables.rollTable(table.key);
      talent = await this.checkTalentReplacement(talent.text);
      table.talents.push(talent);
    }

    table.rolled = true;
    this.updateMessage("Rolled", { rolled: table.talents.join(", ") });
    this.render(true);
  }

  async checkTalentReplacement(talent){
    if (this.context.talentReplacement[talent]) {
      let choice = await foundry.applications.api.DialogV2.confirm.confirm({
        window : {title: game.i18n.localize("CHARGEN.SkillsTalents.ReplaceTalentDialog.Title")},
        content: game.i18n.format("CHARGEN.SkillsTalents.ReplaceTalentDialog.Content", {talent, replacement: this.context.talentReplacement[talent]})
      });

      if (choice) {
        this.updateMessage("ReplacedTalent", {talent, replacement: this.context.talentReplacement[talent]});
        return this.context.talentReplacement[talent];
      }
    }

    return talent
  }
}

class TrappingStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.hQipqLYlbBEjJEWL"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 450;
    options.height = 600;
    options.classes.push("trappings");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageTrappings");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageTrappings"); }

  get template() {
    return "systems/wfrp4e/templates/apps/chargen/trappings.hbs";
  }

  constructor(...args) {
    super(...args);

    this.context.classStrings = game.wfrp4e.config.classTrappings[this.data.items.career.system.class.value]?.split(",") || [];
    this.context.careerStrings = this.data.items.career.system.trappings;

    if (this.context.classStrings.length == 0) {
      this.showError("ClassTrappingsNotFound", { class: this.data.items.career.system.class.value });
    }

    this.context.class = Promise.all(this.context.classStrings.map(i => WFRP_Utility.find(i.trim(), game.wfrp4e.config.trappingItems)));
    this.context.career = Promise.all(this.context.careerStrings.map(i => WFRP_Utility.find(i, game.wfrp4e.config.trappingItems)));
    this.context.income = {};
  }

  context = {
    items: [],
    class: [],
    career: [],
    missing: null,
    added: []
  };

  async getData() {
    let data = await super.getData();
    this.context.class = await this.context.class;
    this.context.career = await this.context.career;

    if (!this.context.missing) {
      this.context.missing = [];

      this.context.class.forEach((trapping, i) => {
        if (!trapping) {
          this.context.missing.push({
            string: this.context.classStrings[i],
            choice: "keep"
          });
        }
      });

      this.context.career.forEach((trapping, i) => {
        if (!trapping) {
          this.context.missing.push({
            string: this.context.careerStrings[i],
            choice: "keep"
          });
        }
      });
    }

    this.context.class = this.context.class.filter(i => i);
    this.context.career = this.context.career.filter(i => i);
    return data;
  }

  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new foundry.applications.ux.DragDrop.implementation({
      dropSelector: '.chargen-content',
      permissions: { drop: () => true },
      callbacks: { drop: this._onDrop.bind(this) },
    });

    dragDrop.bind(html[0]);

    html.find(".missing-trapping-choice input").click(ev => {
      let name = ev.currentTarget.name;
      let index = Number(name.split("-")[1]);
      this.context.missing[index].choice = ev.currentTarget.value;
      this.render(true);
    });

    html.find(".remove-trapping").click(ev => {
      let index = Number(ev.currentTarget.dataset.index);
      this.context.added.splice(index, 1);
      this.render(true);
    });

  }

  async onRollIncome()
  {
    this.context.income = await game.wfrp4e.market.rollIncome(this.data.items.career);
    this.updateMessage("Income", { name: this.context.income.item.name, quantity  : this.context.income.item.system.quantity.value });
    this.render(true);
  }

  async _onDrop(ev) {
    let dragData = JSON.parse(ev.dataTransfer.getData("text/plain"));

    if (dragData.type == "Item") {
      this.context.added.push(await Item.implementation.fromDropData(dragData));
    }
    this.render(true);
  }

  _updateObject(ev, formData) {

    // Of the trappings not found, only keep the ones that are marked as "keep", and create a new miscellaneous trapping item for them
    let missing = this.context.missing.filter(i => i.choice == "keep").map(i => new Item.implementation({ name: i.string, img : "systems/wfrp4e/icons/blank.png", type: "trapping", system: { "trappingType.value": "misc" } }));

    this.data.items.trappings = missing.concat(this.context.class, this.context.career, this.context.added);
    this.data.items.income = this.context.income.item;
    super._updateObject(ev, formData);
  }
}

class DetailsStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journals.JournalEntry.IQ0PgoJihQltCBUU.JournalEntryPage.Q4C9uANCqPzlRKFD"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 500;
    options.height = 700;
    options.classes.push("details");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageDetails");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageDetails"); }

  get template() {
    return "systems/wfrp4e/templates/apps/chargen/details.hbs";
  }

  constructor(...args) {
    super(...args);
  }
  context = {
    gender: ""
  };


  async getData() {
    let data = await super.getData();
    return data;
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find(".roll-details").click(async (ev) => {
      let type = ev.currentTarget.dataset.type;
      if (this[type]) {
        let value = await this[type]();
        let input = $(ev.target).parents(".detail-form").find("input")[0];
        input.value = value;
      }
    });

    html.find("input[name='gender']").change(ev => {
      this.context.gender = ev.currentTarget.value; // Need to store gender to pass to name generation
    });
  }

  _updateObject(ev, formData) {
    this.data.details.name = formData.name;
    this.data.details.gender = formData.gender;
    this.data.details.age = formData.age;
    this.data.details.height = formData.height;
    this.data.details.eyes = formData.eyes;
    this.data.details.hair = formData.hair;
    this.data.details.motivation = formData.motivation;
    this.data.details.short = formData.short;
    this.data.details.long = formData.long;
    super._updateObject(ev, formData);
  }

  rollName() {
    return NameGenWfrp.generateName({ species: this.data.species, gender: this.context.gender });
  }
  async rollAge() {
    return (await new Roll(game.wfrp4e.config.speciesAge[this.data.species]).roll({allowInteractive : false})).total;
  }
  async rollHeight() {
    let heightRoll = (await new Roll(game.wfrp4e.config.speciesHeight[this.data.species].die).roll({allowInteractive : false})).total;
    let hFeet = game.wfrp4e.config.speciesHeight[this.data.species].feet;
    let hInches = game.wfrp4e.config.speciesHeight[this.data.species].inches + heightRoll;
    hFeet += Math.floor(hInches / 12);
    hInches = hInches % 12;
    return `${hFeet}'${hInches}`;
  }
  async rollEyes() {
    return (await game.wfrp4e.tables.rollTable("eyes", {}, this.data.species)).result;
  }
  async rollHair() {
    return (await game.wfrp4e.tables.rollTable("hair", {}, this.data.species)).result;
  }
  async rollMotivation() {
    return (await game.wfrp4e.tables.rollTable("motivation")).result;
  }
}

/**
 * This class is the center of character generation through the chat prompts (started with /char)
 */
class CharGenWfrp4e extends FormApplication {
  constructor(existing={}, options) {
    super(null, options);
    this.data = existing?.data || {
      species: null,
      subspecies: null,
      exp: {
        species: 0,
        characteristics: 0,
        career: 0
      },
      items: {
        career: null,
      },
      skillAdvances: {

      },
      characteristics: {
        ws: {initial: 0, advances : 0},
        bs: {initial: 0, advances : 0},
        s: {initial: 0, advances : 0},
        t: {initial: 0, advances : 0},
        i: {initial: 0, advances : 0},
        ag: {initial: 0, advances : 0},
        dex: {initial: 0, advances : 0},
        int: {initial: 0, advances : 0},
        wp: {initial: 0, advances : 0},
        fel: {initial: 0, advances : 0}
      },
      fate: { base: 0, allotted: 0 },
      resilience: { base: 0, allotted: 0 },
      move: 4,
      details : {
        gender : "",
        name : "",
        age : null,
        height : "",
        hair : "",
        eyes : "",
        short : "",
        long : "",
      },
      misc : {
        // Object for stages to add whatever data they wish to be merged into actor data
        // e.g. "system.details.motivation.value" : "Courage"
      }
    };
    this.stages = [
      {
        class: SpeciesStage,
        key: "species",
        dependantOn: [],
        app: null,
        complete: false
      },
      {
        class: CareerStage,
        key: "career",
        dependantOn: ["species"],
        app: null,
        complete: false
      },
      {
        class: AttributesStage,
        key: "attributes",
        dependantOn: ["career"],
        app: null,
        complete: false
      },
      {
        class: SkillsTalentsStage,
        key: "skills-talents",
        dependantOn: ["career"],
        app: null,
        complete: false
      },
      {
        class: TrappingStage,
        app: null,
        key: "trappings",
        dependantOn: ["career"],
        complete: false
      },
      {
        class: DetailsStage,
        app: null,
        key: "details",
        dependantOn: ["species"],
        complete: false
      }
    ];

    // If using existing data, record which stages were already complete
    if (existing?.stages)
    {
      for(let existingStage of existing.stages)
      {
        let stage = this.stages.find(s => s.key == existingStage.key);
        if (stage)
        {
          stage.complete = existingStage.complete;
        }
      }
    }

    this.actor = {type: "character", system: foundry.utils.deepClone(game.system.template.Actor.character), items: [] };

    if (!game.user.isGM)
    {
      ChatMessage.create({content : game.i18n.format("CHARGEN.Message.Start", {user : game.user.name})}).then(msg => this.message = msg);
    }

    // Warn user if they won't be able to create a character
    if (!game.user.isGM && !game.settings.get("core", "permissions").ACTOR_CREATE.includes(game.user.role) && !game.users.find(u => u.isGM && u.active))
    {
      ui.notifications.warn(game.i18n.localize("CHARGEN.NoGMWarning"), {permanent : true});
    }

    let speciesTable = game.wfrp4e.tables.findTable("species");

    if (speciesTable?.results.some(i => !i.name))
    {
      ui.notifications.warn("The configured Species table is from an older version and may not be compatible with character creation in V13. To ensure it works correctly, please delete and reimport the table from the compendium.", {permanent : true});
    }

    Hooks.call("wfrp4e:chargen", this);
  }


  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "chargen";
    options.template = "systems/wfrp4e/templates/apps/chargen/chargen.hbs";
    options.classes = options.classes.concat("wfrp4e", "chargen");
    options.resizable = true;
    options.width = 1000;
    options.height = 600;
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.Title");
    return options;
  }


  async getData() {

    let skills = [];


    let allItems = [];
    for(let key in this.data.items)
    {
      allItems = allItems.concat(this.data.items[key]);
    }


    let allChanges = allItems
    .filter(i => i)
    .reduce((prev, current) => prev.concat(Array.from(current.effects)), []) // reduce items to effects
    .reduce((prev, current) => prev.concat(current.changes), [])      // reduce effects to changes
    .filter(c => c.key.includes("characteristics"));                   // filter changes to characteristics

    let characteristics = foundry.utils.duplicate(this.data.characteristics);

    for (let ch in characteristics)
    {
      // Apply modifiers from item effects
      let changes = allChanges.filter(c => c.key.includes(`characteristics.${ch}`));
      let initialChanges = changes.filter(c => c.key.includes(`characteristics.${ch}.initial`));
      let modifierChanges = changes.filter(c => c.key.includes(`characteristics.${ch}.modifier`));

      let initialSum = initialChanges.reduce((prev, current) => prev += Number(current.value), 0);
      let modifierSum = modifierChanges.reduce((prev, current) => prev += Number(current.value), 0);

      characteristics[ch].initial += initialSum;
      characteristics[ch].total = characteristics[ch].initial + characteristics[ch].advances + modifierSum;
    }



    for(let key in this.data.skillAdvances)
    {
      let skill = await WFRP_Utility.findSkill(key);
      if (skill)
      {
        let ch = characteristics[skill.system.characteristic.value];
        if (ch && this.data.skillAdvances[key] > 0)
        {
          skills.push(`${key} (+${this.data.skillAdvances[key]}) ${ch.initial + ch.advances + this.data.skillAdvances[key]}`);
        }
      }
    }

    let exp = 0;
    for(let key in this.data.exp)
    {
      exp += this.data.exp[key];
    }

    this.data.fate.total = this.data.fate.allotted + this.data.fate.base;
    this.data.resilience.total = this.data.resilience.allotted + this.data.resilience.base;

    this.stages.forEach(stage => {
      stage.title ??= stage.class.title;
    });

    return {
      characteristics,
      speciesDisplay : this.data.subspecies ? `${game.wfrp4e.config.species[this.data.species]} (${game.wfrp4e.config.subspecies[this.data.species]?.[this.data.subspecies].name})` :  game.wfrp4e.config.species[this.data.species],
      stages: this.stages,
      data : this.data,
      stageHTML :  await this._getStageHTML(),
      skills : skills.join(", "),
      talents : this.data.items.talents?.map(i => i.name).join(", "),
      trappings : this.data.items.trappings?.map(i => i.name).join(", "),
      exp
    }
  }

  static async start()
  {
    let existing = localStorage.getItem("wfrp4e-chargen");
    if (existing)
    {
      let useExisting = await foundry.applications.api.DialogV2.confirm({title : game.i18n.localize("CHARGEN.UseExistingData"), content : game.i18n.localize("CHARGEN.UseExistingDataContent")});

      return new this(useExisting ? JSON.parse(existing) : null).render(true);
    }
    else
    {
      return new this().render(true);
    }
  }

  async _getStageHTML()
  {
    let html = [];

    for(let stage of this.stages)
    {
      html.push(await stage.app?.addToDisplay());
    }

    return html.filter(i => i).join("")
  }

  async _updateObject(ev, formData)
  {
    try {

      if (this.message)
        this.message.update({content : this.message.content + game.i18n.format("CHARGEN.Message.Created", {name : this.data.details.name})});

      this.actor.system.details.species.value = this.data.species;
      this.actor.system.details.species.subspecies = this.data.subspecies;

      for(let exp in this.data.exp)
      {
        if (Number.isNumeric(this.data.exp[exp]))
          this.actor.system.details.experience.total += Number(this.data.exp[exp]);
      }

      for(let key in this.data.items)
      {
        let items = this.data.items[key];
        if (!(items instanceof Array))
        {
          items = [items];
        }
        this.actor.items = this.actor.items.concat(items.filter(i => i));
      }

      let money = await WFRP_Utility.allMoneyItems();

      money.forEach(m => m.system.quantity.value = 0);

      this.actor.items = this.actor.items.concat(money.filter(m => !this.actor.items.find(existing => existing.name == m.name)));

      // Get basic skills, add advancements (if skill advanced and isn't basic, find and add it)
      let skills = await WFRP_Utility.allBasicSkills();
      for(let skill in this.data.skillAdvances)
      {
        let adv = this.data.skillAdvances[skill];
        if (Number.isNumeric(adv))
        {
          let existing = skills.find(s => s.name == skill);

          if (!existing)
          {
            existing = await WFRP_Utility.findSkill(skill);
            existing = existing.toObject();
            skills.push(existing);
          }
          existing.system.advances.value += Number(adv);
        }
      }
      this.actor.items = this.actor.items.concat(skills);

      foundry.utils.mergeObject(this.actor.system.characteristics, this.data.characteristics, {overwrite : true});
      this.actor.system.status.fate.value = this.data.fate.base + this.data.fate.allotted;
      this.actor.system.status.resilience.value = this.data.resilience.base + this.data.resilience.allotted;

      this.actor.system.status.fortune.value =  this.actor.system.status.fate.value;
      this.actor.system.status.resolve.value =  this.actor.system.status.resilience.value;

      this.actor.system.details.move.value = this.data.move;

      this.actor.name = this.data.details.name || "New Character";
      this.actor.system.details.gender.value = this.data.details.gender;
      this.actor.system.details.age.value = this.data.details.age;
      this.actor.system.details.height.value = this.data.details.height;
      this.actor.system.details.haircolour.value = this.data.details.hair;
      this.actor.system.details.eyecolour.value = this.data.details.eyes;
      this.actor.system.details.motivation.value = this.data.details.motivation;
      this.actor.system.details["personal-ambitions"] = {
        "short-term" : this.data.details.short,
        "long-term" : this.data.details.long
      };

      foundry.utils.mergeObject(this.actor, foundry.utils.expandObject(this.data.misc), {overwrite : true});


      this.actor.items = this.actor.items.filter(i => {
        if (i.type == "skill")
        {
          // Include any skill with advances
          if (i.system.advances.value > 0)
          {
            return true
          }
          // or include any basic skill that isn't a specialization
          if (i.system.advanced.value == "bsc" && i.system.grouped.value == "noSpec")
          {
            return true;
          }
          // or include any basic skill that IS a specialisation (but not specialised, i.e. Art, or Ride)
          if(i.system.advanced.value == "bsc" && i.system.grouped.value == "isSpec" && !i.name.includes("(") && !i.name.includes(")")) 
          {
            return true
          }
          else return false;
        }
        else // Return true if any other item besides skills
        {
          return true
        };
      }).map(i => {
        return i instanceof Item.implementation ? i.toObject() : i
      });


      // Must create items separately so preCreate scripts run
      let actorItems = this.actor.items;
      this.actor.items = [];

      if (game.user.isGM || game.settings.get("core", "permissions").ACTOR_CREATE.includes(game.user.role))
      {

        let document = await Actor.implementation.create(this.actor, {skipItems : true});
        await document.createEmbeddedDocuments("Item", actorItems, {skipSpecialisationChoice : true});
        // for(let i of document.items.contents)
        // {
        //   // Run onCreate scripts
        //   await i._onCreate(i._source, {}, game.user.id);
        // }
        document.sheet.render(true);
        localStorage.removeItem("wfrp4e-chargen");
      }
      else {
        let actorId = foundry.utils.randomID();
        this.actor._id = actorId;
        const payload =  {id : game.user.id, data : this.actor, options : {skipSpecialisationChoice : true, skipItems : true, keepId : true}};
        await SocketHandlers.call("createActor", payload, "GM");
        let actor = game.actors.get(actorId);
        await actor.createEmbeddedDocuments("Item", actorItems, {skipSpecialisationChoice : true});
        if (actor && actor.isOwner) 
        {
          // for(let i of actor.items.contents)
          // {
          //   // Run onCreate scripts
          //   await i._onCreate(i._source, {}, game.user.id);
          // }
          actor.sheet.render(true);
          localStorage.removeItem("wfrp4e-chargen");
        }
      }
    }
    catch(e)
    {
      ui.notifications.error(game.i18n.format("CHARGEN.ERROR.Create", {error: e}));
    }
  }

  complete(stageIndex) {
    this.stages[stageIndex].complete = true;
    Hooks.call("wfrp4e:chargenStageCompleted", this, this.stages[stageIndex]);
    localStorage.setItem("wfrp4e-chargen", JSON.stringify({data : this.data, stages : this.stages}));
    this.render(true);
  }

  canStartStage(stage)
  {
    if (!stage)
      return false

    let dependancies = stage.dependantOn.map(i => this.stages.find(s => s.key == i));
    return dependancies.every(stage => stage.complete)

  }

  addStage(stage, index, stageData = {}) {
    let stageObj = stage.stageData();
    stageObj = foundry.utils.mergeObject(stageObj, stageData);

    if (index === undefined) {
      this.stages.push(stageObj);
    } else { // Insert new stage in specified index
      let newStages = this.stages.slice(0, index);
      newStages.push(stageObj);
      newStages = newStages.concat(this.stages.slice(index));
      this.stages = newStages;
    }
  }

  replaceStage(key, stage)
  {
    let existing = this.stages.find(i => i.key == key);
    if (existing)
    {
      existing.class = stage;
    }
  }


  activateListeners(html) {
    super.activateListeners(html);

    html.find(".chargen-button").on("click", ev => {
      let stage = this.stages[Number(ev.currentTarget.dataset.stage)];

      if (!this.canStartStage(stage))
      {
        return ui.notifications.error(game.i18n.format("CHARGEN.ERROR.StageStart", {stage : stage.dependantOn.toString()}))
      }

      if (stage.app)
        stage.app.render(true);
      else {
        stage.app = new stage.class(
          this.data,
          {
            complete : this.complete.bind(this), // Function used by the stage to complete itself
            index : Number(ev.currentTarget.dataset.stage),
            message : this.message
          });
        stage.app.render(true);
      }
    });
  }
}

function sidebar() {
  Hooks.on("renderActorDirectory", async (app, html) =>
  {
      let button = document.createElement("button");
      button.textContent = game.i18n.localize("BUTTON.CharacterCreation");
      button.classList.add("character-creation");

      button.onclick = () => {CharGenWfrp4e.start();};
      let div = document.createElement("div");
      div.classList.add("action-buttons", "flexrow");
      div.appendChild(button);
      html.querySelector(".header-actions").insertAdjacentElement("afterend", div);
  });
}

function rolltable() {
    Hooks.on("preCreateTableResult", (result, data) => {
        if (!data.img)
            result.updateSource({"img" : "icons/svg/d10-grey.svg"});
    });

    Hooks.on("preCreateRollTable", (table, data) => {
        if (!data.img)
            table.updateSource({"img" : "systems/wfrp4e/ui/buttons/d10.webp"});
    });

    Hooks.on("getHeaderControlsRollTableSheet", (sheet, controls) => {
        controls.push({
            label : "Configure Table Key",
            icon : "fa-solid fa-key",
            action : "configureKey" 
        });
        sheet.options.actions.configureKey = function (ev, target){
            let key = this.document.getFlag("wfrp4e", "key");
            let column = this.document.getFlag("wfrp4e", "column");

            new foundry.applications.api.DialogV2({
              window: { title: "Table Key & Column" },
              content: `
              <div class="form-group">
                <label>Key</label>
              <div class="form-fields">
              <input type="text" value="${key}" name="key"/>
              </div>
              </div>

              <div class="form-group">
                <label>Column</label>
              <div class="form-fields">
              <input type="text" value="${column}" name="column"/>
              </div>
              </div>
              `,
              buttons: [{
                action: "submit",
                label: "Submit",
                default: true,
                callback: (event, button, dialog) => {
                    let key = button.form.elements.key.value;
                    let column = button.form.elements.column.value;

                    this.document.update({"flags.wfrp4e" : {key, column}});
                }
              }],
            }).render({ force: true });
        };
        sheet.options.actions.configureKey = sheet.options.actions.configureKey.bind(sheet);
    });
}

class StatBlockParser extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "stat-parser";
        options.template = "systems/wfrp4e/templates/apps/stat-parser.hbs";
        options.height = 600;
        options.width = 600;
        options.minimizable = true;
        options.title = "Stat Block Parser";
        return options;
    }

    getData() {

        let types = game.system.template.Actor.types;
        return { types }
    }


    async _updateObject(event, formData) {
        let {name, type, system, items} = await StatBlockParser.parseStatBlock(formData.statBlock, this.object.type);
        await this.object.update({name, type, system});
        await this.object.createEmbeddedDocuments("Item", items);
    }

    static async parseStatBlock(statString, type = "npc") {
        let model = foundry.utils.duplicate(game.model.Actor[type]);

        let blockArray = statString.split("\n");
        let name = blockArray[0].split("—")[0].split(" ").filter(f => !!f);

        name = name.map(word => {
            if (word == "VON")
                return word.toLowerCase();

            word = word.toLowerCase();
            word = word[0].toUpperCase() + word.substring(1, word.length);
            return word;
        });
        name = name.join(" ");

        let status  = -1;
        if (blockArray[0].includes("("))
            status = blockArray[0];
        else if (blockArray[1].includes("("))
            status = blockArray[1];
        
        if (status != -1 && foundry.utils.hasProperty(model, "details.status.value"))
        {
            status = status.substring(status.indexOf("(")+1, status.indexOf(")"));
            model.details.status.value = status[0] + status.slice(1).toLowerCase();
        }

        let tableIndex = blockArray.findIndex(v => v.includes(" WS "));
        let characteristicNames = blockArray[tableIndex].split(" ");
        let characteristicValues = blockArray[tableIndex + 1].split(" ");

        for (let i = 0; i < characteristicNames.length; i++) {
            const value = Number(characteristicValues[i]) || 0;

            if (characteristicNames[i] == "Agi")
                characteristicNames[i] = "Ag";
            if (characteristicNames[i].toLowerCase() == "m") {
                model.details.move.value = value;
                continue;
            }
            if (characteristicNames[i].toLowerCase() == "w")
                continue;

            try {
                model.characteristics[characteristicNames[i].toLowerCase()].initial = value;
            }
            catch { }
        }


        let skillRegex = /([a-zA-Z\s]+?)(?:\((.+?)\)|)\s?(\d{1,3}|)(?:,|$)/gm;
        let talentRegex = /(?:,?(.+?)(\d{1,2})?(?:\((.+?)\)\s*(\d{1,2})?|,|$))/gm;
        let traitRegex = /(?:,?(.+?)(\+?\d{1,2}\+?)?\s*?(?:\((.+?)\)\s*(\+?\d{1,2})?|,|$))/gm;

        let skillBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Skills")));
        let talentBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Talents")));
        let traitBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Traits")));
        let trappingBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Trappings")) || v.split(" ")[0].includes(game.i18n.localize("Possessions")));


        let skillBlockIndex = skillBlockIndexStart;
        let talentBlockIndex = talentBlockIndexStart;
        let traitBlockIndex = traitBlockIndexStart;
        let trappingBlockIndex = trappingBlockIndexStart;

        let skillBlock = blockArray[skillBlockIndex] || "";
        let talentBlock = blockArray[talentBlockIndex] || "";
        let traitBlock = blockArray[traitBlockIndex] || "";
        let trappingBlock = blockArray[trappingBlockIndex] || "";

        while (skillBlockIndex >= 0) {
            skillBlockIndex++;
            if (skillBlockIndex == talentBlockIndexStart || skillBlockIndex == traitBlockIndexStart || skillBlockIndex == trappingBlockIndexStart || skillBlockIndex >= blockArray.length)
                break;

            skillBlock = skillBlock.concat(" " + blockArray[skillBlockIndex]);
        }
        while (talentBlockIndex >= 0) {
            talentBlockIndex++;
            if (talentBlockIndex == skillBlockIndexStart || talentBlockIndex == traitBlockIndexStart || talentBlockIndex == trappingBlockIndexStart || talentBlockIndex >= blockArray.length)
                break;

            talentBlock = talentBlock.concat(" " + blockArray[talentBlockIndex]);
        }
        while (traitBlockIndex >= 0) {
            traitBlockIndex++;
            if (traitBlockIndex == skillBlockIndexStart || traitBlockIndex == talentBlockIndexStart || traitBlockIndex == trappingBlockIndexStart || traitBlockIndex >= blockArray.length)
                break;

            traitBlock = traitBlock.concat(" " + blockArray[traitBlockIndex]);
        }
        while (trappingBlockIndex >= 0) {
            trappingBlockIndex++;
            if (trappingBlockIndex == skillBlockIndexStart || trappingBlockIndex == talentBlockIndexStart || trappingBlockIndex == traitBlockIndexStart || trappingBlockIndex >= blockArray.length)
                break;

            trappingBlock = trappingBlock.concat(" " + blockArray[trappingBlockIndex]);
        }



        let skillStrings = skillBlock.substring(skillBlock.indexOf(":")+1);
        let talentStrings = talentBlock.substring(talentBlock.indexOf(":")+1);
        let traitStrings = traitBlock.substring(traitBlock.indexOf(":")+1);
        let trappingStrings = trappingBlock.substring(trappingBlock.indexOf(":")+1);


        let skillMatches = skillStrings.matchAll(skillRegex);
        let talentMatches = talentStrings.matchAll(talentRegex);
        let traitMatches = traitStrings.matchAll(traitRegex);
        //let trappingMatches = skillStrings.matchAll(trappingRegex)


        let skills = [];
        let talents = [];
        let traits = [];
        let trappings = [];


        for (let match of skillMatches){

            /**
             * 3 Cases
             * 1. Intution 67
             * 2. Language (Magick) 52
             * 3. Melee (Basic 56, Polearm 62, ...)
             */

            let skillName = match[1]; // Name of the skill, should always exist
            let skillGroup = match[2]; // either null (case 1), a word(s) (case 2) or a group of words-values pairs (case 3)
            let skillValue = match[3];  // Either null (case 3) or a value (case 1 and 2)

            let skillSearches = [];
            let skillItems = [];

            // Case 3
            if (!Number.isNumeric(skillValue))
            {
                let innerMatches = skillGroup.matchAll(skillRegex); // rerun regex on inner group
                for (let inner of innerMatches)
                {
                    skillSearches.push({name : skillName, group : inner[1], value : inner[3]});
                }
            }
            else // case 1 and 2
            {
                skillSearches.push({name : skillName, group : skillGroup, value : skillValue});
            }

            skillSearches.forEach(s => {
                s.name = s.name?.trim();
                s.group = s.group?.trim();
                s.value = s.value?.trim();
            });


            for(let search of skillSearches)
            {
                let skillItem;
                try {skillItem = await WFRP_Utility.findSkill(`${search.name} ${search.group ? "(" + search.group + ")" : ""}`.trim());}
                catch {}
                if (!skillItem) {
                    console.error("Could not find " + search.name);
                    ui.notifications.error(game.i18n.format("ERROR.Parser", {name: search.name}), { permanent: true });
                    continue
                }
                else skillItem = skillItem.toObject();

                skillItem.system.advances.value = Number(search.value) - model.characteristics[skillItem.system.characteristic.value].initial;

                skillItems.push(skillItem);

            }
            skills = skills.concat(skillItems);
        }
        
        for (let match of talentMatches){

            let talentName = match[1].trim();
            let talentAdvances = parseInt(match[2] || match[4]); // could be match 2 or 4 depending on if there's a specialization
            let talentSpec = match[3]?.trim();

            let talentItem;
            try { talentItem = await WFRP_Utility.findTalent(talentName); }
            catch { }

            if (!talentItem) {
                console.error("Could not find " + talentName);
                ui.notifications.error(game.i18n.format("ERROR.Parser", {name: talentName}), { permanent: true });
                continue
            }
            talentItem = talentItem.toObject();

            if (talentName == game.i18n.localize("NAME.Doomed"))
            {
                talentItem.system.description.value += `<br><br><em>${talentSpec}</em>`;
            }
            else if (talentName == game.i18n.localize("NAME.Etiquette"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("Social Group"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.Resistance"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("the associated Threat"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.AcuteSense"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("Sense"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.Strider"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("the Terrain"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.Savant"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("chosen Lore"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == "Craftsman")
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace("any one", match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentSpec)
                talentItem.name += ` (${talentSpec})`;

            talentItem.system.advances.value = 1;

            if (Number.isNumeric(talentAdvances))
            {
                for (let i = 1; i < talentAdvances; i++)
                    talents.push(talentItem);

            }
            talents.push(talentItem);
        }

        for (let match of traitMatches) {

            let traitName = match[1];
            let traitVal = match[2] || match[4]; // could be match 2 or 4 depending on if there's a specialization
            let traitSpec = match[3];


            let traitItem;
            try {
                traitItem = await WFRP_Utility.findItem(traitName, "trait");
            }
            catch { }
            if (!traitItem) {
                console.error("Could not find " + traitName);
                ui.notifications.error(game.i18n.format("ERROR.Parser", {name: traitName}), { permanent: true });
                continue
            }
            traitItem = traitItem.toObject();

            if (Number.isNumeric(traitVal))
            {
                traitItem.system.specification.value = traitName.includes('Weapon','Horns','Tail','Tentacles','Bite') ? traitVal - parseInt(characteristicValues[3]/10) : traitVal;
                traitItem.name = (traitItem.name +  ` ${traitSpec ? "("+ traitSpec + ")" : ""}`).trim();
            }
            else 
                traitItem.system.specification.value = traitSpec;

            traits.push(traitItem);
        }

        if (trappingStrings)
        {
            for (let trapping of trappingStrings.split(",")) {
    
                let trappingItem = await WFRP_Utility.findItem(trapping, game.wfrp4e.config.trappingItems);
                if (!trappingItem) {
                    trappingItem = new Item.implementation({ img: "systems/wfrp4e/icons/blank.png", name: trapping, type: "trapping", data: game.model.Item.trapping });
                    trappingItem.updateSource({"trappingType.value" : "misc"});
                }
                trappings.push(trappingItem.toObject());
            }
        }

        let moneyItems = await WFRP_Utility.allMoneyItems() || [];
        // moneyItems = moneyItems.map(i => i.toObject())
        moneyItems = moneyItems.sort((a, b) => (a.system.coinValue > b.system.coinValue) ? -1 : 1);
        moneyItems.forEach(m => m.system.quantity.value = 0);

        skills.forEach(t => {
            delete t._id;
        });

        trappings.forEach(t => {
            delete t._id;
        });
        
        talents.forEach(t => {
            delete t._id;
        });
        traits.forEach(t => {
            delete t._id;
        });

        let items = skills.concat(talents).concat(traits).concat(trappings).concat(moneyItems);

        let effects = items.reduce((effects, item) => effects.concat(item.effects), []);

        effects.forEach(e => {
            for(let c of e.changes)
            {
                let systemPath = c.key.replace("system.", "");
                if (foundry.utils.hasProperty(model, systemPath))
                {
                    foundry.utils.setProperty(model, systemPath, -1 * Number(c.value) + foundry.utils.getProperty(model, systemPath));
                }
            }
        });

        return { name, type, system: model, items}
    }

}

class EditTest extends  HandlebarsApplicationMixin(ApplicationV2)
{
    static DEFAULT_OPTIONS = {
        tag: "form",
        classes: ["warhammer", "standard-form", "edit-test"],
        window: {
            title: "Edit Test",
            resizable : false,
        },
        form: {
            submitOnChange: false,
            closeOnSubmit : true,
            handler: this._onSubmit
        }
    }

    constructor(test, options) {
        super(options);
        this.test = test;
    }


      /** @override */
    static PARTS = {
        form: {
            template: "systems/wfrp4e/templates/apps/edit-test.hbs",
        },
    };

    async _prepareContext(options) {
        let context = await super._prepareContext(options);
        context.roll = this.test.preData.roll;
        context.hitloc = this.test.preData.hitloc;
        context.SL = this.test.preData.SL;
        context.target = this.test.preData.target;
        return context;
    }

    static _onSubmit(ev, form, formData)
    {
        this.test.edit(formData.object);
    }
}

let fields$x = foundry.data.fields;
class OpposedHandlerMessage extends WarhammerMessageModel 
{
    static defineSchema() 
    {
        let schema = {};
        schema.opposedData = new fields$x.ObjectField();
        return schema;
    }

    get opposedHandler() 
    {
        return new OpposedHandler(this.opposedData, this.parent);
    }

    static get actions() 
    { 
        return foundry.utils.mergeObject(super.actions, {
            clickOpposedToggle : this.onClickOpposedToggle,
            clickOpposedImg : this.onClickOpposedImg,
            clickOpposedResponse : this.onClickOpposedResponse
        });
    }

    async onRender(html)
    {
      warhammer.utility.replacePopoutTokens(html);
    }

    /**
     * The opposed button was clicked, evaluate whether it is an attacker or defender, then proceed
     * to evaluate if necessary.
     */
    static async clickManualOpposed(message) {

        if (game.wfrp4e.oppose && !game.wfrp4e.oppose.attackerMessage) 
        {
            delete game.wfrp4e.oppose;
        }

        // Opposition already exists - click was defender
        if (game.wfrp4e.oppose) 
        {
            await game.wfrp4e.oppose.setDefender(message);
            await game.wfrp4e.oppose.renderMessage(); // Rerender opposed start with new message
            await game.wfrp4e.oppose.computeOpposeResult();
            delete game.wfrp4e.oppose;
        }
        // No opposition - click was attacker
        else 
        {
            game.wfrp4e.oppose = new OpposedHandler();
            await game.wfrp4e.oppose.setAttacker(message);
            await game.wfrp4e.oppose.renderMessage();
        }

    }

    static onClickOpposedImg(ev, target)
    {
        let side = target.dataset.side;
        this.opposedHandler[side]?.sheet.render(true);
    }

    static onClickOpposedResponse(ev, target)
    {
        let id = target.dataset.itemId;
        this.opposedHandler.resolveOpposed(id);
    }
}

function entryContext () {

  /**
   * Add right click option to actors to add all basic skills
   */
  Hooks.on("getActorContextOptions", async (html, options) => {
    options.push(
      {
        name: game.i18n.localize("ACTOR.AddBasicSkills"),
        condition: game.user.isGM,
        icon: '<i class="fas fa-plus"></i>',
        callback: target => {
          const actor = game.actors.get(target.dataset.entryId);
          actor.addBasicSkills();
        }
      });
    options.push(
      {

        name: game.i18n.localize("ACTOR.ClearMount"),
        icon: '<i class="fas fa-horse"></i>',
        callback: target => {
          const actor = game.actors.get(target.dataset.entryId);
          return actor.update({
            "system.status.mount": {
              "id": "",
              "mounted": false,
              "isToken": false,
              "tokenData": {
                "scene": "",
                "token": ""
              }
            }
          })
        }
      });
    options.push(
      {

        name: game.i18n.localize("ACTOR.ImportStatBlock"),
        condition: game.user.isGM,
        icon: '<i class="fa fa-download"></i>',
        callback: target => {
          const actor = game.actors.get(target.dataset.entryId);
          new StatBlockParser(actor).render(true);
        }
      });
  });

  Hooks.on("getChatMessageContextOptions", (html, options) => {
    let canApply = li => game.messages.get(li.dataset.messageId).system.opposedTest || li.querySelector(".dice-roll");
    let hasTest  = li => game.messages.get(li.dataset.messageId).system.test;
    let canApplyFortuneReroll = function (li) {
      //Condition to have the fortune contextual options:
      //Be owner of the actor
      //actor have fortune point
      //Own the roll
      //Once per roll (or at least, not on a reroll card)
      //Test must be failed 
      let message = game.messages.get(li.dataset.messageId);
      let test = message.system?.test;
      return test && test.actor.isOwner && test.actor.status.fortune?.value > 0 && test.failed && !test.fortuneUsed.reroll

    };
    let canApplyFortuneAddSL = function (li) {
      //Condition to have the fortune contextual options:
      //Be owner of the actor
      //Have fortune point
      //Own the roll
      //Once per roll (or at least, not on a reroll card)
      let message = game.messages.get(li.dataset.messageId);
      let test = message.system?.test;
      return test && test.actor.isOwner && test.actor.status.fortune?.value > 0 && !test.fortuneUsed.SL 
    };
    let canApplyDarkDeals = function (li) {
      //Condition to have the darkdeak contextual options:
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.dataset.messageId);
      let test = message.system?.test;
      return test && test.actor.isOwner && test.actor.type == "character"
    };

    let canGMReroll = function (li) {
      //Condition to have the darkdeak contextual options:
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.dataset.messageId);
      let test = message.system?.test;
      return test && game.user.isGM
    };

    let canCompleteUnopposed = function (li) {
      //Condition to be able to target someone with the card
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.dataset.messageId);
      let test = message.system?.test;
      return game.user.isGM && test && test.opposedMessages.length >= 2
    };

    let canApplyAllDamage = function (li) {
      //Condition to be able to target someone with the card
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.dataset.messageId);
      let test = message.system?.test;
      return game.user.isGM &&  test && test.opposedMessages.length >= 2 && test.opposedMessages.some(m => m?.system.opposedHandler?.resultMessage)
    };

    let canApplyTotalPower = function (li) {
      //Condition to be able to target someone with the card
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.dataset.messageId);
      let test = message.system?.test;
      return (message.isOwner || message.isAuthor) && test && test instanceof CastTest && test.result.critical && game.settings.get("wfrp4e", "useWoMOvercast") && !test.result.totalPower
    };

    options.push(
      {
        name: game.i18n.localize("CHATOPT.ApplyDamage"),
        icon: '<i class="fas fa-user-minus"></i>',
        condition: canApply,
        callback: li => {

          if (li.querySelector(".dice-roll")) {
            let amount = li.querySelector('.dice-total').textContent;
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount));
          }
          else {
            let message = game.messages.get(li.dataset.messageId);
            let opposedTest = message.system.opposedTest;

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.NORMAL)
              .then(updateMsg => OpposedHandler.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyDamageNoAP"),
        icon: '<i class="fas fa-user-shield"></i>',
        condition: canApply,
        callback: li => {
          if (li.querySelector(".dice-roll")) {
            let amount = li.querySelector('.dice-total').textContent;
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP }));
          }
          else {
            let message = game.messages.get(li.dataset.messageId);
            let opposedTest = message.system.opposedTest;

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP)
              .then(updateMsg => OpposedHandler.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyDamageNoTB"),
        icon: '<i class="fas fa-fist-raised"></i>',
        condition: canApply,
        callback: li => {
          if (li.querySelector(".dice-roll")) {
            let amount = li.querySelector('.dice-total').textContent;
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB }));
          }
          else {
            let message = game.messages.get(li.dataset.messageId);
            let opposedTest = message.system.opposedTest;

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB)
              .then(updateMsg => OpposedHandler.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyDamageNoTBAP"),
        icon: '<i class="fas fa-skull-crossbones"></i>',
        condition: canApply,
        callback: li => {
          if (li.querySelector(".dice-roll")) {
            let amount = li.querySelector('.dice-total').textContent;
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL }));
          }
          else {
            let message = game.messages.get(li.dataset.messageId);
            let opposedTest = message.system.opposedTest;

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL)
              .then(updateMsg => OpposedHandler.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.UseFortuneReroll"),
        icon: '<i class="fas fa-dice"></i>',
        condition: canApplyFortuneReroll,
        callback: li => {
          let message = game.messages.get(li.dataset.messageId);
          let test = message.system.test;
          test.useFortune("reroll");
        }
      },
      {
        name: game.i18n.localize("CHATOPT.Reroll"),
        icon: '<i class="fas fa-dice"></i>',
        condition: canGMReroll,
        callback: li => {
          let message = game.messages.get(li.dataset.messageId);
          let test = message.system.test;
          test.reroll();
        }
      },
      {
        name: game.i18n.localize("CHATOPT.UseFortuneSL"),
        icon: '<i class="fas fa-plus-square"></i>',
        condition: canApplyFortuneAddSL,
        callback: li => {
          let message = game.messages.get(li.dataset.messageId);
          let test = message.system.test;
          test.useFortune("addSL");
        }
      },
      {
        name: game.i18n.localize("CHATOPT.DarkDeal"),
        icon: '<i class="fas fa-pen-nib"></i>',
        condition: canApplyDarkDeals,
        callback: li => {
          let message = game.messages.get(li.dataset.messageId);
          let test = message.system.test;
          test.useDarkDeal();
        }
      },
      {
        name: game.i18n.localize("CHATOPT.StartOpposed"),
        icon: '<i class="fas fa-sword"></i>',
        condition: li => {return (hasTest(li) && !game.wfrp4e.oppose)},
        callback: li => {
          let message = game.messages.get(li.dataset.messageId);
          let test = message.system.test;

          let targets = Array.from(game.user.targets).map(t => t.actor.speakerData(t.document));

          if (targets.length)
          {
            if (canvas.scene) 
            { 
              game.canvas.tokens.setTargets([]);
            }

            test.context.targets = test.context.targets.concat(targets);
            targets.map(t => WFRP_Utility.getToken(t)).forEach(t => 
            {
              test.createOpposedMessage(t);
            });
          }
          else // no targets
          {
            OpposedHandlerMessage.clickManualOpposed(message);
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.DefendOpposed"),
        icon: '<i class="fas fa-shield"></i>',
        condition: li => {return (hasTest(li) && game.wfrp4e.oppose)},
        callback: li => {
          let message = game.messages.get(li.dataset.messageId);
          OpposedHandlerMessage.clickManualOpposed(message);
        }
      },
      {
        name: game.i18n.localize("CHATOPT.CompleteUnopposed"),
        icon: '<i class="fas fa-angle-double-down"></i>',
        condition: canCompleteUnopposed,
        callback: li => {

          let message = game.messages.get(li.dataset.messageId);
          let test = message.system.test;
          test.opposedMessages.forEach(message => {
            if (message)
            {
              let oppose = message.system.opposedHandler;
              oppose.resolveUnopposed();
            }
          });
        }
      },
      {
        name: game.i18n.localize("CHATOPT.EditTest"),
        icon: '<i class="fas fa-edit"></i>',
        condition: hasTest,
        callback: li => {
          let message = game.messages.get(li.dataset.messageId);
          let test = message.system.test;
          new EditTest(test).render(true);
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyAllDamage"),
        icon: '<i class="fas fa-user-minus"></i>',
        condition: canApplyAllDamage,
        callback: li => {
          let message = game.messages.get(li.dataset.messageId);
          let test = message.system.test;
          for (let message of test.opposedMessages) {
            if (message) {
              let opposedTest = message.system.opposedHandler;
              if (!opposedTest.defenderTest.actor.isOwner) {
                ui.notifications.error(game.i18n.localize("ErrorDamagePermission"));
              } else {
                opposedTest.defender.applyDamage(opposedTest.resultMessage.system.opposedTest, game.wfrp4e.config.DAMAGE_TYPE.NORMAL)
                  .then(updateMsg => OpposedHandler.updateOpposedMessage(updateMsg, opposedTest.resultMessage.id));
              }
            }
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.TotalPower"),
        icon: '<i class="fa-solid fa-bolt"></i>',
        condition: canApplyTotalPower,
        callback: li => {
          let message = game.messages.get(li.dataset.messageId);
          let test = message.system.test;
          test.preData.totalPower = true;
          test.roll();
        }
      }
    );
  });
}

function token() {


  Hooks.on("createToken", async (token, data, user) => {

    if(game.user.isUniqueGM) // Prevents multiple mount tokens
    {
      let scene = token.parent;

      if (token.actor.isMounted && canvas.scene.id == scene.id)
      {
        let mount = token.actor.mount;
        let mountToken = await mount.getTokenDocument();
        mountToken.updateSource({ x : token.x, y : token.y, hidden: token.hidden, sort : token.sort - 1 });

        // Shift token slightly if same size
        if (mountToken.actor.details.size.value == token.actor.details.size.value)
        {
          mountToken.updateSource({
            x : mountToken.x + canvas.grid.size/4,
            y : mountToken.y + canvas.grid.size/4
          });
        }
        mountToken = (await scene.createEmbeddedDocuments("Token", [mountToken]))[0];
        await token.update({"flags.wfrp4e.mount" : mountToken.id }); // place mount id in token so when it moves, the mount moves (see updateToken)
        token.zIndex = 1; // Ensure rider is on top

        if (!mountToken.actorLink)
        {
            let tokenData = {
              scene : scene._id,
              token : mountToken._id
            };
          token.actor.update({"system.status.mount.isToken" : true, "system.status.mount.tokenData" : tokenData});
        }
      }

    }

    if (game.user.id == user)
    {
        token.actor.runScripts("createToken", token);
    }
  });

  Hooks.on("updateToken", (token, updateData, options) => {
      let scene = token.parent;
      if (game.user.isUniqueGM)
      {
        if (foundry.utils.hasProperty(token, "flags.wfrp4e.mount") && (updateData.x || updateData.y) && scene.id == canvas.scene.id)
        {
          if (canvas.tokens.get(token.id).actor.isMounted)
          {
            let mountId = token.getFlag("wfrp4e", "mount");
            let mountToken = canvas.tokens.get(mountId);
            if (mountToken)
            {

              let tokenUpdate = {_id : mountId, x : updateData.x || token.x, y: updateData.y || token.y, sort : token.sort - 1 };
              if (token.actor?.details.size.value == token.actor?.mount.details.size.value)
              {
                tokenUpdate.x += canvas.grid.size / 4;
                tokenUpdate.y += canvas.grid.size / 4;
              }
              mountToken.document.update(tokenUpdate);
            }
          }
        }
      }
    });

  Hooks.on('renderTokenHUD', (hud, html) => {
    _addMountButton(hud, html);
    _addPassengerButton(hud, html);

    for (let condition of html.querySelectorAll("img.effect-control")) {
      condition.dataset.tooltip = game.wfrp4e.config.conditions[condition.dataset["statusId"]];
      if (condition.dataset.statusId == "dead")
        condition.dataset.tooltip = "Dead";
    }
  });

  Hooks.on("refreshToken", token => {
    if (token.document?.getFlag("wfrp4e", "hidePassengers"))
      token.passengers?.destroy();
    else
      passengerRender(token);
    });
    



  
  function _addMountButton(hud, html)
  {
    if (canvas.tokens.controlled.length == 2)// && canvas.tokens.controlled[0].actor.details.size.value != canvas.tokens.controlled[1].actor.details.size.value)
    {
      const button = document.createElement("button");
      button.classList.add("control-icon");
      button.innerHTML = `<i class="fas fa-horse"></i>`;

      button.addEventListener("click", (async event => {
        let token1 = canvas.tokens.controlled[0].document;
        let token2 = canvas.tokens.controlled[1].document;

        if (!token1 || !token2)
          return  

        let mountee = hud.object.document;
        let mounter = hud.object.document.id == token1.id ? token2 : token1;
        if (game.wfrp4e.config.actorSizeNums[mounter.actor.details.size.value] > game.wfrp4e.config.actorSizeNums[mountee.actor.details.size.value])
        {
          let temp = mountee;
          mountee = mounter;
          mounter = temp;
        }

        let tokenData = undefined;
        if (!mountee.actorLink) {
          tokenData = {
            scene: canvas.scene.id,
            token: mountee.id
          };
          if (mounter.actorLink)
            ui.notifications.warn(game.i18n.localize("WarnUnlinkedMount"));
        }
        await mounter.actor.update({ "system.status.mount.id": mountee.actorId, "system.status.mount.mounted": true, "system.status.mount.isToken": !mountee.actorLink, "system.status.mount.tokenData": tokenData });
        await mounter.update({"flags.wfrp4e.mount" : mountee._id, x : mountee.x, y : mountee.y});
        mounter.zIndex = 1; // Ensure rider is on top


      }));
      html.querySelector('.col.right').insertAdjacentElement("beforeend", button);
    }
  }

  function _addPassengerButton(hud, html)
  {
      if (hud.object.actor?.type != "vehicle")
      {
        return
      }

      const button = document.createElement("button");
      button.classList.add("control-icon");
      if (hud.object.document.getFlag("wfrp4e", "hidePassengers"))
      {
        button.classList.add("active");
      }
      button.innerHTML = `<i class="fa-solid fa-user-slash"></i>`;

      button.dataset.tooltip = "WFRP4E.TogglePassengers";

      button.addEventListener("click", (event => {
        let newState = !hud.object.document.getFlag("wfrp4e", "hidePassengers");
        event.currentTarget.classList.toggle("active", newState);
        
        hud.object.document.setFlag("wfrp4e", "hidePassengers", newState).then(() => {
          // newState ? hud.object.passengers?.destroy() : passengerRender(hud.object);
        });
      }));
      html.querySelector('.col.right').insertAdjacentElement("beforeend", button);

  }
}

/** Creates and manages an Item posted to chat, retrievable by dragging and dropping from chat into an Actor sheet.
 *  If the item is physical, with quantity and price, it also tracks who has dragged and the amount it has been dragged
 *  If a "Post Quantity" is specified, then it can only be retrieved that many times before disallowing further dragging. 
 */

  

class CreditMessageModel extends WarhammerMessageModel {
  static defineSchema() 
  {
      let schema = {};

      // Pay string i.e. "5gc1ss12bp"
      schema.payString = new foundry.data.fields.StringField({});

      // What payment is for
      schema.reason = new foundry.data.fields.StringField();

      schema.splits = new foundry.data.fields.ArrayField(new foundry.data.fields.StringField({nullable : true}));

      return schema;
  }

  static handleCreditCommand(amount, mode="each", {split, reason, target}={})
  {
      //If the user isnt a GM, they pay
      if (!game.user.isGM) 
      {
          ui.notifications.error("MARKET.CreditCommandNotAllowed", {localize : true});
      } 
      else // If GM
      {
        if (target) // If targeted reward
        {
          let actor = game.actors.find(a => a.name.toLowerCase().includes(target.toLowerCase() ) );
          if ( actor ) 
          {
            let p = getActiveDocumentOwner(actor);
            if (actor.hasPlayerOwner && p ) 
            {
              target = p.name; // In this case, replace the actor by the player name for chat card, as usual
            } 
            else 
            {
              MarketWFRP4e.directPayCommand(amount, actor); // No player/Not active -> substract money
              return false;
            }
          }
        }
        // Default choice, display chat card
        this.createCreditMessage(amount, mode, {split : Number(split) ,reason, player: target});
      }
      return false;
  }
  

  static createCreditMessage(amount, mode, {split=1, reason, target}={}, mergeChatData={})
  {
    let parsedMoney = MarketWFRP4e.parseMoneyTransactionString(amount);
    if (split <= 0)
    {
      split = 1;
    }

      //If the /pay command has a syntax error, we display an error message to the gm
    if (!parsedMoney) {
      let msg = `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.PayCommandExample")}</i></p>`;
      ChatMessage.create(WFRP_Utility.chatDataSetup(msg, "gmroll", false, { alias: game.i18n.localize("MARKET.CreditRequest") }));
      return
    } 

    if (mode == "each")
    {
      let nbActivePlayers = Array.from(game.users).filter(u => u.role != 4 && u.active).length;
      split = nbActivePlayers;
    }
    else if (split > 1)
    {
      parsedMoney = MarketWFRP4e.splitAmountBetweenAllPlayers(parsedMoney, split);
    }

    let messageData = {
        payString : MarketWFRP4e.amountToString(parsedMoney),
        splits : new Array(split).fill(""),
        reason
    };

    foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/market/market-credit.hbs", {
        gc: parsedMoney.gc,
        ss: parsedMoney.ss,
        bp: parsedMoney.bp,
        splits : messageData.splits
      }).then(html => {
        let chatData = WFRP_Utility.chatDataSetup(html, "roll", false, {forceWhisper: target, flavor : (reason && "For: " + reason), alias : game.i18n.localize("MARKET.CreditRequest")});
        foundry.utils.mergeObject(chatData, mergeChatData);
        chatData.type = "credit";
        chatData.system = messageData;
        ChatMessage.create(chatData);
      });
  }

  async updateMessage(actor, index)
  {
    let splits = foundry.utils.deepClone(this.splits);
    // if (splits[index])
    // {
    //   return; // Don't update if index already has ID
    // }
    splits[index] = actor.uuid;

    this.parent.update({"system.splits" : splits});

    let templateData = MarketWFRP4e.parseMoneyTransactionString(this.payString);

    templateData.splits = (await Promise.all(splits.map(fromUuid))).map(i => i?.name);

    let content = await foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/chat/market/market-credit.hbs", templateData);

    this.parent.update({content});
  }

  static get actions() {
    return foundry.utils.mergeObject(super.actions, {
      receive : this._onReceive,
    });
  }


  static async _onReceive(ev, target)
  {
      let actor;
      let index = Number(target.dataset.index);

      // If this reward has already been claimed, simply return
      // The message will be updated to remove the button, but if the user
      // presses quickly, it shouldn't reward more than once.
      if (this.parent.system.splits[index])
      {
        return;
      }

      if (!game.user.isGM) 
      {
        actor = game.user.character;
      } 
      else 
      {
        let target = targetsWithFallback()[0];
        if (target)
        {
          actor = target;
        }
      }
      this.parent.system.splits[index] = actor.uuid;
      let money = MarketWFRP4e.creditCommand(this.payString, actor, {suppressMessage : true});
      actor.updateEmbeddedDocuments("Item", money, {updateCreditMessage : {id : this.parent.id, index}});
  }

}

/**
 * This class handles all aspects of custom WFRP tables.
 * 
 * The WFRP_Tables is given table objects on 'init' and 'ready' hooks by
 * both the system, modules, and the world. See the tables folder for 
 * how they're structured. All files in that folder will be
 * added to WFRP_Tables if possible. 
 */


class WFRP_Tables {


  static handleTableCommand(key, { modifier, column }) {
    let msg = {};
    if (!key) {
      game.wfrp4e.tables.formatChatRoll("menu").then(text => {
        if (!text)
          return
        msg.content = text;
        msg.speaker = { alias: "Table Menu" };
        ChatMessage.create(msg);
      });
    }
    else {
      // Call tables class to roll and return html
      game.wfrp4e.tables.formatChatRoll(key, { modifier: modifier, showRoll: true, returnResult: true }, column).then(result => {
        if (!result)
          return
        msg.content = result.object?.name.length ? `<strong>${result.object.name}</strong>` : '';
        msg.content += `<p>${result.result}</p>`;
        ChatMessage.create(msg);
      });
    }
  }


  /**
   * The base function to retrieve a result from a table given various parameters.
   * 
   * Options: 
   * `modifier` - modify the roll result by a certain amount
   * `cancelUnderMin` - If true, cancels any rolls that result in a value under the bounds of the table)
   * `lookup` - forego rolling and use this value to lookup the result on the table.
   * 
   * @param {String} table Table name - the filename of the table file
   * @param {Object} options Various options for rolling the table, like modifier
   * @param {String} column Which column to roll on, if possible.
   */
  static async rollTable(tableKey, options = {}, column = null) {
    Hooks.call("wfrp4e:rollTable", {tableKey, options, column});

    let modifier = options.modifier || 0;
    let table = this.findTable(tableKey.toLowerCase(), column);

    if (table) {

      if (table.columns)
        throw new Error(game.i18n.localize("ERROR.Column"))

      let formula = table.formula;

      // If no die specified, just use the table size and roll
      let roll = await new Roll(`${formula} + @modifier`, { modifier }).roll({allowInteractive : false});
      if (options.showRoll)
      {
        let msg = await roll.toMessage({speaker : {alias : table.name}}, {rollMode : game.settings.get("core", "rollMode")});
        if (game.dice3d)
          await game.dice3d.waitFor3DAnimationByMessageID(msg.id);
      }

      if (game.dice3d && !options.hideDSN && !options.showRoll)
        await game.dice3d.showForRoll(roll);

      let rollValue = options.lookup || roll.total; // options.lookup will ignore the rolled value for the input value
      let displayTotal = options.lookup || roll.result; // Roll value displayed to the user
      if (modifier == 0)
      {
        displayTotal = (0, eval)(displayTotal); // Clean up display value if modifier 0 (59 instead of 59 + 0)
      }
      if (this._isBelowMin(table, rollValue) && !options.cancelUnderMin)
      {
        rollValue = this._minRange(table);
      }

      if (this._isAboveMax(table, rollValue))
      {
        rollValue = this._maxRange(table);
      }

      let rollResult = table.getResultsForRoll(rollValue)[0];
      let flags = rollResult?.flags?.wfrp4e || {};
      let result = {
        result : rollResult?.getChatText(),
        roll : displayTotal,
        total : rollValue,
        name : rollResult?.name,
        object : rollResult?.toObject(),
        title : table.name,
      };



      // If table result text is a UUID link, add a text property with just the label
      result.text = WFRP_Utility.extractLinkLabel(result.result);

      foundry.utils.mergeObject(result, flags);

      if (Object.keys(game.wfrp4e.config.hitLocationTables).includes(tableKey))
        result = this.formatHitloc(rollResult, rollValue);

      return result

    }
    else if (tableKey == "hitloc" || tableKey == "scatter") {

      // Scatter is a special table - calculate distance and return
      if (tableKey == "scatter") {
        let roll = (await new Roll(`1d10`).roll({allowInteractive : false})).total;
        let dist = (await new Roll('2d10').roll({allowInteractive : false})).total;

        return { result: this.scatterResult({roll, dist}), roll }

      }
      else if (tableKey == "hitloc") {
        let roll = await new Roll(`1d100`).roll({allowInteractive : false});
        let result = this._lookup("hitloc", options.lookup || roll.total);
        result.roll = roll.total;
        return result
      }
    }
    else {
      if (tableKey != "menu")
        return ui.notifications.error(game.i18n.format("ERROR.Table", {key : tableKey}))
      else 
        return this.tableMenu()
    }
  }

  // Returns whether or not provided table has a result for the provided value
  static _isCovered(table, value)
  {
    for(let result of table.results.contents)
    {
      if (this._inRange(value, result.range))
      {
        return true;
      }
    }
    return false;
  }

  static _isBelowMin(table, value)
  {
    if (this._isCovered(table, value))
      {
        return false
      }
      
    return value < this._minRange(table, value)
  }

  static _isAboveMax(table, value)
  {
    if (this._isCovered(table, value))
    {
      return false
    }

    return value > this._maxRange(table, value);
  }

  static _maxRange(table)
  {
    return table.results.contents.reduce((max, result) => result.range[0] > max ? result.range[0] : max, Number.MIN_SAFE_INTEGER)
  }

  static _minRange(table)
  {
    return table.results.contents.reduce((min, result) => result.range[0] < min ? result.range[0] : min, Number.MAX_SAFE_INTEGER)
  }

  /**
   * Retrieves a value from a table, using the column if specified
   * 
   * @param {String} table table name
   * @param {Number} value value to lookup
   * @param {String} column column to look under, if needed
   */
  static _lookup(table, value, column = null) {
    if (column && this[table].columns) {
      for (let row of this[table].rows) {
        if (WFRP_Tables._inRange(value, row.range[column]))
          return foundry.utils.duplicate(row)
      }
    }

    else if (column && this[table].multi) {
      for (let row of this[table].rows) {
        if (WFRP_Tables._inRange(value, row.range[column]))
          return foundry.utils.duplicate(row[column])
      }
    }

    else {
      for (let row of this[table].rows) {
        if (WFRP_Tables._inRange(value, row.range))
          return foundry.utils.duplicate(row)
      }
    }
  }

  static _inRange(value, range) {
    if (range.length == 0)
      return false
    if (range.length == 1)
      range.push(range[0]);
    if (value >= range[0] && value <= range[1])
      return true
  }

  /* -------------------------------------------- */

  // critlleg doesn't exist, yet will be asked for because hit location and 'crit' are concatenated
  // Therefore, change specific locations to generalized ones (rarm -> arm)
  static generalizeTable(table) {
    table = table.toLowerCase();
    table = table.replace("lleg", "leg");
    table = table.replace("rleg", "leg");
    table = table.replace("rarm", "arm");
    table = table.replace("larm", "arm");
    return table;
  }

  
  static formatHitloc(result, roll) {
    let flags = result.flags.wfrp4e || {};
    return {
      description : result.description,
      result : flags.loc,
      roll
    }
  }

  static async rollToChat(table, options = {}, column = null, rollMode) {
    let chatOptions = game.wfrp4e.utility.chatDataSetup("", rollMode, true);
    options.returnObject = true;
    let tableResult = await this.formatChatRoll(table, options, column);
    chatOptions.content = tableResult.result;
    chatOptions.type = 0;
    if (chatOptions.content)
      ChatMessage.create(chatOptions);
    ui.sidebar.activateTab("chat");
    return tableResult;
  }

  static findTable(key, column) {
    warhammer.utility.log(`Finding Table key: ${key} column: ${column}`);
    let tables = game.tables.filter(i => i.getFlag("wfrp4e", "key") == key);
    let table; 

    // Look at table settings first
    let tableSettings = game.settings.get("wfrp4e", "tableSettings");
    warhammer.utility.log(`Table Settings: `, undefined, tableSettings);

    // If tableSettings has comma separated ids, return them as columns
    let id = tableSettings[`${key}${column ? "-"+column : ""}`]?.split(",");
    if (id && id.length)
    {
      if (id.length > 1)
      {
        tables = id.map(i => game.tables.get(i));
      }
      else // If only one id in table settings, just use that table
      {
        table = game.tables.get(id[0]);
      }
    }

    if (table)
    {
      warhammer.utility.log("Found Table with settings");
    }

    if (!table)
    {

      warhammer.utility.log("Table not found with settings, finding first table that matches");

      // If more than one table with that key, and column is specified, return that column
      if (tables.length > 1 && column)
        table = tables.find(i => i.getFlag("wfrp4e", "column") == column);

      // If only one result with that key, or multiple results that don't have a column, return the first one (this condition is needed to return Minor Miscast table if Minor Miscast (Moo) also exists at the same time)
      else if (tables.length == 1 || tables.map(t => t.getFlag("wfrp4e", "column")).filter(t => t).length < 1) 
      {
        table = tables[0];
      }

      // If multiple results, return a special object that has a generalized name and columns array listing the tables 
      else  if (tables.length)
        table =  {name : tables[0].name.split("-")[0].trim(), columns: tables, roll : async () => {
            let table = await ItemDialog.create(tables, 1, game.i18n.localize("CHAT.ColumnPrompt"));
            return await table[0]?.roll();
        }};

      }
    warhammer.utility.log("Find Table returns", undefined, table);
    return table;

  }

  /**
   * Takes the key of an existing hit location Rollable Table and returns a simple hitloc object.
   * 
   * {
   *  lArm : "Left Arm",
   *  rArm : "Right Arm",
   *  ....
   * }
   * 
   * @param {String} key key of the hit location table
   */
  static getHitLocTable(key)
  {
    let hitloc = {};
    let table = this.findTable(key);

    if (table)
    {
      table.results.forEach(result => {
        if (result.flags.wfrp4e.loc)
          hitloc[result.flags.wfrp4e.loc] = result.description;
      });
    }
    return hitloc
  }


    /**
   * Takes a hitloc key and turns it into a result object
   * 
   * 
   * @param {String} key key of the hit location table
   */
     static hitLocKeyToResult(resultKey, tableKey = "hitloc")
     {
       let table = this.findTable(tableKey);
   
       if (table)
       {
         for(let result of table.results)
         {
           if (result.flags.wfrp4e?.loc == resultKey)
             return this.formatHitloc(result, result.range[0])
         }
       }
     }

  /* -------------------------------------------- */

  /**
   * 
   * Wrapper for rollTable to format rolls from chat commands nicely.
   * 
   * Calls rollTable() and displays the result in a specific format depending
   * on the table rolled on.
   * 
   * @param {String} table Table name - the filename of the table file
   * @param {Object} options Various options for rolling the table, like modifier
   * @param {String} column Which column to roll on, if possible.
   */
  static async formatChatRoll(table, options = {}, column = null) {

    table = this.generalizeTable(table);

    let tableObject = this.findTable(table, column);

    if (tableObject && tableObject.columns)
      return {result : this.promptColumn(table)};


    let result = await this.rollTable(table, options, column);
    if (options.lookup && !game.user.isGM) // If the player (not GM) rolled with a lookup value, display it so they can't be cheeky cheaters
      result.roll = game.i18n.localize("TABLE.Lookup") + result.roll;
    try {
      // Cancel the roll if below minimum range
      if (this._isBelowMin(tableObject, result.total) && options.cancelUnderMin)
        return game.i18n.format("TABLE.Cancel", { result: result.roll })
    }
    catch
    { }

    // If the roll is an item, don't post the link to chat, post the item to chat
    if (result.object?.documentUuid)
    {
      let document = await fromUuid(result.object.documentUuid);
      if (document?.documentName == "Item")
      {
        await document.postItem(undefined, {"flags.wfrp4e.sourceMessageId" : options.messageId});
        return null;
      }

    }

    if (options.returnResult)
    {
      return result
    }
    else 
    {
      return result.result;
    }

  }

  /**
   * Show the table help menu, display all tables as clickables and hidden tables if requested.
   * 
   * @param {Boolean} showHidden Show hidden tables
   */
  static tableMenu() {
    let tableMenu = `<b><code>/table</code> ${game.i18n.localize("Commands")}</b><br>`;

    let tables = game.tables.filter(i => i.permission);

    let columnsAdded = [];

    // For each table, add a clickable link
    for (let table of tables)
    {
      let key = table.getFlag("wfrp4e", "key");
      let tableObject = this.findTable(key);

      // If the table is a column, add only the general table, and remember the table to not list again for future columns (Only list Weather, not Weather - Spring, Weather - Winter, etc)
      if (tableObject.columns && !columnsAdded.includes(key))
      {
        columnsAdded.push(key);
        tableMenu += `<a data-table='${key}' class='action-link' data-action="clickTable" ><i class="fas fa-list"></i> <code>${key}</code></a> - ${tableObject.name}<br>`;
      }
      // If no columns, just list tables
      else if (tableObject && !tableObject.columns)
        tableMenu += `<a data-table='${key}' class='action-link' data-action="clickTable" ><i class="fas fa-list"></i> <code>${key}</code></a> - ${table.name}<br>`;
    }
    return {result : tableMenu};
  }

  // When critical casting, there are few options available, one could be a critical wound on a location, so offer a clickable link.
  static criticalCastMenu(crittable) {
    return `${game.i18n.localize("CHAT.ChooseFrom")}:<ul>
      <li><b>${game.i18n.localize("ROLL.CritCast")}</b>: ${game.i18n.localize("CHAT.CritCast")} <a class="action-link"  data-action="clickTable" data-table=${crittable}><i class="fas fa-list"></i> ${game.i18n.localize("Critical Wound")}</a></li>
      <li><b>${game.i18n.localize("ROLL.TotalPower")}</b>: ${game.i18n.localize("CHAT.TotalPower")}</li>
      <li><b>${game.i18n.localize("ROLL.UnstoppableForce")}</b>: ${game.i18n.localize("CHAT.UnstoppableForce")}</li>
      </ul`;
  }


  // Critical casting without reaching appropriate SL - forced to be Total power in order to get the spell off
  static restrictedCriticalCastMenu() {
    return `${game.i18n.localize("CHAT.MustChoose")}:<ul>
      <li><b>${game.i18n.localize("ROLL.TotalPower")}</b>: ${game.i18n.localize("CHAT.TotalPower")}</li>
      </ul`;
  }

  // Display all columns for a table so the user can click on them and roll them.
  static promptColumn(table) {
    let prompt = `<h4>${game.i18n.localize("CHAT.ColumnPrompt")}</h4>`;

    let tableObject = this.findTable(table);
    for (let c of tableObject.columns)
      prompt += `<p><a class = "action-link" data-action="clickTable"  data-table="${table}" data-column = "${c.getFlag("wfrp4e", "column")}"><i class="fas fa-list"></i> ${c.name}</a></p>`;

    return prompt;
  }


  static scatterResult({roll, dist}) {
    let tableHtml = '<table class = "scatter-table">' +
      " <tr>" +
      "<td position='1'> " +
      "</td>" +
      "<td position='2'> " +
      "</td>" +
      "<td position='3'> " +
      "</td>" +
      "</tr>" +
      " <tr>" +
      "<td position='4'> " +
      "</td>" +
      "<td position='10'> " + game.i18n.localize("CHAT.ScatterTarget") +
      "</td>" +
      "<td position='5'> " +
      "</td>" +
      "</tr>" +
      " <tr>" +
      "<td position='6'> " +
      "</td>" +
      "<td position='7'> " +
      "</td>" +
      "<td position='8'> " +
      "</td>" +
      "</tr>" +
      "</table>";

    if (roll == 9)
      tableHtml += game.i18n.localize("CHAT.ScatterYou");
    else if (roll == 10)
      tableHtml += game.i18n.localize("CHAT.ScatterThem");
    else
      tableHtml += game.i18n.localize("CHAT.ScatterNote");
    tableHtml = tableHtml.replace(`position='${roll}'`, "class='selected-position'");
    if (dist && roll <= 8) // Don't roll for 9 or 10
      tableHtml = tableHtml.replace("'selected-position'>", `'selected-position'> ${dist} ${game.i18n.localize("yds")}.`);
    return tableHtml
  }


  static get hitloc() {
    return {
      "name": game.i18n.localize("WFRP4E.LocationsTable"),
      "die": "1d100",
      "rows": [{
        "description": game.i18n.localize("WFRP4E.Locations.head"),
        "result": "head",
        "range": [1, 9]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.lArm"),
        "result": "lArm",
        "range": [10, 24]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.rArm"),
        "result": "rArm",
        "range": [25, 44]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.body"),
        "result": "body",
        "range": [45, 79]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.lLeg"),
        "result": "lLeg",
        "range": [80, 89]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.rLeg"),
        "result": "rLeg",
        "range": [90, 100]
      }]
    }
  }


  static get scatter() {
    return {
      name: game.i18n.localize("WFRP4E.ScatterTable"),
      die: "1d10",
      rows: [
        {
          name: game.i18n.localize("WFRP4E.Scatter.TopLeft"),
          range: [1, 1]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.TopMiddle"),
          range: [2, 2]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.TopRight"),
          range: [3, 3]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.CenterLeft"),
          range: [4, 4]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.CenterRight"),
          range: [5, 5]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.BottomLeft"),
          range: [6, 6]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.BottomMiddle"),
          range: [7, 7]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.BottomRight"),
          range: [8, 8]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.AtYourFeet"),
          range: [9, 9]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.AtTargetFeet"),
          range: [10, 10]
        },
      ]
    }
  }


}

function commands () {
  /**
   * Init function loads tables, registers settings, and loads templates
   */
  Hooks.once("init", () => {
    game.wfrp4e.commands = new ChatCommands({
      table : {
        description: "Roll on a table",
        args : ["table", "modifier", "column"],
        defaultArg : "table",
        examples : "<br><span font-family:'monospaced'</span>/table critarm</span><br><span font-family:'monospaced'</span>/table mutatephys modifier=20 column=khorne</span>",
        callback: (table, modifier, column) => WFRP_Tables.handleTableCommand(table, {modifier, column})
      },
      pay: {
        description: "Post a prompt for payment.",
        notes: "If a player, pay some amount from the assigned Actor. If a GM, post a message prompting to a pay some amount",
        args: ["amount", "for", "target"],
        defaultArg: "amount",
        examples : "<br><span font-family:'monospaced'</span>/pay 12ss for=Room and Board</span>",
        callback: (amount, product, target) => PayMessageModel.handlePayCommand(amount, { target, product })
      },
      credit : {
        description : "Post a prompt to receive money.",
        args : ["amount", "mode", "split", "target", "reason"],
        defaultArg : "amount",
        examples : "<br><span font-family:'monospaced'</span>/credit 100gc reason=Completing the Bounty split=3</span>",
        notes : "Mode can be set to 'split' or 'each', if unspecified, only a single reward is available to take (split=1). If the mode is set to split, and the split argument is not defined, it splits the amount between all active players.",
        callback : (amount, mode, split, target, reason) => CreditMessageModel.handleCreditCommand(amount, mode, {split, target, reason})
      },
      char: {
        description: "Start Character Creation",
        args: [],
        callback: () => CharGenWfrp4e.start()
      },
      cond : {
        description: "Show Condition Description",
        args : ["condition"],
        defaultArg: "condition",
        callback: (condition) => {
                // Only one argument possible [1]: condition to lookup
                let conditionInput = condition.toLowerCase();
                // Don't require spelling, match the closest condition to the input
                let closest = WFRP_Utility.matchClosest( game.wfrp4e.config.conditions, conditionInput);
                if (! game.wfrp4e.config.conditionDescriptions) {
                  ui.notifications.error("No content found");
                  return false
                }
                let description =  game.wfrp4e.config.conditionDescriptions[closest];
                let name =  game.wfrp4e.config.conditions[closest];

                // Create message and return false to not display user input of `/cond`
                ChatMessage.create({content : `<p><strong>${name}</strong></p>${description}`});
        }
      },
      prop : {
        description: "Show a Quality or Flaw",
        args : ["property"],
        defaultArg : "property",
        callback : (property) => {
          let propertyInput = property;
          let allProperties = game.wfrp4e.utility.allProperties();
          let closest = WFRP_Utility.matchClosest( game.wfrp4e.utility.allProperties(), propertyInput);
    
          let description = game.wfrp4e.config.qualityDescriptions[closest] || game.wfrp4e.config.flawDescriptions[closest];
          let name =  allProperties[closest];
    
          ChatMessage.create({content : `<p><strong>${name}</strong></p>${description}`});
          
        }
      },
      name : {
        description : "Generate a name",
        notes : "Core Species Keys: <span font-family:'monospaced'</span>human</span> <span font-family:'monospaced'</span>dwarf</span> <span font-family:'monospaced'</span>helf</span> <span font-family:'monospaced'</span>welf</span> <span font-family:'monospaced'</span>halfling</span>",
        args : ["gender", "species"],
        defaultArg : "gender",
        callback : (gender, species) => {
          // Call generator class to create name, create message, return false to not display user input of `/name`
          let name = NameGenWfrp.generateName({ species, gender });
          ChatMessage.create(WFRP_Utility.chatDataSetup(name, "selfroll"));
        }
      },
      avail : {
        description : "Roll an Availability Test",
        args : ["rarity", "size", "modifier"],
        defaultArg : "rarity",
        callback : (rarity, size, modifier) => {
    
          // Call generator class to start the test, create message, send to chat, return false to not display user input of `/avail`
          MarketWFRP4e.testForAvailability({ settlement : size, rarity, modifier });
        }
      },
      corruption : {
        description : "Prompt Corruption Test",
        args : ["strength", "skill", "source"],
        defaultArg : "strength",
        callback: (strength, skill, source) => {
          CorruptionMessageModel.handleCorruptionCommand(strength, skill, source);
        }
      },
      fear : {
        description : "Prompt Fear Test",
        args : ["rating", "source"],
        defaultArg : "rating",
        callback: (rating, source) => {
          PsychMessageModel.handleFearCommand(rating, source);
        }
      },
      terror : {
        description : "Prompt Terror Test",
        args : ["rating", "source"],
        defaultArg : "rating",
        callback: (rating, source) => {
          PsychMessageModel.handleTerrorCommand(rating, source);
        }
      },
      exp : {
        description : "Prompt XP Reward",
        args : ["amount", "reason"],
        defaultArg : "amount",
        callback: (amount, reason) => {
          XPMessageModel.handleXPCommand(amount, reason);
        }
      },
      travel : {
        description : "Post Travel Distance Tool",
        args : ["from", "to"],
        defaultArg : "from",
        callback: (from, to) => {
          TravelDistanceWFRP4e.displayTravelDistance(from, to);
        }
      },
      trade : {
        description : "Prompt Trade Dialog",
        args : [],
        callback: () => {
          game.wfrp4e.trade.attemptBuy();
        }
      }
    });
  });
}

function registerHooks() {
    init();
    ready();
    canvas$1();
    chat();
    combat();
    controlButtons();
    hotbarDrop();
    journal();
    sidebar();
    rolltable();
    entryContext();
    token();
    i18n();
    settings();
    commands();

    {
        Hooks.on("renderApplication", (app, html, data) => {
            warhammer.utility.log(`Rendering ${app.constructor.name}: `, undefined, data);
        });
    }
}

class BrowserWfrp4e extends warhammer.apps.CompendiumBrowser {
  constructor(...args) {
    super(...args);

    const msg = "BrowserWfrp4e has been removed in favor of the Compendium Browser. Please use `warhammer.apps.CompendiumBrowser.render(true);` instead.";
    ui.notifications.warn(msg, {permanent: true});
  }

}

const WFRP4E = {};

WFRP4E.creditOptions = {
    SPLIT: "split",
    EACH: "each",
};

WFRP4E.toTranslate = [
"statusTiers",
"characteristics",
"characteristicsAbbrev",
"characteristicsBonus",
"skillTypes",
"skillGroup",
"talentMax",
"weaponGroups",
"weaponTypes",
"weaponReaches",
"ammunitionGroups",
"itemQualities",
"itemFlaws",
"weaponQualities",
"weaponFlaws",
"armorQualities",
"armorFlaws",
"armorTypes",
"rangeModifiers",
"rangeBands",
"difficultyLabels",
"difficultyNames",
"locations",
"availability",
"trappingTypes",
"trappingCategories",
"actorSizes",
"magicLores",
"magicWind",
"prayerTypes",
"mutationTypes",
"conditions",
"availabilityTable",
"moneyNames",
"hitLocationTables",
"extendedTestCompletion",
"applyScope",
"weaponGroupDescriptions",
"qualityDescriptions",
"flawDescriptions",
"loreEffectDescriptions",
"conditionDescriptions",
"symptoms",
"symptomDescriptions",
"symptomTreatment",
"reachDescription",
"classTrappings",
"transferTypes"
];

// "Trappings" are more than "trapping" type items
WFRP4E.trappingItems = ["trapping", "armour", "weapon", "container", "ammunition", "money"];

CONFIG.controlIcons.defeated = "systems/wfrp4e/icons/defeated.png";

CONFIG.JournalEntry.noteIcons = {
    "Marker": "systems/wfrp4e/icons/buildings/point_of_interest.png",
    "Apothecary": "systems/wfrp4e/icons/buildings/apothecary.png",
    "Beastmen Herd 1": "systems/wfrp4e/icons/buildings/beastmen_camp1.png",
    "Beastmen Herd 2": "systems/wfrp4e/icons/buildings/beastmen_camp2.png",
    "Blacksmith": "systems/wfrp4e/icons/buildings/blacksmith.png",
    "Bretonnian City 1": "systems/wfrp4e/icons/buildings/bret_city1.png",
    "Bretonnian City 2": "systems/wfrp4e/icons/buildings/bret_city2.png",
    "Bretonnian City 3": "systems/wfrp4e/icons/buildings/bret_city3.png",
    "Bretonnian Worship": "systems/wfrp4e/icons/buildings/bretonnia_worship.png",
    "Caste Hill 1": "systems/wfrp4e/icons/buildings/castle_hill1.png",
    "Caste Hill 2": "systems/wfrp4e/icons/buildings/castle_hill2.png",
    "Caste Hill 3": "systems/wfrp4e/icons/buildings/castle_hill3.png",
    "Castle Wall": "systems/wfrp4e/icons/buildings/castle_wall.png",
    "Cave 1": "systems/wfrp4e/icons/buildings/cave1.png",
    "Cave 2": "systems/wfrp4e/icons/buildings/cave2.png",
    "Cave 3": "systems/wfrp4e/icons/buildings/cave3.png",
    "Cemetery": "systems/wfrp4e/icons/buildings/cemetery.png",
    "Chaos Portal": "systems/wfrp4e/icons/buildings/chaos_portal.png",
    "Chaos Worship": "systems/wfrp4e/icons/buildings/chaos_worship.png",
    "Court": "systems/wfrp4e/icons/buildings/court.png",
    "Dwarf Beer": "systems/wfrp4e/icons/buildings/dwarf_beer.png",
    "Dwarf Hold 1": "systems/wfrp4e/icons/buildings/dwarf_hold1.png",
    "Dwarf Hold 2": "systems/wfrp4e/icons/buildings/dwarf_hold2.png",
    "Dwarf Hold 3": "systems/wfrp4e/icons/buildings/dwarf_hold3.png",
    "Empire Barracks": "systems/wfrp4e/icons/buildings/empire_barracks.png",
    "Empire City 1": "systems/wfrp4e/icons/buildings/empire_city1.png",
    "Empire City 2": "systems/wfrp4e/icons/buildings/empire_city2.png",
    "Empire City 3": "systems/wfrp4e/icons/buildings/empire_city3.png",
    "Farm": "systems/wfrp4e/icons/buildings/farms.png",
    "Food 1": "systems/wfrp4e/icons/buildings/food.png",
    "Food 2": "systems/wfrp4e/icons/buildings/food2.png",
    "Guard Post": "systems/wfrp4e/icons/buildings/guards.png",
    "Haunted Hill": "systems/wfrp4e/icons/buildings/haunted_hill.png",
    "Haunted Wood": "systems/wfrp4e/icons/buildings/haunted_wood.png",
    "Inn 1": "systems/wfrp4e/icons/buildings/inn1.png",
    "Inn 2": "systems/wfrp4e/icons/buildings/inn2.png",
    "Kislev City 1": "systems/wfrp4e/icons/buildings/kislev_city1.png",
    "Kislev City 2": "systems/wfrp4e/icons/buildings/kislev_city2.png",
    "Kislev City 3": "systems/wfrp4e/icons/buildings/kislev_city3.png",
    "Lumber": "systems/wfrp4e/icons/buildings/lumber.png",
    "Magic": "systems/wfrp4e/icons/buildings/magic.png",
    "Metal": "systems/wfrp4e/icons/buildings/metal.png",
    "Mountain 1": "systems/wfrp4e/icons/buildings/mountains1.png",
    "Mountain 2": "systems/wfrp4e/icons/buildings/mountains2.png",
    "Orcs": "systems/wfrp4e/icons/buildings/orcs.png",
    "Orc Camp": "systems/wfrp4e/icons/buildings/orc_city.png",
    "Port": "systems/wfrp4e/icons/buildings/port.png",
    "Road": "systems/wfrp4e/icons/buildings/roads.png",
    "Ruins": "systems/wfrp4e/icons/buildings/ruins.png",
    "Scroll": "systems/wfrp4e/icons/buildings/scroll.png",
    "Sigmar": "systems/wfrp4e/icons/buildings/sigmar_worship.png",
    "Stables": "systems/wfrp4e/icons/buildings/stables.png",
    "Standing Stones": "systems/wfrp4e/icons/buildings/standing_stones.png",
    "Swamp": "systems/wfrp4e/icons/buildings/swamp.png",
    "Temple": "systems/wfrp4e/icons/buildings/temple.png",
    "Textile": "systems/wfrp4e/icons/buildings/textile.png",
    "Tower 1": "systems/wfrp4e/icons/buildings/tower1.png",
    "Tower 2": "systems/wfrp4e/icons/buildings/tower2.png",
    "Tower Hill": "systems/wfrp4e/icons/buildings/tower_hill.png",
    "Wizard Tower": "systems/wfrp4e/icons/buildings/wizard_tower.png",
    "Ulric": "systems/wfrp4e/icons/buildings/ulric_worship.png",
    "Village 1": "systems/wfrp4e/icons/buildings/village1.png",
    "Village 2": "systems/wfrp4e/icons/buildings/village2.png",
    "Village 3": "systems/wfrp4e/icons/buildings/village3.png",
    "Wood Elves 1": "systems/wfrp4e/icons/buildings/welves1.png",
    "Wood Elves 2": "systems/wfrp4e/icons/buildings/welves2.png",
    "Wood Elves 3": "systems/wfrp4e/icons/buildings/welves3.png"
};


CONFIG.TextEditor.enrichers = CONFIG.TextEditor.enrichers.concat([
    {
        pattern : /@Table\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("action-link");
            let values = match[1].split(",");
            a.dataset.action = "clickTable";
            a.dataset.table = values[0];
            a.dataset.modifier = values[1] || 0;
            a.innerHTML = `<i class="fas fa-list"></i>${(game.wfrp4e.tables.findTable(match[1])?.name && !match[2]) ? game.wfrp4e.tables.findTable(match[1])?.name : match[2]}`;
            return a
        }
    },
    {
        pattern : /@Symptom\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("action-link");
            a.dataset.symptom = match[1];
            a.dataset.action = "clickSymptom";
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-user-injured"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Condition\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("action-link");
            a.dataset.cond = match[1];
            a.dataset.action = "clickConditionText";
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-user-injured"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Property\[(.+?)](?:{(.+?)})?/gm,
        enricher : (match) => {
            const a = document.createElement("a");
            a.classList.add("action-link");
            a.dataset.cond = match[1];
            a.dataset.action = "clickProperty";
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-wrench"></i>${label ? label : id}`;
            return a;
        }
    },
    {
        pattern : /@Pay\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("action-link");
            a.dataset.args = match[1];
            a.dataset.action = "clickPay";
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-coins"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Credit\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("action-link");
            a.dataset.args = match[1];
            a.dataset.action = "clickCredit";
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-coins"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Corruption\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("action-link");
            a.dataset.strength = match[1];
            a.dataset.action = "clickCorruption";
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<img src="systems/wfrp4e/ui/misc/chaos.svg" style="border:none">${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Fear\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            let values = match[1].split(",");
            const a = document.createElement("a");
            a.classList.add("action-link");
            a.dataset.action = "clickFear";
            a.dataset.value = values[0];
            a.dataset.name = values[1] || "";
            a.innerHTML = `<img src="systems/wfrp4e/ui/misc/fear.svg" style="border:none"> ${game.i18n.localize("WFRP4E.ConditionName.Fear")} ${values[0]}`;
            return a
        }
    },
    {
        pattern : /@Terror\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            let values = match[1].split(",");
            const a = document.createElement("a");
            a.classList.add("action-link");
            a.dataset.action = "clickTerror";
            a.dataset.value = values[0];
            a.dataset.name = values[1] || "";
            a.innerHTML = `<img src="systems/wfrp4e/ui/misc/terror.svg" style="border:none"> ${game.i18n.localize("NAME.Terror")} ${values[0]}`;
            return a
        }
    },
    {
        pattern : /@Exp\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            let values = match[1].split(",");
            const a = document.createElement("a");
            a.classList.add("action-link");
            a.dataset.amount = values[0];
            a.dataset.action = "clickExp";
            a.dataset.reason= values[1] || "";
            let label = match[2];
            a.innerHTML = `<i class="fas fa-plus"></i> ${ label ? label : (values[1] || values[0])}</a>`;
            return a
        }
    },
]);

// Status Tiers
WFRP4E.statusTiers = {
    "g": "TIER.Gold",
    "s": "TIER.Silver",
    "b": "TIER.Brass"
};

// Characteristic Names
WFRP4E.characteristics = {
    "ws": "CHAR.WS",
    "bs": "CHAR.BS",
    "s": "CHAR.S",
    "t": "CHAR.T",
    "ag": "CHAR.Ag",
    "int": "CHAR.Int",
    "wp": "CHAR.WP",
    "fel": "CHAR.Fel"
};

// Characteristic Abbreviations
WFRP4E.characteristicsAbbrev = {
    "ws": "CHARAbbrev.WS",
    "bs": "CHARAbbrev.BS",
    "s": "CHARAbbrev.S",
    "t": "CHARAbbrev.T",
    "ag": "CHARAbbrev.Ag",
    "int": "CHARAbbrev.Int",
    "wp": "CHARAbbrev.WP",
    "fel": "CHARAbbrev.Fel"
};

// Characteristic Abbreviations
WFRP4E.characteristicsBonus = {
    "ws": "CHARBonus.WS",
    "bs": "CHARBonus.BS",
    "s": "CHARBonus.S",
    "t": "CHARBonus.T",
    "ag": "CHARBonus.Ag",
    "int": "CHARBonus.Int",
    "wp": "CHARBonus.WP",
    "fel": "CHARBonus.Fel"
};

WFRP4E.skillTypes = {
    "bsc": "Basic",
    "adv": "Advanced"
};

WFRP4E.xpCost = {
    "characteristic": [25, 30, 40, 50, 70, 90, 120, 150, 190, 230, 280, 330, 390, 450, 520],
    "skill": [10, 15, 20, 30, 40, 60, 80, 110, 140, 180, 220, 270, 320, 380, 440]
};

WFRP4E.skillGroup = {
    "isSpec": "ITEM.IsSpec",
    "noSpec": "ITEM.NoSpec"
};

WFRP4E.talentMax = {
    "1": "1",
    "2": "2",
    "3": "3",
    "4": "4",
    "none": "None",
    "ws": "CHARBonus.WS",
    "bs": "CHARBonus.BS",
    "s": "CHARBonus.S",
    "t": "CHARBonus.T",
    "ag": "CHARBonus.Ag",
    "int": "CHARBonus.Int",
    "wp": "CHARBonus.WP",
    "fel": "CHARBonus.Fel"
};


// Weapon Groups
WFRP4E.weaponGroups = {
    "basic": "SPEC.Basic",
    "cavalry": "SPEC.Cavalry",
    "fencing": "SPEC.Fencing",
    "brawling": "SPEC.Brawling",
    "flail": "SPEC.Flail",
    "parry": "SPEC.Parry",
    "polearm": "SPEC.Polearm",
    "twohanded": "SPEC.TwoHanded",
    "blackpowder": "SPEC.Blackpowder",
    "bow": "SPEC.Bow",
    "crossbow": "SPEC.Crossbow",
    "entangling": "SPEC.Entangling",
    "engineering": "SPEC.Engineering",
    "explosives": "SPEC.Explosives",
    "sling": "SPEC.Sling",
    "throwing": "SPEC.Throwing",
    "vehicle": "SPEC.Vehicle",
};

// Given a group, what's the primary type, melee or ranged
WFRP4E.groupToType = {
    "basic": "melee",
    "cavalry": "melee",
    "fencing": "melee",
    "brawling": "melee",
    "flail": "melee",
    "parry": "melee",
    "polearm": "melee",
    "twohanded": "melee",
    "blackpowder": "ranged",
    "bow": "ranged",
    "crossbow": "ranged",
    "entangling": "ranged",
    "engineering": "ranged",
    "explosives": "ranged",
    "sling": "ranged",
    "throwing": "ranged",
    "vehicle" : "ranged"
};

WFRP4E.weaponTypes = {
    "melee": "Melee",
    "ranged": "Ranged"
};

// Weapon Reach
WFRP4E.weaponReaches = {
    "personal": "WFRP4E.Reach.Personal",
    "vshort": "WFRP4E.Reach.VShort",
    "short": "WFRP4E.Reach.Short",
    "average": "WFRP4E.Reach.Average",
    "long": "WFRP4E.Reach.Long",
    "vLong": "WFRP4E.Reach.VLong",
    "massive": "WFRP4E.Reach.Massive",
};

// Ammo Groups
WFRP4E.ammunitionGroups = {
    "none": "NoneAmmo",
    "BPandEng": "WFRP4E.BPandEng",
    "bow": "WFRP4E.Bow",
    "crossbow": "WFRP4E.Crossbow",
    "sling": "WFRP4E.Sling",
    "vehicle": "WFRP4E.Vehicle",
    "throwing": "SPEC.Throwing",
    "entangling": "SPEC.Entangling",
};

// Item Qualities
WFRP4E.itemQualities = {
    "durable": "PROPERTY.Durable",
    "fine": "PROPERTY.Fine",
    "lightweight": "PROPERTY.Lightweight",
    "practical": "PROPERTY.Practical",
};

// Item Flaws
WFRP4E.itemFlaws = {
    "ugly": "PROPERTY.Ugly",
    "shoddy": "PROPERTY.Shoddy",
    "unreliable": "PROPERTY.Unreliable",
    "bulky": "PROPERTY.Bulky",
};


// Weapon Qualities
WFRP4E.weaponQualities = {
    "accurate": "PROPERTY.Accurate",
    "blackpowder": "PROPERTY.Blackpowder",
    "blast": "PROPERTY.Blast",
    "damaging": "PROPERTY.Damaging",
    "defensive": "PROPERTY.Defensive",
    "distract": "PROPERTY.Distract",
    "entangle": "PROPERTY.Entangle",
    "fast": "PROPERTY.Fast",
    "hack": "PROPERTY.Hack",
    "impact": "PROPERTY.Impact",
    "impale": "PROPERTY.Impale",
    "magical": "PROPERTY.Magical",
    "penetrating": "PROPERTY.Penetrating",
    "pistol": "PROPERTY.Pistol",
    "precise": "PROPERTY.Precise",
    "pummel": "PROPERTY.Pummel",
    "repeater": "PROPERTY.Repeater",
    "shield": "PROPERTY.Shield",
    "trapblade": "PROPERTY.TrapBlade",
    "unbreakable": "PROPERTY.Unbreakable",
    "wrap": "PROPERTY.Wrap"
};

// Weapon Flaws
WFRP4E.weaponFlaws = {
    "dangerous": "PROPERTY.Dangerous",
    "imprecise": "PROPERTY.Imprecise",
    "reload": "PROPERTY.Reload",
    "slow": "PROPERTY.Slow",
    "tiring": "PROPERTY.Tiring",
    "undamaging": "PROPERTY.Undamaging"
};

// Armor Qualities
WFRP4E.armorQualities = {
    "flexible": "PROPERTY.Flexible",
    "impenetrable": "PROPERTY.Impenetrable",
    "magical": "PROPERTY.Magical",
};

// Armor Flaws
WFRP4E.armorFlaws = {
    "partial": "PROPERTY.Partial",
    "weakpoints": "PROPERTY.Weakpoints",
};

WFRP4E.propertyHasValue = {
    "durable": true,
    "fine": true,
    "lightweight": false,
    "practical": false,
    "ugly": false,
    "shoddy": false,
    "unreliable": false,
    "bulky": false,
    "accurate": false,
    "blackpowder": false,
    "blast": true,
    "damaging": false,
    "defensive": false,
    "distract": false,
    "entangle": false,
    "fast": false,
    "hack": false,
    "impact": false,
    "impale": false,
    "magical" : false,
    "penetrating": false,
    "pistol": false,
    "precise": false,
    "pummel": false,
    "repeater": true,
    "shield": true,
    "trapblade": false,
    "unbreakable": false,
    "wrap": false,
    "dangerous": false,
    "imprecise": false,
    "reload": true,
    "slow": false,
    "tiring": false,
    "undamaging": false,
    "flexible": false,
    "impenetrable": false,
    "partial": false,
    "weakpoints": false
};

// Equipment Types
WFRP4E.armorTypes = {
    "softLeather": "WFRP4E.ArmourType.SLeather",
    "boiledLeather": "WFRP4E.ArmourType.BLeather",
    "mail": "WFRP4E.ArmourType.Mail",
    "plate": "WFRP4E.ArmourType.Plate",
    "other": "WFRP4E.ArmourType.Other",
    "otherMetal": "WFRP4E.ArmourType.OtherMetal"
};

// Range Test Modifiers
WFRP4E.rangeModifiers = {
    "Point Blank": "easy",
    "Short Range": "average",
    "Normal": "challenging",
    "Long Range": "difficult",
    "Extreme": "vhard",
};

// Ranges
WFRP4E.rangeBands = {
    "pb": "Point Blank",
    "short": "Short Range",
    "normal": "Normal",
    "long": "Long Range",
    "extreme": "Extreme",
};

// Difficulty Modifiers
WFRP4E.difficultyModifiers = {
    "veasy": 60,
    "easy": 40,
    "average": 20,
    "challenging": 0,
    "difficult": -10,
    "hard": -20,
    "vhard": -30
};

// Difficulty Labels
WFRP4E.difficultyLabels = {

    "veasy": "DIFFICULTY.VEasy",
    "easy": "DIFFICULTY.Easy",
    "routine": "DIFFICULTY.Routine",
    "average": "DIFFICULTY.Average",\
    "challenging": "DIFFICULTY.Challenging",
    "difficult": "DIFFICULTY.Difficult",
    "hard": "DIFFICULTY.Hard",
    "vhard": "DIFFICULTY.VHard"
};

WFRP4E.difficultyNames = {

    "veasy": "DIFFICULTYNAME.VEasy",
    "easy": "DIFFICULTYNAME.Easy",
    "average": "DIFFICULTYNAME.Average",
    "challenging": "DIFFICULTYNAME.Challenging",
    "difficult": "DIFFICULTYNAME.Difficult",
    "hard": "DIFFICULTYNAME.Hard",
    "vhard": "DIFFICULTYNAME.VHard"
};

WFRP4E.locations = {
    "head": "WFRP4E.Locations.head",
    "body": "WFRP4E.Locations.body",
    "rArm": "WFRP4E.Locations.rArm",
    "lArm": "WFRP4E.Locations.lArm",
    "rLeg": "WFRP4E.Locations.rLeg",
    "lLeg": "WFRP4E.Locations.lLeg",
};

// Trapping Availability
WFRP4E.availability = {
    "None": "-",
    "common": "WFRP4E.Availability.Common",
    "scarce": "WFRP4E.Availability.Scarce",
    "rare": "WFRP4E.Availability.Rare",
    "exotic": "WFRP4E.Availability.Exotic",
    "special": "WFRP4E.Availability.Special",
};


// Trapping Types
WFRP4E.trappingTypes = {
    "clothingAccessories": "WFRP4E.TrappingType.ClothingAccessories",
    "foodAndDrink": "WFRP4E.TrappingType.FoodDrink",
    "toolsAndKits": "WFRP4E.TrappingType.ToolsKits",
    "booksAndDocuments": "WFRP4E.TrappingType.BooksDocuments",
    "tradeTools": "WFRP4E.TrappingType.TradeTools", // Unused - combined with tools and kits
    "drugsPoisonsHerbsDraughts": "WFRP4E.TrappingType.DrugsPoisonsHerbsDraughts",
    "ingredient": "WFRP4E.TrappingType.Ingredient",
    "misc": "WFRP4E.TrappingType.Misc",
};

// These categories are used to label items in containers (Trapping tab)
WFRP4E.trappingCategories = {
    "weapon": "WFRP4E.TrappingType.Weapon",
    "armour": "WFRP4E.TrappingType.Armour",
    "money": "WFRP4E.TrappingType.Money",
    "ammunition": "WFRP4E.TrappingType.Ammunition",
    "container": "WFRP4E.TrappingType.Container",
    "clothingAccessories": "WFRP4E.TrappingType.ClothingAccessories",
    "foodAndDrink": "WFRP4E.TrappingType.FoodDrink",
    "toolsAndKits": "WFRP4E.TrappingType.ToolsKits",
    "booksAndDocuments": "WFRP4E.TrappingType.BooksDocuments",
    "tradeTools": "WFRP4E.TrappingType.TradeTools",
    "drugsPoisonsHerbsDraughts": "WFRP4E.TrappingType.DrugsPoisonsHerbsDraughts",
    "ingredient": "WFRP4E.TrappingType.Ingredient",
    "misc": "WFRP4E.TrappingType.Misc",
};

// Creature Sizes
WFRP4E.actorSizes = {
    "tiny": "SPEC.Tiny",
    "ltl": "SPEC.Little",
    "sml": "SPEC.Small",
    "avg": "SPEC.Average",
    "lrg": "SPEC.Large",
    "enor": "SPEC.Enormous",
    "mnst": "SPEC.Monstrous"
};

WFRP4E.vehicleTypes = {
    "water" : "Water",
    "land" : "Land",
    "air" : "Air"
};

WFRP4E.crewBulk = {
    tiny : {
        crew : 0,
        encumbrance : 0
    },
    ltl : {
        crew : 0.25,
        encumbrance : 1
    },
    sml : {
        crew : 0.5,
        encumbrance : 3
    },
    avg : {
        crew : 1,
        encumbrance : 6
    },
    lrg : {
        crew : 3,
        encumbrance : 18
    },
    enor : {
        crew : 9,
        encumbrance : 54
    },
    mnst : {
        crew : 27,
        encumbrance : 162
    }
};

WFRP4E.vehicleActorSizeComparison = {
    tiny : {
        tiny : 0,
        ltl : 4,
        sml : 3,
        avg : 2,
        lrg : 1,
        enor :-1 ,
        mnst : -2,
    },
    ltl : {
        tiny : 0,
        ltl : 0,
        sml : 4,
        avg : 3,
        lrg : 2,
        enor :1 ,
        mnst : -1,
    },
    sml : {
        tiny : 0,
        ltl : 0,
        sml : 0,
        avg : 4,
        lrg : 3,
        enor :2 ,
        mnst : 1,
    },
    avg : {
        tiny : 0,
        ltl : 0,
        sml : 0,
        avg : 0,
        lrg : 4,
        enor :3 ,
        mnst : 2,
    },
    lrg : {
        tiny : 0,
        ltl : 0,
        sml : 0,
        avg : 0,
        lrg : 0,
        enor :4 ,
        mnst : 3,
    },
    enor : {
        tiny : 0,
        ltl : 0,
        sml : 0,
        avg : 0,
        lrg : 0,
        enor : 0,
        mnst : 4,
    },
    mnst : {
        tiny : 0,
        ltl : 0,
        sml : 0,
        avg : 0,
        lrg : 0,
        enor : 0,
        mnst : 0,
    }
};

WFRP4E.actorSizeNums = {
    "tiny": 0,
    "ltl": 1,
    "sml": 2,
    "avg": 3,
    "lrg": 4,
    "enor": 5,
    "mnst": 6
};

WFRP4E.tokenSizes = {
    "tiny": 0.3,
    "ltl": 0.5,
    "sml": 0.8,
    "avg": 1,
    "lrg": 2,
    "enor": 3,
    "mnst": 4
};

// Condition Types
WFRP4E.magicLores = {
    "petty": "WFRP4E.MagicLores.petty",
    "beasts": "WFRP4E.MagicLores.beasts",
    "death": "WFRP4E.MagicLores.death",
    "fire": "WFRP4E.MagicLores.fire",
    "heavens": "WFRP4E.MagicLores.heavens",
    "metal": "WFRP4E.MagicLores.metal",
    "life": "WFRP4E.MagicLores.life",
    "light": "WFRP4E.MagicLores.light",
    "shadow": "WFRP4E.MagicLores.shadow",
    "hedgecraft": "WFRP4E.MagicLores.hedgecraft",
    "witchcraft": "WFRP4E.MagicLores.witchcraft",
    "daemonology": "WFRP4E.MagicLores.daemonology",
    "necromancy": "WFRP4E.MagicLores.necromancy",
    "undivided" : "WFRP4E.MagicLores.undivided",
    "nurgle": "WFRP4E.MagicLores.nurgle",
    "slaanesh": "WFRP4E.MagicLores.slaanesh",
    "tzeentch": "WFRP4E.MagicLores.tzeentch",
};

// Given a Lore, what is the Wind
WFRP4E.magicWind = {
    "petty": "WFRP4E.MagicWind.petty",
    "beasts": "WFRP4E.MagicWind.beasts",
    "death": "WFRP4E.MagicWind.death",
    "fire": "WFRP4E.MagicWind.fire",
    "heavens": "WFRP4E.MagicWind.heavens",
    "metal": "WFRP4E.MagicWind.metal",
    "life": "WFRP4E.MagicWind.life",
    "light": "WFRP4E.MagicWind.light",
    "shadow": "WFRP4E.MagicWind.shadow",
    "hedgecraft": "WFRP4E.MagicWind.hedgecraft",
    "witchcraft": "WFRP4E.MagicWind.witchcraft",
    "daemonology": "WFRP4E.MagicWind.daemonology",
    "necromancy": "WFRP4E.MagicWind.necromancy",
    "undivided": "WFRP4E.MagicWind.undivided",
    "nurgle": "WFRP4E.MagicWind.nurgle",
    "slaanesh": "WFRP4E.MagicWind.slaanesh",
    "tzeentch": "WFRP4E.MagicWind.tzeentch",
};



// Types of prayers
WFRP4E.prayerTypes = {
    "blessing": "WFRP4E.prayerTypes.blessing",
    "miracle": "WFRP4E.prayerTypes.miracle"
};

WFRP4E.mutationTypes = {
    "physical": "WFRP4E.mutationTypes.physical",
    "mental": "WFRP4E.mutationTypes.mental"
};


WFRP4E.conditions = {
    "ablaze": "WFRP4E.ConditionName.Ablaze",
    "bleeding": "WFRP4E.ConditionName.Bleeding",
    "blinded": "WFRP4E.ConditionName.Blinded",
    "broken": "WFRP4E.ConditionName.Broken",
    "deafened": "WFRP4E.ConditionName.Deafened",
    "entangled": "WFRP4E.ConditionName.Entangled",
    "fatigued": "WFRP4E.ConditionName.Fatigued",
    "poisoned": "WFRP4E.ConditionName.Poisoned",
    "prone": "WFRP4E.ConditionName.Prone",
    "stunned": "WFRP4E.ConditionName.Stunned",
    "surprised": "WFRP4E.ConditionName.Surprised",
    "unconscious": "WFRP4E.ConditionName.Unconscious",
    "grappling": "WFRP4E.ConditionName.Grappling",
    "engaged": "WFRP4E.ConditionName.Engaged",
    "defeated": "WFRP4E.ConditionName.Defeated"
};


WFRP4E.earningValues = {
    "b": "2d10",
    "s": "1d10",
    "g": "1",
};

WFRP4E.randomExp = {
    speciesRand: 20,
    careerRand: 50,
    careerReroll: 25,
    statsRand: 50,
    statsReorder: 25
};

WFRP4E.reachNum = {
    "personal": 1,
    "vshort": 2,
    "short": 3,
    "average": 4,
    "long": 5,
    "vLong": 6,
    "massive": 7,
};

WFRP4E.traitBonuses = {
    "big": {
        "s": 10,
        "t": 10,
        "ag": -5
    },
    "brute": {
        "m": -1,
        "t": 10,
        "s": 10,
        "ag": -10
    },
    "clever": {
        "int": 20,
        "i": 10
    },
    "cunning": {
        "int": 10,
        "fel": 10,
        "i": 10
    },
    "elite": {
        "ws": 20,
        "bs": 20,
        "wp": 20
    },
    "fast": {
        "ag": 10,
        "m": 1
    },
    "leader": {
        "fel": 10,
        "wp": 10
    },
    "tough": {
        "t": 10,
        "wp": 10
    },
    "swarm": {
        "ws": 10
    }
};

WFRP4E.talentBonuses = {
    "savvy": "int",
    "suave": "fel",
    "marksman": "bs",
    "very strong": "s",
    "sharp": "i",
    "lightning reflexes": "ag",
    "coolheaded": "wp",
    "very resilient": "t",
    "nimble fingered": "dex",
    "warrior born": "ws"
};

WFRP4E.corruptionTables = ["mutatephys", "mutatemental"];

WFRP4E.DAMAGE_TYPE = {
    NORMAL: 0,
    IGNORE_AP: 1,
    IGNORE_TB: 2,
    IGNORE_ALL: 3
};

WFRP4E.PSEUDO_ENTITIES = [
    "Table",
    "Condition",
    "Symptom",
    "Roll",
    "Pay",
    "Credit",
    "Corruption",
    "Fear",
    "Terror",
    "Exp"
];

WFRP4E.availabilityTable = {
    "MARKET.Village": {
        "WFRP4E.Availability.Common": {
            test: 100,
            stock: '2'
        },
        "WFRP4E.Availability.Scarce": {
            test: 30,
            stock: '1'
        },
        "WFRP4E.Availability.Rare": {
            test: 15,
            stock: '1'
        },
        "WFRP4E.Availability.Exotic": {
            test: 0,
            stock: '0'
        }
    },
    "MARKET.Town": {
        "WFRP4E.Availability.Common": {
            test: 100,
            stock: '2d10'
        },
        "WFRP4E.Availability.Scarce": {
            test: 60,
            stock: '1d10'
        },
        "WFRP4E.Availability.Rare": {
            test: 30,
            stock: '1d5'
        },
        "WFRP4E.Availability.Exotic": {
            test: 0,
            stock: '0'
        }
    },
    "MARKET.City": {
        "WFRP4E.Availability.Common": {
            test: 100,
            stock: '∞'
        },
        "WFRP4E.Availability.Scarce": {
            test: 90,
            stock: '∞'
        },
        "WFRP4E.Availability.Rare": {
            test: 45,
            stock: '∞'
        },
        "WFRP4E.Availability.Exotic": {
            test: 0,
            stock: '0'
        }
    }
};

WFRP4E.overCastTablesPerWind = {
    "default": {
        range: [
            {cost: 1, value: 2},
            {cost: 4, value: 3},
            {cost: 16, value: 4}],
        target: [
            {cost: 1, value: 1},
            {cost: 4, value: 2},
            {cost: 16, value: 3}],
        AoE: [
            {cost: 3, value: 2},
            {cost: 18, value: 3}],
        duration: [
            {cost: 2, value: 2},
            {cost: 6, value: 3}],
        damage: [
            {cost: 1, value: 1},
            {cost: 1, value: 2},
            {cost: 1, value: 3},
            {cost: 2, value: 4},
            {cost: 3, value: 5},
            {cost: 5, value: 6},
            {cost: 8, value: 7}],
        other: [
            {cost: 2, value: 1},
            {cost: 2, value: 2},
            {cost: 2, value: 3},
            {cost: 2, value: 4},
            {cost: 2, value: 5},
            {cost: 2, value: 6},
            {cost: 2, value: 7},
            {cost: 2, value: 8},
            {cost: 2, value: 9},
            {cost: 2, value: 10},
            {cost: 2, value: 11},
            {cost: 2, value: 12},
            {cost: 2, value: 13},
            {cost: 2, value: 14},
            {cost: 2, value: 15},
            {cost: 2, value: 16},
            {cost: 2, value: 17},
            {cost: 2, value: 18},
            {cost: 2, value: 19},
            {cost: 2, value: 20}
        ]
    }
};

WFRP4E.overCastTable = function(wind) {
    return WFRP4E.overCastTablesPerWind[wind] || WFRP4E.overCastTablesPerWind["default"]
};

WFRP4E.species = {};
WFRP4E.subspecies = {};
WFRP4E.speciesCharacteristics = {};
WFRP4E.speciesSkills = {};
WFRP4E.speciesTalents = {};
WFRP4E.speciesTraits = {};
WFRP4E.speciesRandomTalents = {};
WFRP4E.speciesTalentReplacement = {};
WFRP4E.speciesMovement = {};
WFRP4E.speciesFate = {};
WFRP4E.speciesRes = {};
WFRP4E.speciesExtra = {};
WFRP4E.speciesAge = {};
WFRP4E.speciesHeight = {};
WFRP4E.speciesCareerReplacements = {};
WFRP4E.extraSpecies = [];
WFRP4E.classTrappings = {};
WFRP4E.weaponGroupDescriptions = {};
WFRP4E.reachDescription = {};
WFRP4E.qualityDescriptions = {};
WFRP4E.flawDescriptions = {};
WFRP4E.loreEffectDescriptions = {};
WFRP4E.loreEffects = {};
WFRP4E.conditionDescriptions = {};
WFRP4E.symptoms = {};
WFRP4E.symptomDescriptions = {};
WFRP4E.symptomTreatment = {};
WFRP4E.modTypes = {};
WFRP4E.symptomEffects = {};
WFRP4E.effectScripts = {};
WFRP4E.propertyEffects = {};
WFRP4E.godBlessings = {};

WFRP4E.effectKeysTemplate = "systems/wfrp4e/templates/apps/effect-key-options.hbs",
WFRP4E.avoidTestTemplate = "systems/wfrp4e/templates/apps/effect-avoid-test.hbs",
WFRP4E.logFormat = [`%cWFRP4e` + `%c | @MESSAGE`, "color: gold", "color: unset"],
WFRP4E.rollClasses = {},

WFRP4E.transferTypes = {
    document : "WH.TransferType.Document",
    damage : "WH.TransferType.Damage",
    target : "WH.TransferType.Target",
    area : "WH.TransferType.Area",
    aura : "WH.TransferType.Aura",
    crew : "WH.TransferType.Crew",
    other : "WH.TransferType.Other"
},

WFRP4E.premiumModules = {
    "wfrp4e" : "WFRP4e System",
    "wfrp4e-core" : "Core Rulebook",
    "wfrp4e-starter-set" : "Starter Set",
    "wfrp4e-rnhd" : "Rough Nights & Hard Days",
    "wfrp4e-eis" : "Enemy In Shadows",
    "wfrp4e-ua1" : "Ubersreik Adventures I",
    "wfrp4e-dotr" : "Death on the Reik",
    "wfrp4e-middenheim" : "Middenheim: City of the White Wolf",
    "wfrp4e-archives1" : "Archives of the Empire: Vol I.",
    "wfrp4e-pbtt" : "Power Behind the Throne",
    "wfrp4e-altdorf" : "Altdorf: Crown of the Empire",
    "wfrp4e-ua2" : "Ubersreik Adventures II",
    "wfrp4e-owb1" : "Old World Bundle I",
    "wfrp4e-horned-rat" : "The Horned Rat",
    "wfrp4e-empire-ruins" : "Empire in Ruins",
    "wfrp4e-archives2" : "Archives of the Empire: Vol II.",
    "wfrp4e-up-in-arms" : "Up In Arms",
    "wfrp4e-wom" : "Winds of Magic",
    "wfrp4e-zoo" : "Imperial Zoo",
    "wfrp4e-salzenmund" : "Salzenmund: City of Salt and Silver",
    "wfrp4e-owb2" : "Old World Bundle II",
    "wfrp4e-soc" : "Sea of Claws",
    "wfrp4e-lustria" : "Lustria",
    "wfrp4e-archives3" : "Archives of the Empire: Vol III.",
    "wfrp4e-ua3" : "Ubersreik Adventures III",
    "wfrp4e-tribes" : "Tribes & Tribulations",
    "wfrp4e-owb3" : "Places & Perils",
    "wfrp4e-dslf" : "Deft Steps Light Fingers"
};

WFRP4E.copyrightText = `

<p>No part of this publication may be reproduced, distributed, stored in a retrieval system, or transmitted in any form by any means, electronic, mechanical, photocopying, recording or otherwise without the prior permission of the publishers.</p>        
<p>Warhammer Fantasy Roleplay 4th Edition © Copyright Games Workshop Limited 2025. Warhammer Fantasy Roleplay 4th Edition, the Warhammer Fantasy Roleplay 4th Edition logo, GW, Games Workshop, Warhammer, The Game of Fantasy Battles, the twin-tailed comet logo, and all associated logos, illustrations, images, names, creatures, races, vehicles, locations, weapons, characters, and the distinctive likeness thereof, are either ® or TM, and/or © Games Workshop Limited, variably registered around the world, and used under licence. Cubicle 7 Entertainment and the Cubicle 7 Entertainment logo are trademarks of Cubicle 7 Entertainment Limited. All rights reserved.</p>

<div style="display: flex; justify-content: space-around;">
    <img src="modules/warhammer-lib/assets/c7.png" height=50 width=50/>   
    <img src="modules/warhammer-lib/assets/warhammer.png" height=50 width=50/>
</div>

<ul>
<li>Published by: <strong>Cubicle 7 Entertainment Ltd</strong></li>
<li>Foundry Edition by <strong>@AUTHORS@</strong></li>
<li>Special thanks to: <strong>Games Workshop, Fatshark</strong></li>
</ul>
`;

WFRP4E.trade = { 
    gazetteer : [],
    settlementRating : {
        "hamlet": { popmax: 200,
          size_rating: 1 },
      
        "village": {
          popmax: 1500,
          size_rating: 2
        },
      
        "town": { popmax: 10000,
          size_rating: 3 },
      
        "city": { popmax: 100000000,
          size_rating: 4 }
      },
      wealthAvailability : [
        { wealth: 0,
          offered: -1.0 },
        
          { wealth: 1,
          offered: -0.5 },
        
        { wealth: 2,
          offered: -0.2 },
        
        { wealth: 3,
          offered: 0 },
        
        { wealth: 4,
          offered: 0.05 },
        
        { wealth: 5,
          offered: 0.1 }
        ],
        cargoTypes : {},
        seasons : {},
        cargoTable : {},
        wineBrandyPrice : [],
        qualities : {}
};

// This defines the standard money used. 
// "moneyNames" is what currency name to look for when creating a character 
// The money keys are used for parsing input (like commands)
// Override these values if you wish to have a campaign in a different setting
WFRP4E.moneyNames = {
    "gc" : "NAME.GC",
    "ss" : "NAME.SS",
    "bp" : "NAME.BP"
};

WFRP4E.moneyValues = {
    "gc" : 240,
    "ss" : 20,
    "bp" : 1
};

WFRP4E.hitLocationTables = {
    "hitloc": "WFRP4E.hitLocationTables.hitloc",
    "snake": "WFRP4E.hitLocationTables.snake",
    "spider": "WFRP4E.hitLocationTables.spider"
};

WFRP4E.extendedTestCompletion = {
    none: "ExtendedTest.None",
    reset: "ExtendedTest.Reset",
    remove: "ExtendedTest.Remove"
};

// For modules to add to these, they need to be merged
WFRP4E.systemItems = {};
WFRP4E.systemEffects = {};
WFRP4E.vehicleSystemEffects = {};
WFRP4E.groupAdvantageActions = [];

WFRP4E.PrepareSystemItems = function() {

    this.systemItems = foundry.utils.mergeObject(this.systemItems, {
        reload : {
            type: "extendedTest",
            name: "",
            system: {
                SL: {
                },
                test: {
                    value: ""
                },
                completion: {
                    value: "remove"
                }
            },
            flags: {
                wfrp4e: {
                    reloading: ""
                }
            }
        },
        improv : {
            name: game.i18n.localize("NAME.Improvised"),
            type: "weapon",
            effects : [],
            system: {
                damage: { value: "SB + 1" },
                reach: { value: "personal" },
                weaponGroup: { value: "basic" },
                twohanded: { value: false },
                qualities: { value: [] },
                flaws: { value: [{name : "undamaging"}] },
                special: { value: "" },
                range: { value: "" },
                ammunitionGroup: { value: "" },
                offhand: { value: false },
            }
        },
        stomp : {
            name: game.i18n.localize("NAME.Stomp"),
            type: "trait",
            effects : [],
            system: {
                specification: { value: 0 },
                rollable: { value: true, rollCharacteristic: "ws", bonusCharacteristic: "s", defaultDifficulty: "challenging", damage : true, SL: true, skill : game.i18n.localize("NAME.MeleeBrawling") },
            }
        },
        unarmed : {
            name: game.i18n.localize("NAME.Unarmed"),
            type: "weapon",
            effects : [],
            system: {
                damage: { value: "SB + 0" },
                reach: { value: "personal" },
                weaponGroup: { value: "brawling" },
                twohanded: { value: false },
                qualities: { value: [] },
                flaws: { value: [{name : "undamaging"}] },
                special: { value: "" },
                range: { value: "" },
                ammunitionGroup: { value: "" },
                offhand: { value: false },
            }
        },

        fear : {
            name : game.i18n.localize("NAME.FearExtendedTest"),
            type : "extendedTest",
            system : {
                completion:{value: 'remove'},
                description:{type: 'String', label: 'Description', value: ''},
                failingDecreases:{value: true},
                gmdescription:{type: 'String', label: 'Description', value: ''},
                hide: { test: false, progress: false },
                negativePossible: { value: false },
                SL: { current: 0, target: 1 },
                test: { value: game.i18n.localize("NAME.Cool") }
            },
            flags : {
                wfrp4e : {
                    fear : true
                }
            },
            effects:
                [{
                    name: game.i18n.localize("NAME.Fear"),
                    img: "systems/wfrp4e/icons/conditions/fear.png",
                    statuses : ["fear"],
                    system: {
                            transferData : {},
                            scriptData : [
                                {
                                    label : "@effect.flags.wfrp4e.dialogTitle",
                                    trigger : "dialog",
                                    script : `args.fields.slBonus -= 1`,
                                    options : {
                                        hideScript : "",
                                        activateScript : `return args.data.targets[0]?.name == this.item.flags.wfrp4e?.fearName`
                                    }
                                },
                                {
                                    label : "@effect.name",
                                    trigger : "immediate",
                                    script : `
                                    let name = this.item?.flags?.wfrp4e?.fearName
                                    this.effect.updateSource({"flags.wfrp4e.dialogTitle" : (name ? game.i18n.format("EFFECT.AffectTheSourceOfFearName", {name}) : game.i18n.format("EFFECT.AffectTheSourceOfFear"))})
                                    if (name)
                                    {
                                        this.item.updateSource({name : this.item.name + " (" + name + ")" })
                                    }
                                    `
                                },
                                {
                                    trigger: "endRound",
                                    label: "Roll to remove Fear",
                                    script: `
                                        const test = await this.actor.setupExtendedTest(this.effect.item, {
                                            fields: {difficulty: "challenging"}, 
                                            skipTargets: true, 
                                            appendTitle :  \` - \${this.effect.name}\`, 
                                        });
                                        await test.roll();
                                    `,
                                }
                            ]
                        }
                }]

        },

        terror: {
            name: game.i18n.localize("NAME.Terror"),
            img: "systems/wfrp4e/icons/conditions/terror.png",
            system: {
                transferData : {},
                scriptData : [
                    {
                        label : "@effect.name",
                        trigger : "immediate",
                        script : `
                        let terror = this.effect.flags.wfrp4e.terrorValue;
                        let skillName = game.i18n.localize("NAME.Cool");
                        let test = await args.actor.setupSkill(skillName, {terror: true, appendTitle : " - Terror", skipTargets: true});
                        await test.roll();
                        await this.actor.applyFear(terror, name)
                        if (test.failed)
                        {
                            if (test.result.SL < 0)
                                terror += Math.abs(test.result.SL)

                            await this.actor.addCondition("broken", terror)
                        }
                        `
                    }
                ]
            },
        }
    });


    this.systemEffects = foundry.utils.mergeObject(this.systemEffects, {
        "fear": {
            name: game.i18n.localize("NAME.Fear"),
            img: "systems/wfrp4e/icons/conditions/fear.png",
            statuses: ["fear"],
            flags: {
                wfrp4e: {
                    transferData: {},
                    scriptData: [
                        {
                            label: "@effect.flags.wfrp4e.dialogTitle",
                            trigger: "dialog",
                            script: `args.fields.slBonus -= 1`,
                            options: {
                                    hideScript: "",
                                    activateScript: `return args.data.targets[0]?.name == this.item.flags.wfrp4e?.fearName`
                            }
                        },
                        {
                            label: "@effect.name",
                            trigger: "immediate",
                            script: `
                            let name = this.item?.flags?.wfrp4e?.fearName
                            this.effect.updateSource({"flags.wfrp4e.dialogTitle" : (name ? game.i18n.format("EFFECT.AffectTheSourceOfFearName", {name}) : game.i18n.format("EFFECT.AffectTheSourceOfFear"))})
                            if (name)
                            {
                                this.item.updateSource({name : this.item.name + " (" + name + ")" })
                            }
                            `
                        }
                    ]
                }
            }
        },
        "enc1": {
            name: game.i18n.localize("EFFECT.Encumbrance") + " 1",
            img: "systems/wfrp4e/icons/effects/enc1.png",
            statuses: ["enc1"],
            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "prePrepareData",
                        script: `
                            args.actor.characteristics.ag.modifier -= 10;

                            if (args.actor.details.move.value > 3)
                            {
                                args.actor.details.move.value -= 1;
                                if (args.actor.details.move.value < 3)
                                    args.actor.details.move.value = 3
                            }
                            `
                    }
                ]
            }
        },
        "enc2": {
            name: game.i18n.localize("EFFECT.Encumbrance") + " 2",
            img: "systems/wfrp4e/icons/effects/enc2.png",
            statuses: ["enc2"],
            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "prePrepareData",
                        script: `
                            args.actor.characteristics.ag.modifier -= 20;
                            if (args.actor.details.move.value > 2)
                            {
                                args.actor.details.move.value -= 2;
                                if (args.actor.details.move.value < 2)
                                    args.actor.details.move.value = 2
                            }
                            `
                    }
                ]
            }
        },
        "enc3": {
            name: game.i18n.localize("EFFECT.Encumbrance") + " 3",
            img: "systems/wfrp4e/icons/effects/enc3.png",
            statuses: ["enc3"],
            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "prePrepareData",
                        script: "args.actor.details.move.value = 0;"
                    }
                ]
            }
        },
        "cold1": {
            name: game.i18n.localize("EFFECT.ColdExposure") + " 1",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["cold1"],
            changes: [
                { key: "system.characteristics.bs.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.ag.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.dex.modifier", mode: 2, value: -10 },
            ]
        },
        "cold2": {
            name: game.i18n.localize("EFFECT.ColdExposure") + " 2",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["cold2"],
            changes: [
                { key: "system.characteristics.bs.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.ag.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.ws.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.s.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.t.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.i.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.dex.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.int.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.wp.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.fel.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1 },
                { key: "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1 },
                { key: "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1 },
            ]
        },
        "cold3": {
            name: game.i18n.localize("EFFECT.ColdExposure") + " 3",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["cold3"],
            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "manual",
                        script: `
                            let tb = this.actor.characteristics.t.bonus
                            let damage = (await new Roll("1d10").roll({allowInteractive : false})).total
                            damage -= tb
                            if (damage <= 0) damage = 1
                            if (this.actor.status.wounds.value <= damage) {
                                await this.actor.addCondition("unconscious")
                            }
                            this.actor.modifyWounds(-damage)
                            ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                            `
                    }
                ]
            }
        },
        "heat1": {
            name: game.i18n.localize("EFFECT.HeatExposure") + " 1",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["heat1"],
            changes: [
                { key: "system.characteristics.int.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.wp.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1 },
            ]
        },
        "heat2": {
            name: game.i18n.localize("EFFECT.HeatExposure") + " 2",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["heat2"],
            changes: [
                { key: "system.characteristics.bs.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.ag.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.ws.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.s.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.t.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.i.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.dex.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.int.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.wp.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.fel.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1 },
                { key: "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1 },
                { key: "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1 },
            ]
        },
        "heat3": {
            name: game.i18n.localize("EFFECT.HeatExposure") + " 3",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["heat3"],
            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "manual",
                        script: `
                            let tb = this.actor.characteristics.t.bonus
                            let damage = (await new Roll("1d10").roll({allowInteractive : false})).total
                            damage -= tb
                            if (damage <= 0) {
                                damage = 1
                            }
                            this.actor.modifyWounds(-damage)
                            ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                            `
                    }
                ]
            }
        },
        "thirst1": {
            name: game.i18n.localize("EFFECT.Thirst") + " 1",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["thirst1"],
            changes: [
                { key: "system.characteristics.int.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.wp.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.fel.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1 },
            ]
        },
        "thirst2": {
            name: game.i18n.localize("EFFECT.Thirst") + " 2+",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["thirst2"],
            changes: [
                { key: "system.characteristics.bs.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.ag.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.ws.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.s.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.t.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.i.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.int.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.dex.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.wp.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.fel.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1 },
                { key: "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1 },
                { key: "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1 },
            ],
            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "manual",
                        script: `
                            let tb = this.actor.characteristics.t.bonus
                            let damage = (await new Roll("1d10").roll({allowInteractive : false})).total
                            damage -= tb
                            if (damage <= 0) {
                                damage = 1
                            }
                            this.actor.modifyWounds(-damage)
                            ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                            `
                    }
                ]
            }
        },
        "starvation1": {
            name: game.i18n.localize("EFFECT.Starvation") + " 1",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["starvation1"],
            changes: [
                { key: "system.characteristics.s.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.t.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1 },
                { key: "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1 },
            ]
        },
        "starvation2": {
            name: game.i18n.localize("EFFECT.Starvation") + " 2",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["starvation2"],
            changes: [
                { key: "system.characteristics.bs.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.ag.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.ws.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.s.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.t.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.i.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.int.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.dex.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.wp.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.fel.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1 },
                { key: "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1 },
                { key: "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1 },
            ],
            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "manual",
                        script: `
                            let tb = this.actor.characteristics.t.bonus
                            let damage = (await new Roll("1d10").roll({allowInteractive : false})).total
                            damage -= tb
                            if (damage <= 0) {
                                damage = 1
                            }
                            this.actor.modifyWounds(-damage)
                            ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                            `
                    }
                ]
            }
        },
        "blackpowder": {
            name: game.i18n.localize("EFFECT.BlackpowderShock"),
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["blackpowder"],
            flags: {
                wfrp4e: {
                    blackpowder: true,
                },
            },

            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "immediate",
                        script: `
                            test = await this.actor.setupSkill(game.i18n.localize("NAME.Cool"), {appendTitle : " - " + this.effect.name, skipTargets: true, fields : {difficulty : "average"}});
                            await test.roll();
                            if (test.failed)
                            {
                                this.actor.addCondition("broken");
                            }
                            return false;
                        `
                    }
                ]
            }
        },
        "infighting": {
            name: game.i18n.localize("EFFECT.Infighting"),
            img: "modules/wfrp4e-core/icons/talents/in-fighter.png",
            statuses: ["infighting"],
            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "prePrepareItem",
                        script: `
                            if (args.item.type == "weapon" && args.item.isEquipped)
                            {
                                let weaponLength = args.item.reachNum
                                if (weaponLength > 3)
                                {
                                    let improv = foundry.utils.duplicate(game.wfrp4e.config.systemItems.improv)
                                    improv.system.twohanded.value = args.item.twohanded.value
                                    improv.system.offhand.value = args.item.offhand.value
                                    improv.name = args.item.name + " (" + game.i18n.localize("EFFECT.Infighting") + ")"
                                    foundry.utils.mergeObject(args.item.system, improv.system, {overwrite : true})
                                    args.item.system.qualities = improv.system.qualities
                                    args.item.system.flaws = improv.system.flaws
                                    args.item.name = improv.name
                                    args.item.system.infighting = true;
                                }
                            }
                            `
                    }
                ]
            }
        },
        "defensive": {
            name: game.i18n.localize("EFFECT.OnDefensive"),
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["defensive"],
            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "dialog",
                        script: `args.prefillModifiers.modifier += 20`,
                        options: {
                            hideScript: "return !this.actor.isOpposing",
                            activateScript: `
                                    let skillName = this.effect.name.substring(this.effect.name.indexOf("[") + 1, this.effect.name.indexOf("]"))
                                    return args.skill?.name == skillName
                                `
                        }
                    },
                    {
                        label: "@effect.name",
                        trigger: "immediate",
                        script: `
                                let choice = await ItemDialog.create(this.actor.itemTypes.skill.sort((a, b) => a.name > b.name ? 1 : -1), 1, "Choose which skill to use with On the Defensive");    
                                this.effect.updateSource({name : this.effect.name + " [" +  choice[0]?.name + "]"})
                                `
                    }
                ]
            }
        },
        "dualwielder": {
            name: game.i18n.localize("EFFECT.DualWielder"),
            img: "modules/wfrp4e-core/icons/talents/dual-wielder.png",
            statuses: ["dualwielder"],
            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "dialog",
                        script: `args.prefillModifiers.modifier -= 10`,
                        options: {
                            hideScript: "return !this.actor.isOpposing",
                            activateScript: `return this.actor.isOpposing`
                        }
                    },
                    {
                        label: "Start Turn",
                        trigger: "startTurn",
                        script: `this.effect.delete()`,
                    }
                ]
            }
        },
        "consumealcohol1": {
            name: game.i18n.localize("EFFECT.ConsumeAlcohol") + " 1",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["consumealcohol1"],
            changes: [
                { key: "system.characteristics.bs.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.ag.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.ws.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.int.modifier", mode: 2, value: -10 },
                { key: "system.characteristics.dex.modifier", mode: 2, value: -10 },
            ]
        },
        "consumealcohol2": {
            name: game.i18n.localize("EFFECT.ConsumeAlcohol") + " 2",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["consumealcohol2"],
            changes: [
                { key: "system.characteristics.bs.modifier", mode: 2, value: -20 },
                { key: "system.characteristics.ag.modifier", mode: 2, value: -20 },
                { key: "system.characteristics.ws.modifier", mode: 2, value: -20 },
                { key: "system.characteristics.int.modifier", mode: 2, value: -20 },
                { key: "system.characteristics.dex.modifier", mode: 2, value: -20 },
            ]
        },
        "consumealcohol3": {
            name: game.i18n.localize("EFFECT.ConsumeAlcohol") + " 3",
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["consumealcohol3"],
            changes: [
                { key: "system.characteristics.bs.modifier", mode: 2, value: -30 },
                { key: "system.characteristics.ag.modifier", mode: 2, value: -30 },
                { key: "system.characteristics.ws.modifier", mode: 2, value: -30 },
                { key: "system.characteristics.int.modifier", mode: 2, value: -30 },
                { key: "system.characteristics.dex.modifier", mode: 2, value: -30 },
            ]
        },
        "stinkingdrunk1": {
            name: game.i18n.localize("EFFECT.MarienburghersCourage"),
            img: "systems/wfrp4e/icons/blank.png",
            statuses: ["stinkingdrunk1"],
            system: {
                transferData: {},
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "dialog",
                        script: `args.prefillModifiers.modifier += 20`,
                        options: {
                            hideScript: "return args.skill?.name != game.i18n.localize('NAME.Cool')",
                            activateScript: `return args.skill?.name == game.i18n.localize('NAME.Cool')`
                        }
                    }
                ]
            }
        },
        "invisible" : {
            name: "Invisible",
            img: "icons/svg/invisible.svg",
            statuses: ["invisible"],
            system: {}
        },
        "blind" : {
            name: "Blind",
            img: "icons/svg/blind.svg",
            statuses: ["blind"],
            system: {}
        }
    });

    this.statusEffects = [
        {
            img: "systems/wfrp4e/icons/conditions/bleeding.png",
            id: "bleeding",
            statuses: ["bleeding"],
            name: "WFRP4E.ConditionName.Bleeding",
            description : "WFRP4E.Conditions.Bleeding",
            system: {
                condition : {
                    value : 1,
                    numbered: true,
                    trigger: "endRound"
                },
                scriptData: [
                    {
                        trigger: "manual",
                        label: "@effect.name",
                        script: `let uiaBleeding = game.settings.get("wfrp4e", "uiaBleeding");
                            let actor = this.actor;
                            let effect = this.effect;
                            let bleedingAmt;
                            let bleedingRoll;
                            let msg = ""

                            let damage = effect.conditionValue;
                            let scriptArgs = {msg, damage};
                            await Promise.all(actor.runScripts("preApplyCondition", {effect, data : scriptArgs}))
                            msg = scriptArgs.msg;
                            damage = scriptArgs.damage;
                            msg += await actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, minimumOne : false, suppressMsg : true})

                            if (actor.status.wounds.value == 0 && !actor.hasCondition("unconscious"))
                            {
                                addBleedingUnconscious = async () => {
                                    await actor.addCondition("unconscious")
                                    msg += "<br>" + game.i18n.format("BleedUnc", {name: actor.prototypeToken.name })
                                }
                                if (uiaBleeding) {
                                    test = await actor.setupSkill(game.i18n.localize("NAME.Endurance"), {appendTitle : " - " + this.effect.name, skipTargets: true, fields : {difficulty : "challenging"}});
                                    await test.roll();
                                    if (test.failed) {
                                        await addBleedingUnconscious();
                                    }
                                } else {
                                    await addBleedingUnconscious();
                                }
                            }

                            if (actor.hasCondition("unconscious"))
                            {
                                bleedingAmt = effect.conditionValue;
                                bleedingRoll = (await new Roll("1d100").roll()).total;
                                if (bleedingRoll <= bleedingAmt * 10)
                                {
                                    msg += "<br>" + game.i18n.format("BleedFail", {name: actor.prototypeToken.name}) + " (" + game.i18n.localize("Rolled") + " " + bleedingRoll + ")";
                                    await actor.addCondition("dead")
                                }
                                else if (bleedingRoll % 11 == 0)
                                {
                                    msg += "<br>" + game.i18n.format("BleedCrit", { name: actor.prototypeToken.name } ) + " (" + game.i18n.localize("Rolled") + bleedingRoll + ")"
                                    await actor.removeCondition("bleeding")
                                }
                                else
                                {
                                    msg += "<br>" + game.i18n.localize("BleedRoll") + ": " + bleedingRoll;
                                }
                            }

                            await Promise.all(actor.runScripts("applyCondition", {effect, data : {bleedingRoll}}))
                            if (args.suppressMessage)
                            {
                                let messageData = game.wfrp4e.utility.chatDataSetup(msg);
                                messageData.speaker = {alias: this.effect.name}
                                messageData.flavor = this.effect.name;
                                return messageData
                            }
                            else
                            {
                                return this.script.message(msg)
                            }
                            `
                    }
                ]
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/poisoned.png",
            id: "poisoned",
            statuses: ["poisoned"],
            name: "WFRP4E.ConditionName.Poisoned",
            description : "WFRP4E.Conditions.Poisoned",
            system: {
                condition : {
                    value : 1,
                    numbered: true,
                    trigger: "endRound"
                },
                scriptData: [
                    {
                        trigger: "manual",
                        label: "@effect.name",
                        script: `let actor = this.actor;
                            let effect = this.effect;
                            let msg = ""

                            let damage = effect.conditionValue;
                            let scriptArgs = {msg, damage};
                            await Promise.all(actor.runScripts("preApplyCondition", {effect, data : scriptArgs}))
                            msg = scriptArgs.msg;
                            damage = scriptArgs.damage;
                            msg += await actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true})

                            await Promise.all(actor.runScripts("applyCondition", {effect}))
                            if (args.suppressMessage)
                            {
                                let messageData = game.wfrp4e.utility.chatDataSetup(msg);
                                messageData.speaker = {alias: this.effect.name}
                                return messageData
                            }
                            else
                            {
                                return this.script.message(msg)
                            }
                            `
                    },
                    {
                        trigger: "dialog",
                        label: "@effect.name",
                        script: `args.fields.modifier -= 10 * this.effect.conditionValue`,
                        options: {
                                activateScript: "return true"
                        }
                    }
                ]
            }

        },
        {
            img: "systems/wfrp4e/icons/conditions/ablaze.png",
            id: "ablaze",
            statuses: ["ablaze"],
            name: "WFRP4E.ConditionName.Ablaze",
            description : "WFRP4E.Conditions.Ablaze",
            system: {
                condition : {
                    value : 1,
                    numbered: true,
                    trigger: "endRound"
                },
                scriptData: [
                    {
                        trigger: "manual",
                        label: "@effect.name",
                        script: `let leastProtectedLoc;
                            let leastProtectedValue = 999;
                            for (let loc in this.actor.status.armour)
                            {
                                if (this.actor.status.armour[loc].value != undefined && this.actor.status.armour[loc].value < leastProtectedValue)
                                {
                                    leastProtectedLoc = loc;
                                    leastProtectedValue = this.actor.status.armour[loc].value;
                                }
                            }

                            let formula = "1d10 + @effect.conditionValue - 1"
                            let msg = "<strong>${game.i18n.localize("Formula")}</strong>: @FORMULA"

                            let scriptArgs = {msg, formula}
                            await Promise.all(this.actor.runScripts("preApplyCondition", {effect : this.effect, data : scriptArgs}));
                            formula = scriptArgs.formula;
                            msg = scriptArgs.msg;
                            let roll = await new Roll(formula, this).roll({allowInteractive : false});
                            let terms = roll.terms.map(i => (i instanceof Die ? (i.formula + " (" + i.total + ")") : (i.total))).join("")
                            msg = msg.replace("@FORMULA", terms);

                            let damageMsg = ("<br>" + await this.actor.applyBasicDamage(roll.total, {loc: leastProtectedLoc, suppressMsg : true})).split("")
                            msg += damageMsg.join("");
                            await Promise.all(this.actor.runScripts("applyCondition", {effect : this.effect}))
                            if (args.suppressMessage)
                            {
                                let messageData = game.wfrp4e.utility.chatDataSetup(msg);
                                messageData.speaker = {alias: this.actor.prototypeToken.name}
                                messageData.flavor = this.effect.name
                                return messageData
                            }
                            else
                            {
                                return this.script.message(msg)
                            }
                            `
                    }
                ]
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/deafened.png",
            id: "deafened",
            statuses: ["deafened"],
            name: "WFRP4E.ConditionName.Deafened",
            description : "WFRP4E.Conditions.Deafened",
            system: {
                condition : {
                    value : 1,
                    numbered: true
                },
                scriptData: [
                    {
                        trigger: "dialog",
                        label: "Tests related to hearing",
                        script: `args.fields.modifier -= 10 * this.effect.conditionValue`
                    }
                ]
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/stunned.png",
            id: "stunned",
            statuses: ["stunned"],
            name: "WFRP4E.ConditionName.Stunned",
            description : "WFRP4E.Conditions.Stunned",
            system: {
                condition : {
                    value : 1,
                    numbered: true
                },
                scriptData: [
                    {
                        trigger: "dialog",
                        label: "Penalty to all Tests (@effect.name)",
                        script: `args.fields.modifier -= 10 * this.effect.conditionValue`,
                        options: {
                            activateScript: "return true"
                        }
                    },
                    {
                        trigger: "prePrepareData",
                        label: "Half Movement",
                        script: `args.actor.system.details.move.value /= 2`
                    },
                    {
                        trigger: "endRound",
                        label: "Roll to remove Stunned",
                        script: `
const test = await this.actor.setupSkill(game.i18n.localize("NAME.Endurance"), {fields: {difficulty: "challenging"}, skipTargets: true, appendTitle :  \` - \${this.effect.name}\`, context: {success: "Removed SL + 1 Conditions.", failure: "Failed to remove Conditions."}});
await test.roll();
if (test.succeeded) {
  const toRemove = 1 + Number(test.result.SL);
  this.actor.removeCondition("stunned", toRemove);
}
                    `,
                    },
                    // { // Not sure what to do about this
                    //     trigger: "dialog",
                    //     label : "Bonus to Melee Attacks",
                    //     script : `args.fields.modifier -= 10 * this.effect.conditionValue`,
                    //     "options.dialog.targeter" : true
                    // }
                ]
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/entangled.png",
            id: "entangled",
            statuses: ["entangled"],
            name: "WFRP4E.ConditionName.Entangled",
            description : "WFRP4E.Conditions.Entangled",
            system: {
                condition : {
                    value : 1,
                    numbered: true
                },
                scriptData: [
                    {
                        trigger: "dialog",
                        label: "Tests related to movement of any kind",
                        script: `args.fields.modifier -= 10 * this.effect.conditionValue`,
                        options: {
                                activateScript: "return ['ws', 'bs', 'ag'].includes(args.characteristic)"
                        }
                    }
                ]
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/fatigued.png",
            id: "fatigued",
            statuses: ["fatigued"],
            name: "WFRP4E.ConditionName.Fatigued",
            description : "WFRP4E.Conditions.Fatigued",
            system: {
                condition : {
                    value : 1,
                    numbered: true
                },
                scriptData: [
                    {
                        trigger: "dialog",
                        label: "Penalty to all Tests (@effect.name)",
                        script: `args.fields.modifier -= 10 * this.effect.conditionValue`,
                        options: {
                                activateScript: "return true"
                        }
                    }
                ]
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/blinded.png",
            id: "blinded",
            statuses: ["blinded"],
            name: "WFRP4E.ConditionName.Blinded",
            description : "WFRP4E.Conditions.Blinded",
            system: {
                condition : {
                    value : 1,
                    numbered: true
                },
                scriptData: [
                    {
                        trigger: "dialog",
                        label: "Tests related to sight",
                        script: `args.fields.modifier -= 10 * this.effect.conditionValue`,
                        options: {
                                activateScript: "return ['ws', 'bs', 'ag'].includes(args.characteristic)"
                        }
                    },
                    {
                        trigger: "dialog",
                        label: "Bonus to melee attacks",
                        script: `args.fields.modifier += 10 * this.effect.conditionValue`,
                        options: {
                                targeter: true,
                                hideScript: "return args.item?.attackType != 'melee'",
                                activateScript: "return args.item?.attackType == 'melee'"
                        }
                    }
                ]
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/broken.png",
            id: "broken",
            statuses: ["broken"],
            name: "WFRP4E.ConditionName.Broken",
            description : "WFRP4E.Conditions.Broken",
            system: {
                condition : {
                    value : 1,
                    numbered: true
                },
                scriptData: [
                    {
                        trigger: "dialog",
                        label: "Penalty to all Tests not involving running and hiding.",
                        script: `args.fields.modifier -= 10 * this.effect.conditionValue`,
                        options: {
                            activateScript: "return !args.skill?.name?.includes(game.i18n.localize('NAME.Stealth')) && args.skill?.name != game.i18n.localize('NAME.Athletics')"
                        }
                    }
                ]
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/prone.png",
            id: "prone",
            statuses: ["prone"],
            name: "WFRP4E.ConditionName.Prone",
            description : "WFRP4E.Conditions.Prone",
            system: {
                condition : {
                    value : null,
                    numbered: false
                },
                scriptData: [
                    {
                        trigger: "dialog",
                        label: "Tests related to movement of any kind",
                        script: `args.fields.modifier -= 20`,
                        options: {
                                activateScript: "return ['ws', 'bs', 'ag'].includes(args.characteristic)"
                        }
                    },
                    {
                        trigger: "dialog",
                        label: "Bonus to melee attacks",
                        script: `args.fields.modifier += 20`,
                        options: {
                            targeter: true,
                            hideScript: "return args.item?.system.attackType != 'melee'",
                            activateScript: "return args.item?.system.attackType == 'melee'"
                        }
                    }
                ]
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/surprised.png",
            id: "surprised",
            statuses: ["surprised"],
            name: "WFRP4E.ConditionName.Surprised",
            description : "WFRP4E.Conditions.Surprised",
            system: {
                condition : {
                    value : null,
                    numbered: false
                },
                scriptData: [
                    {
                        trigger: "dialog",
                        label: "Bonus to melee attacks",
                        script: `args.fields.modifier += 20`,
                        options: {
                            targeter: true,
                            hideScript: "return args.item?.system.attackType != 'melee'",
                            activateScript: "return args.item?.system.attackType == 'melee'"
                        }
                    }
                ]
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/unconscious.png",
            id: "unconscious",
            statuses: ["unconscious"],
            name: "WFRP4E.ConditionName.Unconscious",
            description : "WFRP4E.Conditions.Unconscious",
            system : {
                condition : {
                    value : null,
                    numbered: false
                },
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/grappling.png",
            id: "grappling",
            statuses: ["grappling"],
            name: "WFRP4E.ConditionName.Grappling",
            description : "WFRP4E.Conditions.Grappling",
            system : {
                condition : {
                    value : null,
                    numbered: false
                },
            }
        },
        {
            img: "systems/wfrp4e/icons/conditions/engaged.png",
            id: "engaged",
            statuses: ["engaged"],
            name: "WFRP4E.ConditionName.Engaged",
            description : "WFRP4E.Conditions.Engaged",
            system: {
                condition : {
                    value : null,
                    numbered: false
                },
                scriptData: [
                    {
                        trigger: "dialog",
                        label: "@effect.name",
                        script: `args.abort = true
                        ui.notifications.error(game.i18n.localize("EFFECT.ShooterEngagedError"))`,
                        options: {
                                hideScript: "return !args.weapon || args.weapon.isMelee || args.weapon.properties.qualities.pistol",
                                activateScript: "return args.weapon.isRanged && !args.weapon.properties.qualities.pistol"
                        }
                    }
                ]
            }
        },
        {
            img: "systems/wfrp4e/icons/defeated.png",
            id: "dead",
            statuses: ["dead"],
            name: "WFRP4E.ConditionName.Dead",
            description : "WFRP4E.Conditions.Dead",
            system : {
                condition : {
                    value : null,
                    numbered: false
                },
            }
        }
    ];


    foundry.utils.mergeObject(this.propertyEffects, {

        // Qualities
        accurate: {
            name : game.i18n.localize("PROPERTY.Accurate"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item"
                },
                scriptData : [{
                    label : "Accurate",
                    trigger : "dialog",
                    script : "args.fields.modifier += 10;",
                    options : {
                        hideScript : "",
                        activateScript : "return true"
                    }
                }
            ],
            }
        },
        blackpowder: {
            img : "systems/wfrp4e/icons/blank.png",
            name: game.i18n.localize("EFFECT.BlackpowderShock"),
            system: {
                transferData : {
                    type : "target",
                    documentType : "Actor"
                },
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "immediate",
                        script: `
                            test = await this.actor.setupSkill(game.i18n.localize("NAME.Cool"), {appendTitle : " - " + this.effect.name, skipTargets: true, fields : {difficulty : "average"}});
                            await test.roll();
                            if (test.failed)
                            {
                                this.actor.addCondition("broken");
                            }
                            return false;
                        `
                    }
                ]
            }
        },
        engineering: {
            img : "systems/wfrp4e/icons/blank.png",
            name: game.i18n.localize("EFFECT.BlackpowderShock"),
            system: {
                transferData : {
                    type : "target",
                    documentType : "Actor"
                },
                scriptData: [
                    {
                        label: "@effect.name",
                        trigger: "immediate",
                        script: `
                            test = await this.actor.setupSkill(game.i18n.localize("NAME.Cool"), {appendTitle : " - " + this.effect.name, skipTargets: true, fields : {difficulty : "average"}});
                            await test.roll();
                            if (test.failed)
                            {
                                this.actor.addCondition("broken");
                            }
                            return false;
                        `
                    }
                ]
            }
        },
        blast: {
            name : game.i18n.localize("PROPERTY.Blast"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item"
                },
                scriptData : [{
                    label : "Blast",
                    trigger : "rollWeaponTest",
                    script : "if (args.test.succeeded) args.test.result.other.push(`<a class='content-link' data-action='placeTemplate' data-type='radius'><i class='fas fa-ruler-combined'></i>${this.item.properties.qualities.blast.value} yard Blast</a>`)",
                }]
            }
        },
        damaging: {
            name : game.i18n.localize("PROPERTY.Damaging"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        defensive: {
            name : game.i18n.localize("PROPERTY.Defensive"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Actor",
                    equipTransfer: true
                },
                scriptData : [{
                    label : "Defensive",
                    trigger : "dialog",
                    script : "args.fields.slBonus++;",
                    options : {
                        activateScript : "return args.actor.attacker",
                        hideScript : "return !args.actor.attacker"
                    }
                }]
            }
        },
        distract: {
            name : game.i18n.localize("PROPERTY.Distract"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        entangle: {
            name : game.i18n.localize("PROPERTY.Entangle"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
                scriptData : [{
                    label : "Entangle",
                    trigger : "applyDamage",
                    script : "args.actor.addCondition('entangled')"
                }]
            }

        },
        fast: {
            name : game.i18n.localize("PROPERTY.Fast"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        hack: {
            name : game.i18n.localize("PROPERTY.Hack"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        impact: {
            name : game.i18n.localize("PROPERTY.Impact"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        impale: {
            name : game.i18n.localize("PROPERTY.Impale"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        magical: {
            name : game.i18n.localize("PROPERTY.Magical"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        penetrating: {
            name : game.i18n.localize("PROPERTY.Penetrating"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        pistol: {
            name : game.i18n.localize("PROPERTY.Pistol"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        precise: {
            name : game.i18n.localize("PROPERTY.Precise"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item"
                },
                scriptData : [{
                    label : "Precise",
                    trigger : "dialog",
                    script : "args.fields.successBonus += 1;",
                    options : {
                        hideScript : "",
                        activateScript : "return true"
                    }
                }]
            }
        },
        pummel: {
            name : game.i18n.localize("PROPERTY.Pummel"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        repeater: {
            name : game.i18n.localize("PROPERTY.Repeater"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        shield: {
            name : game.i18n.localize("PROPERTY.Shield"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        trapblade: {
            name : game.i18n.localize("PROPERTY.TrapBlade"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        unbreakable: {
            name : game.i18n.localize("PROPERTY.Unbreakable"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        wrap: {
            name : game.i18n.localize("PROPERTY.Wrap"),
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },




        // Flaws
        dangerous: {
            name : game.i18n.localize("PROPERTY.Dangerous"), 
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        imprecise: {
            name : game.i18n.localize("PROPERTY.Imprecise"), 
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item"
                },
                scriptData : [{
                    label : "Imprecise",
                    trigger : "dialog",
                    script : "args.fields.slBonus -= 1;",
                    options : {
                        hideScript : "",
                        activateScript : "return true"
                    }
                }]
            }
        },
        reload: {
            name : game.i18n.localize("PROPERTY.Reload"), 
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        slow: {
            name : game.i18n.localize("PROPERTY.Slow"), 
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        tiring: {
            name : game.i18n.localize("PROPERTY.Tiring"), 
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
        undamaging: {
            name : game.i18n.localize("PROPERTY.Undamaging"), 
            img : "systems/wfrp4e/icons/blank.png",
            system : {
                transferData : {
                    documentType : "Item",
                },
            }
        },
    });

};


WFRP4E.effectTextStyle = CONFIG.canvasTextStyle.clone();
WFRP4E.effectTextStyle.fontSize = "30";
WFRP4E.effectTextStyle.fontFamily="CaslonAntique";

WFRP4E.rollModes = CONFIG.Dice.rollModes;

WFRP4E.transferDocumentTypes = defaultWarhammerConfig.transferDocumentTypes;

WFRP4E.badgeInfo = defaultWarhammerConfig.badgeInfo;

WFRP4E.badgeInfo.img = "systems/wfrp4e/ui/badge.webp";
WFRP4E.badgeInfo.notes = "https://github.com/moo-man/WFRP4e-FoundryVTT/releases";
WFRP4E.badgeInfo.issues = "https://github.com/moo-man/WFRP4e-FoundryVTT/issues";
WFRP4E.badgeInfo.wiki = "https://moo-man.github.io/WFRP4e-FoundryVTT/pages/home.html";

WFRP4E.bugReporterConfig = {
    repoEndpoint: "https://api.github.com/repos/moo-man/WFRP4e-FoundryVTT",
    troubleshooting : "https://moo-man.github.io/WFRP4e-FoundryVTT/pages/troubleshooting.html",
    successMessage : "The longbeards hear you, thank you for your submission into the Dammaz Kron, these wrongs must be righted! If you wish to monitor or follow up with additional details like screenshots, you can find your issue here: @URL",
};

// To migrate
// "invoke => manual"
// "oneTime" => "immediate"
// "addItems" => "immediate"
// "dialogChoice" => ???
// "prefillDialog" => "dialog"
// "targetPrefillDialog" => "dialog" with targeter option true
WFRP4E.scriptTriggers = {
    "manual" : "Manually Invoked",
    "immediate" : "Immediate",
    "dialog" : "Dialog",
    "addItems" : "Add Items",
    "preUpdate" : "Pre Update",
    "update" : "On Update",
    "equipToggle" : "Equip Toggle",
    "prePrepareData" : "Pre-Prepare Data",
    "prePrepareItems" : "Pre-Prepare Actor Items",
    "prepareData" : "Prepare Data",
    "prepareOwned" : "Prepare Owned Data (For Items)",
    "computeCharacteristics" : "Compute Characteristics",
    "computeEncumbrance" : "Compute Encumbrance",
    "preWoundCalc" : "Pre-Wound Calculation",
    "woundCalc" : "Wound Calculation",
    "calculateSize" : "Size Calculation",
    "preAPCalc" : "Pre-Armour Calculation",
    "APCalc" : "Armour Calculation",
    "preApplyDamage" : "Pre-Apply Damage",
    "applyDamage" : "Apply Damage",
    "preTakeDamage" : "Pre-Take Damage",
    "takeDamage" : "Take Damage",
    "computeTakeDamageModifiers" : "Compute Take Damage Modifiers",
    "computeApplyDamageModifiers" : "Compute Apply Damage Modifiers",
    "preApplyCondition" : "Pre-Apply Condition",
    "applyCondition" : "Apply Condition",
    "prePrepareItem" : "Pre-Prepare Item",
    "prepareItem" : "Prepare Item",
    "preRollTest" : "Pre-Roll Test",
    "preRollWeaponTest" : "Pre-Roll Weapon Test",
    "preRollCastTest" : "Pre-Roll Casting Test",
    "preChannellingTest" : "Pre-Roll Channelling Test",
    "preRollPrayerTest" : "Pre-Roll Prayer Test",
    "preRollTraitTest" : "Pre-Roll Trait Test",
    "rollTest" : "Roll Test",
    "rollIncomeTest" : "Roll Income Test",
    "rollWeaponTest" : "Roll Weapon Test",
    "rollCastTest" : "Roll Casting Test",
    "rollChannellingTest" : "Roll Channelling Test",
    "rollPrayerTest" : "Roll Prayer Test",
    "rollTraitTest" : "Roll Trait Test",
    "preOpposedAttacker" : "Pre-Opposed Attacker",
    "preOpposedDefender" : "Pre-Opposed Defender",
    "opposedAttacker" : "Opposed Attacker",
    "opposedDefender" : "Opposed Defender",
    "calculateOpposedDamage" : "Calculate Opposed Damage",
    "targetPrefillDialog" : "Prefill Targeter's Dialog",
    "getInitiativeFormula" : "Get Initiative",
    "createToken" : "Create Token",
    "deleteEffect" : "Effect Deleted",
    "startCombat"  : "WH.Trigger.StartCombat",
    "startRound" : "WH.Trigger.StartRound",
    "startTurn" : "Start Turn",
    "updateCombat"  : "WH.Trigger.UpdateCombat",
    "endTurn" : "End Turn",
    "endRound" : "End Round",
    "endCombat" : "End Combat",

};

WFRP4E.syncTriggers = [
    "prePrepareData",
    "prePrepareItems",
    "prepareData",
    "preWoundCalc",
    "woundCalc",
    "calculateSize",
    "preAPCalc",
    "APCalc",
    "prePrepareItem",
    "prepareItem",
    "getInitiativeFormula"
];

WFRP4E.triggerMapping = {
    "update" : "updateDocument",
    "addItems" : "onCreate",
    "preUpdate" : "preUpdateDocument"
};

WFRP4E.placeholderItemData = {
    type : "trapping",
    img : "systems/wfrp4e/icons/blank.png"
};

WFRP4E.getZoneTraitEffects = (region) => 
{
    return [];
};

class WFRP4eActiveEffectConfig extends WarhammerActiveEffectConfig 
{
    systemTemplate=""


    hiddenProperties(){
        let hidden = super.hiddenProperties();
        hidden.equipTransfer = !this.document.item?.system?.isEquippable;
        return hidden;
    }
}

let fields$w = foundry.data.fields;

 class BaseItemModel extends BaseWarhammerItemModel 
 {

     static defineSchema() 
     {
        return {
            description : new fields$w.SchemaField({
                value: new fields$w.HTMLField()
            }),
            gmdescription : new fields$w.SchemaField({
                value: new fields$w.HTMLField()
            }),
        } 
     }

     get tags()
     {
        return new Set().add(this.parent.type);
     }

     /** @override */
     static get compendiumBrowserFilters() {
       return new Map([
         ["description", {
           label: "Description",
           type: "text",
           config: {
             keyPath: "system.description.value",
           }
         }]
       ]);
     }

     static _deriveSource(uuid) {
       const source = super._deriveSource(uuid);

       if (game.wfrp4e.config.premiumModules[source.slug])
         source.value = game.wfrp4e.config.premiumModules[source.slug];

       return source;
     }

     async _preCreate(data, options, user)
     {
        await super._preCreate(data, options, user);

        if (!data.img || data.img == "icons/svg/item-bag.svg")
        {
            this.parent.updateSource({img : "systems/wfrp4e/icons/blank.png"});
        }
     }

    get skillToUse() {
        return this.getSkillToUse(this.parent.actor)
    }

    get isMagical() {
        return false;
    }

  /**
   * Sometimes a weapon isn't being used by its owning actor (namely: vehicles)
   * So the simple getter BaseItemModel#skillToUse isn't sufficient, we need to provide
   * an actor to use their skills instead
   * 
   * @abstract
   * @param {Object} actor Actor whose skills are being used
   */
    getSkillToUse(actor)
    {
        
    }


    async expandData(htmlOptions) {
        htmlOptions.async = true;
        const data = this.parent.toObject().system;
        data.properties = [];
        data.other = [];
        data.description.value = data.description.value || "";
        data.description.value = await foundry.applications.ux.TextEditor.implementation.enrichHTML(data.description.value, htmlOptions);
        data.manualScripts = this.parent.manualScripts;
        data.independentEffects = this.parent.testIndependentEffects;
        return data;
      }

    /**
     * @abstract
     */
    chatData()
    {
        
    } 
 }

let fields$v = foundry.data.fields;

class PhysicalItemModel extends BaseItemModel
{
    static metadata = Object.freeze(foundry.utils.mergeObject(super.metadata, {
        isPhysical: true
    }, {inplace: false}));

    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.quantity = new fields$v.SchemaField({
            value: new fields$v.NumberField({initial: 1, min : 0})
        });
        schema.encumbrance = new fields$v.SchemaField({
            value: new fields$v.NumberField()
        });
        schema.price = new fields$v.SchemaField({
            gc: new fields$v.NumberField(),
            ss: new fields$v.NumberField(),
            bp: new fields$v.NumberField()
        });
        schema.availability = new fields$v.SchemaField({
            value: new fields$v.StringField()
        });
        schema.location = new fields$v.SchemaField({
            value: new fields$v.StringField()
        });
        schema.damageToItem = new fields$v.SchemaField({
            value: new fields$v.NumberField({min: 0}),
            shield: new fields$v.NumberField({min: 0}),
        });
        return schema;
    }

    static sumPriceValue(price) {
        let value = 0;

        value += Number(price?.gc) * 240 || 0;
        value += Number(price?.ss) * 12 || 0;
        value += Number(price?.bp) || 0;

        return value;
    }

    /** @override */
    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
            ["quantity", {
                label: "Quantity",
                type: "range",
                config: {
                    keyPath: "system.quantity.value"
                }
            }],
            ["encumbrance", {
                label: "Encumbrance",
                type: "range",
                config: {
                    keyPath: "system.encumbrance.value"
                }
            }],
            ["price", {
                label: "Price",
                type: "range",
                config: {
                    text: true,
                    valueGetter: (data) => PhysicalItemModel.sumPriceValue(data.system.price),
                    keyPath: "system.price",
                    mutator: ({min, max}) => {
                        min = game.wfrp4e.market.parseMoneyTransactionString(min || "");
                        max = game.wfrp4e.market.parseMoneyTransactionString(max || "");

                        return {
                            min: min ? PhysicalItemModel.sumPriceValue(min) : undefined,
                            max: max ? PhysicalItemModel.sumPriceValue(max) : undefined,
                        };
                    }
                }
            }],
            ["availability", {
                label: "Availability",
                type: "set",
                config: {
                    keyPath: "system.availability.value",
                    choices: game.wfrp4e.config.availability
                }
            }]
        ]);
    }

        /**
     * Used to identify an Item as one being a child of PhysicalItemModel
     *
     * @final
     * @returns {boolean}
     */
        get isPhysical() {
            return true;
        }

        get tags() 
        {
            return super.tags.add("physical");
        }
    

    async _preCreate(data, options, user)
    {
       await super._preCreate(data, options, user);

       // Previously this checked if item was still owned, not sure if that's necessary 
       // It seems that every case where a new item is created, it should clear the location
       this.updateSource({"location.value" :  ""});
    }

    computeBase() 
    {
        this.encumbrance.total = 0;
        super.computeBase();

        this.encumbrance.total = this.computeEncumbrance();
    }

    computeEncumbrance() 
    {
        let enc = 0;
        if (this.encumbrance && this.quantity) 
        {
            enc = (this.encumbrance.value * this.quantity.value);
            if (this.encumbrance.value % 1 != 0)
            {
                enc = enc.toFixed(2);
            }
        }
        return enc
    }

/**
 * Helper method to apply damage to an item
 * 
 * @param {number} value Damage the item by this amount
 */
    damageItem(value = 1) 
    {
        // Can ignore .shield because that is exclusive to weapons
        let currentDamage = this.damageToItem.value + value;

        // If maxDamageTaken is undefined, there is no max
        let max = this.maxDamageTaken();
        if (max && currentDamage > max) 
        {
            currentDamage = max;
        }

        return this.parent.update({ [`system.damageToItem.value`]: currentDamage})
    }


    /**
     * Defines the amount of damage this item can take
     * @abstract
     */
    maxDamageTaken()
    {

    }

    /**
     * Reduces the quantity of this Item by specified amount.
     *
     * @param {number} amount by how much should the quantity be reduced?
     *
     * @returns {Promise<ItemWFRP4e>}
     */
    async reduceQuantity(amount = 1) {
        return await this.parent.update({"system.quantity.value": this.quantity.value - amount});
    }

    async split(amount) 
    {
        let actor = this.parent.actor;
        if (!actor) 
        {
            return;
        }

        let newItem = this.parent.toObject();
        delete newItem._id;
        let itemUpdate = this.toObject();

        let oldQuantity = this.quantity.value;

        if (this.parent.type == "cargo") 
        {
            oldQuantity = this.encumbrance.value;
        }

        if (amount >= oldQuantity) 
        {
            return ui.notifications.notify(game.i18n.localize("Invalid Quantity"))
        }

        if (this.parent.type == "cargo") 
        {
            newItem.system.encumbrance.value = amount;
            itemUpdate.encumbrance.value -= amount;
        }
        else 
        {
            newItem.system.quantity.value = amount;
            itemUpdate.quantity.value -= amount;
        }
        await actor.update({ items: [newItem, { _id: this.parent.id, system: itemUpdate }] });
    }

    static migrateData(data)
    {
        if (data.location?.value === '0')
        {
            data.location.value = '';
        }
    }
}

class Migration {

  static async migrateWorld() {
    ui.notifications.info(`Applying WFRP4e System Migration for version ${game.system.version}. Please be patient and do not close your game or shut down your server.`, { permanent: true });


      let updates = [];
      // Migrate Journals
      for (let i of game.journal.contents) {
        try {
          let updateData = Migration.migrateJournalData(i);
          if (!foundry.utils.isEmpty(updateData) || updateData.pages.length > 0) {
            updates.push(updateData);
            console.log(`Migrating Journal document ${i.name}`);
          }
        } catch (err) {
          err.message = `Failed wfrp4e system migration for Journal ${i.name}: ${err.message}`;
          console.error(err);
        }
      }
      await JournalEntry.updateDocuments(updates);

      updates = [];
      // Migrate Tables
      for (let i of game.tables.contents) {
        try {
          let updateData = Migration.migrateTableData(i);
          if (!foundry.utils.isEmpty(updateData) || updateData.results.length > 0) {
            updates.push(updateData);
            console.log(`Migrating Table document ${i.name}`);
          }
        } catch (err) {
          err.message = `Failed wfrp4e system migration for RollTable ${i.name}: ${err.message}`;
          console.error(err);
        }
      }
      await RollTable.updateDocuments(updates);



    // Migrate World Items
    for (let i of game.items.contents) {
      try {
        let updateData = Migration.migrateItemData(i);
        if (!foundry.utils.isEmpty(updateData)) {
          console.log(`Migrating Item document ${i.name}`);
          await i.update(updateData, { enforceTypes: false });
        }
        let loreIds = this._loreEffectIds(i);
        if (loreIds.length)
        {
          await i.deleteEmbeddedDocuments("ActiveEffect", loreIds);
        }
      } catch (err) {
        err.message = `Failed wfrp4e system migration for Item ${i.name}: ${err.message}`;
        console.error(err);
      }
    }

    for (let p of game.packs) {
      if (p.metadata.type == "Item" && p.metadata.package == "world")
        await Migration.migrateCompendium(p);
    }
    for (let p of game.packs) {
      if (p.metadata.type == "Actor" && p.metadata.package == "world")
        await Migration.migrateCompendium(p);
    }
    for (let p of game.packs) {
      if (p.metadata.type == "Scene" && p.metadata.package == "world")
        await Migration.migrateCompendium(p);
    }

    // Migrate World Actors
    for (let a of game.actors.contents) {
      try {
        let updateData = Migration.migrateActorData(a);
        if (!foundry.utils.isEmpty(updateData)) {
          console.log(`Migrating Actor document ${a.name}`);
          await a.update(updateData, { enforceTypes: false });
        }
        let loreIds = this._loreEffectIds(a);
        if (loreIds.length)
        {
          await a.deleteEmbeddedDocuments("ActiveEffect", loreIds);
        }
        await this.migrateActorEffects(a, true);
      } catch (err) {
        err.message = `Failed wfrp4e system migration for Actor ${a.name}: ${err.message}`;
        console.error(err);
      }
    }

    // // Migrate Actor Override Tokens
    // for (let s of game.scenes.contents) {
    //   try {
    //     let updateData = Migration.migrateSceneData(s);
    //     if (!foundry.utils.isEmpty(updateData)) {
    //       console.log(`Migrating Scene document ${s.name}`);
    //       await s.update(updateData, { enforceTypes: false });
    //       // If we do not do this, then synthetic token actors remain in cache
    //       // with the un-updated actorData.
    //       s.tokens.contents.forEach(t => t._actor = null);
    //     }
    //   } catch (err) {
    //     err.message = `Failed wfrp4e system migration for Scene ${s.name}: ${err.message}`;
    //     console.error(err);
    //   }
    // }

    // // Set the migration as complete
    ui.notifications.info(`wfrp4e System Migration to version ${game.system.version} completed!`, { permanent: true });
  };

  /* -------------------------------------------- */

  /**
   * Apply migration rules to all Entities within a single Compendium pack
   * @param pack
   * @return {Promise}
   */
  static async migrateCompendium(pack) {
    const document = pack.metadata.type;
    if (!["Actor", "Item", "Scene"].includes(document)) return;

    // Unlock the pack for editing
    const wasLocked = pack.locked;
    await pack.configure({ locked: false });

    // Begin by requesting server-side data model migration and get the migrated content
    await pack.migrate();
    const documents = await pack.getDocuments();

    // Iterate over compendium entries - applying fine-tuned migration functions
    for (let doc of documents) {
      let updateData = {};
      try {
        switch (document) {
          case "Actor":
            updateData = Migration.migrateActorData(doc);
            await this.migrateActorEffects(doc, true);
            break;
          case "Item":
            updateData = Migration.migrateItemData(doc);
            break;
          case "Scene":
            updateData = Migration.migrateSceneData(doc);
            break;
        }

        // Save the entry, if data was changed
        if (foundry.utils.isEmpty(updateData)) continue;
        await doc.update(updateData);
        console.log(`Migrated ${document} document ${doc.name} in Compendium ${pack.collection}`);
      }

      // Handle migration failures
      catch (err) {
        err.message = `Failed wfrp4e system migration for document ${doc.name} in pack ${pack.collection}: ${err.message}`;
        console.error(err);
      }
    }

    // Apply the original locked status for the pack
    await pack.configure({ locked: wasLocked });
    console.log(`Migrated all ${document} entities from Compendium ${pack.collection}`);
  };

  /* -------------------------------------------- */
  /*  Entity Type Migration Helpers               */
  /* -------------------------------------------- */

  /**
   * Migrate a single Actor entity to incorporate latest data model changes
   * Return an Object of updateData to be applied
   * @param {object} actor    The actor data object to update
   * @return {Object}         The updateData to apply
   */
  static migrateActorData(actor) {
    let updateData = {};

    // Migrate Owned Items
    if (actor.items) {
      const items = actor.items.reduce((arr, i) => {
        // Migrate the Owned Item
        let itemUpdate = Migration.migrateItemData(i);

        // Update the Owned Item
        if (!foundry.utils.isEmpty(itemUpdate)) {
          itemUpdate._id = i.id;
          arr.push(foundry.utils.expandObject(itemUpdate));
        }

        return arr;
      }, []);
      if (items.length > 0) updateData.items = items;
    }

    let html = this._migrateV10Links(actor.system.details.biography?.value);
    if (html != actor.system.details.biography?.value)
    {
      updateData["system.details.biography.value"] = html;
    }

    html = this._migrateV10Links(actor.system.details.gmnotes?.value);
    if (html != actor.system.details.gmnotes?.value)
    {
      updateData["system.details.gmnotes.value"] = html;
    }
    
    html = this._migrateV10Links(actor.system.details.description?.value);
    if (html != actor.system.details.description?.value)
    {
      updateData["system.details.description.value"] = html;
    }

    html = this._migrateV10Links(actor.system.details.gmdescription?.value);
    if (html != actor.system.details.gmdescription?.value)
    {
      updateData["system.details.gmdescription.value"] = html;
    }


    if (actor.type == "vehicle")
    {
      if (actor.system.roles?.length)
      {
        let roleItems = [];
        for(let role of actor.system.roles)
          {
            roleItems.push({name : role.name, img : "systems/wfrp4e/icons/blank.png", type : "vehicleRole", system : {
              test : role.test
            }});
      }
      if (roleItems.length)
        {
          updateData.items = updateData.items ? updateData.items.concat(roleItems) : roleItems;
          updateData["system.roles"] = [];
        }
      }
    }

    return updateData;
  };

  static async migrateActorEffects(actor, update=false)
  {
    let itemsUpdate = [], deleteActorEffects = [];

    for (let effect of actor.effects)
    {
      let origin = effect.origin?.split(".");
      let item = actor.items.get(origin?.[origin.length-1]);
      if (origin && item)
      {
          let existingUpdate = itemsUpdate.find(i => i._id == item.id);
          let itemEffect = item.effects.getName(effect.name)?.toObject() || {};
          let oldId = itemEffect._id;
          let oldChanges = itemEffect.changes;
          foundry.utils.mergeObject(itemEffect, effect.toObject()); 
          itemEffect._id = oldId; // Preserve item id so effect isn't duplicated on the item
          
          if (itemEffect.changes.length == 0)
          {
            itemEffect.changes = oldChanges;
          }
          
          if (existingUpdate)
          {
            existingUpdate.effects.push(itemEffect);
          }
          else 
          {
            itemsUpdate.push({_id : item.id, effects : [itemEffect]});
          }
          
          deleteActorEffects.push(effect.id);
      }
      else if (effect.changes.length == 0 && (effect.scripts.length == 0 || effect.scripts.every(c => !c.trigger)))
      {
        deleteActorEffects.push(effect.id);
        console.log(`Deleting empty effect ${effect.name}`);
      }
    }
    if (update)
    {
      if (itemsUpdate.length)
      {
        await actor.update({items : itemsUpdate});
        console.log(itemsUpdate);
      }
      if (deleteActorEffects.length)
      {
        await actor.deleteEmbeddedDocuments("ActiveEffect", deleteActorEffects, {skipDeletingItems : true});
        console.log(deleteActorEffects);
      }
    }


    let effectModels = [];
    for (let effect of actor.effects)
    {
      effectModels.push(this.migrateEffectData(effect));
    }
    effectModels = effectModels.filter(e => !foundry.utils.isEmpty(e));

    await actor.updateEmbeddedDocuments("ActiveEffect", effectModels);
  }

  static migrateJournalData(journal)
  {
    let updateData = {_id : journal.id, pages : []};

    for(let page of journal.pages)
    {
      let html = page.text.content;
      console.log(`Checking Journal Page HTML ${journal.name}.${page.name}`);
      let newHTML = this._migrateV10Links(html);

      if (html != newHTML)
      {
        updateData.pages.push({_id : page.id, "text.content" : newHTML});
      }
    }
    return updateData;
  }

  static migrateTableData(table)
  {
    let updateData = {_id : table.id, results : []};

    for(let result of table.results)
    {
      if (result.type == 0)
      {
        let html = result.text;
        let newHTML = this._migrateV10Links(html);

        if (html != newHTML)
        {
          updateData.results.push({_id : result.id, text : newHTML});
        }
      }

      else if (result.type == 2 && this.v10Conversions[result.documentCollection])
      {
        updateData.results.push({_id : result.id, documentCollection : this.v10Conversions[result.documentCollection]});
      }
    }
    return updateData;
  }

  /**
 * Migrate a single Actor entity to incorporate latest data model changes
 * Return an Object of updateData to be applied
 * @param {object} actor    The actor data object to update
 * @return {Object}         The updateData to apply
 */
  static async migrateOwnedItemEffects(actor) {

    let itemsToRemove = [];

    let itemsToAdd = [];

    for (let item of actor.items) {
      if (item.getFlag("core", "sourceId")) {
        let source = item.getFlag("core", "sourceId");
        let newItem = item.toObject();
        let sourceItem = await fromUuid(source);
        if (sourceItem)
          sourceItem = sourceItem.toObject();

        if (sourceItem.name == item.name) {
          newItem.effects = sourceItem.effects;
          itemsToRemove.push(item.id);
          itemsToAdd.push(newItem);
        }
      }
    }

    await actor.deleteEmbeddedDocuments("Item", itemsToRemove);
    await actor.createEmbeddedDocuments("Item", itemsToAdd, { keepId: true });

    console.log(`Replaced Items ${itemsToAdd.map(i => i.name).join(", ")} for actor ${actor.name}`);
  };


  /* -------------------------------------------- */


  /**
   * Scrub an Actor's system data, removing all keys which are not explicitly defined in the system template
   * @param {Object} actorData    The data object for an Actor
   * @return {Object}             The scrubbed Actor data
   */
  static cleanActorData(actorData) {

    // Scrub system data
    const model = game.model.Actor[actorData.type];
    actorData.data = foundry.utils.filterObject(actorData.data, model);

    // Scrub system flags
    const allowedFlags = CONFIG.wfrp4e.allowedActorFlags.reduce((obj, f) => {
      obj[f] = null;
      return obj;
    }, {});
    if (actorData.flags.wfrp4e) {
      actorData.flags.wfrp4e = foundry.utils.filterObject(actorData.flags.wfrp4e, allowedFlags);
    }

    // Return the scrubbed data
    return actorData;
  }


/* -------------------------------------------- */

  /**
   * Migrate a single Item entity to incorporate latest data model changes
   *
   * @param {object} item  Item data to migrate
   * @return {object}      The updateData to apply
   */
   static migrateArmourData(item) {
    let updateData = {};

      foundry.utils.mergeObject(updateData, this.migrateProperties(item));

    return updateData;
  };

     static migrateWeaponData(item) {
      let updateData = {};

      foundry.utils.mergeObject(updateData, this.migrateProperties(item));
      return updateData;
    };

    static migrateAmmoData(item) {
      let updateData = {};

      foundry.utils.mergeObject(updateData, this.migrateProperties(item));
      return updateData;
    };

    static migrateProperties(item)
    {
      let updateData = {};
      if (typeof item.system.qualities.value == "string")
      {
        let allQualities = WFRP_Utility.qualityList();
        updateData["system.qualities.value"] = item.system.qualities.value.split(",").map(i => i.trim()).map(i => {return {name : warhammer.utility.findKey(i.split(" ")[0], allQualities), value : Number(i.split(" ")[1]) }}).filter(i => i.name);
      }
      if (typeof item.system.flaws.value == "string")
      {
        let allFlaws = WFRP_Utility.flawList();
        updateData["system.flaws.value"] = item.system.flaws.value.split(",").map(i => i.trim()).map(i => {return {name : warhammer.utility.findKey(i.split(" ")[0], allFlaws), value : Number(i.split(" ")[1])}}).filter(i => i.name);
      }
      return updateData;
    }


  /**
   * Migrate a single Item entity to incorporate latest data model changes
   *
   * @param {object} item  Item data to migrate
   * @return {object}      The updateData to apply
   */
  static migrateItemData(item) {
    let updateData = {};

    if (item.type == "armour")
    {
      updateData = Migration.migrateArmourData(item);
    }

    if (item.type == "weapon")
    {
      updateData = Migration.migrateWeaponData(item);
    }

    if (item.type == "ammunition")
    {
      updateData = Migration.migrateAmmoData(item);
    }
    
    if (item.type == "spell")
    {
      if (typeof item.system.lore.effect == "string")
      {
        updateData["system.lore.effectString"] = item.system.lore.effect;
      }
    }

    if (item.type == "trait" && !item.system.disabled)
    {
      updateData["system.disabled"] = item.actor?.system?.excludedTraits?.includes(item.id) || false;
    }

    
    let newDescription = this._migrateV10Links(item.system.description.value);
    let newGMDescription = this._migrateV10Links(item.system.gmdescription.value);

    if (item.system.description.value != newDescription)
    {
      updateData["system.description.value"] = newDescription;
    }

    if (item.system.gmdescription.value != newGMDescription)
    {
      updateData["system.gmdescription.value"] = newGMDescription;
    }

    // Migrate Effects
    if (item.effects) {
      const effects = item.effects.reduce((arr, e) => {

        let effectUpdate = Migration.migrateEffectData(e);

        // Update the Owned Item
        if (!foundry.utils.isEmpty(effectUpdate)) {
          effectUpdate._id = e.id;
          arr.push(foundry.utils.expandObject(effectUpdate));
        }

        return arr;
      }, []);
      if (effects.length > 0) updateData.effects = effects;
    }

    if (!foundry.utils.isEmpty(updateData))
      // console.log("Migration data for " + item.name, updateData)
    return updateData;
  };

  static removeLoreEffects(docData)
  {
    let loreEffects = (docData.effects || []).filter(i => i.flags?.wfrp4e?.lore);
    if (loreEffects.length)
    {
      warhammer.utility.log("Removing lore effects for " + docData.name, true, loreEffects);
      // return document.deleteEmbeddedDocuments("ActiveEffect", loreEffects.map(i => i.id));
    }
    return docData.effects?.filter(e => !loreEffects.find(le => le._id == e._id)) || [];
  }

  /* -------------------------------------------- */

  /**
   * Migrate a single Effect entity to incorporate latest data model changes
   *
   * @param {object} effect Effect data to migrate
   * @return {object}      The updateData to apply
   */
  static migrateEffectData(effect) {
    let updateData = Migration._migrateEffectFlags(effect);
    if (!foundry.utils.isEmpty(updateData))
    {
      return updateData;
    }
  };

  /* -------------------------------------------- */

  /**
   * Migrate a single Scene entity to incorporate changes to the data model of it's actor data overrides
   * Return an Object of updateData to be applied
   * @param {Object} scene  The Scene data to Update
   * @return {Object}       The updateData to apply
   */
  static migrateSceneData(scene) {
    const tokens = scene.tokens.map(token => {
      const t = token.toJSON();
      if (!t.actorId || t.actorLink) {
        t.actorData = {};
      }
      else if (!game.actors.has(t.actorId)) {
        t.actorId = null;
        t.actorData = {};
      }
      else if (!t.actorLink) {
        const actorData = foundry.utils.duplicate(t.actorData);
        actorData.type = token.actor?.type;
        const update = Migration.migrateActorData(actorData);
        ['items', 'effects'].forEach(embeddedName => {
          if (!update[embeddedName]?.length) return;
          const updates = new Map(update[embeddedName].map(u => [u._id, u]));
          t.actorData[embeddedName].forEach(original => {
            const update = updates.get(original._id);
            if (update) foundry.utils.mergeObject(original, update);
          });
          delete update[embeddedName];
        });

        foundry.utils.mergeObject(t.actorData, update);
      }
      return t;
    });
    return { tokens };
  };

  /* -------------------------------------------- */
  /*  Low level migration utilities
  /* -------------------------------------------- */

  
static _migrateEffectFlags(effect)
{
    let applicationData = foundry.utils.getProperty(effect, "flags.wfrp4e.applicationData") || {};
    let scriptData = foundry.utils.getProperty(effect, "flags.wfrp4e.scriptData") || [];
    let conditionValue = foundry.utils.getProperty(effect, "flags.wfrp4e.value");
    let update = {};
    if (Number.isNumeric(conditionValue))
    {
      foundry.utils.setProperty(update, "system.condition.value", conditionValue);
    }
    if (isEmpty(applicationData) && scriptData.length == 0)
    {
      return update;
    }

    let selfOnly = false;
    if (effect.item &&
    effect.item.range && 
    effect.item.range.value.toLowerCase() == game.i18n.localize("You").toLowerCase() && 
    effect.item.target && 
    effect.item.target.value.toLowerCase() == game.i18n.localize("You").toLowerCase())
    {
      selfOnly = true;
    }

    let system = {
        transferData: {
            type : applicationData.type,
            documentType : applicationData.documentType,
            avoidTest : applicationData.avoidTest,
            testIndependent : applicationData.testIndependent,
            preApplyScript : applicationData.preApplyScript,
            equipTransfer : applicationData.equipTransfer,
            enableConditionScript : applicationData.enableConditionScript,
            filter : applicationData.filter,
            prompt : applicationData.prompt,
            selfOnly,
            area: {
              radius : applicationData.radius,
              templateData : applicationData.templateData,
  
              duration : applicationData.areaType,
              keep : applicationData.keep,
  
              aura: {
                  render : applicationData.renderAura,
                  transferred : applicationData.targetedAura,
              }
          },
        },
        scriptData: effect.system.scriptData.length ? effect.system.scriptData : scriptData,
        zone: {},
        sourceData: {
            item : effect.flags?.wfrp4e?.sourceItem,
            test : effect.flags?.wfrp4e?.sourceTest,
            area : effect.flags?.wfrp4e?.fromArea,
        }
    };

    system.scriptData.forEach(script => {
      if (typeof script == "string")
      {
        script = {script : script};
      }
      if (!script.options)
      {
        script.options = {};
      }
      script.options = foundry.utils.mergeObject(foundry.utils.mergeObject(script.options, script.options.dialog || {}), script.options.immediate || {});
    });
    return {"flags.wfrp4e.-=applicationData" : null,  "flags.wfrp4e.-=scriptData" : null, system};
}

  static _loreEffectIds(document)
  {
    return document.effects.filter(e => e.flags.wfrp4e?.lore).map(i => i.id)
  }

  static _migrateV10Links(html)
  {
    try 
    {
      if (!html) return html
      
      for(let key in this.v10Conversions)
      {
        let priorHTML = html;
        html = html.replaceAll(key, this.v10Conversions[key]);
        if (html != priorHTML)
        {
          console.log(`Replacing ${key} with ${this.v10Conversions[key]}`);
        }
      }
      return html;
    }
    catch (e)
    {
      console.error("Error replacing links: " + e);
    }
  }

  static v10Conversions = {
    "wfrp4e-core.journal-entries" : "wfrp4e-core.journals",
    "wfrp4e-core.maps" : "wfrp4e-core.scenes",
    "wfrp4e-core.bestiary" : "wfrp4e-core.actors",
    "wfrp4e-core.careers" : "wfrp4e-core.items",
    "wfrp4e-core.criticals" : "wfrp4e-core.items",
    "wfrp4e-core.skills" : "wfrp4e-core.items",
    "wfrp4e-core.talents" : "wfrp4e-core.items",
    "wfrp4e-core.traits" : "wfrp4e-core.items",
    "wfrp4e-core.psychologies" : "wfrp4e-core.items",
    "wfrp4e-core.mutations" : "wfrp4e-core.items",
    "wfrp4e-core.injuries" : "wfrp4e-core.items",
    "wfrp4e-core.diseases" : "wfrp4e-core.items",
    "wfrp4e-core.spells" : "wfrp4e-core.items",
    "wfrp4e-core.prayers" : "wfrp4e-core.items",
    "wfrp4e-core.trappings" : "wfrp4e-core.items",
    "wfrp4e-eis.mutations" : "wfrp4e-eis.items",
    "wfrp4e-eis.spells" : "wfrp4e-eis.items",
  }
}

class TagManager  {
  createTags()
  {
    this.tags = {};
    Array.from(game.packs.keys()).forEach(packKey => {
      this.tags[packKey] = this.findTagsFromIndex(game.packs.get(packKey).index);
    });
  }

  findTagsFromIndex(index)
  {
    let tags = [];
    index.forEach(i => {
      if (!tags.includes(i.type))
        tags.push(i.type);
    });
    return tags
  }

  getPacksWithTag(tags)
  {

    if (!tags || tags.length == 0)
      return Object.keys(this.tags).map(k => game.packs.get(k))

    if (!Array.isArray(tags))
      tags = [tags];
    
    let keys = [];

    for(let key in this.tags)
      if (this.tags[key].some(t => tags.includes(t)))
        keys.push(key);

    return keys.map(k => game.packs.get(k))
  }

}

class ItemProperties extends  HandlebarsApplicationMixin(ApplicationV2)
{
    static DEFAULT_OPTIONS = {
        tag: "form",
        classes: ["warhammer", "standard-form", "item-properties"],
        window: {
            title: "Item Properties",
            resizable : true,
        },
        position : {
            width: 400
        },
        form: {
            submitOnChange: true,
            handler: this._onSubmit
        }
    }
    constructor(document, options) {
        super(options);
        this.document = document;

        if (ItemProperties.hasWeaponProperties(this.document)) {
            this.qualities = foundry.utils.deepClone(game.wfrp4e.config.weaponQualities);
            this.flaws = foundry.utils.deepClone(game.wfrp4e.config.weaponFlaws);
        } else if (ItemProperties.hasArmourProperties(this.document)) {
            this.qualities = foundry.utils.deepClone(game.wfrp4e.config.armorQualities);
            this.flaws = foundry.utils.deepClone(game.wfrp4e.config.armorFlaws);
        } else {
            this.qualities = {};
            this.flaws = {};
        }

        foundry.utils.mergeObject(this.qualities, game.wfrp4e.config.itemQualities);
        foundry.utils.mergeObject(this.flaws, game.wfrp4e.config.itemFlaws);

        if (this.document.type === "trait") {
            ui.notifications.warn(game.i18n.localize("PROPERTIES.TraitWarning"));
        }
    }

    static hasWeaponProperties(object) {
        switch (object.type) {
            case 'weapon':
            case 'ammunition':
                return true;
            case 'trait':
                return object.system.rollable.value;
            default:
                return object.system.isWeapon;
        }
    }

    static hasArmourProperties(object) {
        switch (object.type) {
            case 'armour':
                return true;
            case 'trait':
                return !object.system.rollable.value;
            default:
                return object.system.isArmour;
        }
    }

    async _prepareContext(options) {
        let context = await super._prepareContext(options);

        context.qualities = Object.keys(this.qualities).map(i => {
            return {
                name: this.qualities[i],
                hasValue: game.wfrp4e.config.propertyHasValue[i],
                key: i,
                existing: this.document.originalProperties.qualities[i],
            }
        });

        context.flaws = Object.keys(this.flaws).map(i => {
            return {
                name: this.flaws[i],
                hasValue: game.wfrp4e.config.propertyHasValue[i],
                key: i,
                existing: this.document.originalProperties.flaws[i],
            }
        });

        context.customQualities = this.document.qualities.value.filter(i => i.custom).map(i => `${i.name} ${i.value ? "(" + i.value + ")" : ""}: ${i.description}`).join(" | ");
        context.customFlaws = this.document.flaws.value.filter(i => i.custom).map(i => `${i.name} ${i.value ? "(" + i.value + ")" : ""}: ${i.description}`).join(" | ");
        context.document = this.document;
        return context
    }

    
    /** @override */
    static PARTS = {
        form: {
            template: "systems/wfrp4e/templates/apps/item-properties.hbs",
            scrollable: [""]
        }
    }


    static async _onSubmit(event, form, formData) {

        let qualities = [];
        let flaws = [];
        let groups = [];

        for (let prop in formData.object) {

            if (prop == "custom-quality")
                qualities = qualities.concat(this.parseCustomProperty(formData.object[prop]));
            else if (prop == "custom-flaw")
                flaws = flaws.concat(this.parseCustomProperty(formData.object[prop]));

            if (formData.object[prop] && !prop.includes("-value")) {
                let property = {
                    name: prop,
                    value: null
                };
                if (formData.object[`${prop}-value`]) {
                    let value = formData.object[`${prop}-value`];
                    if (Number.isNumeric(value))
                        value = parseInt(value);
                    property.value = value;
                }

                if (formData.object[`${prop}-group`]) 
                {
                    property.group = formData.object[`${prop}-group`];
                    groups.push(property.group);
                }

                if (this.qualities[prop])
                    qualities.push(property);
                else if (this.flaws[prop])
                    flaws.push(property);
            }
        }


        // Find the first quality for each group, arbitrarily set that to be the active
        // Hack or Impale or Defensive -> Hack is default active
        for(let groupNum of groups)
        {
            let first = qualities.find(q => q.group == groupNum);
            if (first) first.active = true;
        }

        warhammer.utility.log("Updating Qualities/Flaws", false, formData, qualities, flaws);
        this.document.update({ "system.qualities.value": qualities, "system.flaws.value": flaws });
    }

    parseCustomProperty(string)
    {
        let regex = /(.+?)(\((.+?)\))*\s*:(.+?)(\||$)/gm;

        let matches = string.matchAll(regex);
        let traits = [];

        for (let match of matches)
        {
            traits.push({
                key : match[1].trim().slugify(),
                custom : true,
                value : match[3],
                name : match[1].trim(),
                display : (match[1].trim() + ` ${match[3] ? match[3] : ""}`).trim(),
                description : match[4].trim()
            });
        }

        return traits
    }

      /** @inheritDoc */
    async _onFirstRender(context, options) {
        await super._onFirstRender(context, options);
        this.document.apps.properties = this;
    }


    /** @inheritDoc */
    async _onRender(options) {
        await super._onRender(options);

        // Automatically check or uncheck a property if the associated textbox has been changed
        this.element.querySelectorAll("input.value").forEach(e => {
            e.addEventListener("keyup", ev => {
                let property = ev.target.classList[1];
                let checked = ev.target.value ? true : false;
                let element = this.element.querySelector(`[name=${property}]`);
                if (element)
                    element.checked = checked;
            });
        });
    }

    /** @inheritDoc */
    async _onClose(options)
    {
        super._onClose(options);
        delete this.document.apps.properties;
    }



}

let fields$u = foundry.data.fields;

class CharacterModel extends StandardActorModel {
    static preventItemTypes = [];

    static defineSchema() {
        let schema = super.defineSchema();

        schema.characteristics = new fields$u.EmbeddedDataField(CharacteristicsModel);
        schema.status = new fields$u.EmbeddedDataField(CharacterStatusModel);
        schema.details = new fields$u.EmbeddedDataField(CharacterDetailsModel);

        return schema;
    }

    async _preCreate(data, options, user) {
        await super._preCreate(data, options, user);
        this.parent.updateSource({
          "prototypeToken.sight": { enabled: true },
          "prototypeToken.actorLink": true,
          "prototypeToken.disposition": CONST.TOKEN_DISPOSITIONS.FRIENDLY
        });
    }

    async _preUpdate(data, options, user) 
    {
      await super._preUpdate(data, options, user);
      if (!options.skipExperienceChecks)
      {
        await this._checkCharacteristicChange(data, options, user);
        await this._handleExperienceChange(data, options);

      }
    }

    async _checkCharacteristicChange(data, options, user)
    {
      let charChanges = foundry.utils.getProperty(options.changed, "system.characteristics");
      if (charChanges)
      {
        let keys = Object.keys(charChanges);
        for(let c of keys)
        {
          if (charChanges[c].advances)
          {
            let resolved = await Advancement.advancementDialog(c, charChanges[c].advances, "characteristic", this.parent);
            if (!resolved)
            {
              charChanges[c].advances = this.characteristics[c].advances;
              data.system.characteristics[c].advances = this.characteristics[c].advances;
              this.parent.sheet.render(true); // this doesn't feel right but otherwise the inputted value will still be on the sheet
            }
          }
        }
      }
    }

    async _onUpdate(data, options, user) {
        await super._onUpdate(data, options, user);

        if(!options.skipCorruption && foundry.utils.getProperty(options.changed, "system.status.corruption.value") && game.user.id == user)
        {
          this.checkCorruption();
        }
        
        // If XP received from message award, add
        if (options.fromMessage && game.user.isUniqueGM)
        {
          game.messages.get(options.fromMessage)?.updateReceived(this.parent);
        }
    }

    computeBase() {
        if (this.autoCalc.corruption) 
        {
          this.status.corruption.max = 0;
        }
        super.computeBase();
    }

    computeDerived() {
        super.computeDerived();

        this.computeCorruption();
        this.computeCareer();

        this.details.experience.current = this.details.experience.total - this.details.experience.spent;
    }

    computeCorruption()
    {
        let tb = this.characteristics.t.bonus;
        let wpb = this.characteristics.wp.bonus;
    
        // If the user has not opted out of auto calculation of corruption, add pure soul value
        if (this.autoCalc.corruption) {
          this.status.corruption.max += tb + wpb;
        }
    }

    computeCareer()
    {
        let career = this.currentCareer;
        let actorSkills = this.parent.itemTypes.skill;
        let actorTalents = this.parent.itemTypes.talent;
        if (career) 
        {
          let { standing, tier } = this._applyStatusModifier(career.system.status);
          this.details.status.standing = standing;
          this.details.status.tier = tier;
          this.details.status.value = game.wfrp4e.config.statusTiers[this.details.status.tier] + " " + this.details.status.standing;
          this.details.career = career;
          career.system.untrainedSkills = [];
          career.system.untrainedTalents = [];

          
          let availableCharacteristics = career.system.characteristics;
          for (let char in this.characteristics) 
          {
            if (availableCharacteristics[char])
            {
                this.characteristics[char].career = true;
                if (this.characteristics[char].advances >= career.system.level.value * 5) 
                {
                  this.characteristics[char].complete = true;
                }
              }
          }

                  
          // Find skills that have been trained or haven't, add advancement indicators or greyed out options (untrainedSkills)
          for (let sk of career.system.skills.concat(career.system.addedSkills)) 
          {
            let trainedSkill = actorSkills.find(s => s.name.toLowerCase() == sk.toLowerCase());
            if (trainedSkill) 
              trainedSkill.system.addCareerData(career);
            else 
              career.system.untrainedSkills.push(sk);
            
          }

          // Find talents that have been trained or haven't, add advancement button or greyed out options (untrainedTalents)
          for (let talent of career.system.talents) 
          {
              let trainedTalent = actorTalents.filter(t => t.name == talent);
              if (trainedTalent.length)
              {
                for(let t of trainedTalent)
                {
                  t.system.addCareerData(career);
                }
              }
              else 
              {
                career.system.untrainedTalents.push(talent);
              }
          }
        }
        else
        {
          this.details.status.value = "";
        }
    
    }

    

    get currentCareer() 
    {
        return this.parent.itemTags["career"].find(c => c.current.value)
    }
    
    awardExp(amount, reason, message=null, suppressChat=false) 
    {
      let experience = foundry.utils.duplicate(this.details.experience);
      experience.total += amount;
      experience.log.push({ reason, amount, spent: experience.spent, total: experience.total, type: "total" });
      this.parent.update({ "system.details.experience": experience }, {fromMessage : message});
      if (!suppressChat) 
        ChatMessage.create({ content: reason ? game.i18n.format("CHAT.ExpReceived", { amount, reason }) : game.i18n.format("CHAT.ExpReceivedNoReason", { amount })  , speaker: { alias: this.parent.name } });
    }

    addToExpLog(amount, reason, newSpent, newTotal) 
    {
      if (!newSpent)
        newSpent = this.details.experience.spent;
      if (!newTotal)
        newTotal = this.details.experience.total;

      let expLog = foundry.utils.duplicate(this.details.experience.log || []);
      expLog.push({ amount, reason, spent: newSpent, total: newTotal, type: newSpent ? "spent" : "total" });
      return expLog
    }

    async _handleExperienceChange(data, options, changed) {
        if (foundry.utils.hasProperty(options.changed, "system.details.experience") && !foundry.utils.hasProperty(options.changed, "system.details.experience.log")) 
        {
          let reason = await ValueDialog.create({title : game.i18n.localize("ExpChange"), text :game.i18n.localize("ExpChangeHint")});
          let expLog = this.details.experience.log || [];
          let newEntry = { reason };
          if (foundry.utils.hasProperty(data, "system.details.experience.spent")) {
              newEntry.amount = data.system.details.experience.spent - this.details.experience.spent;
              newEntry.spent = data.system.details.experience.spent;
              newEntry.total = this.details.experience.total;
              newEntry.type = "spent";
          }
          if (foundry.utils.hasProperty(data, "system.details.experience.total")) {
              newEntry.amount = data.system.details.experience.total - this.details.experience.total;
              newEntry.spent = this.details.experience.spent;
              newEntry.total = data.system.details.experience.total;
              newEntry.type = "total";
          }

          expLog.push(newEntry);
          foundry.utils.setProperty(data, "system.details.experience.log", expLog);
        }
    }

    _applyStatusModifier({ standing, tier }) {
        let modifier = this.details.status.modifier || 0;
    
        if (modifier < 0)
          this.details.status.modified = "negative";
        else if (modifier > 0)
          this.details.status.modified = "positive";
    
        let temp = standing;
        standing += modifier;
        modifier = -(Math.abs(temp));
    
        if (standing <= 0 && tier != "b") {
          standing = 5 + standing;
          if (tier == "g")
            tier = "s";
          else if (tier == "s")
            tier = "b";
    
          // If modifier is enough to subtract 2 whole tiers
          if (standing <= 0 && tier != "b") {
            standing = 5 + standing;
            tier = "b"; // only possible case here
          }
    
          if (standing < 0)
            standing = 0;
        }
        // If rock bottom
        else if (standing <= 0 && tier == "b") {
          standing = 0;
        }
        else if (standing > 5 && tier != "g") {
          standing = standing - 5;
          if (tier == "s")
            tier = "g";
          else if (tier == "b")
            tier = "s";
    
          // If modifier is enough to get you 2 whole tiers
          if (standing > 5 && tier != "g") {
            standing -= 5;
            tier = "g"; // Only possible case here
          }
        }
        return { standing, tier }
      }

      
  async checkCorruption() {

    let test;
    if (this.status.corruption.value > this.status.corruption.max) 
    {
      let skill = this.parent.has(game.i18n.localize("NAME.Endurance"), "skill");
      if (skill) 
      {
        test = await this.parent.setupSkill(skill, { title: game.i18n.format("DIALOG.MutateTitle", { test: skill.name}), mutate: true, skipTargets: true});
      }
      else {
        test = await this.parent.setupCharacteristic("t", { title: game.i18n.format("DIALOG.MutateTitle", { test: game.wfrp4e.config.characteristics["t"], skipTargets: true }), mutate: true });
      }
      await test.roll();
    }
  }
}

let fields$t = foundry.data.fields;

class VehiclePassengersModel extends ListModel {

    static get listSchema() {
        return new fields$t.SchemaField({
            id : new fields$t.StringField(),
            count : new fields$t.NumberField({min : 0}),
            roleIds : new fields$t.ArrayField(new fields$t.DocumentIdField())
        });
    }

    compute(roles)
    {
        this.list.forEach(passenger => {
            let actor = game.actors.get(passenger?.id);
            if (actor)
            {
                passenger.actor = actor,
                passenger.linked = actor.prototypeToken.actorLink,
                passenger.img = warhammer.utility.replacePopoutPath(actor.prototypeToken.texture.src),
                passenger.roles = passenger.roleIds.map(id => roles.find(r => r.id == id)).filter(i => i);
            }
            else 
            {
                passenger.notFound = true;
                passenger.img = "systems/wfrp4e/tokens/unknown.png";
            }
        });
        roles.forEach(r => r.system.assignments = this.list.filter(passenger => passenger.roleIds.includes(r.id)));
    }

    async choose(roles=[], filter)
    {
        if (typeof roles == "string")
        {
            roles = [roles];
        }
        let passengers = this.list.filter(i => i.actor?.isOwner);
        if (roles.length)
        {
            passengers = passengers.filter(passenger => passenger.roles.some(role => roles.includes(role.name)));
        }
        if (filter)
        {
            passengers = passengers.filter(filter);
        }
        
        if (passengers.length == 0)
        {
            ui.notifications.error("ERROR.NoAvailableActors", {localize: true});
            return
        }

        if (passengers.length == 1)
        {
            return passengers[0].actor;    
        }

        return (await ItemDialog.create(passengers.map(i => i.actor), 1, {text: game.i18n.localize("DIALOG.ChoosePassenger"), title: game.i18n.localize("SECTION.Passengers")}))[0]

    }

    has(actor)
    {
        return this.list.find(i => i.id == actor.id);
    }

    get (id)
    {
        return this.list.find(i => i.id == id);
    }

    add(actor)
    {
        return {[this.schema.fields.list.fieldPath] : this.list.concat({id : actor.id, count : 1})};
    }

    edit(id, data)
    {
        let list = foundry.utils.deepClone(this.list);
        let passenger = list.find(i => i.id == id);
        if (passenger)
        {
            foundry.utils.mergeObject(passenger, data);
        }
        return {[this.schema.fields.list.fieldPath] : list};
    }

    count(id, value=1)
    {
        let list = foundry.utils.deepClone(this.list);
        let passenger = list.find(i => i.id == id);
        passenger.count += value;
        return {[this.schema.fields.list.fieldPath] : list}
    }

    addRole(id, role)
    {
        if (role instanceof Item)
        {
            role = role.id;
        }

        let list = foundry.utils.deepClone(this.list);
        let passenger = list.find(i => i.id == id);
        if (!passenger.roleIds.includes(role));
        {
            passenger.roleIds.push(role);
        }
        return {[this.schema.fields.list.fieldPath] : list}
    }

    removeRole(id, role)
    {
        if (role instanceof Item)
        {
            role = role.id;
        }

        let list = foundry.utils.deepClone(this.list);
        let passenger = list.find(i => i.id == id);
        passenger.roleIds = passenger.roleIds.filter(i => i != role);
        return {[this.schema.fields.list.fieldPath] : list}
    }

}

let fields$s = foundry.data.fields;

class VehicleStatusModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.wounds = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 }),
            max: new fields$s.NumberField(),
        });
        schema.criticalWounds = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 }),
            max: new fields$s.NumberField(),
        });
        schema.carries = new fields$s.SchemaField({
            current: new fields$s.NumberField({ initial: 0 }),
            max: new fields$s.NumberField({ initial: 10 }),
        });
        schema.encumbrance = new fields$s.SchemaField({
            current: new fields$s.NumberField({ initial: 0 }),
            initial: new fields$s.NumberField({ initial: 0 }),
        });
        schema.morale = new fields$s.EmbeddedDataField(MoraleModel);
        schema.mood = new fields$s.EmbeddedDataField(ManannMoodModel);
        return schema;
    }

    static get compendiumBrowserVehicleStatusFilters() {
        return new Map([
            ["carries", {
                label: "Carries",
                type: "range",
                config: {
                    keyPath: "system.status.carries.max"
                }
            }],
            ["encumbrance", {
                label: "Encumbrance",
                type: "range",
                config: {
                    keyPath: "system.status.encumbrance.current"
                }
            }],
        ]);
    }

    initializeArmour()
    {
        this.ward = {value: null};
        this.armour = {
            head: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Head"),
                show: true,
            },
            body: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Body"),
                show: true
            },
            rArm: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Right Arm"),
                show: true
            },
            lArm: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Left Arm"),
                show: true
            },
            rLeg: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Right Leg"),
                show: true

            },
            lLeg: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Left Leg"),
                show: true
            },
            shield: 0,
            shieldDamage: 0
        };
    }

}

let fields$r = foundry.data.fields;

class VehicleModel extends BaseActorModel {
    static preventItemTypes = ["talent", "career", "disease", "injury", "mutation", "spell", "psychology", "skill", "prayer", "injury", "template"];
    static LOCALIZATION_PREFIXES = ["WH.Models.vehicle"]
    static defineSchema() {
        let schema = super.defineSchema();
        schema.characteristics = new fields$r.SchemaField({
            t: new fields$r.EmbeddedDataField(CharacteristicModel)
        });
        schema.status = new fields$r.EmbeddedDataField(VehicleStatusModel);
        schema.details = new fields$r.EmbeddedDataField(VehicleDetailsModel);
        schema.passengers = new fields$r.EmbeddedDataField(VehiclePassengersModel);
        schema.vehicleType = new fields$r.StringField({initial : "water"});
        schema.roles = new fields$r.ArrayField(new fields$r.ObjectField({deprecated : true})); // needed for migrating old roles
        return schema;
    }

    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
            ["vehicleType", {
                label: "VEHICLE.Type",
                type: "set",
                config: {
                    choices: game.wfrp4e.config.vehicleTypes,
                    keyPath: "system.vehicleType"
                }
            }],
            ...Array.from(VehicleStatusModel.compendiumBrowserVehicleStatusFilters),
            ...Array.from(VehicleDetailsModel.compendiumBrowserVehicleDetailsFilters),
        ]);
    }

    async _preCreate(data, options, user) {

        await super._preCreate(data, options, user);
        let preCreateData = {};
        if (!data.prototypeToken)
            foundry.utils.mergeObject(preCreateData,
            {
                "prototypeToken.texture.src": "systems/wfrp4e/tokens/vehicle.png"
            });

        if (!data.img || data.img == "icons/svg/mystery-man.svg") {
            preCreateData.img = "systems/wfrp4e/tokens/vehicle.png";
        }

        this.parent.updateSource(preCreateData);
    }
    
    itemIsAllowed(item) {
        let allowed = super.itemIsAllowed(item);

        // Prevent standard traits
        if (allowed && item.type == "trait")
        {
            allowed = allowed && item.system.category == "vehicle";
            if (!allowed)
            {
                ui.notifications.error("ERROR.StandardTraitsOnVehicle");
            }
        }
        return allowed
    }

    /**
     * @return {boolean}
     */
    get canSwim() {
        return this.details.move[this.details.move.primary].enabled;
    }

    /**
     * @return {{walk: number, swim: number}}
     */
    get movementDistance() {
        return {
            walk: this.details.move.value,
            swim: this.details.move[this.details.move.primary].value,
        };
    }

    initialize()
    {
        this.collision = 0;
        this.details.crew.current = 0;
    }

    computeBase()
    {
        super.computeBase();
        this.parent.runScripts("prePrepareData", { actor: this.parent });
        this.characteristics.t.computeValue();
        this.characteristics.t.computeBonus();
        this.status.wounds.bonus = Math.floor(this.status.wounds.value / 10);
        this.details.size.value = this.details.computeSize();
        this.status.initializeArmour();
        this.passengers.compute(this.parent.itemTypes.vehicleRole);
        this.crew = this.passengers.list.filter(i => i.roles?.length > 0);
        this.status.morale.compute();
        this.status.mood.compute();
    }

    computeDerived() {
        super.computeDerived();
        this.parent.runScripts("prePrepareItems", {actor : this.parent });
        this.characteristics.t.computeValue();
        this.characteristics.t.computeBonus();
        this.collision += this.characteristics.t.bonus + this.status.wounds.bonus;
        this.computeEncumbrance();
        this.details.computeMove();
        this.parent.runScripts("prepareData", { actor: this.parent });
    }


    computeEncumbrance() {
        if (!game.actors) // game.actors does not exist at startup, use existing data
        {
            game.wfrp4e.postReadyPrepare.push(this);
        }
        else 
        {
            this.status.encumbrance.current += this.details.computeCrewEncumbrance(this.passengers.list);
        }

        for (let i of this.parent.items) 
        {
            i.prepareOwnedData();
            
            if (i.encumbrance)
            {
                this.status.encumbrance.current += Number(i.encumbrance.total);
            }
        }

        this.status.encumbrance.current = Math.floor(this.status.encumbrance.current * 10) / 10;
        this.status.encumbrance.mods = this.parent.itemTags["vehicleMod"].reduce((prev, current) => prev + current.encumbrance.total, 0);
        this.status.encumbrance.over = this.status.encumbrance.mods - this.status.encumbrance.initial;
        this.status.encumbrance.over = this.status.encumbrance.over < 0 ? 0 : this.status.encumbrance.over;

        this.status.encumbrance.max = this.status.carries.max;
        this.status.encumbrance.pct = this.status.encumbrance.over / this.status.encumbrance.max * 100;
        this.status.encumbrance.carryPct = this.status.encumbrance.current / this.status.carries.max * 100;
        if (this.status.encumbrance.pct + this.status.encumbrance.carryPct > 100) {
            this.status.encumbrance.penalty = Math.floor(((this.status.encumbrance.carryPct + this.status.encumbrance.pct) - 100) / 10); // Used in handling tests
        }
    }

    get crewEffects() 
    {
        return this.parent.effects.contents.concat(this.parent.items.contents.reduce((effects, item) => effects.concat(item.effects.contents), [])).filter(e => e.system.transferData.type == "crew");
    }

    getOtherEffects() 
    {
        return super.getOtherEffects().concat(this.status.morale.getMoraleEffects(this.parent))
    }

    static migrateData(data)
    {
        if (data.passengers instanceof Array)
        {
            data.passengers = {
                list : data.passengers
            };
        }
    }
}

foundry.data.fields;

class NPCModel extends StandardActorModel 
{
    static preventItemTypes = [];

    static defineSchema() 
    {
        let schema = super.defineSchema();
        return schema;
    }
}

let fields$q = foundry.data.fields;

class CreatureModel extends StandardActorModel 
{
    static preventItemTypes = [];

    static defineSchema() 
    {
        let schema = super.defineSchema();
        // deprecated
        schema.excludedTraits = new fields$q.ArrayField(new fields$q.StringField());
        return schema;
    }
}

let fields$p = foundry.data.fields;

const PropertiesMixin = (cls) => class extends cls
{
    static defineSchema() {
        let schema = super.defineSchema();
        schema.qualities = new fields$p.SchemaField({
            value: new fields$p.ArrayField(new fields$p.ObjectField({}))
        });
        schema.flaws = new fields$p.SchemaField({
            value: new fields$p.ArrayField(new fields$p.ObjectField({}))
        });
        return schema;
    }

    /**
     * Create the properties filter configuration for a type.
     * @param {string} type  Item type.
     * @returns {CompendiumBrowserFilterDefinitionEntry}
     */
    static compendiumBrowserPropertiesFilter(type) {
        return [
            ["qualities", {
                label: "Qualities",
                type: "set",
                config: {
                    choices: game.wfrp4e.utility.qualityList(type),
                    keyPath: "system.qualities.value",
                    valueGetter: (data) => data.system.qualities.value.map(q => q.name),
                    multiple: true,
                    collapsed: true
                }
            }],
            ["flaws", {
                label: "Flaws",
                type: "set",
                config: {
                    choices: game.wfrp4e.utility.flawList(type),
                    keyPath: "system.flaws.value",
                    valueGetter: (data) => data.system.flaws.value.map(f => f.name),
                    multiple: true,
                    collapsed: true
                }
            }]
        ];
    }

    /**
     * Used to identify an Item as one being a child of PropertiesMixin
     *
     * @final
     * @returns {boolean}
     */
    get hasProperties() {
        return true;
    }

    get tags() 
    {
        return super.tags.add("properties");
    }

    //#region getters

    get loading() {
        return this.properties.flaws.reload
    }

    get repeater() {
        return this.properties.qualities.repeater
    }

    get isMagical() {
        return this.properties.qualities.magical || this.properties.unusedQualities?.magical; // Should still be magical if unused
      }

    get properties() {

        if (this._properties && this._properties._totalProperties == this.qualities.value.length + this.flaws.value.length)
        {
            return this._properties;
        }

        this._properties = {
            qualities: this.constructor.propertyArrayToObject(this.qualities.value, game.wfrp4e.utility.qualityList(), this.parent),
            flaws: this.constructor.propertyArrayToObject(this.flaws.value, game.wfrp4e.utility.flawList(),  this.parent),
        };

        this._properties._totalProperties = this.qualities.value.length + this.flaws.value.length;

        return this._properties;
    }

    get originalProperties() {
        let properties = {
            qualities: this.constructor.propertyArrayToObject(this._source.qualities.value, game.wfrp4e.utility.qualityList(),  this.parent),
            flaws: this.constructor.propertyArrayToObject(this._source.flaws.value, game.wfrp4e.utility.flawList(),  this.parent),
            unusedQualities: {}
        };
        return properties;
    }

    get OriginalQualities() {
        let qualities = Object.values(this.originalProperties.qualities);
        let ungrouped = qualities.filter(i => !i.group).map(q => q.display);
        let grouped = [];
        let groupNums = this.QualityGroups;
        for (let g of groupNums) {
            grouped.push(qualities.filter(i => i.group == g).map(i => i.display).join(" " + game.i18n.localize("QualitiesOr") + " "));
        }
        return ungrouped.concat(grouped)
    }

    get OriginalFlaws() {
        return Object.values(this.originalProperties.flaws).map(f => f.display)
    }


    // Related to OR qualities - can choose which one is active
    get QualityGroups() {
        // return groups with no duplicates
        return Object.values(this.originalProperties.qualities)
            .map(i => i.group)
            .filter(i => Number.isNumeric(i))
            .filter((value, index, array) => {
                return array.findIndex(i => value == i) == index
            });
    }

    get Qualities() {
        return Object.values(this.properties.qualities).map(q => q.display)
    }

    get UnusedQualities() {
        return Object.values(this.properties.unusedQualities).map(q => q.display)
    }

    get InactiveQualities() {
        return Object.values(this.properties.inactiveQualities).map(q => q.display)
    }

    get Flaws() {
        return Object.values(this.properties.flaws).map(f => f.display)
    }

    //#endregion

    getOtherEffects()
    {
        return super.getOtherEffects().concat(Object.values(foundry.utils.mergeObject(foundry.utils.deepClone(this.properties.qualities), this.properties.flaws)).map(p => p.effect).filter(i => i) || []);
    }


    computeBase() {
        this._properties = null;
        super.computeBase();
    }

    computeEncumbrance() 
    {
        let enc = super.computeEncumbrance();

        if (this.properties.qualities?.lightweight && enc >= 1)
            enc -= 1 * this.quantity.value;
        if (this.properties.flaws?.bulky)
            enc += 1 * this.quantity.value;

        return enc
    }

    /**
   * 
   * @param {Object} properties properties object to add
   */
    _addProperties(properties) {
        let qualities = this.qualities.value;
        let flaws = this.flaws.value;

        for (let q in properties.qualities) {
            let hasQuality = qualities.find(quality => quality.name == q);
            if (hasQuality && properties.qualities[q].value) {
                hasQuality.value += properties.qualities[q].value;
            }
            else
                qualities.push({ name: q, value: properties.qualities[q].value });
        }
        for (let f in properties.flaws) {
            let hasQuality = flaws.find(flaw => flaw.name == f);
            if (hasQuality && properties.flaws[f].value) {
                hasQuality.value += properties.flaws[f].value;
            }
            else
                flaws.push({ name: f, value: properties.flaws[f].value });
        }
        this._properties = null;
    }

    static propertyArrayToObject(array, propertyObject, document) {

        let properties = {};

        // Convert quality/flaw arry into an properties object (accessible example `item.properties.qualities.accurate` or `item.properties.flaws.reload.value)
        if (array) {
            array.forEach(p => {
                if (propertyObject[p.name]) {
                    properties[p.name] = {
                        key: p.name,
                        display: propertyObject[p.name],
                        value: p.value,
                        group: p.group,
                        active: p.active,
                        effect: this._createPropertyEffect(p, document)
                    };
                    if (p.value)
                        properties[p.name].display += " " + (Number.isNumeric(p.value) ? p.value : `(${p.value})`);

                }
                else if (p.custom) {
                    properties[p.key] = {
                        key: p.key,
                        display: p.display
                    };
                }
                // Unrecognized
                else properties[p.name] = {
                    key: p.name,
                    display: p.name
                };
            });
        }

        return properties
    }

      
    static propertyStringToArray(propertyString, propertyObject)
    {
        let newProperties = [];
        let oldProperties = propertyString.toString().split(",").map(i => i.trim());
        for (let property of oldProperties) {
          if (!property)
            continue
    
          let newProperty = {};
          let splitProperty = property.split(" ");
          if (Number.isNumeric(splitProperty[splitProperty.length - 1])) {
            newProperty.value = parseInt(splitProperty[splitProperty.length - 1]);
            splitProperty.splice(splitProperty.length - 1, 1);
          }
    
          splitProperty = splitProperty.join(" ");
    
          newProperty.name = warhammer.utility.findKey(splitProperty, propertyObject);
          if (newProperty)
            newProperties.push(newProperty);
          else
            newProperties.push(property);
        }
        return newProperties
    }
  
    
    static propertyStringToObject(propertyString, propertyObject)
    {
        let array = this.propertyStringToArray(propertyString, propertyObject);
        return this.propertyArrayToObject(array, propertyObject)
    }
  

    static _createPropertyEffect(property, document)
    {
        let effectData = foundry.utils.deepClone(game.wfrp4e.config.propertyEffects[property.name]);
        if (effectData)
        {
            let type = game.wfrp4e.utility.qualityList()[property.name] ? "qualities" : "flaws";
            effectData.img = document.img;
            foundry.utils.setProperty(effectData, "flags.wfrp4e", {value : property.value, path : `system.properties.${type}.${property.name}.effect`});
            return new CONFIG.ActiveEffect.documentClass(effectData, {parent : document});
        }
    }
};

let fields$o = foundry.data.fields;

class AmmunitionModel extends PropertiesMixin(PhysicalItemModel)
{
    static LOCALIZATION_PREFIXES = ["WH.Models.ammunition"];

    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.ammunitionType = new fields$o.SchemaField({
            value: new fields$o.StringField({choices : game.wfrp4e.config.ammunitionGroups})
        });
        schema.range = new fields$o.SchemaField({
            value: new fields$o.StringField()
        });
        schema.damage = new fields$o.SchemaField({
            value: new fields$o.StringField(),
            dice: new fields$o.StringField({ initial: "" })
        });
        
        schema.special = new fields$o.SchemaField({
            value: new fields$o.StringField()
        });
        return schema;
    }

  /**
   * Used to identify an Item as one being a child or instance of AmmunitionModel
   *
   * @final
   * @returns {boolean}
   */
  get isAmmunition() {
    return true;
  }

  static get compendiumBrowserFilters() {
    return new Map([
      ...Array.from(super.compendiumBrowserFilters),
      ["ammunitionType", {
        label: this.LOCALIZATION_PREFIXES + ".FIELDS.ammunitionType.value.label",
        type: "set",
        config: {
          choices: game.wfrp4e.config.ammunitionGroups,
          keyPath: "system.ammunitionType.value"
        }
      }],
      ["damage", {
        label: "BROWSER.ModifiesDamage",
        type: "boolean",
        config: {
          keyPath: "system.damage",
          valueGetter: (data) => (
            !!data.system.damage?.value?.length &&
            data.system.range?.value.toLowerCase() !== game.i18n.localize("as weapon").toLowerCase()
          ) || !!data.system.damage?.dice?.length
        }
      }],
      ["range", {
        label: "BROWSER.ModifiesRange",
        type: "boolean",
        config: {
          keyPath: "system.range",
          valueGetter: (data) => !!data.system.range?.value?.length &&
            data.system.range?.value?.toLowerCase() !== game.i18n.localize("as weapon").toLowerCase()
        }
      }],
      ...this.compendiumBrowserPropertiesFilter("weapon"),
    ]);
  }

      // Ammunition Expansion Data
  async expandData(htmlOptions) {
    let data = await super.expandData(htmlOptions);
    let properties = [];
    properties.push(game.wfrp4e.config.ammunitionGroups[this.ammunitionType.value]);

    if (this.range.value)
      properties.push(`${game.i18n.localize("Range")}: ${this.range.value}`);

    if (this.damage.value) {
      let damage = this.damage.value;
      if (this.damage.dice)
        damage += " + " + this.damage.dice;
      properties.push(`${game.i18n.localize("Damage")}: ${damage}`);
    }

    let itemProperties = this.Qualities.concat(this.Flaws);
    for (let prop of itemProperties)
      properties.push("<a data-action='postItemProperty' class ='item-property'>" + prop + "</a>");

    if (this.special.value)
      properties.push(`${game.i18n.localize("Special")}: ` + this.special.value);

    data.properties = properties.filter(p => !!p);
    return data;
  }

  chatData() {
    let properties = [
      `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
      `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
      `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
    ];

    properties.push(`<b>${game.i18n.localize("ITEM.AmmunitionType")}:</b> ${game.wfrp4e.config.ammunitionGroups[this.ammunitionType.value]}`);

    if (this.range.value)
      properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);

    if (this.damage.value)
      properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);

    // Make qualities and flaws clickable
    if (this.qualities.value.length)
      properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a data-action='postItemProperty' class ='item-property'>" + i + "</a>").join(", ")}`);

    if (this.flaws.value.length)
      properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a data-action='postItemProperty' class ='item-property'>" + i + "</a>").join(", ")}`);


    properties = properties.filter(p => p != game.i18n.localize("Special"));
    if (this.special.value)
      properties.push(`<b>${game.i18n.localize("Special")}</b>: ` + this.special.value);

    properties = properties.filter(p => !!p);
    return properties;
  }

  // Ammo effects should never transfer to actors, they always append to the weapon's effects
  shouldTransferEffect(effect)
  {
    return false;
  }
}

let fields$n = foundry.data.fields;

/**
 * @extends PhysicalItemModel
 */
class EquippableItemModel extends PhysicalItemModel {
  static defineSchema() {
    let schema = super.defineSchema();

    schema.equipped = new fields$n.SchemaField({
      value: new fields$n.BooleanField({initial: false})
    });

    return schema;
  }

  async _onUpdate(data, options, user) {
    await super._onUpdate(data, options, user) || {};

    if (game.user.id === user && foundry.utils.hasProperty(data, "system.equipped")) {
      await Promise.all(this.parent.runScripts("equipToggle", {equipped: this.isEquipped}));
      await this.onEquipToggle(data, options, user);
    }
  }

  computeBase() {
    super.computeBase();

    this.reduceEquippedEncumbrance();
  }

  shouldTransferEffect(effect)
  {
      return super.shouldTransferEffect(effect) && (!effect.system.transferData.equipTransfer || this.isEquipped)
  }

  /**
   * Used to identify an Item as one being a child of EquippableItemModel
   *
   * @final
   * @returns {boolean}
   */
  get isEquippable() {
    return true;
  }

  get tags() 
  {
    return super.tags.add("equippable");
  }

  /**
   * @returns {boolean}
   */
  get isEquipped() {
    return this.equipped.value;
  }

  /**
   * @returns {Promise<boolean>}
   */
  async toggleEquip(data = {}) {
    let equipped = this.isEquipped;
    if (equipped || this.canEquip) {
      equipped = !equipped;
      data = foundry.utils.mergeObject(data, {"system.equipped.value": equipped});
      await this.parent.update(data);
    }

    return equipped;
  }

  reduceEquippedEncumbrance() {
    if (this.isEquipped && this.weighsLessEquipped) {
      this.encumbrance.total = Math.max(0, this.encumbrance.total - 1);
    }
  }

  /**
   * @returns {boolean}
   */
  get usesHands() {
    return false;
  }

  /**
   * @returns {boolean}
   */
  get canEquip() {
    return true;
  }

  /**
   * @returns {boolean}
   */
  get weighsLessEquipped() {
    return false;
  }

  /**
   * @returns {number}
   */
  get equipPoints() {
    return 0;
  }

  async onEquipToggle(data, options, user) {

  }
}

let fields$m = foundry.data.fields;

/**
 *
 * @extends EquippableItemModel
 * @mixes PropertiesMixin
 */
class ArmourModel extends PropertiesMixin(EquippableItemModel) {
    static LOCALIZATION_PREFIXES = ["WH.Models.armour"];
    static defineSchema() {
    let schema = super.defineSchema();
    schema.armorType = new fields$m.SchemaField({ // TODO migrate this to the "correct" spelling
      value: new fields$m.StringField({}),//choices : game.wfrp4e.config.armorTypes})
    });
    schema.penalty = new fields$m.SchemaField({
      value: new fields$m.StringField()
    });
    schema.special = new fields$m.SchemaField({
      value: new fields$m.StringField()
    });

    schema.AP = new fields$m.SchemaField({
      head: new fields$m.NumberField({ initial: 0 }),
      lArm: new fields$m.NumberField({ initial: 0 }),
      rArm: new fields$m.NumberField({ initial: 0 }),
      lLeg: new fields$m.NumberField({ initial: 0 }),
      rLeg: new fields$m.NumberField({ initial: 0 }),
      body: new fields$m.NumberField({ initial: 0 }),
    });
    schema.APdamage = new fields$m.SchemaField({
      head: new fields$m.NumberField({ initial: 0 }),
      lArm: new fields$m.NumberField({ initial: 0 }),
      rArm: new fields$m.NumberField({ initial: 0 }),
      lLeg: new fields$m.NumberField({ initial: 0 }),
      rLeg: new fields$m.NumberField({ initial: 0 }),
      body: new fields$m.NumberField({ initial: 0 }),
    });
    return schema;
  }

  static get compendiumBrowserFilters() {
    return new Map([
      ...Array.from(super.compendiumBrowserFilters),
      ["armorType", {
        label: this.LOCALIZATION_PREFIXES + ".FIELDS.armorType.value.label",
        type: "set",
        config: {
          choices: game.wfrp4e.config.armorTypes,
          keyPath: "system.armorType.value"
        }
      }],
      ["location", {
        label: "Location",
        type: "set",
        config: {
          choices: game.wfrp4e.config.locations,
          keyPath: "system.AP",
          valueGetter: (data) => Object.entries(data.system.AP).reduce((acc, [k, v]) => {
            if (!!v) acc.push(k);
            return acc;
          }, []),
          multiple: true
        }
      }],
      ["ap", {
        label: "AP",
        type: "range",
        config: {
          keyPath: "system.AP",
          valueGetter: (data) => Object.entries(data.system.AP)
            .reduce((acc, [k, v]) => Math.max(acc, v), 0),
        }
      }],
      ...this.compendiumBrowserPropertiesFilter("armor"),
    ]);
  }

  async _preUpdate(data, options, user)
  {
    await super._preUpdate(data, options, user);
    if (data.system?.APdamage)
    {
      for(let loc in data.system.APdamage)
      {
        let maxDamageAtLocation = this.AP[loc] + Number(this.properties.qualities.durable?.value || 0);
        data.system.APdamage[loc] = Math.clamp(data.system.APdamage[loc], 0, maxDamageAtLocation);
      }
    }
  }

  /**
   * Used to identify an Item as one being a child or instance of ArmourModel
   *
   * @final
   * @returns {boolean}
   */
  get isArmour() {
    return true;
  }

  get worn() {
    console.warn("[DEPRECATION] `armour.worn` is deprecated, please use `armour.equipped` instead");
    return this.equipped;
  }

  get weighsLessEquipped() {
    return true;
  }

  get isMetal() 
  {
    return ["plate", "mail", "otherMetal"].includes(this.armorType.value)
  }

  get protects() {
    let protects = {};
    for (let loc in this.AP) {
      if (this.AP[loc] > 0)
        protects[loc] = true;
      else
        protects[loc] = false;
    }
    return protects
  }

  get currentAP() {
    let currentAP = foundry.utils.deepClone(this.AP);
    for (let loc in currentAP) {
        currentAP[loc] -= this.properties.qualities.durable  // If durable, subtract its value from APdamage
                          ? Math.max(0, (this.APdamage[loc] - (this.properties.qualities.durable?.value || 0)))
                          : this.APdamage[loc];
    }
    return currentAP
  }

  async _preCreate(data, options, user) {
    await super._preCreate(data, options, user);

    if (this.parent.isOwned && this.parent.actor.type != "character" && this.parent.actor.type != "vehicle") 
    {
      this.updateSource({"equipped.value" : true});
    }
  }

  computeBase() {
    super.computeBase();
    this.damaged = {
      "head": false,
      "lArm": false,
      "rArm": false,
      "lLeg": false,
      "rLeg": false,
      "body": false
    };
  }

    /** 
   * Helper method to apply damage to an item
   * 
   * @param {number} value Damage the item by this amount
   * @param {Array} location Array of locations to damage
   */
    damageItem(value = 1, location=["head", "lArm", "rArm", "lLeg", "rLeg", "body"])
    {
        let update = {};
        for(let loc of location)
        {
          update[`system.APdamage.${loc}`] = Math.clamp(this.APdamage[loc] + value, 0, this.AP[loc]);
        }
        return this.parent.update(update);
    }
  
  // Armour Expansion Data
  async expandData(htmlOptions) {
    let data = await super.expandData(htmlOptions);
    let properties = [];
    properties.push(game.wfrp4e.config.armorTypes[this.armorType.value]);
    let itemProperties = this.Qualities.concat(this.Flaws);
    for (let prop of itemProperties)
      properties.push("<a data-action='postItemProperty' class ='item-property'>" + prop + "</a>");
    properties.push(this.penalty.value);

    data.properties = properties.filter(p => !!p);
    return data;
  }

  chatData() {
    let properties = [
      `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
      `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
      `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
    ];

    if (this.armorType.value)
      properties.push(`<b>${game.i18n.localize("ITEM.ArmourType")}</b>: ${game.wfrp4e.config.armorTypes[this.armorType.value]}`);
    if (this.penalty.value)
      properties.push(`<b>${game.i18n.localize("Penalty")}</b>: ${this.penalty.value}`);


    for (let loc in game.wfrp4e.config.locations)
      if (this.AP[loc])
        properties.push(`<b>${game.wfrp4e.config.locations[loc]} AP</b>: ${this.currentAP[loc]}/${this.AP[loc]}`);



    // Make qualities and flaws clickable
    if (this.qualities.value.length)
      properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a data-action='postItemProperty' class ='item-property'>" + i + "</a>").join(", ")}`);

    if (this.flaws.value.length)
      properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a data-action='postItemProperty' class ='item-property'>" + i + "</a>").join(", ")}`);


    properties = properties.filter(p => p != game.i18n.localize("Special"));
    if (this.special.value)
      properties.push(`<b>${game.i18n.localize("Special")}</b>: ` + this.special.value);

    properties = properties.filter(p => !!p);
    return properties;
  }

  
  static migrateData(data)
  {
    super.migrateData(data);
    if (data.currentAP)
    {
        data.AP = data.maxAP;
        data.APdamage = data.currentAP;

        for(let loc in data.currentAP)
        {
          if(data.currentAP[loc] == -1)
            data.APdamage[loc] = 0;
          else {
            data.APdamage[loc] = data.maxAP[loc] - data.currentAP[loc];
          }
        }
    }

    if (data.worn?.value) {
      foundry.utils.setProperty(data, "equipped.value", data.worn.value);
    }
  }

}

let fields$l = foundry.data.fields;

class CareerModel extends BaseItemModel
{
    static LOCALIZATION_PREFIXES = ["WH.Models.career"];
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.careergroup = new fields$l.SchemaField({
            value: new fields$l.StringField()
        });
        schema.class = new fields$l.SchemaField({
            value: new fields$l.StringField()
        });
        schema.current = new fields$l.SchemaField({
            value: new fields$l.BooleanField()
        });
        schema.complete = new fields$l.SchemaField({
            value: new fields$l.BooleanField()
        });
        schema.level = new fields$l.SchemaField({
            // value: new fields.NumberField({min: 1, choices : [1, 2, 3, 4], initial : 1})
            value: new fields$l.NumberField({min: 1, choices : {1 : "1", 2 : "2", 3 : "3", 4 : "4"}, initial : 1})
        });
        schema.status = new fields$l.SchemaField({
            standing: new fields$l.NumberField({min: 1}),
            tier: new fields$l.StringField({choices: game.wfrp4e.config.statusTiers})
        });
        schema.characteristics = new fields$l.SchemaField({
            ws: new fields$l.BooleanField(),
            bs: new fields$l.BooleanField(),
            s: new fields$l.BooleanField(),
            t: new fields$l.BooleanField(),
            i: new fields$l.BooleanField(),
            ag: new fields$l.BooleanField(),
            dex: new fields$l.BooleanField(),
            int: new fields$l.BooleanField(),
            wp: new fields$l.BooleanField(),
            fel: new fields$l.BooleanField(),
        });

        schema.skills = new fields$l.ArrayField(new fields$l.StringField());
        schema.addedSkills = new fields$l.ArrayField(new fields$l.StringField());
        schema.talents = new fields$l.ArrayField(new fields$l.StringField());
        schema.trappings = new fields$l.ArrayField(new fields$l.StringField());
        schema.incomeSkill = new fields$l.ArrayField(new fields$l.NumberField());
        schema.previousCareer = new fields$l.EmbeddedDataField(DocumentReferenceModel);
        return schema;
    }
      /**
   * Used to identify an Item as one being a child or instance of CareerModel
   *
   * @final
   * @returns {boolean}
   */
  get isCareer() {
    return true;
  }

  static get compendiumBrowserFilters() {
    return new Map([
      ...Array.from(super.compendiumBrowserFilters),
      // @todo type='set' and choices?
      ["careergroup", {
        label: this.LOCALIZATION_PREFIXES + ".FIELDS.careergroup.value.label",
        type: "text",
        config: {
          keyPath: "system.careergroup.value"
        }
      }],
      // @todo type='set' and choices?
      ["class", {
        label: this.LOCALIZATION_PREFIXES + ".FIELDS.class.value.label",
        type: "text",
        config: {
          keyPath: "system.class.value"
        }
      }],
      ["level", {
        label: this.LOCALIZATION_PREFIXES + ".FIELDS.level.value.label",
        type: "set",
        config: {
          choices: {1: 1, 2: 2, 3: 3, 4: 4},
          keyPath: "system.level.value"
        }
      }],
      ["statusStanding", {
        label: this.LOCALIZATION_PREFIXES + ".FIELDS.status.standing.label",
        type: "range",
        config: {
          keyPath: "system.status.standing"
        }
      }],
      ["statusTier", {
        label: this.LOCALIZATION_PREFIXES + ".FIELDS.status.tier.label",
        type: "set",
        config: {
          choices: game.wfrp4e.config.statusTiers,
          keyPath: "system.status.tier"
        }
      }],
      ["characteristics", {
        label: "Characteristics",
        type: "set",
        config: {
          choices: game.wfrp4e.config.characteristics,
          keyPath: "system.characteristics",
          valueGetter: (data) => {
            if (foundry.utils.getType(data.system.characteristics) === "Array")
              return data.system.characteristics;

            return Object.entries(data.system.characteristics).reduce((acc, [k, v]) => {
              if (v) acc.push(k);
              return acc;
            }, [])
          },
          multiple: true
        }
      }],
      ["skills", {
        label: "Skills",
        type: "text",
        config: {
          keyPath: "system.skills",
          multiple: true
        }
      }],
      ["talents", {
        label: "Talents",
        type: "text",
        config: {
          keyPath: "system.talents",
          multiple: true
        }
      }],
      ["trappings", {
        label: "Trappings",
        type: "text",
        config: {
          keyPath: "system.trappings",
          multiple: true
        }
      }],
      ["incomeSkill", {
        label: "Income",
        type: "text",
        config: {
          keyPath: "system.incomeSkill",
          multiple: true
        }
      }],
    ]);
  }

  async _preUpdate(data, options, user)
  {
    await super._preUpdate(data, options, user);

    // If the last skill inputted has commas, separate them into their own array elements
    let skills = foundry.utils.getProperty(data, "system.skills");
    if (skills && skills[skills.length - 1]?.includes(","))
    {
      foundry.utils.setProperty(data, "system.skills", skills.slice(0, skills.length - 1).concat(skills[skills.length - 1].split(",").map(i => i.trim())));
    }
  }


    async _onCreate(data, options, user)
    {
        await super._onCreate(data, options, user);
        
        if (this.parent.actor?.type == "creature") 
        {
            await this.parent.actor.system.advance(this.parent);
        }
    }

    async _onUpdate(data, options, user)
    {
        await super._onUpdate(data, options, user);

        if (game.user.id == user) 
        {
            if (this.parent.isOwned && data.system?.current?.value) 
            {
                let actor = this.parent.actor;
                let careerUpdates = actor.itemTypes.career.filter(i => i.system.current.value && i.id != this.parent.id).map(i => {
                    return {
                        "system.current.value": false,
                        _id: i.id
                    }
                });
                // Reset all other careers to not be current (only one can be current)
                actor.update({ items: careerUpdates });
            }
            if (this.parent.isOwned && this.parent.actor.type == "npc" && foundry.utils.getProperty(options.changed, "system.complete.value")) 
            {
                this._promptCareerAdvance();
            }

            if (this.parent.isOwned && this.parent.actor.type == "character" && foundry.utils.getProperty(options.changed, "system.current.value")) 
            {
                this.handleCareerLinking();
            }
        }
    }


    async _promptCareerAdvance()
    {
        let advance = await foundry.applications.api.DialogV2.confirm({yes : {default: true}, content: game.i18n.localize("CAREERAdvHint"), window : {title: game.i18n.localize("CAREERAdv")}});

        if (advance)
        {
            await this.parent.actor.system.advance(this.parent);
            await this.parent.actor.update({ "system.details.status.value": game.wfrp4e.config.statusTiers[this.status.tier] + " " + this.status.standing });
        }
    }


    async changeSkillName(newName, oldName, skipPrompt) {
        let careerSkills = foundry.utils.duplicate(this.skills);

        // If career has the skill, change the name
        if (careerSkills.includes(oldName)) 
        {
            careerSkills[careerSkills.indexOf(oldName)] = newName;
        }
        else // if it doesn't, return
        {
            return;
        }

        // Ask the user to confirm the change
        let changeCareer = skipPrompt || await foundry.applications.api.DialogV2.confirm({yes : {default: true}, window : {title: game.i18n.localize("SHEET.CareerSkill")}, content: `<p>${game.i18n.localize("SHEET.CareerSkillPrompt")}</p>`});

        if (changeCareer)
        {
            ui.notifications.notify(`${game.i18n.format("SHEET.CareerSkillNotif", { oldName, newName, career: this.parent.name })}`);
            this.parent.update({ "system.skills": careerSkills });
        }
    }

    async handleCareerLinking()
    {
        if (this.level.value == 1 || this.previousCareer.document)
        {
            return;
        }
        else 
        {
            let actor = this.parent.actor;
            let previousCareers = actor.itemTypes.career.filter(i => i.system.careergroup.value == this.careergroup.value && i.id != this.parent.id).sort((a, b) => b.system.level.value - a.system.level.value);
            let previous = previousCareers[0];

            if (!previous)
            {
                return;
            }

            if (await foundry.applications.api.DialogV2.confirm({yes : {default: true}, window : {title : game.i18n.localize("DIALOG.LinkCareer")}, content : `<p>${game.i18n.format("DIALOG.LinkCareerContent", {new : this.parent.name, old : previous.name})}</p>`}))
            {
                let collectedSkills = previous.system.skills.concat(this.skills.slice(previous.system.skills.length));

                this.parent.update({system : {previousCareer : {name : previous.name, id : previous.id}, skills : collectedSkills}});
            }
        }
    }

    _addModelProperties()
    {
        if (this.parent.actor)
        {
            this.previousCareer.relative = this.parent.actor.items;
        }
    }

    // Career should only be applied if career is active
    effectIsApplicable(effect) 
    {
        return this.current.value;
    }
    

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties = [];
        data.properties.push(`<b>${game.i18n.localize("Class")}</b>: ${this.class.value}`);
        data.properties.push(`<b>${game.i18n.localize("Group")}</b>: ${this.careergroup.value}`);
        data.properties.push(game.wfrp4e.config.statusTiers[this.status.tier] + " " + this.status.standing);
        data.properties.push(`<b>${game.i18n.localize("Characteristics")}</b>: ${Object.keys(this.characteristics).filter(i => this.characteristics[i]).map(i => i = " " + game.wfrp4e.config.characteristicsAbbrev[i])}`);
        data.properties.push(`<b>${game.i18n.localize("Skills")}</b>: ${this.skills.map(i => i = " " + i)}`);
        data.properties.push(`<b>${game.i18n.localize("Talents")}</b>: ${this.talents.map(i => i = " " + i)}`);
        data.properties.push(`<b>${game.i18n.localize("Trappings")}</b>: ${this.trappings.map(i => i = " " + i)}`);
        data.properties.push(`<b>${game.i18n.localize("Income")}</b>: ${this.incomeSkill.map(i => ` <a class = 'career-income' data-career-id=${this.id}> ${this.skills[i]} <i class="fas fa-coins"></i></a>`)}`);
        // When expansion data is called, a listener is added for 'career-income'
        return data;
      }

      chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Class")}</b>: ${this.class.value}`);
        properties.push(`<b>${game.i18n.localize("Group")}</b>: ${this.careergroup.value}`);
        properties.push(`<b>${game.i18n.localize("Status")}</b>: ${game.wfrp4e.config.statusTiers[this.status.tier] + " " + this.status.standing}`);
        properties.push(`<b>${game.i18n.localize("Characteristics")}</b>: ${Object.keys(this.characteristics).filter(i => this.characteristics[i]).map(i => i = " " + game.wfrp4e.config.characteristicsAbbrev[i])}`);
        properties.push(`<b>${game.i18n.localize("Skills")}</b>: ${this.skills.map(i => i = " " + "<a class = 'skill-lookup'>" + i + "</a>")}`);
        properties.push(`<b>${game.i18n.localize("Talents")}</b>: ${this.talents.map(i => i = " " + "<a class = 'talent-lookup'>" + i + "</a>")}`);
        properties.push(`<b>${game.i18n.localize("Trappings")}</b>: ${this.trappings.map(i => i = " " + i)}`);
        properties.push(`<b>${game.i18n.localize("Income")}</b>: ${this.incomeSkill.map(i => " " + this.skills[i])}`);
        return properties;
      }

      static migrateData(data)
      {
        if (data.characteristics instanceof Array)
        {
            data.characteristics = {
                ws : data.characteristics.includes("ws"),
                bs : data.characteristics.includes("bs"),
                s : data.characteristics.includes("s"),
                t : data.characteristics.includes("t"),
                i : data.characteristics.includes("i"),
                ag : data.characteristics.includes("ag"),
                dex : data.characteristics.includes("dex"),
                int : data.characteristics.includes("int"),
                wp : data.characteristics.includes("wp"),
                fel : data.characteristics.includes("fel")
            };
        }

        // if (data.skills instanceof Array)
        // {
        //     data.skills = {list : data.skills};
        // }
        // if (data.talents instanceof Array)
        // {
        //     data.talents = {list : data.talents};
        // }
        // if (data.trappings instanceof Array)
        // {
        //     data.trappings = {list : data.trappings};
        // }
      }
}

let fields$k = foundry.data.fields;

/**
 *
 * @extends EquippableItemModel
 */
class ContainerModel extends EquippableItemModel {
    static LOCALIZATION_PREFIXES = ["WH.Models.container"];
    
    static defineSchema() {
        let schema = super.defineSchema();
        schema.wearable = new fields$k.SchemaField({
            value: new fields$k.BooleanField()
        });
        schema.carries = new fields$k.SchemaField({
            value: new fields$k.NumberField()
        });
        schema.countEnc = new fields$k.SchemaField({
            value: new fields$k.BooleanField()
        });

        return schema;
    }

    static get compendiumBrowserFilters() {
      return new Map([
        ...Array.from(super.compendiumBrowserFilters),
        ["wearable", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.wearable.value.label",
          type: "boolean",
          config: {
            keyPath: "system.wearable.value"
          }
        }],
        ["carries", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.carries.value.label",
          type: "range",
          config: {
            keyPath: "system.carries.value"
          }
        }],
      ]);
    }

  /**
   * Used to identify an Item as one being a child or instance of ContainerModel
   *
   * @final
   * @returns {boolean}
   */
  get isContainer() {
    return true;
  }

    get worn() {
      console.warn("[DEPRECATION] `container.worn` is deprecated, please use `container.equipped` instead");
      return this.equipped;
    }

    get weighsLessEquipped() {
      return true;
    }

    async _preUpdate(data, options, user) {
      await super._preUpdate(data, options, user);
      if (foundry.utils.getProperty(data, "system.location.value") == this.parent.id)
      {
        delete foundry.utils.setProperty(data, "system.location.value", null);
      }
  }

    async _onUpdate(data, options, user)
    {
        await super._onUpdate(data, options, user);

        if (data.system?.location?.value) 
        {
            let allContainers = this.parent.actor?.itemTags["container"];
            if (this.formsLoop(this.parent, allContainers))
            {
              ui.notifications.error("Loop formed - Resetting Container Location");
              this.parent.update({"system.location.value" : ""});
            }
        }
    }


    async _preDelete(options, user) {
        await super._preDelete(options, user);

        // When deleting a container, remove the flag that determines whether it's collapsed in the sheet
        if (this.parent.actor) 
        {
            // Reset the location of items inside
            let items = (this.packsInside || []).concat(this.carrying || []).map(i => i.toObject());
            for (let item of items) 
            {
                item.system.location.value = "";
            }

            await this.parent.actor.update({items, [`flags.wfrp4e.sheetCollapsed.-=${this.parent.id}`]: null });
        }
    }


    formsLoop(container, containerList, stack = []) {
      if (!container.location.value)
        return false
      else if (stack.includes(container.id))
        return true
      else {
        stack.push(container.id);
        return this.formsLoop(containerList.find(c => c.id == container.location.value), containerList, stack)
      }
    }


    computeOwned()
    {
      if (!this.countEnc.value)
      {
        this.encumbrance.value = 0;
      }
    }

    computeEncumbrance() 
    {
      let enc = super.computeEncumbrance();
      if (!this.countEnc.value)
      {
        enc = 0;
      }
      return enc;
    }


    chatData() {
      let properties = [
        `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} GC, ${this.price.ss || 0} SS, ${this.price.bp || 0} BP`,
        `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
        `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
      ];
  
      properties.push(`<b>${game.i18n.localize("Wearable")}</b>: ${(this.wearable.value ? game.i18n.localize("Yes") : game.i18n.localize("No"))}`);
      properties.push(`<b>${game.i18n.localize("ITEM.CountOwnerEnc")}</b>: ${(this.countEnc.value ? game.i18n.localize("Yes") : game.i18n.localize("No"))}`);
      return properties;
    }

    static migrateData(data)
    {
      super.migrateData(data);
      if (data.worn?.value) {
        data.equipped = {value: data.worn.value};
      }
    }
}

let fields$j = foundry.data.fields;

class LocationalItemModel extends BaseItemModel {

    static LOCALIZATION_PREFIXES = ["WH.Components.Locational"];


    static defineSchema() {
        let schema = super.defineSchema();
        schema.prompt = new fields$j.BooleanField();
        schema.location = new fields$j.SchemaField({
            value: new fields$j.StringField(),
            key: new fields$j.StringField(),
        });
        return schema;
    }

    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
            ["location", {
                label: "Location",
                type: "set",
                config: {
                    choices: [
                        "WFRP4E.Locations.head",
                        "WFRP4E.Locations.body",
                        "WFRP4E.Locations.arm",
                        "WFRP4E.Locations.leg"
                    ]
                      .map(game.i18n.localize.bind(game.i18n))
                      .reduce((acc, a) => {
                          acc[a] = a;
                          return acc;
                      }, {}),
                    keyPath: "system.location.value"
                }
            }],
        ]);
    }

    /**
     * Used to identify an Item as one being a child of LocationalItemModel
     *
     * @final
     * @returns {boolean}
     */
    get isLocational() {
        return true;
    }


    async _preCreate(data, options, user) {
        await super._preCreate(data, options, user);

        if (this.parent.isOwned)
        {
            this.checkSourceTest(); // If this item has a source test, use that location
            
            let location = this.location.key;
            if (!location && this.prompt) {
                await this.promptLocation();
            }
            else if (location && !options.skipLocationValue) // The location key might already be defined, but not the display value, so set that accordingly
            {
                this.updateSource({"location.value" : game.wfrp4e.config.locations[location]});
            }
        }
    }

    checkSourceTest()
    {
        let sourceMessageId = this.parent.getFlag("wfrp4e", "sourceMessageId");
        let actor = this.parent?.actor;
        
        if (sourceMessageId && actor)
        {

            let message = game.messages.get(sourceMessageId);
            // Might come from single or opposed test
            let test = message.system.test; 
            let opposed = message.system.opposedTest;

            if (test)
            {
                this.updateSource({"location.key" : actor.convertHitLoc(test.result.hitloc.result)});
            }
            else if (opposed)
            {
                // Opposed test already compute the "true" hit location
                this.updateSource({"location.key" : opposed.result.hitloc.value});
            }
        }
    }

    async promptLocation() {
        let location = await foundry.applications.api.DialogV2.wait({
            window : {title: game.i18n.localize("Location")},
            content: "Choose Location",
            buttons: [
                {
                    action : "left",
                    label: `${game.i18n.localize("Left")} ${this.location.value}`,
                    callback: () => {
                        return "l";
                    }
                },
                {
                    action : "right",
                    label: `${game.i18n.localize("Right")} ${this.location.value}`,
                    callback: () => {
                        return "r";
                    }
                }
            ]
        });


        let displayLocation = this.location.value;

        if (location == "l") {
            displayLocation = `${game.i18n.localize("Left")} ${this.location.value}`;
        }
        if (location == "r") {
            displayLocation = `${game.i18n.localize("Right")} ${this.location.value}`;
        }

        this.parent.updateSource({ "system.location": { key: location + this.location.value, value: displayLocation } });
    }

    usesLocation(weapon) {
        let actor = this.parent?.actor;
        if (!this.location.key || !actor || !weapon.isEquipped) {
            return false;
        }
        
        // At this point, we know weapon is equipped

        if (weapon.system.twohanded.value)
        {
            return true;
        }

        if (actor.mainArmLoc == this.normalizeLocation(this.location.key)) {
            return !weapon.system.offhand.value // If not in offhand, it is in the main hand
        }
        else if (actor.secondaryArmLoc == this.normalizeLocation(this.location.key)) {
            return weapon.system.offhand.value
        }
    }

    // e.g. converts rHand to rArm
    normalizeLocation(key)
    {
        if (key[0] == "r")
        {
            return "rArm";
        }
        else if (key[0] == "l")
        {
            return "lArm";
        }
    }

    get weaponsAtLocation() {
        return this.parent?.actor?.itemTypes.weapon.filter(weapon => this.usesLocation(weapon)) || []
    }
}

let fields$i = foundry.data.fields;

class CriticalModel extends LocationalItemModel {

    static LOCALIZATION_PREFIXES = ["WH.Models.critical"];

    static defineSchema() {
        let schema = super.defineSchema();
        schema.wounds = new fields$i.SchemaField({
            value: new fields$i.StringField(),
        });

        schema.modifier = new fields$i.SchemaField({
            value: new fields$i.StringField(),
        });
        return schema;
    }


    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
            ["wounds", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.wounds.value.label",
                type: "range",
                config: {
                    keyPath: "system.wounds.value"
                }
            }]
        ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of CriticalModel
     *
     * @final
     * @returns {boolean}
     */
    get isCrticial() 
    {
        return true;
    }

    async _onCreate(data, options, user) {
        await super._onCreate(data, options, user);
        if (this.parent.actor && this.parent.actor.type != "vehicle" && game.user.id == user) 
        {
            let actor = this.parent.actor;
            try {

                let newWounds;
                let appliedWounds = Number.parseInt(this.wounds.value);
                if (Number.isInteger(appliedWounds)) 
                {
                    ui.notifications.notify(`${this.wounds.value} ${game.i18n.localize("CHAT.CriticalWoundsApplied")} ${actor.name}`);
                    newWounds = actor.status.wounds.value - appliedWounds;
                } 
                else if (this.wounds.value.toLowerCase() == "death") 
                {
                    newWounds = 0;
                }

                if (game.combat && game.user.isGM) {
                    let minorInfections = game.combat.getFlag("wfrp4e", "minorInfections") || [];
                    minorInfections.push(actor.name);
                    game.combat.setFlag("wfrp4e", "minorInfections", null).then(c => game.combat.setFlag("wfrp4e", "minorInfections", minorInfections));
                }
                if (!isNaN(newWounds))
                {
                    actor.update({ "system.status.wounds.value": newWounds });
                }
            }
            catch (e) {
                console.error(`_onCreate from ${this.parent?.actor?.name} threw error: ${e}.\n Arguments:`, this);
            }
        }
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(`<b>${game.i18n.localize("Wounds")}</b>: ${this.wounds.value}`);
        if (this.modifier.value)
          data.properties.push(`<b>${game.i18n.localize("Modifier")}</b>: ${this.modifier.value}`);
        return data;
      }

      chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Wounds")}</b>: ${this.wounds.value}`);
        properties.push(`<b>${game.i18n.localize("Location")}</b>: ${this.location.value}`);
        if (this.modifier.value)
          properties.push(`<b>${game.i18n.localize("Modifier")}</b>: ${this.modifier.value}`);
        return properties;
      }

}

let fields$h = foundry.data.fields;

/**
 * Represents an Item used by both Patrons and Characters/NPCs
 */
class DiseaseModel extends BaseItemModel {

  static LOCALIZATION_PREFIXES = ["WH.Models.disease"];

  static defineSchema() {
    let schema = super.defineSchema();
    schema.contraction = new fields$h.SchemaField({
      value: new fields$h.StringField(),
    });

    schema.incubation = new fields$h.SchemaField({
      value: new fields$h.StringField(),
      unit: new fields$h.StringField(),
      text : new fields$h.StringField()
    });

    schema.duration = new fields$h.SchemaField({
      value: new fields$h.StringField(),
      unit: new fields$h.StringField(),
      active: new fields$h.BooleanField(),
      text : new fields$h.StringField()
    });

    schema.symptoms = new fields$h.SchemaField({
      value: new fields$h.StringField(),
    });

    schema.diagnosed = new fields$h.BooleanField({initial: false});

    schema.permanent = new fields$h.SchemaField({
      value: new fields$h.StringField(),
    });

    return schema;
  }

  static get compendiumBrowserFilters() {
    return new Map([
      ...Array.from(super.compendiumBrowserFilters),
      ["symptoms", {
        label: this.LOCALIZATION_PREFIXES + ".FIELDS.symptoms.value.label",
        type: "text",
        config: {
          keyPath: "system.symptoms.value",
          multiple: true
        }
      }]
    ]);
  }

  async _onUpdate(data, options, user)
  {
    await super._onUpdate(data, options,user);
    if (data.system?.active && user == game.user.id)
    {
      this.start("duration");
    }

    if (foundry.utils.hasProperty(options, "changed.system.symptoms.value") && !options.skipSymptomHandling)
    {
      this.updateSymptoms(this.symptoms.value);
    }
  }

  async _onCreate(data, options, user)
  {
    await super._onCreate(data, options,user);
    if (this.parent.isOwned && user == game.user.id)
    {
      if (!this.duration.active)
      {
        this.start("incubation");
      }
    }
  }

  /**
   * Used to identify an Item as one being a child or instance of DiseaseModel
   *
   * @final
   * @returns {boolean}
   */
  get isDisease() {
    return true;
  }

  async expandData(htmlOptions) {
    let data = await super.expandData(htmlOptions);
    data.properties.push(`<b>${game.i18n.localize("Contraction")}:</b> ${this.contraction.value}`);
    data.properties.push(`<b>${game.i18n.localize("Incubation")}:</b> ${this.incubation.value} ${this.incubation.unit}`);
    data.properties.push(`<b>${game.i18n.localize("Duration")}:</b> ${this.duration.value} ${this.duration.unit}`);
    data.properties = data.properties.concat(this.parent.effects.map(i => i = "<a class='clickSymptom' data-action='action-link'><i class='fas fa-user-injured'></i> " + i.name.trim() + "</a>").join(", "));

    if (this.permanent.value)
      data.properties.push(`<b>${game.i18n.localize("Permanent")}:</b> ${this.permanent.value}`);

    return data;
  }

  chatData() {
    let properties = [];
    properties.push(`<b>${game.i18n.localize("Contraction")}:</b> ${this.contraction.value}`);
    properties.push(`<b>${game.i18n.localize("Incubation")}:</b> <a class = 'chat-roll'><i class='fas fa-dice'></i> ${this.incubation.value}</a>`);
    properties.push(`<b>${game.i18n.localize("Duration")}:</b> <a class = 'chat-roll'><i class='fas fa-dice'></i> ${this.duration.value}</a>`);
    properties.push(`<b>${game.i18n.localize("Symptoms")}:</b> ${(this.symptoms.value.split(",").map(i => i = "<a class='clickSymptom' data-action='action-link'><i class='fas fa-user-injured'></i> " + i.trim() + "</a>")).join(", ")}`);

    if (this.permanent.value)
      properties.push(`<b>${game.i18n.localize("Permanent")}:</b> ${this.permanent.value}`);

    return properties;
  }

  get show()
  {
    return this.diagnosed || game.user.isGM
  }

  async updateSymptoms(text)
  {
      // Alright get ready for some shit

      // Get all symptoms user inputted
      let symptomText = text.split(",").map(i => i.trim());
  
      // Extract just the name (with no severity)
      let symtomNames = symptomText.map(s => {
        if (s.includes("("))
          return s.substring(0, s.indexOf("(") - 1)
        else return s
      });
  
      // take those names and lookup the associated symptom key
      let symptomKeys = symtomNames.map(s => warhammer.utility.findKey(s, game.wfrp4e.config.symptoms));
  
      // Map those symptom keys into effects, renaming the effects to the user input
      let symptomEffects = symptomKeys.map((s, i) => {
        if (game.wfrp4e.config.symptomEffects[s])
        {
          let effect = foundry.utils.duplicate(game.wfrp4e.config.symptomEffects[s]);
          effect.name = symptomText[i];
          return effect
  
        }
      }).filter(i => !!i);
  
      // Remove all previous symptoms from the item
      let effects = this.parent.effects.map(i => i.toObject()).filter(e => foundry.utils.getProperty(e, "flags.wfrp4e.symptom"));
  
      // Delete previous symptoms
      await this.parent.deleteEmbeddedDocuments("ActiveEffect", effects.map(i => i._id));
  
      // Add symptoms from input
      await this.parent.createEmbeddedDocuments("ActiveEffect", symptomEffects);
  
      return this.parent.update({ "system.symptoms.value": text }, {skipSymptomHandling : true})
  }

  async start(type, update=false)
  {
    if (!type)
    {
      throw new Error("Must provide incubation or duration as type")
    }

    try
    {
      let roll = await new Roll(this[type].value, this.parent).roll({allowInteractive : false});
      let update = {[`system.${type}.value`] : roll.total};
      if (type == "duration")
      {
        update["system.duration.active"] = true;
      }
      await this.parent.update(update);

      let messageData = this.getMessageData();

      messageData.speaker.alias += " " + type;

      roll.toMessage(messageData, {rollMode : "gmroll"});
    } 
    catch (e) 
    {
      ChatMessage.create(this.getMessageData(game.i18n.localize("CHAT.DiseaseRollError")));
    }
  }

  async increment()
  {
    if (this.duration.active)
    {
      return await this.parent.update({"system.duration.value" : Number(this.duration.value) + 1})
    }
    else 
    {
      return await this.parent.update({"system.incubation.value" : Number(this.incubation.value) + 1})
    }
  }

  async decrement()
  {
    let update = {};
    if (this.duration.active)
    {
      if (isNaN(this.duration.value))
      {
        return await this.start("duration");
      }
      let duration = Number(this.duration.value) - 1;
      if (duration == 0)
      {
        return await this.finishDuration();
      }
      else 
      {
        update = {"system.duration.value" : duration};
      }
    }
    else
    {
      if (isNaN(this.incubation.value))
      {
        return await this.start("incubation");
      }
      let incubation = Number(this.incubation.value) - 1;
      if (incubation == 0)
      {
        update = {"system.incubation.value" : incubation};
        await this.start("duration");
      }
      else 
      {
        update = {"system.incubation.value" : incubation};
      }
    }
    return await this.parent.update(update);
  }

  async finishDuration() {
    let disease = this.parent;
    let msg = game.i18n.format("CHAT.DiseaseFinish", { disease: disease.name });
    let removeDisease = true;
    const symptoms = disease.system.symptoms.value.toLowerCase();

    if (symptoms.includes(game.i18n.localize("NAME.Lingering").toLowerCase())) 
    {
      let lingering = disease.effects.find(e => e.name.includes(game.i18n.localize("WFRP4E.Symptom.Lingering")));
      if (lingering) 
      {
        let difficultyname = lingering.specifier;
        let difficulty = warhammer.utility.findKey(difficultyname, game.wfrp4e.config.difficultyNames, { caseInsensitive: true }) || "challenging";
	  
        let test = await this.parent.actor.setupSkill(game.i18n.localize("NAME.Endurance"), {appendTitle: ` - ${game.i18n.localize("NAME.Lingering")}`, fields: {difficulty : difficulty} }, {skipTargets: true});
        await test.roll();

        if (test.failed) 
        {
          let negSL = Math.abs(test.result.SL);
          let lingeringDisease;

          if (negSL <= 1) 
          {
            let roll = (await new Roll("1d10").roll({allowInteractive : false})).total;
            msg += "<br>" + game.i18n.format("CHAT.LingeringExtended", { roll });
            removeDisease = false;
            disease.system.duration.value = roll;
          } 
          else if (negSL <= 5) 
          {
            msg += "<br>" + game.i18n.localize("CHAT.LingeringFestering");
            lingeringDisease = await fromUuid("Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb");
          } 
          else if (negSL >= 6) 
          {
            msg += "<br>" + game.i18n.localize("CHAT.LingeringRot");
            lingeringDisease = await fromUuid("Compendium.wfrp4e-core.items.M8XyRs9DN12XsFTQ");
          }

          if (lingeringDisease) 
          {
            lingeringDisease = lingeringDisease.toObject();
            lingeringDisease.system.incubation.value = 0;
            lingeringDisease.system.duration.active = true;

            await Item.create(lingeringDisease, {parent : disease.actor});
          }
        }
      }
    }

    ChatMessage.create(foundry.utils.mergeObject(this.getMessageData(msg), {whisper : ChatMessage.getWhisperRecipients("GM")}));

    if (removeDisease) 
    {
      await disease.delete();
    }

    return disease;
  }

  // Effects from this disease should transfer if it is not a symptom, or if it is, only if the disease is active
  shouldTransferEffect(effect)
  {
    return !effect.getFlag("wfrp4e", "symptom") || this.duration.active === true;
  }

  getMessageData(content="")
  {
    return {content, speaker : {alias: this.parent.name}, flavor : this.parent.actor.name};
  }
}

let fields$g = foundry.data.fields;

class InjuryModel extends LocationalItemModel
{

  static LOCALIZATION_PREFIXES = ["WH.Models.injury"];


  static defineSchema()
  {
    let schema = super.defineSchema();
    schema.penalty = new fields$g.SchemaField({
      value: new fields$g.StringField(),
    });
    schema.duration = new fields$g.SchemaField({
      value: new fields$g.StringField(),
      active: new fields$g.BooleanField(),
      permanent: new fields$g.BooleanField(),
    });
    return schema;
  }

  static get compendiumBrowserFilters() {
    return new Map([
      ...Array.from(super.compendiumBrowserFilters),
      ["penalty", {
        label: "Penalty",
        type: "text",
        config: {
          keyPath: "system.penalty.value"
        }
      }],
      ["permanent", {
        label: this.LOCALIZATION_PREFIXES + ".FIELDS.duration.permanent.label",
        type: "boolean",
        config: {
          keyPath: "system.duration.permanent"
        }
      }]
    ]);
  }

  /**
   * Used to identify an Item as one being a child or instance of InjuryModel
   *
   * @final
   * @returns {boolean}
   */
  get isInjury() {
    return true;
  }

  chatData() {
    let properties = [];
    properties.push(`<b>${game.i18n.localize("Location")}</b>: ${this.location.value}`);
    if (this.penalty.value)
      properties.push(`<b>${game.i18n.localize("Penalty")}</b>: ${this.penalty.value}`);
    return properties;
  }

  async increment() {
    if (this.duration.active)
    {
      return await this.parent.update({"system.duration.value" : Number(this.duration.value) + 1})
    }
  }

  async decrement() {
    if (isNaN(this.duration.value)) {
      return await this.start();
    }

    let update = {};
    let duration = Number(this.duration.value) - 1;

    if (duration == 0) {
      return await this.finish();
    } else {
      update["system.duration.value"] = duration;
    }

    return await this.parent.update(update);
  }

  async start() {
    try {
      let roll = await new Roll(this.duration.value, this.parent.actor).roll({allowInteractive : false});
      roll.toMessage({speaker: {alias: this.parent.actor.name}, flavor: this.parent.name});

      return await this.parent.update({
        "system.duration.value": roll.total,
        "system.duration.active": true
      });
    } catch (error) {
      return ui.notifications.error(game.i18n.localize("ERROR.ParseInjury"));
    }
  }

  async finish() {
    let msg = game.i18n.format("CHAT.InjuryFinish", {injury: this.parent.name});

    ChatMessage.create(foundry.utils.mergeObject(this.getMessageData(msg), {whisper: ChatMessage.getWhisperRecipients("GM")}));

    await this.parent.delete();
  }

  getMessageData(content = "") {
    return {content, speaker: {alias: this.parent.name}, flavor: this.parent.actor.name};
  }
}

let fields$f = foundry.data.fields;

class MoneyModel extends PhysicalItemModel
{
    static LOCALIZATION_PREFIXES = ["WH.Models.money"];
    
    static defineSchema() 
    {
        // Patron Fields
        let schema = super.defineSchema();

        schema.coinValue = new fields$f.SchemaField({
            value : new fields$f.NumberField({initial: 1}),
        });

        return schema;
    }

    static get compendiumBrowserFilters() {
      return new Map([
        ...Array.from(super.compendiumBrowserFilters),
        ["coinValue", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.coinValue.value.label",
          type: "range",
          config: {
            keyPath: "system.coinValue.value"
          }
        }],
      ]);
    }


    
  async _onUpdate(data, options, user) {
    await super._onUpdate(data, options, user);
    // If credit received from message award, update message
    if (options.updateCreditMessage && game.user.isUniqueGM && this.parent.isEmbedded)
    {
      game.messages.get(options.updateCreditMessage.id).system.updateMessage(this.parent.actor, options.updateCreditMessage.index);
      delete options.updateCreditMessage;
    }
}

  /**
   * Used to identify an Item as one being a child or instance of MoneyModel
   *
   * @final
   * @returns {boolean}
   */
  get isMoney() {
    return true;
  }

    async expandData() {
        let data = await super.expandData(htmlOptions);
        data.properties = [`${game.i18n.localize("ITEM.PenniesValue")}: ${this.coinValue.value}`];
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("ITEM.PenniesValue")}</b>: ${this.coinValue.value}`,
          `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
        ];
        return properties;
      }
}

let fields$e = foundry.data.fields;

class MutationModel extends BaseItemModel
{
    static LOCALIZATION_PREFIXES = ["WH.Models.mutation"];

    static defineSchema() 
    {
        // Patron Fields
        let schema = super.defineSchema();
        schema.mutationType = new fields$e.SchemaField({
            value : new fields$e.StringField({choices : game.wfrp4e.config.mutationTypes}),
        });
        
        schema.modifier = new fields$e.SchemaField({
            value : new fields$e.StringField(),
        });
        return schema;
    }

    static get compendiumBrowserFilters() {
      return new Map([
        ...Array.from(super.compendiumBrowserFilters),
        ["mutationType", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.mutationType.value.label",
          type: "set",
          config: {
            choices : game.wfrp4e.config.mutationTypes,
            keyPath: "system.mutationType.value"
          }
        }],
        ["mutationModifier", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.modifier.value.label",
          type: "text",
          config: {
            keyPath: "system.modifier.value"
          }
        }]
      ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of MutationModel
     *
     * @final
     * @returns {boolean}
     */
    get isMutation() {
      return true;
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(game.wfrp4e.config.mutationTypes[this.mutationType.value]);
        if (this.modifier.value)
          data.properties.push(this.modifier.value);
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("ITEM.MutationType")}</b>: ${game.wfrp4e.config.mutationTypes[this.mutationType.value]}`,
        ];
        if (this.modifier.value)
          properties.push(`<b>${game.i18n.localize("Modifier")}</b>: ${this.modifier.value}`);
        return properties;
      }
    
}

let fields$d = foundry.data.fields;

class OvercastItemModel extends BaseItemModel {


  static defineSchema() 
  {
      let schema = super.defineSchema();
      // Embedded Data Models?
      schema.overcast = new fields$d.SchemaField({
          enabled : new fields$d.BooleanField(),
          label : new fields$d.StringField(),
          valuePerOvercast : new fields$d.SchemaField({
               type : new fields$d.StringField(),
               value : new fields$d.NumberField({initial : 1}),
               SL : new fields$d.BooleanField(),
               additional  : new fields$d.StringField(),
               characteristic  : new fields$d.StringField(),
               bonus : new fields$d.BooleanField(),
               cost : new fields$d.StringField()
          }),
          initial : new fields$d.SchemaField({
              type : new fields$d.StringField(),
              value : new fields$d.NumberField({initial : 1}),
              SL : new fields$d.BooleanField(),
              additional  : new fields$d.StringField(),
              characteristic  : new fields$d.StringField(),
              bonus : new fields$d.BooleanField(),
          })
      });
      return schema;
  }

  /**
   * Used to identify an Item as one being a child of OvercastItemModel
   *
   * @final
   * @returns {boolean}
   */
  get hasOvercast() {
    return true;
  }

  get isMagical() {
    return true;
  }



    /**
   * Turns a formula into a processed string for display
   * 
   * Processes damage formula based - same as calculateSpellAttributes, but with additional
   * consideration to whether its a magic missile or not
   * 
   * @param   {String}  formula         Formula to process - "Willpower Bonus + 4" 
   * @param   {boolean} isMagicMissile  Whether or not it's a magic missile - used in calculating additional damage
   * @returns {String}  Processed formula
   */
      computeSpellDamage(formula, isMagicMissile) {
      try {
      if (formula) {
          formula = formula.toLowerCase();

          if (isMagicMissile) {// If it's a magic missile, damage includes willpower bonus
          formula += "+" + this.parent.actor.characteristics["wp"].bonus;
          }

          let labels = game.wfrp4e.config.characteristics;
          let sortedCharacteristics = Object.entries(this.parent.actor.characteristics).sort((a,b) => -1 * labels[a[0]].localeCompare(labels[b[0]]));
          sortedCharacteristics.forEach(arr => {
          let ch = arr[0];
          // Handle characteristic with bonus first
          formula = formula.replace(game.wfrp4e.config.characteristicsBonus[ch].toLowerCase(), this.parent.actor.characteristics[ch].bonus);
          formula = formula.replace(game.wfrp4e.config.characteristics[ch].toLowerCase(), this.parent.actor.characteristics[ch].value);
          });

          return (0, eval)(formula);
      }
      return 0;
      }
      catch (e) {
        console.error(`Spell from ${this.parent?.actor?.name} threw error: ${e}.\n Arguments:`, this, formula);
        if (ui.notifications) {
          throw ui.notifications.error(game.i18n.format("ERROR.ParseSpell"))
        }
      }
  }



  // Don't really like this here as it uses assumed subclass data, but it'll do for now
  computeOvercastingData() {
    let usage = {
      damage: undefined,
      range: undefined,
      duration: undefined,
      target: undefined,
      other: undefined,
    };

    let damage = this.Damage;
    let target = this.Target;
    let duration = this.Duration;
    let range = this.Range;

    if (this.magicMissile?.value) {
      usage.damage = {
        label: game.i18n.localize("Damage"),
        count: 0,
        initial: parseInt(damage) || damage,
        current: parseInt(damage) || damage,
        available: false
      };
    }
    if (parseInt(target) && !includesMaximum(target)) {
      usage.target = {
        label: game.i18n.localize("Target"),
        count: 0,
        AoE: false,
        initial: parseInt(target) || target,
        current: parseInt(target) || target,
        unit: "",
        available: false
      };
    }
    else if (target?.includes("AoE") && !includesMaximum(target)) {
      let aoeValue = target.substring(target.indexOf("(") + 1, target.length - 1);
      usage.target = {
        label: game.i18n.localize("AoE"),
        count: 0,
        AoE: true,
        initial: parseInt(aoeValue) || aoeValue,
        current: parseInt(aoeValue) || aoeValue,
        unit: aoeValue.split(" ")[1],
        available: false
      };
    }
    if (parseInt(duration) && !includesMaximum(duration)) {
      usage.duration = {
        label: game.i18n.localize("Duration"),
        count: 0,
        initial: parseInt(duration) || duration,
        current: parseInt(duration) || duration,
        unit: duration.split(" ")[1],
        available: false
      };
    }
    if (parseInt(range) && !includesMaximum(range)) {
      usage.range = {
        label: game.i18n.localize("Range"),
        count: 0,
        initial: parseInt(range) || aoeValue,
        current: parseInt(range) || aoeValue,
        unit: range.split(" ")[1],
        available: false
      };
    }

    if (this.overcast?.enabled) {
      let other = {
        label: this.overcast.label,
        count: 0
      };


      // Set initial overcast option to type assigned, value is arbitrary, characcteristics is based on actor data, SL is a placeholder for tests
      if (this.overcast.initial.type == "value") {
        other.initial = parseInt(this.overcast.initial.value) || 0;
        other.current = parseInt(this.overcast.initial.value) || 0;
      }
      else if (this.overcast.initial.type == "characteristic") {
        let char = this.parent.actor.characteristics[this.overcast.initial.characteristic];

        if (this.overcast.initial.bonus)
          other.initial = char.bonus;
        else
          other.initial = char.value;

        other.current = other.initial;
      }
      else if (this.overcast.initial.type == "SL") {
        other.initial = "SL";
        other.current = "SL";
      }

      // See if overcast increments are also based on characteristics, store that value so we don't have to look it up in the roll class
      if (this.overcast.valuePerOvercast.type == "characteristic") {
        let char = this.parent.actor.characteristics[this.overcast.valuePerOvercast.characteristic];

        if (this.overcast.valuePerOvercast.bonus)
          other.increment = char.bonus;
        else
          other.increment = char.value;

        //other.increment = other.initial;
      }

      usage.other = other;
    }

    this.overcast.usage = usage;

    // Perhaps not the best implementation, but if a spell range (or other) says "maximum", don't allow overcasting
    function includesMaximum(string) {
      return string.toLowerCase().includes(game.i18n.localize("ITEM.Maximum").toLowerCase());
    }

  }



  /**
   * Turns a formula into a processed string for display
   * 
   * Turns a spell attribute such as "Willpower Bonus Rounds" into a more user friendly, processed value
   * such as "4 Rounds". If the aoe is checked, it wraps the result in AoE (Result).
   * 
   * @param   {String}  formula   Formula to process - "Willpower Bonus Rounds" 
   * @param   {boolean} aoe       Whether or not it's calculating AoE (changes string return)
   * @returns {String}  formula   processed formula
   */
  computeSpellPrayerFormula(type, aoe = false, formulaOverride) {
    let formula = formulaOverride || this[type]?.value;
    try {
      if (Number.isNumeric(formula))
        return formula

      formula = formula.toLowerCase();

      // Do not process these special values
      if (formula != game.i18n.localize("You").toLowerCase() && formula != game.i18n.localize("Special").toLowerCase() && formula != game.i18n.localize("Instant").toLowerCase()) {
        // Iterate through characteristics
        let labels = game.wfrp4e.config.characteristics;
        let sortedCharacteristics = Object.entries(this.parent.actor.characteristics).sort((a,b) => -1 * labels[a[0]].localeCompare(labels[b[0]]));
        sortedCharacteristics.forEach(arr => {
          let ch = arr[0];
          // Handle characteristic with bonus first
          formula = formula.replace(game.wfrp4e.config.characteristicsBonus[ch].toLowerCase(), this.parent.actor.characteristics[ch].bonus);
          formula = formula.replace(game.wfrp4e.config.characteristics[ch].toLowerCase(), this.parent.actor.characteristics[ch].value);
        });

        let total = 0;
        let i = 0;
        let s = formula;
        for (; i < s.length; i++) {
          if (!(!isNaN(parseInt(s[i])) || s[i] == ' ' || s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/')) {
            break;
          }
        }
        if (i > 0) {
          if (i != s.length) {
            total = (0, eval)(s.substr(0, i - 1)) || "";
            formula = total.toString() + " " + s.substr(i).trim();
          } else {
            total = (0, eval)(s) || "";
            formula = total.toString();
          }
        }

        // If AoE - wrap with AoE ( )
        if (aoe)
          formula = "AoE (" + formula.capitalize() + ")";
      }
      return formula.capitalize();
    }
    catch (e) {
      console.error(`computeSpellPrayerFormula from ${this.parent?.actor?.name} threw error: ${e}.\n Arguments:`, this, formula);
      return 0;
    }
  }
}

let fields$c = foundry.data.fields;

class PrayerModel extends OvercastItemModel
{
    static LOCALIZATION_PREFIXES = ["WH.Models.prayer"];

    static defineSchema() 
    {
        let schema = super.defineSchema();

        schema.type = new fields$c.SchemaField({
            value : new fields$c.StringField({initial : "blessing", choices : game.wfrp4e.config.prayerTypes}),
        });
        schema.god = new fields$c.SchemaField({
            value : new fields$c.StringField(),
        });             
        schema.range = new fields$c.SchemaField({
            value : new fields$c.StringField(),
        });
        schema.target = new fields$c.SchemaField({
            value : new fields$c.StringField(),
            aoe : new fields$c.BooleanField(),
            extendableAoE : new fields$c.BooleanField(),
        });
        schema.duration = new fields$c.SchemaField({
            value : new fields$c.StringField(),
            extendable : new fields$c.BooleanField(),
        });
        schema.damage = new fields$c.SchemaField({
            dice : new fields$c.StringField(),
            value : new fields$c.StringField(),
            addSL : new fields$c.BooleanField(),
        });
        return schema;
    }

    static get compendiumBrowserFilters() {
      return new Map([
        ...Array.from(super.compendiumBrowserFilters),
        ["prayerType", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.type.value.label",
          type: "set",
          config: {
            choices : game.wfrp4e.config.prayerTypes,
            keyPath: "system.type.value"
          }
        }],
        ["god", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.god.value.label",
          type: "text",
          config: {
            keyPath: "system.god.value"
          }
        }],
        ["range", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.range.value.label",
          type: "text",
          config: {
            keyPath: "system.range.value"
          }
        }],
        ["target", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.target.value.label",
          type: "text",
          config: {
            keyPath: "system.target.value"
          }
        }],
        ["aoe", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.target.aoe.label",
          type: "boolean",
          config: {
            keyPath: "system.target.aoe"
          }
        }],
        ["duration", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.duration.value.label",
          type: "text",
          config: {
            keyPath: "system.duration.value"
          }
        }],
        ["doesDamage", {
          label: "SHEET.DoesDamage",
          type: "boolean",
          config: {
            keyPath: "system.damage",
            valueGetter: (data) => !!data.system.damage?.value?.length || !!data.system.damage?.dice?.length,
          }
        }],
      ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of PrayerModel
     *
     * @final
     * @returns {boolean}
     */
    get isPrayer() {
      return true;
    }

    get Target() {
        return this.computeSpellPrayerFormula("target", this.target.aoe)
      }


    get Duration() {
      let duration = this.computeSpellPrayerFormula("duration", this.range?.aoe);
      return duration
    }

      get Range() {
        return this.computeSpellPrayerFormula("range")
    }

    get Damage() {
        return parseInt(this.computeSpellDamage(this.damage.value, false) || 0)
      }

      get DamageString() {
        let string = this.Damage;
    
        if (this.damage.dice)
          string += `+ ${this.damage.dice}`;

        return string
      }
  

    async _preCreate(data, options, user) 
    {
      await super._preCreate(data, options, user);

        if (this.parent.isOwned) 
        {
            let actor = this.parent.actor;
            if (actor.type == "character" && this.type.value == "miracle") {
                Advancement.miracleGainedDialog(this.parent, actor);
            }
        }
    }

    computeOwned()
    {
        super.computeOwned();
        this.computeOvercastingData();
    }

    getSkillToUse(actor) {
      actor = actor || this.parent.actor;
      let skills = actor?.itemTags["skill"] || [];
      let skill = skills.find(i => i.name.toLowerCase() == game.i18n.localize("NAME.Pray").toLowerCase());
      return skill;
    }


    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(`${game.i18n.localize("Range")}: ${this.Range}`);
        data.properties.push(`${game.i18n.localize("Target")}: ${this.Target}`);
        data.properties.push(`${game.i18n.localize("Duration")}: ${this.Duration}`);
        let damage = this.Damage || "";
        if (this.damage.dice)
          damage += " + " + this.damage.dice;
        if (this.damage.addSL)
          damage += " + " + game.i18n.localize("SL");
        if (this.damage.value)
          data.properties.push(`${game.i18n.localize("Damage")}: ${this.DamageString}`);
        return data;
      }

      chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);
        properties.push(`<b>${game.i18n.localize("Target")}</b>: ${this.target.value}`);
        properties.push(`<b>${game.i18n.localize("Duration")}</b>: ${this.duration.value}`);
        if (this.damage.value)
          properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);
        return properties;
      }
    
}

foundry.data.fields;

class PsychologyModel extends BaseItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();

        return schema;
    }

    /**
     * Used to identify an Item as one being a child or instance of PsychologyModel
     *
     * @final
     * @returns {boolean}
     */
    get isPsychology() {
        return true;
    }

    chatData() {
        return [];
      }
}

let fields$b = foundry.data.fields;


class TalentModel extends BaseItemModel {
    static LOCALIZATION_PREFIXES = ["WH.Models.talent"];
    static defineSchema() {
        let schema = super.defineSchema();
        schema.max = new fields$b.SchemaField({
            value: new fields$b.StringField({choices : game.wfrp4e.config.talentMax})
        });
        schema.advances = new fields$b.SchemaField({
            value: new fields$b.NumberField({initial : 1, min: 1}),
            force: new fields$b.BooleanField()
        });
        schema.career = new fields$b.SchemaField({
            value: new fields$b.StringField()
        });
        schema.tests = new fields$b.SchemaField({
            value: new fields$b.StringField()
        });
        return schema;
    }

    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
            ["max", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.max.value.label",
                type: "set",
                config: {
                    choices : game.wfrp4e.config.talentMax,
                    keyPath: "system.max.value"
                }
            }],
            ["tests", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.tests.value.label",
                type: "text",
                config: {
                    keyPath: "system.tests.value",
                }
            }],
        ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of TalentModel
     *
     * @final
     * @returns {boolean}
     */
    get isTalent() {
        return true;
    }

    get Max() {
        switch (this.max.value) // Turn its max value into "numMax", which is an actual numeric value
        {
            case '1':
                return 1;

            case '2':
                return 2;

            case '3':
                return 3;

            case '4':
                return 4;

            case 'none':
                return "-";

            default:
                return this.parent.actor.characteristics[this.max.value].bonus;
        }
    }

    get cost() {
        return (this.Advances + 1) * 100
    }

    get Advances() {
        if (this.parent.isOwned) {
          let talents = this.parent.actor.itemTags["talent"];
          return talents.filter(i => i.name == this.parent.name).reduce((prev, current) => prev += current.advances.value, 0)
        }
        else {
          return this.advances.value
        }
      }

    computeOwned() {
        this.advances.indicator = this.advances.force;
    }

    addCareerData(career) {
        if (!career)
            return

        this.advances.career = this;
        this.advances.indicator = this.advances.indicator || !!this.advances.career || false;
    }

    chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Max")}: </b> ${game.wfrp4e.config.talentMax[this.max.value]}`);
        if (this.tests.value)
            properties.push(`<b>${game.i18n.localize("Tests")}: </b> ${this.tests.value}`);
        return properties;
    }
}

let fields$a = foundry.data.fields;

/**
 *
 * @extends EquippableItemModel
 * @mixes PropertiesMixin
 */
class TrappingModel extends PropertiesMixin(EquippableItemModel)
{
    static LOCALIZATION_PREFIXES = ["WH.Models.trapping"];
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.trappingType = new fields$a.SchemaField({
            value: new fields$a.StringField({choices: game.wfrp4e.config.trappingTypes})
        }),
        schema.spellIngredient = new fields$a.SchemaField({
            value: new fields$a.StringField()
        });
        return schema;
    }

    static get compendiumBrowserFilters() {
      return new Map([
        ...Array.from(super.compendiumBrowserFilters),
        ["trappingType", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.trappingType.value.label",
          type: "set",
          config: {
            choices : game.wfrp4e.config.trappingTypes,
            keyPath: "system.trappingType.value"
          }
        }]
      ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of TrappingModel
     *
     * @final
     * @returns {boolean}
     */
    get isTrapping() {
      return true;
    }

    async _preCreate(data, options, user)
    {
       await super._preCreate(data, options, user);

       if (this.trappingType == "clothingAccessories" && this.parent.isOwned && this.parent.actor.type != "character" && this.parent.actor.type != "vehicle")
       {
        this.updateSource({"worn" : true}); // TODO: migrate this into a unified equipped property
       }
    }

    get worn() {
      console.warn("[DEPRECATION] `container.worn` is deprecated, please use `container.equipped.value` instead");
      return this.equipped.value;
    }
  
    get weighsLessEquipped() {
      return true;
    }
  
    get canEquip() {
      return this.trappingType.value === "clothingAccessories";
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
    
        let itemProperties = this.Qualities.concat(this.Flaws);
        for (let prop of itemProperties)
          data.properties.push("<a data-action='postItemProperty' class ='item-property'>" + prop + "</a>");
    
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("ITEM.TrappingType")}</b>: ${game.wfrp4e.config.trappingCategories[this.trappingType.value]}`,
          `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
          `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
          `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
        ];
    
        // Make qualities and flaws clickable
        if (this.qualities.value.length)
          properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a data-action='postItemProperty' class ='item-property'>" + i + "</a>").join(", ")}`);
    
        if (this.flaws.value.length)
          properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a data-action='postItemProperty' class ='item-property'>" + i + "</a>").join(", ")}`);
    
        return properties;
      }

    static migrateData(data)
    {
      super.migrateData(data);

      if (data.worn) {
        data.equipped = {value: data.worn};
      }
    }
}

let fields$9 = foundry.data.fields;

class SkillModel extends BaseItemModel {
    static LOCALIZATION_PREFIXES = ["WH.Models.skill"];

    static defineSchema() {
        let schema = super.defineSchema();
        schema.advanced = new fields$9.SchemaField({
            value: new fields$9.StringField({initial : "bsc", choices : game.wfrp4e.config.skillTypes}),
        });
        schema.grouped = new fields$9.SchemaField({
            value: new fields$9.StringField({ initial: "noSpec", choices : game.wfrp4e.config.skillGroup })
        });
        schema.characteristic = new fields$9.SchemaField({
            value: new fields$9.StringField({ initial: "ws", choices : game.wfrp4e.config.characteristics }),
        });
        schema.advances = new fields$9.SchemaField({
            value: new fields$9.NumberField(),
            costModifier: new fields$9.NumberField(),
            force: new fields$9.BooleanField(),
        });
        schema.modifier = new fields$9.SchemaField({
            value: new fields$9.NumberField(),
        });
        schema.total = new fields$9.SchemaField({
            value: new fields$9.NumberField(),
        });
        return schema;
    }

    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
            ["advanced", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.advanced.value.label",
                type: "set",
                config: {
                    choices : game.wfrp4e.config.skillTypes,
                    keyPath: "system.advanced.value"
                }
            }],
            ["grouped", {
                label: "ITEM.IsSpec",
                type: "boolean",
                config: {
                    keyPath: "system.grouped.value",
                    valueGetter: (data) => data.system.grouped?.value === "isSpec"
                }
            }],
            ["characteristic", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.characteristic.value.label",
                type: "set",
                config: {
                    choices : game.wfrp4e.config.characteristics,
                    keyPath: "system.characteristic.value"
                }
            }],
        ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of SkillModel
     *
     * @final
     * @returns {boolean}
     */
    get isSkill() {
        return true;
    }

    get cost() {
          return Advancement.calculateAdvCost(this.advances.value, "skill", this.advances.costModifier)
    }

    get modified() {
        if (this.modifier) {
          if (this.modifier.value > 0)
            return "positive";
          else if (this.modifier.value < 0)
            return "negative"
        }
        return ""
      }

    get isGrouped() 
    {
        return this.grouped.value == "isSpec";
    }

    get isBasic()
    {
        return this.advanced.value == "bsc";
    }

    async _preUpdate(data, options, user) {
        await super._preUpdate(data, options, user);
        let actor = this.parent.actor;

        if (actor?.type == "character" && this.isGrouped && options.changed.name) 
        {
            this._handleSkillNameChange(data.name, this.parent.name);
        }

        if (actor?.type == "character" && foundry.utils.getProperty(options.changed, "system.advances.value") && !options.skipExperienceChecks)
        {
            let resolved = await Advancement.advancementDialog(this.parent, data.system.advances.value, "skill", actor);
    
            if (!resolved)  
            {
                data.system.advances.value = this.advances.value;
                this.parent.actor.sheet.render(true); // this doesn't feel right but otherwise the inputted value will still be on the sheet
            }
        }
    }

    async _preCreate(data, options, user)
    {
        await super._preCreate(data, options, user);
        await this._handleSpecialisationChoice(data, options, user);
        return this._handleSkillMerging(data, options,user);
    }

    async _onUpdate(data, options, user)
    {
        await super._onUpdate(data, options, user);
    }

    computeOwned()
    {
        this.total.value = this.modifier.value + this.advances.value + this.parent.actor.system.characteristics[this.characteristic.value].value;
        this.advances.indicator = this.advances.force;
    }

    addCareerData(career) {
        if (!career)
          return
          
        this.advances.career = this;
        if (this.advances.value >= career.level.value * 5)
        {
            this.advances.complete = true;
        }
        this.advances.indicator = this.advances.indicator || !!this.advances.career || false;
      }

    async _handleSpecialisationChoice(data, options, user)
    {
        if (this.parent.isEmbedded && !options.skipSpecialisationChoice)
        {
            // If skill has (any) or (), ask for a specialisation
            if (this.parent.specifier.toLowerCase() == game.i18n.localize("SPEC.Any").toLowerCase() || (this.isGrouped && !(this.parent.specifier)))
            {
                let skills = await warhammer.utility.findAllItems("skill", game.i18n.localize("SHEET.LoadingSkills"), true);
                let specialisations = skills.filter(i => i.name.split("(")[0]?.trim() == this.parent.baseName);
                let effects = [];

                // if specialisations are found, prompt it, if not, skip to value dialog
                let choice = specialisations.length > 0 ? await ItemDialog.create(specialisations, 1, {title : game.i18n.localize("SHEET.SkillSpecialization"), text : game.i18n.localize("SHEET.SkillSpecializationText")}) : [];
                let newName = "";
                if (choice[0])
                {
                    // Need to fetch the item to get effects...
                    let chosenSkill = await fromUuid(choice[0].uuid);
                    newName = chosenSkill.name;
                    effects = chosenSkill.effects?.contents.map(i => i.toObject());
                }
                else 
                {
                    newName = this.parent.baseName + ` (${await ValueDialog.create({text: game.i18n.localize("SHEET.SkillSpecializationEnter"), title : game.i18n.localize("SHEET.SkillSpecialization")})})`;

                }

                if (newName)
                {
                    this._handleSkillNameChange(newName, this.parent.name, options.career);
                    this.parent.updateSource({name : newName, effects});
                }
            }
        }
    }

    // If an owned (grouped) skill's name is changing, change the career data to match
    _handleSkillNameChange(newName, oldName, skipPrompt=false) {
        let currentCareer = this.parent.actor?.currentCareer;
        if (!currentCareer) 
        {
            return
        }
        else 
        {
            currentCareer.system.changeSkillName(newName, oldName, skipPrompt);
        }
    }
    
    _handleSkillMerging(data, options, user)
    {
        if (this.parent.isEmbedded && this.parent.actor.inCollection) // prevent error during chargen
        {
            let actor = this.parent.actor;

            let existing = actor.itemTags.skill.find(i => i.name == this.parent.name);

            if (existing)
            {
                existing.update({"system.advances.value" : existing.advances.value + this.advances.value}, options);
            }
        }
    }

    
    async allowCreation(data, options, user)
    {
        let allowed = super.allowCreation(data, options, user);
        if (allowed && this.parent.isEmbedded && this.advances.value != 0)
        {
            let actor = this.parent.actor;
            let existing = actor.itemTags.skill.find(i => i.name == this.parent.name);
            allowed = !existing;
        }
        return allowed
    }

    chatData() {
        let properties = [];
        properties.push(this.advanced == "adv" ? `<b>${game.i18n.localize("Advanced")}</b>` : `<b>${game.i18n.localize("Basic")}</b>`);
        return properties;
    }
    
}

let fields$8 = foundry.data.fields;

class SpellModel extends OvercastItemModel {
    static LOCALIZATION_PREFIXES = ["WH.Models.spell"];

    static defineSchema() {
        let schema = super.defineSchema();

        schema.lore = new fields$8.SchemaField({
            value: new fields$8.StringField(),
            effectString: new fields$8.StringField(),
        });
        schema.range = new fields$8.SchemaField({
            value: new fields$8.StringField(),
            vortex: new fields$8.BooleanField(),
        });
        schema.target = new fields$8.SchemaField({
            value: new fields$8.StringField(),
            aoe: new fields$8.BooleanField(),
        });
        schema.duration = new fields$8.SchemaField({
            value: new fields$8.StringField(),
            extendable: new fields$8.BooleanField(),
        });
        schema.damage = new fields$8.SchemaField({
            dice: new fields$8.StringField(),
            value: new fields$8.StringField(),
        });
        schema.cn = new fields$8.SchemaField({
            value: new fields$8.NumberField(),
            SL: new fields$8.NumberField(),
        });
        schema.magicMissile = new fields$8.SchemaField({
            value: new fields$8.BooleanField(),
        });
        schema.ritual = new fields$8.SchemaField({
            value: new fields$8.BooleanField(),
            type: new fields$8.StringField(),
            xp: new fields$8.NumberField(),
        });
        schema.memorized = new fields$8.SchemaField({
            value: new fields$8.BooleanField(),
        });
        schema.skill = new fields$8.SchemaField({
            value: new fields$8.StringField(),
        });
        schema.ingredients = new fields$8.ArrayField(new fields$8.StringField());
        schema.currentIng = new fields$8.SchemaField({
            value: new fields$8.StringField(),
        });
        schema.wind = new fields$8.SchemaField({
            value: new fields$8.StringField(),
        });
        return schema;
    }

    static get compendiumBrowserFilters() {
      return new Map([
        ...Array.from(super.compendiumBrowserFilters),
        ["lore", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.lore.value.label",
          type: "set",
          config: {
            blank: "None",
            choices : game.wfrp4e.config.magicLores,
            keyPath: "system.lore.value"
          }
        }],
        ["range", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.range.value.label",
          type: "text",
          config: {
            keyPath: "system.range.value"
          }
        }],
        ["target", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.target.value.label",
          type: "text",
          config: {
            keyPath: "system.target.value"
          }
        }],
        ["aoe", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.target.aoe.label",
          type: "boolean",
          config: {
            keyPath: "system.target.aoe"
          }
        }],
        ["duration", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.duration.value.label",
          type: "text",
          config: {
            keyPath: "system.duration.value"
          }
        }],
        ["magicMissile", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.magicMissile.value.label",
          type: "boolean",
          config: {
            keyPath: "system.magicMissile.value",
          }
        }],
        ["ritual", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.ritual.value.label",
          type: "boolean",
          config: {
            keyPath: "system.ritual.value",
          }
        }],
        ["doesDamage", {
          label: "SHEET.DoesDamage",
          type: "boolean",
          config: {
            keyPath: "system.damage",
            valueGetter: (data) => !!data.system.damage?.value?.length || !!data.system.damage?.dice?.length,
          }
        }],
      ]);
    }

    async _preUpdate(data, options, user)
    {
      await super._preUpdate(data, options, user);
      if (foundry.utils.hasProperty(options.changed, "system.cn.SL"))
      {
          data.system.cn.SL = Math.max(data.system.cn.SL, 0);
      }

      if (foundry.utils.hasProperty(options, "changed.system.cn.SL") && game.settings.get("wfrp4e", "useWoMChannelling") && !options.updateWoM)
      {
        let items = this.parent.actor?.items.filter(s => s.type == "spell" && s.system.lore.value == this.lore.value && s.id != this.parent.id).map(s => {
          return {
            _id : s.id,
            "system.cn.SL" : options.changed.system.cn.SL
          }
        });
        this.parent.actor?.updateEmbeddedDocuments("Item", items, {updateWoM : true});
      }
    }

    async _onUpdate(data, options, user)
    {
      if (game.user.id == user && this.parent.actor?.type == "character" && foundry.utils.hasProperty(options.changed, "system.memorized.value"))
      {
        if (options.changed.system.memorized.value)
        {
          WFRP_Audio.PlayContextAudio({ item: this.parent, action: "memorize" });
          await Advancement.memorizeCostDialog(this.parent, this.parent.actor);
        }
        else 
        {
          WFRP_Audio.PlayContextAudio({ item: this.parent, action: "unmemorize" });
        }
      }
    }

    /**
     * Used to identify an Item as one being a child or instance of SpellModel
     *
     * @final
     * @returns {boolean}
     */
    get isSpell() {
      return true;
    }

    get ingredient() {
        if (this.currentIng.value)
          return this.parent.actor?.items.get(this.currentIng.value)
      }


      get ingredientList() {
        return this.parent.actor?.itemTags["trapping"].filter(t => t.trappingType.value == "ingredient" && t.spellIngredient.value == this.parent.id)
      }

      get Target() {
        return this.computeSpellPrayerFormula("target", this.target.aoe)
      }

      get Duration() {
        let duration = this.computeSpellPrayerFormula("duration", this.range?.aoe);
        if (this.duration?.extendable)
          duration += "+";
        return duration
      }

      get Range() {
          return this.computeSpellPrayerFormula("range")
      }

      get Damage() {
        return parseInt(this.computeSpellDamage(this.damage.value, this.magicMissile.value) || 0)
      }    
    
    

    async _preCreate(data, options, user) {
        await super._preCreate(data, options, user);

        if (this.parent.isOwned) {
            let actor = this.parent.actor;
            if (actor.type != "character" && actor.type != "vehicle") {
                this.updateSource({"memorized.value" : true});
            }

            if (actor.type == "character" && (this.lore.value == "petty" || this.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))) {
                Advancement.memorizeCostDialog(this.parent, actor);
            }
        }
    }

    computeBase() {
        let lore = foundry.utils.deepClone(game.wfrp4e.config.loreEffects[this.lore.value]);
        if (lore) {
            foundry.utils.setProperty(lore, "flags.wfrp4e.path", "system.lore.effect");
            this.lore.effect = new ActiveEffectWFRP4e(lore, { parent: this.parent });
        }
        this._addSpellDescription();
    }

    computeOwned()
    {
        this.cn.value = this.memorized.value ? this.cn.value : this.cn.value * 2;
        if (this.ritual?.value && !this.memorized.value)
        {
          this.cn.value *= 2; // Unmemorized rituals are 4 * CN
        }
        else 
        {
          this.computeOvercastingData();
        }
    }


    getSkillToUse(actor) 
    {
        actor = actor || this.parent.actor;
        let skills = actor?.itemTags["skill"] || [];
        let skill;
        // Use skill override, if not found, use Language (Magick)
        if (this.skill.value)
        {
            skill = skills.find(i => i.name.toLowerCase() == this.skill.value.toLowerCase());
        }
        if (!skill)
        {
            skill = skills.find(i => i.name.toLowerCase() == `${game.i18n.localize("NAME.Language")} (${game.i18n.localize("SPEC.Magick")})`.toLowerCase());
        }
        return skill
    }

    getOtherEffects()
    {
        return super.getOtherEffects().concat(this.lore.effect || [])
    }

    /**
    * Augments the spell item's description with the lore effect
    * 
    * The spell's lore is added at the end of the spell's description for
    * an easy reminder. However, this causes issues because we don't want
    * the lore to be 'saved' in the description. So we append the lore
    * if it does not already exist
    * 
    * @param {Object} spell 'spell' type item
    */
    _addSpellDescription() {
        let description = this.description.value;
        if (description && description.includes(game.i18n.localize("SPELL.Lore")))
            return description

        // Use lore override if it exists
        if (this.lore.effectString)
            description += `<p>\n\n <b>${game.i18n.localize("SPELL.Lore")}</b> ${this.lore.effectString}<p>`;
        // Otherwise, use config value for lore effect
        else if (game.wfrp4e.config.loreEffectDescriptions && game.wfrp4e.config.loreEffectDescriptions[this.lore.value])
            description += `<p>\n\n <b>${game.i18n.localize("SPELL.Lore")}</b> ${game.wfrp4e.config.loreEffectDescriptions[this.lore.value]}<p>`;

        this.description.value = description;
    }


    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(`${game.i18n.localize("Range")}: ${this.Range}`);
        let target = this.Target;
        if (target?.includes("AoE"))
          target = `<a class='aoe-template' data-id="${this.id}" data-actor-id="${this.parent.actor.id}"><i class="fas fa-ruler-combined"></i>${target}</a>`;
        data.properties.push(`${game.i18n.localize("Target")}: ${target}`);
        data.properties.push(`${game.i18n.localize("Duration")}: ${this.Duration}`);
        if (this.magicMissile.value)
          data.properties.push(`${game.i18n.localize("Magic Missile")}: +${this.Damage}`);
        else if (this.damage.value || this.damage.dices) {
          let damage = this.Damage || "";
          if (this.damage.dice)
            damage += " + " + this.damage.dice;
          data.properties.push(`${game.i18n.localize("Damage")}: ${damage}`);
        }
        return data;
      }

      chatData() {
        let properties = [];
        if (game.wfrp4e.config.magicLores[this.lore.value])
          properties.push(`<b>${game.i18n.localize("Lore")}</b>: ${game.wfrp4e.config.magicLores[this.lore.value]}`);
        else
          properties.push(`<b>${game.i18n.localize("Lore")}</b>: ${this.lore.value}`);
        properties.push(`<b>${game.i18n.localize("CN")}</b>: ${this.cn.value}`);
        properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);
        properties.push(`<b>${game.i18n.localize("Target")}</b>: ${this.target.value}`);
        properties.push(`<b>${game.i18n.localize("Duration")}</b>: ${this.duration.value}`);
        if (this.damage.value)
          properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);
    
        return properties;
      }


}

let fields$7 = foundry.data.fields;

class TraitModel extends PropertiesMixin(BaseItemModel)
{
    static LOCALIZATION_PREFIXES = ["WH.Models.trait"];
    static defineSchema() 
    {
        let schema = super.defineSchema();

        schema.category = new fields$7.StringField({initial : "standard", choices : {standard : game.i18n.localize("ITEM.Standard"), vehicle : game.i18n.localize("SPEC.Vehicle")}});

        schema.rollable = new fields$7.SchemaField({
            value : new fields$7.BooleanField({}),
            damage : new fields$7.BooleanField({}),
            skill : new fields$7.StringField({}),
            rollCharacteristic : new fields$7.StringField({choices : game.wfrp4e.config.characteristics}),
            bonusCharacteristic : new fields$7.StringField({choices : game.wfrp4e.config.characteristics,  blank: true}),
            dice : new fields$7.StringField({}),
            defaultDifficulty : new fields$7.StringField({initial : "challenging", choices : game.wfrp4e.config.difficultyLabels}),
            SL : new fields$7.BooleanField({}),
            attackType : new fields$7.StringField({initial: "melee", choices : {melee : game.i18n.localize("Melee"), ranged : game.i18n.localize("Ranged")}})
        });

        schema.specification = new fields$7.SchemaField({
            value : new fields$7.StringField(),
        });

        schema.qualities = new fields$7.SchemaField({
            value: new fields$7.ArrayField(new fields$7.ObjectField({}))
        });

        schema.flaws = new fields$7.SchemaField({
            value: new fields$7.ArrayField(new fields$7.ObjectField({}))
        });

        schema.disabled = new fields$7.BooleanField({initial : false});
    
        return schema;
    }

    static get compendiumBrowserFilters() {
      return new Map([
        ...Array.from(super.compendiumBrowserFilters),
        ["category", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.category.label",
          type: "set",
          config: {
            choices: {standard: game.i18n.localize("ITEM.Standard"), vehicle: game.i18n.localize("SPEC.Vehicle")},
            keyPath: "system.category"
          }
        }],
        ["rollable", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.rollable.value.label",
          type: "boolean",
          config: {
            keyPath: "system.rollable.value",
          }
        }],
        ["doesDamage", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.rollable.damage.label",
          type: "boolean",
          config: {
            keyPath: "system.rollable.damage",
          }
        }],
        ["rollCharacteristic", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.rollable.rollCharacteristic.label",
          type: "set",
          config: {
            keyPath: "system.rollable.rollCharacteristic",
            choices : game.wfrp4e.config.characteristics
          }
        }],
        ...this.compendiumBrowserPropertiesFilter(),
      ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of TraitModel
     *
     * @final
     * @returns {boolean}
     */
    get isTrait() {
      return true;
  }

    get enabled() {
      return !this.disabled;
    }
    
    get isMelee()
    {
        return this.attackType == "melee";
    }

    get isRanged()
    {
        return this.attackType == "ranged";
    }

    get attackType() {
        if (this.rollable.damage)
          return this.rollable.attackType
      }

      get DisplayName() {
        return this.specification.value ? this.parent.name + " (" + this.Specification + ")" : this.parent.name;
      }


    get Damage() {
        let damage;
        let actor = this.parent.actor;
        if (this.rollable.damage)
            damage = this.Specification;
    
    
        //@HOUSE
        if (game.settings.get("wfrp4e", "homebrew").mooSizeDamage && actor.sizeNum > 3) 
        {
          if (this.rollable.bonusCharacteristic == "s") 
          {
            game.wfrp4e.utility.logHomebrew("mooSizeDamage");
            let SBsToAdd = actor.sizeNum - 3;
            damage += (actor.characteristics.s.bonus * SBsToAdd);
          }
    
        }
        //@/HOUSE
    
        return parseInt(damage || 0)
      }

      get DamageString() {
        let string = "";
        string += this.Damage;
    
        if (this.damage.dice)
          string += `+ ${this.damage.dice}`;
    
        if (this.ammo && this.ammo.damage.dice)
          string += `+ ${this.ammo.damage.dice}`;
    
        return string
      }

      get mountDamage() {

        let actor = this.parent.actor;
        if (!actor)
            return;

        if (this.attackType != "melee" || !actor.isMounted || !actor.mount)
        {
            return this.Damage
        }
    
        if (this.rollable.bonusCharacteristic == "s") 
        {
          return this.Damage + (actor.mount.characteristics[this.rollable.bonusCharacteristic].bonus - actor.characteristics[this.rollable.bonusCharacteristic].bonus)
        }
        else
        {
            return this.Damage
        }
      }

      get Specification() {

        let actor = this.parent.actor;

        let specification;
        if (this.specification.value) {
          if (this.rollable.bonusCharacteristic && this.rollable.damage)  // Bonus characteristic adds to the specification (Weapon +X includes SB for example)
          {
            specification = parseInt(this.specification.value) || 0;
            if (actor)
            {
              specification += actor.characteristics[this.rollable.bonusCharacteristic].bonus;
            }
            if (this.attackType && actor)
            {
              specification += (actor.flags[`${this.attackType}DamageIncrease`] || 0);
            }
          }
          else
            specification = this.specification.value;
        }
        return specification
      }
    
      get SpecificationBonus() {
        return this.parent.actor?.characteristics[this.rollable.bonusCharacteristic].bonus
      }

    computeBase() 
    {
        super.computeBase();
    }
      
    getSkillToUse(actor) {
        actor = actor || this.parent.actor;
        let skills = actor?.itemTags["skill"] || [];
        let skill = skills.find(i => i.name == this.rollable.skill);
        return skill;
    }


    chatData() {
        let properties = [];
        if (this.specification.value)
          properties.push(`<b>${game.i18n.localize("Specification")}: </b> ${this.specification.value}`);
        return properties;
      }


    shouldTransferEffect(effect) {
        return this.enabled;
    }

}

let fields$6 = foundry.data.fields;

/**
 *
 * @extends EquippableItemModel
 * @mixes PropertiesMixin
 */
class WeaponModel extends PropertiesMixin(EquippableItemModel) {
    static LOCALIZATION_PREFIXES = ["WH.Models.weapon"];
    static defineSchema() {
        let schema = super.defineSchema();
        schema.damage = new fields$6.SchemaField({
            value: new fields$6.StringField({ initial: "" }),
            dice: new fields$6.StringField({ initial: "" })
        });
        schema.weaponGroup = new fields$6.SchemaField({
            value: new fields$6.StringField({ initial: "basic", blank : true, choices : game.wfrp4e.config.weaponGroups})
        });
        schema.reach = new fields$6.SchemaField({
            value: new fields$6.StringField({ initial: "", blank : true, choices : game.wfrp4e.config.weaponReaches })
        });
        schema.range = new fields$6.SchemaField({
            value: new fields$6.StringField({ initial: "" })
        });
        schema.skill = new fields$6.SchemaField({
            value: new fields$6.StringField({ initial: "" })
        });
        schema.modeOverride = new fields$6.SchemaField({
            value: new fields$6.StringField({ initial: "", blank: true, choices : game.wfrp4e.config.weaponTypes })
        });
        schema.twohanded = new fields$6.SchemaField({
            value: new fields$6.BooleanField({ initial: false })
        });
        schema.ammunitionGroup = new fields$6.SchemaField({
            value: new fields$6.StringField({ initial: "", blank : true, choices : game.wfrp4e.config.ammunitionGroups })
        });
        schema.currentAmmo = new fields$6.SchemaField({
            value: new fields$6.StringField({ initial: "" })
        });
        schema.consumesAmmo = new fields$6.SchemaField({
            value: new fields$6.BooleanField({ initial: false })
        });
        schema.special = new fields$6.SchemaField({
            value: new fields$6.StringField({ initial: "" })
        });
        schema.loaded = new fields$6.SchemaField({
            value: new fields$6.BooleanField({ initial: false }),
            repeater: new fields$6.BooleanField({ initial: false }),
            amt: new fields$6.NumberField({ min: 0, initial: 0 })
        });
        schema.offhand = new fields$6.SchemaField({
            value: new fields$6.BooleanField({ initial: false })
        });

        return schema;
    }

    /** @override */
    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
          ["weaponGroup", {
              label: this.LOCALIZATION_PREFIXES + ".FIELDS.weaponGroup.value.label",
              type: "set",
              config: {
                  choices: game.wfrp4e.config.weaponGroups,
                  keyPath: "system.weaponGroup.value"
              }
          }],
          ...this.compendiumBrowserPropertiesFilter("weapon"),
        ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of VehicleRoleModel
     *
     * @final
     * @returns {boolean}
     */
    get isWeapon() {
        return true;
    }

    //#region getters 

    get isMelee() {
        return this.modeOverride?.value == "melee" || (game.wfrp4e.config.groupToType[this.weaponGroup.value] == "melee" && this.modeOverride?.value != "ranged")
    }

    get isRanged() {
        return this.modeOverride?.value == "ranged" || (game.wfrp4e.config.groupToType[this.weaponGroup.value] == "ranged" && this.modeOverride?.value != "melee")
    }

    get weighsLessEquipped() {
        return false;
    }

    get WeaponGroup() {
        return game.wfrp4e.config.weaponGroups[this.weaponGroup.value]
    }

    get Reach() {
        return game.wfrp4e.config.weaponReaches[this.reach.value];
    }

    get Range() {
        return this.applyAmmoMods(this.computeWeaponFormula("range"), "range")
      }
    

    get attackType() {
        return this.modeOverride?.value || game.wfrp4e.config.groupToType[this.weaponGroup.value]
    }

    get reachNum() {
        return game.wfrp4e.config.reachNum[this.reach.value]
    }

    get ammo() {
        if (this.isRanged && this.currentAmmo?.value && this.parent.isOwned)
          return this.parent.actor.items.get(this.currentAmmo.value)
    }

    get ammoList() {
        let ammo;
        if (this.ammunitionGroup.value == "throwing")
            ammo = this.parent.actor.itemTags["weapon"].filter(i => i.weaponGroup.value == "throwing").map(i => i.toObject());
        else
            ammo = this.parent.actor.itemTags["ammunition"].filter(a => a.ammunitionType.value == this.ammunitionGroup.value).map(i => i.toObject());

        ammo.forEach(i => {
            let location = this.parent.actor.items.get(i.system.location.value);
            i.name = `(${i.system.quantity.value}) ${i.name} ${location ? "- " + location.name : ""}`.trim();
        });
        return ammo;
    }

    get Damage() {

        let actor = this.parent.actor;
        let damage = this.applyAmmoMods(this.computeWeaponFormula("damage"), "damage") + (actor.flags[`${this.attackType}DamageIncrease`] || 0) - Math.max((this.damageToItem.value - (this.properties.qualities.durable?.value || 0)), 0);

        //@HOUSE
        if (game.settings.get("wfrp4e", "homebrew").mooSizeDamage && actor.system instanceof StandardActorModel)
        {
          if (this.damage.value.includes("SB") && actor.sizeNum > 3)
          {
            game.wfrp4e.utility.logHomebrew("mooSizeDamage");
            let SBsToAdd = actor.sizeNum - 3;
            damage += (actor.characteristics.s.bonus * SBsToAdd);
          }
    
        }
        //@/HOUSE
    
        return parseInt(damage || 0)
      }

      get DamageString() {
        let string = this.Damage;
    
        if (this.damage.dice)
          string += `+ ${this.damage.dice}`;
    
        if (this.ammo && this.ammo.damage.dice)
          string += `+ ${this.ammo.damage.dice}`;
    
        return string
      }

      get mountDamage() {

        let actor = this.parent.actor;
        if (!actor)
            return;

        if (this.attackType != "melee" || !actor.isMounted || !actor.mount)
        {
            return this.Damage
        }
                                                                                                                                // Account for Durable, Math.max so durable doesn't go past damageToItem
        return this.applyAmmoMods(this.computeWeaponFormula("damage", actor.mount), "damage") + (actor.flags[`${this.attackType}DamageIncrease`] || 0) - Math.max((this.damageToItem.value - (this.properties.qualities.durable?.value || 0)), 0)

      }

      //#endregion


    async _preCreate(data, options, user) {
        await super._preCreate(data, options, user);

        if (this.parent.isOwned && this.parent.actor.type != "character" && this.parent.actor.type != "vehicle") {
            this.updateSource({"system.equipped" : true}); // TODO: migrate this into a unified equipped property
        }
    }


    async _preUpdate(data, options, user) {
        await super._preUpdate(data, options, user);

        if (this.weaponGroup.value == "throwing" && foundry.utils.getProperty(data, "system.ammunitionGroup.value") == "throwing") {
            delete data.system.ammunitionGroup.value;
            return ui.notifications.notify(game.i18n.localize("SHEET.ThrowingAmmoError"))
        }

        if (foundry.utils.hasProperty(data, "system.equipped")) {
            data["system.offhand.value"] = false;
        }

        if (foundry.utils.hasProperty(options, "changed.system.loaded"))
        {
            let loaded = data.system.loaded; 

            if (loaded.amt > this.loaded.max)
            {
                loaded.amt = this.loaded.max;
            }

            if (loaded.amt == 0)
            {
                loaded.value = false;
            }
            else if (loaded.amt)
            {
                loaded.value = true;
            }

            if (options.changed.system?.loaded?.value)
            {
                loaded.amt = this.loaded.max || 1;
            }
            else if (options.changed.system?.loaded?.value == false)
            {
                loaded.amt = 0;
            }
        }
    }

    async _onUpdate(data, options,user)
    {
        await super._onUpdate(data, options, user);
        if (foundry.utils.hasProperty(options, "changed.system.loaded") && this.parent.actor)
        {
            this.parent.actor.checkReloadExtendedTest(this.parent);
        }
    }

    get usesHands()
    {
        let actor = this.parent?.actor;
        let locations = [];
        if (actor && this.isEquipped)
        {
            if (this.twohanded.value)
            {
                locations = locations.concat(["rArm", "lArm"]);
            }
            else if (this.offhand.value)
            {
                locations.push(actor.secondaryArmLoc);
            }
            else
            {
                locations.push(actor.mainArmLoc);
            }
        }
        return locations;
    }

    get equipPoints() {
        return this.twohanded.value ? 2 : 1;
        // return this.usesHands.length;
    }

    async toggleEquip(data = {}) {
        return await super.toggleEquip(data);
    }

    get canEquip() {
        const actor = this.parent.actor;
        if (game.settings.get("wfrp4e", "limitEquippedWeapons") && actor.type !== "vehicle") {
            return actor.system.equipPointsUsed + this.equipPoints <= actor.system.settings.equipPoints;
        }

        return true;
    }

    get properties() {
        // Kinda jank, but if some properties have been added by scripts, we need to recreate the properties object
        let _totalProperties = this.qualities.value.length + this.flaws.value.length + (this.ammo?.system.properties._totalProperties || 0);
        if (this._properties && this._properties._totalProperties == _totalProperties)
        {
            return this._properties;
        }

        let properties = super.properties;
        properties.unusedQualities = {};
        properties.inactiveQualities = {};
        properties._totalProperties = _totalProperties;

        //TODO: Don't like having to check for type here
        if (this.parent.isOwned && !this.skillToUse && this.parent.actor.type != "vehicle") {
            properties.unusedQualities = properties.qualities;
            properties.qualities = {};
            if (this.ammo)
                properties.qualities = this.ammo.properties.qualities;
        }

        if (this.parent.isOwned) {
            for (let prop in properties.qualities) {
                let property = properties.qualities[prop];
                if (Number.isNumeric(property.group) && !property.active) {
                    properties.inactiveQualities[prop] = property;
                    delete properties.qualities[prop];
                }
            }
        }

        properties.special = this.special?.value;
        if (this.ammo)
            properties.specialAmmo = this.ammo.properties.special;

        return properties;
    }


    computeOwned() {

        if (this.isRanged && this.ammo && (this.skillToUse || this.parent.actor.type == "vehicle"))
            this._addProperties(this.ammo.properties);

        if (this.weaponGroup.value == "flail" && !this.skillToUse && !this.flaws.value.find(i => i.name == "dangerous"))
            this.flaws.value.push({ name: "dangerous" });

        if (game.settings.get("wfrp4e", "homebrew").mooQualities) {
            game.wfrp4e.utility.logHomebrew("mooQualities");
            let momentum = this.qualities.value.find(q => q.name == "momentum" && q.value);
            if (momentum?.value && this.parent.actor.status.advantage.value > 0) {
                let qualityString = momentum.value;
                this._addProperties({ qualities: this.constructor.propertyStringToObject(qualityString, game.wfrp4e.utility.allProperties()), flaws: {} });
                this.qualities.value.splice(this.qualities.value.findIndex(q => q.name == "momentum"), 1);
            }
        }

        this.range.bands = this.computeRangeBands();

        if (this.loading) {
            this.loaded.max = 1;
            if (this.repeater) {
                this.loaded.max = this.repeater.value;
                if (!this.loaded.max)
                    this.loaded.max = 1;
            }
        }
    }


    reduceEquippedEncumbrance()
    {
        // Redefine this as empty to prevent subtracting encumbrance 
    }


    computeRangeBands() {

        let range = this.applyAmmoMods(this.computeWeaponFormula("range"), "range");
        if (!range || this.attackType == "melee")
            return

        let rangeBands = {};

        rangeBands[`${game.i18n.localize("Point Blank")}`] = {
            range: [0, Math.ceil(range / 10)],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Point Blank"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Point Blank"]
        };
        rangeBands[`${game.i18n.localize("Short Range")}`] = {
            range: [Math.ceil(range / 10) + 1, Math.ceil(range / 2)],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Short Range"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Short Range"]
        };
        rangeBands[`${game.i18n.localize("Normal")}`] = {
            range: [Math.ceil(range / 2) + 1, range],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Normal"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Normal"]
        };
        rangeBands[`${game.i18n.localize("Long Range")}`] = {
            range: [range + 1, range * 2],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Long Range"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Long Range"]
        };
        rangeBands[`${game.i18n.localize("Extreme")}`] = {
            range: [range * 2 + 1, range * 3],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Extreme"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Extreme"]
        };

        //@HOUSE
        if (game.settings.get("wfrp4e", "homebrew").mooRangeBands) {
            game.wfrp4e.utility.logHomebrew("mooRangeBands");
            if (!this.parent.getFlag("wfrp4e", "optimalRange"))
                warhammer.utility.log("Warning: No Optimal Range set for " + this.name);

            rangeBands[`${game.i18n.localize("Point Blank")}`].modifier = this.#optimalDifference(game.i18n.localize("Point Blank")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Point Blank")}`].difficulty;
            rangeBands[`${game.i18n.localize("Short Range")}`].modifier = this.#optimalDifference(game.i18n.localize("Short Range")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Short Range")}`].difficulty;
            rangeBands[`${game.i18n.localize("Normal")}`].modifier = this.#optimalDifference(game.i18n.localize("Normal")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Normal")}`].difficulty;
            rangeBands[`${game.i18n.localize("Long Range")}`].modifier = this.#optimalDifference(game.i18n.localize("Long Range")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Long Range")}`].difficulty;
            rangeBands[`${game.i18n.localize("Extreme")}`].modifier = this.#optimalDifference(game.i18n.localize("Extreme")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Extreme")}`].difficulty;
        }
        //@/HOUSE


        // If entangling and has no ammunition (implying non-projectiles like a whip)
        if (this.weaponGroup.value == "entangling" && this.ammunitionGroup.value == "none") {
            rangeBands[`${game.i18n.localize("Point Blank")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Short Range")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Normal")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Long Range")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Extreme")}`].modifier = 0;
        }
        return rangeBands;
    }

    //@HOUSE
    #optimalDifference(range)
    {
        let keys = Object.keys(game.wfrp4e.config.rangeBands);
        let rangeKey = warhammer.utility.findKey(range, game.wfrp4e.config.rangeBands);
        let weaponRange = this.parent.getFlag("wfrp4e", "optimalRange");
        if (!weaponRange || !rangeKey)
            return 1

        return Math.abs(keys.findIndex(i => i == rangeKey) - keys.findIndex(i => i == weaponRange))
    }
    //@/HOUSE

    applyAmmoMods(value, type) {
        // If weapon ammo, just use its damage
        if (this.ammo?.type == "weapon" && type == "damage") {
            return Number(this.ammo.damage.value)
        }

        // If no ammo or has weapon ammo, don't apply mods
        if (!this.ammo || this.ammo.type == "weapon")
            return value

        let ammoValue = this.ammo[type].value;

        if (!ammoValue)
            return value

        // If range modification was handwritten, process it
        if (ammoValue.toLowerCase() == game.i18n.localize("as weapon")) ;
        else if (ammoValue.toLowerCase() == "as weapon") ;
        // Do nothing to weapon's range
        else if (ammoValue.toLowerCase() == game.i18n.localize("half weapon"))
            value /= 2;
        else if (ammoValue.toLowerCase() == "half weapon")
            value /= 2;
        else if (ammoValue.toLowerCase() == game.i18n.localize("third weapon"))
            value /= 3;
        else if (ammoValue.toLowerCase() == "third weapon")
            value /= 3;
        else if (ammoValue.toLowerCase() == game.i18n.localize("quarter weapon"))
            value /= 4;
        else if (ammoValue.toLowerCase() == "quarter weapon")
            value /= 4;
        else if (ammoValue.toLowerCase() == game.i18n.localize("twice weapon"))
            value *= 2;
        else if (ammoValue.toLowerCase() == "twice weapon")
            value *= 2;
        else // If the range modification is a formula (supports +X -X /X *X)
        {
            try {
                try // Works for + and -
                {
                    ammoValue = (0, eval)(ammoValue);
                    value = Math.floor((0, eval)(value + ammoValue));
                }
                catch // if *X and /X
                {                                      // eval (50 + "/5") = eval(50/5) = 10
                    value = Math.floor((0, eval)(value + ammoValue));
                }
            } catch (error) {
                ui.notifications.error(game.i18n.format("ERROR.AMMO_MODS", {type}));
                console.error(error, {value, type, item: this, ammo: this.ammo});
            }
        }
        return value
    }


    /**
   * Calculates a weapon's range or damage formula.
   * 
   * Takes a weapon formula for Damage or Range (SB + 4 or SBx3) and converts to a numeric value.
   * 
   * @param {String} formula formula to be processed (SBx3 => 9).
   * 
   * @return {Number} Numeric formula evaluation
   */
    computeWeaponFormula(type, mount) {
        let formula = this[type].value || "0";
        let actorToUse = this.parent.actor;
        try {
            formula = formula.toLowerCase();
            // Iterate through characteristics
            for (let ch in this.parent.actor.characteristics) {
                if (ch == "s" && mount)
                    actorToUse = mount;
                else
                    actorToUse = this.parent.actor;
                // Determine if the formula includes the characteristic's abbreviation + B (SB, WPB, etc.)
                if (formula.includes(ch.concat('b'))) {
                    // Replace that abbreviation with the Bonus value
                    formula = formula.replace(ch.concat('b'), actorToUse.characteristics[ch].bonus.toString());
                }
            }
            // To evaluate multiplication, replace x with *
            formula = formula.replace('x', '*');

            return (0, eval)(formula);
        }
        catch (e)
        {
            console.error(`computeWeaponFormula from ${this.parent?.actor?.name} threw error: ${e}.\n Arguments:`, this, formula);
            return formula
        }
    }

    getSkillToUse(actor) {
        actor = actor || this.parent.actor;
        let skills = actor?.itemTags["skill"] || [];
        let skill = skills.find(x => x.name.toLowerCase() == this.skill.value.toLowerCase());
        if (!skill) {
            skill = skills.find(x => x.name.toLowerCase().includes(`(${this.WeaponGroup.toLowerCase()})`));
        }
        return skill
    }


    /** 
     * Helper method to apply damage to an item
     * 
     * @param {number} value Damage the item by this amount
     * @param {string} type "value", "shield" or "both"
     */
    damageItem(value = 1, type="value")
    {
        let update = {};
        let broken = false;
        if (["value", "both"].includes(type))
        {

            let currentDamage = this.damageToItem.value + value;
            
            // If maxDamageTaken is undefined, there is no max
            let max = this.maxDamageTaken("value");
            if (max && currentDamage > max)
            {
                currentDamage = max;
            }
            if (currentDamage == max)
            {
                broken = true;
            }
            
            update[`system.damageToItem.value`] = currentDamage;
        }
        if (["shield", "both"].includes(type))
        {

            let currentDamage = this.damageToItem.shield + value;
            
            // If maxDamageTaken is undefined, there is no max
            let max = this.maxDamageTaken("shield");
            if (max && currentDamage > max)
            {
                currentDamage = max;
            }
           
            if (currentDamage == max)
            {
                broken = true;
            }

            update[`system.damageToItem.shield`] = currentDamage;
        }

        if (broken)
        {
            ui.notifications.notify(`${this.parent.name} broken!`);
        }

        return this.parent.update(update);
    }

    maxDamageTaken(type)
    {
        if (type == "value")
        {
            let regex = /\d{1,3}/gm;
            return Number(regex.exec(this.damage.value)[0] || 0) + Number(this.properties.qualities.durable?.value || 0) || 999
        }
        else if (type == "shield")
        {
            return Number(this.properties.qualities.shield?.value || 0)
        }
    }

    
    getOtherEffects()
    {
        let other = [];
        if (this.weaponGroup.effect)
        {
            other.push(this.weaponGroup.effect);
        }
        if (this.ammo)
        {
            other = other.concat(this.ammo.effects.contents);
        }
        return super.getOtherEffects().concat(other);
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);

        if (this.weaponGroup.value)
            data.properties.push(this.WeaponGroup);
        if (this.range.value)
            data.properties.push(`${game.i18n.localize("Range")}: ${this.range.value}`);
        if (this.damage.value) {
            let damage = this.damage.value;
            if (this.damage.dice)
                damage += " + " + this.damage.dice;
            data.properties.push(`${game.i18n.localize("Damage")}: ${damage}`);
        }
        if (this.twohanded.value)
            data.properties.push(game.i18n.localize("ITEM.TwoHanded"));
        if (this.reach.value)
            data.properties.push(`${game.i18n.localize("Reach")}: ${game.wfrp4e.config.weaponReaches[this.reach.value] + " - " + game.wfrp4e.config.reachDescription[this.reach.value]}`);
        if (this.damageToItem.value)
            data.properties.push(`${game.i18n.format("ITEM.WeaponDamaged", { damage: this.damageToItem.value })}`);
        if (this.damageToItem.shield)
            data.properties.push(`${game.i18n.format("ITEM.ShieldDamaged", { damage: this.damageToItem.shield })}`);

        let itemProperties = this.OriginalQualities.concat(this.OriginalFlaws);
        for (let prop of itemProperties)
            data.properties.push("<a data-action='postItemProperty' class ='item-property'>" + prop + "</a>");

        if (this.special.value)
            data.properties.push(`${game.i18n.localize("Special")}: ` + this.special.value);

        data.properties = data.properties.filter(p => !!p);
        return data;
    }

    chatData() {
        let properties = [
            `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
            `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
            `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
        ];

        if (this.weaponGroup.value)
            properties.push(`<b>${game.i18n.localize("Group")}</b>: ${this.WeaponGroup}`);
        if (this.range.value)
            properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);
        if (this.damage.value)
            properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);
        if (this.twohanded.value)
            properties.push(`<b>${game.i18n.localize("ITEM.TwoHanded")}</b>`);
        if (this.reach.value)
            properties.push(`<b>${game.i18n.localize("Reach")}</b>: ${game.wfrp4e.config.weaponReaches[this.reach.value] + " - " + game.wfrp4e.config.reachDescription[this.reach.value]}`);
        if (this.damageToItem.value)
            properties.push(`${game.i18n.format("ITEM.WeaponDamaged", { damage: this.damageToItem.value })}`);
        if (this.damageToItem.shield)
            properties.push(`${game.i18n.format("ITEM.ShieldDamaged", { damage: this.damageToItem.shield })}`);

        // Make qualities and flaws clickable
        if (this.qualities.value.length)
            properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a data-action='postItemProperty' class ='item-property'>" + i + "</a>").join(", ")}`);

        if (this.flaws.value.length)
            properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a data-action='postItemProperty' class ='item-property'>" + i + "</a>").join(", ")}`);


        properties = properties.filter(p => p != game.i18n.localize("Special"));
        if (this.special.value)
            properties.push(`<b>${game.i18n.localize("Special")}</b>: ` + this.special.value);

        properties = properties.filter(p => !!p);
        return properties;
    }

    static migrateData(data)
    {
        super.migrateData(data);
        if (data.equipped && typeof data.equipped !== 'object') {
            data.equipped = {value: data.equipped};
        }
    }
}

let fields$5 = foundry.data.fields;

class ExtendedTestModel extends BaseItemModel {
    static LOCALIZATION_PREFIXES = ["WH.Models.extendedTest"];


    static defineSchema() {
        let schema = super.defineSchema();

        schema.SL = new fields$5.SchemaField({
            current: new fields$5.NumberField({ initial: 0 }),
            target: new fields$5.NumberField({ initial: 1 }),
        });

        schema.test = new fields$5.SchemaField({
            value: new fields$5.StringField({})
        });

        schema.negativePossible = new fields$5.SchemaField({
            value: new fields$5.BooleanField({ initial: false })
        });

        schema.failingDecreases = new fields$5.SchemaField({
            value: new fields$5.BooleanField({ initial: true })
        });

        schema.completion = new fields$5.SchemaField({
            value: new fields$5.StringField({ initial: "none", choices : game.wfrp4e.config.extendedTestCompletion})
        });

        schema.hide = new fields$5.SchemaField({
            test: new fields$5.BooleanField({ initial: false }),
            progress: new fields$5.BooleanField({ initial: false }),
        });

        schema.difficulty = new fields$5.SchemaField({
            value: new fields$5.StringField({ initial: "challenging", choices : game.wfrp4e.config.difficultyLabels })
        });

        return schema;
    }

    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
            ["SL", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.SL.target.label",
                type: "range",
                config: {
                    keyPath: "system.SL.target"
                }
            }],
            ["test", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.test.value.label",
                type: "text",
                config: {
                    keyPath: "system.test.value"
                }
            }],
            ["negativePossible", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.negativePossible.value.label",
                type: "boolean",
                config: {
                    keyPath: "system.negativePossible.value"
                }
            }],
            ["failingDecreases", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.failingDecreases.value.label",
                type: "boolean",
                config: {
                    keyPath: "system.failingDecreases.value"
                }
            }],
            ["completion", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.completion.value.label",
                type: "boolean",
                config: {
                    choices: game.wfrp4e.config.extendedTestCompletion,
                    keyPath: "system.completion.value"
                }
            }],
            ["difficulty", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.difficulty.value.label",
                type: "boolean",
                config: {
                    choices: game.wfrp4e.config.difficultyLabels,
                    keyPath: "system.difficulty.value"
                }
            }],
            ["hide.test", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.hide.test.label",
                type: "boolean",
                config: {
                    keyPath: "system.hide.test"
                }
            }],
            ["hide.progress", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.hide.progress.label",
                type: "boolean",
                config: {
                    keyPath: "system.hide.progress"
                }
            }]
        ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of ExtendedTestModel
     *
     * @final
     * @returns {boolean}
     */
    get isExtendedTest() {
        return true;
    }

    computeOwned() {
        this.SL.pct = 0;
        if (this.SL.target > 0)
            this.SL.pct = this.SL.current / this.SL.target * 100;
        if (this.SL.pct > 100)
            this.SL.pct = 100;
        if (this.SL.pct < 0)
            this.SL.pct = 0;
    }

    chatData() {
        let properties = [];
        let pct = 0;
        if (this.SL.target > 0)
            pct = this.SL.current / this.SL.target * 100;
        if (pct > 100)
            pct = 100;
        if (pct < 0)
            pct = 0;
        properties.push(`<b>${game.i18n.localize("Test")}</b>: ${this.test.value}`);
        if (!this.hide.test && !this.hide.progress)
            properties.push(`<div class="test-progress">
      <div class="progress-bar-container">
        <div class="progress-bar" style="width: ${pct}%"></div>
      </div>
      <span><a class="extended-SL">${this.SL.current}</a> / ${this.SL.target} SL</span>
    </div>`);

        return properties;
    }
}

let fields$4 = foundry.data.fields;

class VehicleModModel extends PhysicalItemModel
{
    static LOCALIZATION_PREFIXES = ["WH.Models.vehicleMod"];

    static metadata = Object.freeze(foundry.utils.mergeObject(super.metadata, {
      isVehicle: true
    }, {inplace: false}));

    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.modType = new fields$4.SchemaField({
            value : new fields$4.StringField({choices: game.wfrp4e.config.modTypes})
        });
        return schema;
    }

    static get compendiumBrowserFilters() {
      return new Map([
        ...Array.from(super.compendiumBrowserFilters),
        ["modType", {
          label: this.LOCALIZATION_PREFIXES + ".FIELDS.modType.value.label",
          type: "set",
          config: {
            choices : game.wfrp4e.config.modTypes,
            keyPath: "system.modType.value"
          }
        }]
      ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of VehicleModModel
     *
     * @final
     * @returns {boolean}
     */
    get isVehicleMod() {
      return true;
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties = [game.wfrp4e.config.modTypes[this.modType.value]];
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("VEHICLE.ModType")}</b>: ${game.wfrp4e.config.modTypes[this.modType.value]}`,
          `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
          `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
        ];
        return properties
      }
}

let fields$3 = foundry.data.fields;

class CargoModel extends PhysicalItemModel
{
    static LOCALIZATION_PREFIXES = ["WH.Models.cargo"];

    static metadata = Object.freeze(foundry.utils.mergeObject(super.metadata, {
      isVehicle: true
    }, {inplace: false}));

    static defineSchema() 
    {

        let schema = super.defineSchema();
        schema.cargoType = new fields$3.SchemaField({
            value: new fields$3.StringField({})
        });
        schema.unitPrice = new fields$3.SchemaField({
            value: new fields$3.NumberField()
        });
        schema.origin = new fields$3.SchemaField({
            value: new fields$3.StringField()
        });
        schema.quality = new fields$3.SchemaField({
            value: new fields$3.StringField({initial : "average"})
        });
        schema.tradeType = new fields$3.StringField({initial : "river", choices : {river : "River", maritime : "Maritime"}});
        return schema;
    }

  /**
   * Used to identify an Item as one being a child or instance of CargoModel
   *
   * @final
   * @returns {boolean}
   */
  get isCargo() {
    return true;
  }

    computeBase()
    {
        super.computeBase();
        if (this.cargoType.value != "wine" && this.cargoType.value != "brandy")
        {
            this.quality.value = "average";
        }
        if (this.tradeType == "river")
        {
          this.price.gc = this.unitPrice.value * this.encumbrance.value / 10;
        }
        else if (this.tradeType == "maritime")
          {
          this.price.gc = this.unitPrice.value * this.encumbrance.value;
        }
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
    
        if (this.origin.value)
          data.properties.push(`<b>${game.i18n.localize("ITEM.Origin")}</b>: ${this.origin.value}`);
    
        if (game.wfrp4e.trade.cargoTypes)
          data.properties.push(`<b>${game.i18n.localize("ITEM.CargoType")}</b>: ${game.wfrp4e.trade.cargoTypes[this.cargoType.value]}`);
    
        if (game.wfrp4e.config.trade.qualities && (this.cargoType.value == "wine" || this.cargoType.value == "brandy"))
          data.properties.push(`<b>${game.i18n.localize("ITEM.CargoQuality")}</b>: ${game.wfrp4e.config.trade.qualities[this.quality.value]}`);
    
        return data;
      }

      chatData() {
        let properties = [];
    
        if (this.origin.value)
          properties.push(`<b>${game.i18n.localize("ITEM.Origin")}</b>: ${this.origin.value}`);
    
        if (game.wfrp4e.trade.cargoTypes)
          properties.push(`<b>${game.i18n.localize("ITEM.CargoType")}</b>: ${game.wfrp4e.trade.cargoTypes[this.cargoType.value]}`);
    
        if (game.wfrp4e.config.trade.qualities && (this.cargoType.value == "wine" || this.cargoType.value == "brandy"))
          properties.push(`<b>${game.i18n.localize("ITEM.CargoQuality")}</b>: ${game.wfrp4e.config.trade.qualities[this.quality.value]}`);
        return properties;
      }
    
}

function loadScripts() 
{
    Hooks.on("init", () => 
    {
        foundry.utils.mergeObject(game.wfrp4e.config.effectScripts, {"00ZCnahnTGvzG9KA":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.weczkAMPlTjX7lqU\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item])","01VFjGVxkjb5P1ve":"return args.item?.system?.isRanged && args.data.targets[0]?.actor?.sizeNum < 3","03mJu59V4iByWlsO":"// The imbiber immediately\n// takes 3 Poisoned Conditions that cannot be resisted at first,\nawait this.actor.addCondition(\"poisoned\", 3)\n\n// recovers a number of Wounds equal to their Toughness Bonus, \nawait this.actor.modifyWounds(this.actor.system.characteristics.t.bonus)\n\n// and acquires the Regenerate Creature Trait.\nconst hasRegenerate = this.actor.has(\"Regenerate\")\nif (hasRegenerate === undefined) {\n  fromUuid(\"Compendium.wfrp4e-core.items.SfUUdOGjdYpr3KSR\").then(trait => {\n    let traitItem = trait.toObject()\n    this.actor.createEmbeddedDocuments(\"Item\", [traitItem], {fromEffect: this.effect.id})\n  })\n}\n\nthis.script.message(`<p><strong>${this.actor.prototypeToken.name}</strong> has \n    <ul>\n      <li>gained 3 Poisoned Conditions that cannot be resisted at first</li>\n      <li>recovered ${this.actor.system.characteristics.t.bonus} Wounds</li>\n      <li>acquired the Regenerate Creature Trait.</li>\n    </ul>\n    It’s up to Ranald if their regenerating can outpace their poisoning.</p>\n    <p>When all Poisoned Conditions are lost, so too is Regenerate.</p>`, \n    { whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })   \n","04bAiHISSW53w94Y":"this.actor.addCondition(\"blinded\", 3)","06IaVCOC0RCJbxEf":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.8piWcBKFlQ2J1E3A\")\nlet data = item.toObject();\ndata.system.location.key= this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data])","08S8Ozi5b4EdwZp5":"args.fields.slBonus += this.actor.system.characteristics.wp.bonus;","09sSpnW8z2zcVEdf":"if (!args.flags.quietenedApplied)\n{\n   args.fields.modifier += 10;\n   args.flags.quietenedApplied = true\n}","0BP5l7bIkf744G1k":"return !args.context.terror  && !args.extendedTest?.flags.wfrp4e?.fear","0FNOq4J1AdPd2A0q":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Row\")) && !args.skill?.name.includes(game.i18n.localize(\"NAME.Sail\"));","0FWto1oEr3jbWggw":"let spells = await warhammer.utility.findAllItems(\"spell\", \"Loading Spells\", true, [\"system.lore.value\"])\n\nlet text = (await game.wfrp4e.tables.rollTable(\"random-caster\", {hideDSN: true})).result\n\nlore = Array.from(text.matchAll(/{(.+?)}/gm))[0][1]\n\nif (text == \"GM's Choice\")\n{\n    return this.script.notification(text)\n}\n\nif (spellsWithLore.length > 0)\n{\n    let spellsWithLore = spells.filter(i => game.wfrp4e.config.magicLores[i.system.lore.value] == lore)\n    let selectedSpell = spellsWithLore[Math.floor(CONFIG.Dice.randomUniform() * spellsWithLore.length)]\n    this.script.notification(selectedSpell.name);\n    this.actor.createEmbeddedDocuments(\"Item\", [(await fromUuid(selectedSpell)).toObject()])\n}\nelse\n{\n    ui.notifications.notify(`Could not find ${lore} spell. Try Again`)\n}","0H2syk6qc0sCY0pj":"if ( args.actor.has(game.i18n.localize(\"NAME.AA\"), \"talent\") ||\nargs.actor.has(game.i18n.localize(\"NAME.SecondSight\"), \"talent\") ) {\n\targs.modifiers.other.push({label : this.effect.name, value : 5, details : \"Target has Aethyric Attunement or Second Sight\"});\n}","0KG3HoTNoZhaINIj":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.4CMKeDTDrRQZbPIJ\")\nlet fixation = (await game.wfrp4e.tables.rollTable(\"fixations\"))\nlet data = item.toObject();\ndata.system.specification.value = fixation.result;\nthis.item.updateSource({name : this.item.name += ` (${fixation.result})`});\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","0LCQtsiK2aUfYRmD":"return ![\"t\", \"wp\"].includes(args.characteristic)","0NAD1LNcVyAZ1fC7":"return args.skill?.name !== game.i18n.localize(\"NAME.Cool\") && args.skill?.name !== game.i18n.localize(\"NAME.Endurance\");","0PzfGjGhHQbxEwlb":"this.item.update({\"system.AP\" : {lArm : 0, rArm : 0, lLeg : 0, rLeg: 0}});","0R0QAr3D024kWPfo":"let table = game.wfrp4e.tables.findTable(\"mutatephys\");\nif (!table)\n{\n\treturn ui.notifications.error(\"Mutation table not found, please ensure a table with the `mutatephys` key is imported in the world.\")\n}\nlet result = (await table.roll()).results[0];\nlet uuid = `Compendium.${result.documentCollection}.${result.documentId}`\nlet item = await fromUuid(uuid);\n\nif (item)\n{\n    this.script.notification(`${item.name} added`)\n    this.actor.createEmbeddedDocuments(\"Item\", [item])\n}\nelse \n{\n    ui.notifications.error(\"Item could not be found: \" + uuid)\n}","0Uly7OmkH0zqYbxQ":"let location = this.item.system.location.key;\n\nif (location)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.notification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}\n\nlet roll = await new Roll(\"max(1, 1d10 - @system.characteristics.t.bonus)\", this.actor).roll()\n\nroll.toMessage(this.script.getChatData({flavor : `${this.effect.name} (Duration)`}));\n\nthis.effect.updateSource({\"duration.rounds\" : roll.total})","0YKQGbsKdHSmYGE7":"if (args.skill?.name != game.i18n.localize(\"NAME.Gossip\"))\n{\n\treturn true;\n}\nelse \n{\n\targs.data.canReverse = true; // Kind of a kludge here, the talent Tests has a specific condition, but the description simply says \"any gossip test can be reversed\" so check it here instead of submission\n}\n    ","0abwNjpzo3SbEOeO":"if (args.applyAP && args.modifiers.ap.metal) \n{\n    args.modifiers.ap.ignored += args.modifiers.ap.metal\n    args.modifiers.ap.details.push(\"<strong>\" + this.effect.name + \"</strong>: Ignore Metal (\" + args.modifiers.ap.metal + \")\");\n    args.modifiers.ap.metal = 0\n}","0amHqfjTRp5ff6Op":"let wounds = this.effect.sourceActor.system.characteristics.wp.bonus;\nthis.actor.modifyWounds(wounds);\nthis.script.message(`Healed ${wounds} Wounds`);","0e0UZT2FodOJDdgW":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.GbDyBCu8ZjDp6dkj\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","0e7OkamNAaAk4Oit":"let item1 = await fromUuid(\"Compendium.wfrp4e-core.items.3S4OYOZLauXctmev\")\nlet item2 = await fromUuid(\"Compendium.wfrp4e-core.items.7mCcI3q7hgWcmbBU\")\n\nlet data1 = item1.toObject();\ndata1.system.location.key = this.item.system.location.key\n\nlet data2 = item2.toObject();\ndata2.system.location.key = this.item.system.location.key\n\nthis.actor.createEmbeddedDocuments(\"Item\", [data1, data2], {fromEffect: this.effect.id})\n","0hAbiNR1nFkpFMRz":"if (!this.actor.has(game.i18n.localize(\"NAME.SecondSight\"),\"talent\")) this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.OEjUvJKi0xmBwbS2\", this.effect)","0iTLDgFHO9Rgc010":"args.fields.modifier -= 20;","0jTqyz0wRlK6XPF7":"if (args.test.spell)\n{\n\targs.test.result.other.push(`<strong>${this.effect.name}</strong>: Automatic Failure`)\n}","0mrUnxzufYgsR0Ph":"this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test => {\n    await test.roll()\n    if (test.failed)\n    {\n        this.actor.addCondition(\"stunned\")\n    }\n})\n","0vaYwAlMWTmOBl8k":"if (!args.flags.strikeToStun)\n{\n    args.flags.strikeToStun = true\n    args.fields.modifier += 20;\n    args.fields.hitLocation = \"head\";\n}\nargs.fields.successBonus++;","0wmIC2MssUX6LW3N":"if (args.test.options.doomboltRolled)\n{\n\targs.test.result.damage += 4;\n}","0yyofYHeDRQlFliO":"return args.context.terror  || args.extendedTest?.flags.wfrp4e?.fear","11uCC0mK2uL783al":"let type = this.item.getFlag(\"wfrp4e\", \"breath\");\n\nif ([\"fire\", \"electricity\", \"poison\"].includes(type))\n{\n    args.applyAP = false;\n}","15C6LbCUmQgPEoDM":"await args.actor.addCondition(\"ablaze\");","16nCOByUaSFDym1V":"args.fields.modifier -= 20\n","18MeEQ0As3JvER71":"let state = !this.effect.disabled;\nthis.effect.update({\"disabled\": state});\n\nif (state)\n  return ui.notifications.info(\"EFFECT.CreatureBackInWater\", {localize: true})\n\nreturn ui.notifications.info(\"EFFECT.CreatureOutOfWater\", {localize: true});","190PHSHKGaJ74wsR":"if (!this.item.name.includes(\"(\") || this.item.system.tests.value.includes(\"Terrain\") || this.item.system.tests.value.toLowerCase().includes(\"(any)\"))\n{\n    let tests = this.item.system.tests.value\n    let name = this.item.name\n\n    // If name already specifies, make sure tests value reflects that\n    if (name.includes(\"(\") && !name.toLowerCase().includes(\"(any)\"))\n    {\n        let terrain = name.split(\"(\")[1].split(\")\")[0]\n        tests = tests.replace(\"the Terrain\", terrain)\n    }\n    else // If no sense specified, provide dialog choice\n    {\n        let choice = await ItemDialog.create(ItemDialog.objectToArray({\n            coastal : \"Coastal\",\n            deserts : \"Deserts\",\n            marshes : \"Marshes\",\n            rocky : \"Rocky\",\n            tundra : \"Tundra\",\n            woodlands : \"Woodlands\"\n        }, this.item.img), 1, \"Choose Terrain\");\n        if (choice[0])\n        {\n            name = `${name.split(\"(\")[0].trim()} (${choice[0].name})`\n            tests = tests.replace(\"the Terrain\", choice[0].name + \" Terrain\")\n        }\n    }\n\n    this.effect.updateSource({name})\n    this.item.updateSource({name, \"system.tests.value\" : tests})\n}","1A87vGLh2PXH0rG0":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Language\"));","1BT0MWM2cbhlEnrn":"        let characteristics = {\n            \"ws\" : 5,\n            \"bs\" : 5,\n            \"s\" : 5,\n            \"t\" : 0,\n            \"i\" : 5,\n            \"ag\" : 5,\n            \"dex\" : 5,\n            \"int\" : 0,\n            \"wp\" : 5,\n            \"fel\" : 5\n        }\n        let items = []\n\n        let updateObj = this.actor.toObject();\n\n        let talents = (await Promise.all([game.wfrp4e.tables.rollTable(\"talents\"), game.wfrp4e.tables.rollTable(\"talents\"), game.wfrp4e.tables.rollTable(\"talents\")])).map(i => i.text)\n        \n        for (let ch in characteristics)\n        {\n            updateObj.system.characteristics[ch].modifier += characteristics[ch];\n        }\n        \n        for (let talent of talents)\n        {\n            let talentItem = await game.wfrp4e.utility.findTalent(talent)\n            if (talentItem)\n            {\n                items.push(talentItem.toObject());\n            }\n            else \n            {\n                ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n            }\n        }\n      \n        \n        await this.actor.update(updateObj)\n        this.actor.createEmbeddedDocuments(\"Item\", items);\n    \n","1CeYp5MlPcH68UIw":"let characteristics = {\n    \"ws\" : 15,\n    \"bs\" : 10,\n    \"s\" : 10,\n    \"t\" : 15,\n    \"i\" : 10,\n    \"ag\" : 0,\n    \"dex\" : 0,\n    \"int\" : 10,\n    \"wp\" : 10,\n    \"fel\" : 10\n}\nlet skills = [\"Intimidate\", \"Leadership\", \"Perception\"]\nlet skillAdvancements = [10, 10, 10]\nlet talents = [\"Combat Aware\", \"Drilled\", \"Menacing\", \"Robust\"]\nlet trappings = [\"Hand Weapon\", \"Mail Coat\", \"Mail Chausses\"]\nlet specialItems = [ \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWFRP4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","1Du4e27M8WgP2iui":"if (args.equipped === true && this.actor.name !== \"Kurgorn Three-eyes\") \n{\n    this.actor.addCondition(\"blinded\", 1, {\"statuses\" : [\"blinded\", \"blind\"]})\n    this.script.notification(`Blinded while wearing the ${this.item.name}`);\n} \n\nif (args.equipped === false && this.actor.name !== \"Kurgorn Three-eyes\") \n{\n  this.actor.removeCondition(\"blinded\")\n}","1E47r2ba6IGe8uFK":"return args.characteristic != \"t\"","1IodsW9ImamYoEYz":"args.actor.details.move.run += 4","1JwxZujbDcueLWBL":"await this.actor.addCondition(\"ablaze\", 2)\nawait this.script.message(await this.actor.applyBasicDamage(this.effect.sourceTest.result.damage, {suppressMsg: true}))","1LDSzXeO5CzXgTOc":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\")) || args.skill?.name == `${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})`","1LDm3OB32skZe6Xv":"return args.characteristic != \"wp\"","1MDOKny7IirJPoI6":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` ${this.effect.name}`})\nawait test.roll()\nif (test.succeeded)\n{\n    this.effect.delete();\n}\n","1OpT3CXs07XFWWCT":"args.context.cardsharp = true;","1PQPxFjmRlulHHzo":"if (args.opposedTest.result.hitloc.value == this.item.system.location.key && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 2);\n}\n    ","1UalUmNzjB4rp3SZ":"return [\"ws\", \"bs\", \"s\", \"ag\", \"t\", \"dex\"].includes(args.characteristic)","1ZArMNUI8qqH6zkX":"let test = await args.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  \" - \" + this.effect.name, context : {failure: \"Gained a Stunned Condition\"}})\nawait test.roll();\nif (test.failed)\n{\n    args.actor.addCondition(\"stunned\")\n}\n\n","1ZrzpfVwPJHdwp23":"this.actor.status.addArmour(1, {source: this.effect, magical : true})","1exiWlVUHsXDLLAH":"this.script.notification(`Cannot enter ${this.effect.name}!`);","1fQr1Dg7DX0vfz3r":"let healed = parseInt(this.effect.sourceTest.result.SL)\nthis.actor.modifyWounds(healed)\nthis.script.message(`Healed ${healed} Wounds`)","1jQq9v8fXK8zuEBU":"let damage = this.effect.sourceActor.hasCondition(\"fatigued\") ? 6 : 10;\n\nlet loc = \"body\"\n\nlet APatLoc = this.actor.system.status.armour[loc];\n\nlet metalAP = APatLoc.layers.reduce((metal, layer) => metal += ((layer.metal && !layer.magical) ? layer.value : 0), 0)\n\nlet APused = Math.max(0, APatLoc.value - metalAP); // remove metal AP at location;\n\ndamage -= (APused + this.actor.system.characteristics.t.bonus)\n\nlet msg = await this.actor.applyBasicDamage(damage, {suppressMsg : true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL});\nmsg += ` (ignored ${metalAP} metal AP on ${game.wfrp4e.config.locations[loc]})`\nthis.script.message(msg)\n\nlet test = await this.actor.setupSkill(\"Endurance\", {fields : {difficulty : \"difficult\"}, appendTitle : ` - ${this.effect.name}`});\nawait test.roll();\nif (test.failed)\n\tthis.actor.addCondition(\"stunned\");","1kB2su7hLRYDhZ2H":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\nif (!test.succeeded)\n{\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.ZhMADOqoo0y8Q9bx\")\n    let data = item.toObject();\n    if (this.item.system.location.key == \"rLeg\")\n    {\n        data.system.location.value = \"Right Toe\"\n\tdata.system.location.key = \"rToe\";\n    }\n    else if (this.item.system.location.key == \"lLeg\")\n    {\n        data.system.location.value = \"Left Toe\"\n\tdata.system.location.key = \"lToe\";\n    }\n    this.actor.createEmbeddedDocuments(\"Item\", [data])\n}\nthis.effect.delete();","1l7Jz2ZHbAWko7Vm":"args.context.ballockKnife = true;","1mNkLj9JYNr3ofC6":"this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test => {\n    await test.roll();\n    if (test.failed)\n    {\n        this.actor.addCondition(\"stunned\", 3)\n    }\n})","1wEjrgff7ASxKVmy":"if (args.effect.conditionId == \"bleeding\")\n    args.data.damage -= 1","1wKVvxRTHOyV4Qdv":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Sail\"))","1wrPvP6lJwIAfmsl":"let choice = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.locations), 1, \"Choose Location\");\n\nlet location = choice[0].id;\n\nlet itemTargeted = this.actor.items.get(this.effect.getFlag(\"wfrp4e\", \"itemTargets\")[0])\n\nif (itemTargeted)\n{\n    itemTargeted.update({[`system.APdamage.${location}`] : itemTargeted.system.APdamage[location] + 1})\n}","1yOvw74jzFfaI87b":"return args.context.reload\n","20fvE9nJmcfGYVzw":"if ( args.totalWoundLoss > 0 ) {\n    let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {difficulty: \"average\"})\n    await test.roll();\n    if (!test.succeeded)\n    {   \n        this.actor.addSystemEffect(\"gangrene\");\n    }\n}","22PMOW0G5MWiBQmg":"let fear = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nfear = fear.toObject();\nfear.system.specification.value = 1;\nawait this.actor.createEmbeddedDocuments(\"Item\", [fear], {fromEffect : this.effect.id})","22bW97lkvCqisfHX":"return args.type != \"channelling\" && !args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\"))","23HgjCB1oecxANvA":"if (args.item.range && args.item.range.bands)\n{\nargs.item.range.bands[game.i18n.localize(\"Long Range\")].modifier = 0\nargs.item.range.bands[game.i18n.localize(\"Extreme\")].modifier /= 2\n}","23vWiHUjxtRQ3Efz":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.eWPN3CV2Eddwz8aM\")\nlet data = item.toObject();\ndata.system.location.value = \"Back\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","29wHhLMnuoVjfQtN":"const sl = this.effect.getFlag(\"wfrp4e-archives3\", \"sl\");\nargs.item.system.damage.value += `+${sl}`;","2AOo7KUyzMrgIlgM":"CorruptionMessageModel.createCorruptionMessage(this.item.system.specification.value, {speaker : {alias: this.actor.prototypeToken.name}})","2AdSBXw7IwCiqawQ":"return args.skill?.name == game.i18n.localize(\"NAME.Bribery\") || args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"));","2Cw5j0iGAnFNegWr":"return args.item?.system.attackType\n","2EAYX5G9Fh3HJwiP":"let broken = this.actor.hasCondition(\"broken\");\n\nif (broken) {\n    broken.delete();\n    this.script.notification(\"Removed Broken.\");\n}","2Ej6LUqn8frTRURo":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {difficulty: \"hard\"})\nawait test.roll();\nif (!test.succeeded)\n{\n    await this.actor.addCondition(\"unconscious\");\n}","2GYAd4OC888oQFBp":"return ![\"fel\"].includes(args.characteristic)","2NLINicPQWbuvp2n":"return args.item?.name != game.i18n.localize(\"NAME.Navigation\")","2OqLHRqEBEjBm2LW":"args.fields.slBonus += this.actor.system.characteristics.wp.bonus","2QB0LjueuJcIaHaC":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = this.item.specifier;\n    if (!value)\n    {\n        value = await ValueDialog.create({text : \"Enter Armour value\", title : this.effect.name});\n    }\n    if (value)\n    {\n        this.item.updateSource({\"system.specification.value\" : value, name : this.item.baseName});\n    }\n}","2Qi1hwLYhdE6v6Hs":"if (![\"rLeg\", \"lLeg\"].includes(this.effect.getFlag(\"wfrp4e\", \"location\")))\n\treturn true;\n\nif (args.context.dodge)\n{\n\targs.abort = true;\n\tthis.script.notification(\"Cannot Dodge!\")\n}\nreturn [\"t\", \"int\", \"wp\", \"fel\"].includes(args.characteristic)","2S6XlGCdRlXuaaVw":"this.actor.system.status.corruption.value += 1","2VNnVrtktdGUqXEV":"if (args.totalWoundLoss > 0)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed && parseInt(args.opposedTest.attackerTest.result.SL) > 0)\n    {\n        args.actor.addCondition(\"stunned\", parseInt(args.opposedTest.attackerTest.result.SL))\n    }\n}   ","2W9uMTT6iJhfQ044":"let skill = `${game.i18n.localize(\"NAME.Trade\")} (${this.item.parenthesesText})`\nlet currentCareer = this.actor.system.currentCareer;\nlet existingSkill = this.actor.itemTypes.skill.find(i => i.name == skill);\n\nif (!currentCareer) return\n\n\nlet inCurrentCareer = currentCareer.system.skills.concat(currentCareer.system.addedSkills).includes(skill);\nlet craftsmanAdded = this.actor.getFlag(\"wfrp4e\", \"craftsmanAdded\") || {};\nif (existingSkill && inCurrentCareer && !craftsmanAdded[existingSkill.name])\n{\n\texistingSkill.system.advances.costModifier = -5;\n}\nelse \n{\n\tcraftsmanAdded[skill] = true;\n\tcurrentCareer.system.addedSkills.push(skill);\n\tfoundry.utils.setProperty(this.actor, \"flags.wfrp4e.craftsmanAdded\", craftsmanAdded)\n}","2WBq5gW780C6zfCp":"if (args.weapon && this.item.system.usesLocation(args.weapon))\n{\n    args.bleedingHand = true;\n    let success = await this.effect.manualScripts[0].execute({actor: this.actor})\n    if (!success)\n    {\n        args.abort = true;\n    }\n}","2WSN306tL4apjRtD":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9h82z72XGo9tfgQS\")\nlet data = item.toObject();\ndata.name = data.name += ` (${game.i18n.localize(\"SPEC.Hearing\")})`\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","2XXqxAF5s5Sws6qj":"this.actor.system.status.corruption.value += 2","2XaJNYUMQAmSOsqi":"const {targetUuid} = this.effect.flags.wfrp4e;\n\nif (args.attacker.uuid !== targetUuid) return;\n\nlet recordedWounds = this.effect.getFlag(\"wfrp4e\", \"damageToReturn\") ?? 0;\n\nrecordedWounds += args.totalWoundLoss;\n\nthis.effect.setFlag(\"wfrp4e\", \"damageToReturn\", recordedWounds);","2Yh4vQm0ZJukRH1x":"return !args.skill?.name.includes(\"Channelling\");","2cKarG9ToyW2ptCd":"if (this.item.system.quantity.value)\n{\n\tthis.item.update({\"system.quantity.value\" : this.item.system.quantity.value - 0.25})\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[1].convertToApplied()]})\n}\nelse\n{\n\tthis.script.notification(\"None left!\", \"error\")\n}","2hzDv8ROulOe1elK":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Lore\"));","2kRwCc31fuZgrsy8":"CorruptionMessageModel.createCorruptionMessage(\"major\", this.script.getChatData());","2mFNelLOAQ6iJsZl":"if (args.test.isFumble)\n{\n    args.test.result.other.push(\"@Table[doomrocket-fumble]\")\n}","2miWWeRrEpq1beG4":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.qn4ZpvTQIX4rcJDl\");\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n","2p9IK6Y5Z4NQD6FY":"args.prefillModifiers.difficulty = \"hard\"","2rzxQlL7A9ujZ9uK":"if (args.opposedTest.result.winner == \"attacker\") {\n  if (args.opposedTest.defenderTest.weapon && args.opposedTest.defenderTest.item.properties.qualities.shield) {\n    ui.notifications.notify(`<b>${this.effect.name}</b>: Gained ${this.item.Advances} Advantage`)\n    this.actor.setAdvantage(this.item.Advances)\n  }\n}","2sDH6RvoOAR40oqH":"\n\nif (![\"Goblin\", \"Orc\"].includes(this.actor.system.details.species.value)) {\n    let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), { appendTitle: ` - ${this.effect.name}` })\n    await test.roll();\n    if (test.failed) {\n        let infection = await fromUuid(\"Compendium.wfrp4e-core.items.Item.1hQuVFZt9QnnbWzg\")\n        this.actor.createEmbeddedDocuments(\"Item\", [infection])\n    }\n}\n\n// Since wounds change when the effect is deleted, need to wait until after \n// the max wounds have been recalculated to apply damage\nwarhammer.utility.sleep(1000).then(async () => {\n    let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\n\n    roll.toMessage(this.script.getChatData());\n    this.script.message(await this.actor.applyBasicDamage(roll.total, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg: true }))\n\n})","2vTVR0quRZQtjNfQ":"let currentCareer = this.actor.system.currentCareer;\nif (!currentCareer)\n{\n    return;\n}\n\nlet talents = [game.i18n.localize(\"NAME.AA\"),\n`${game.i18n.localize(\"NAME.ArcaneMagic\")} (${game.i18n.localize(\"SPEC.Any\")})`,\ngame.i18n.localize(\"NAME.ChaosMagic\") + \" \" +  \"(Tzeentch)\",\ngame.i18n.localize(\"NAME.FastHands\"),\ngame.i18n.localize(\"NAME.ID\"),\ngame.i18n.localize(\"NAME.MagicalSense\"),\ngame.i18n.localize(\"NAME.PettyMagic\"),\ngame.i18n.localize(\"NAME.SecondSight\"),\ngame.i18n.localize(\"NAME.WarWizard\"),\ngame.i18n.localize(\"NAME.Witch\")].filter(t => !currentCareer.system.talents.includes(t))\n\ncurrentCareer.system.talents = currentCareer.system.talents.concat(talents)","2wk0yrRPlPsdqr3L":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9GNpAqgsKzxZKJpp\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","2yW0kuwLfgRzJR2S":"const duration = 3600 * (1 + Number(this.effect.sourceTest.result.SL));\nthis.effect.update({\"duration.seconds\": duration});","2yctEihGmdCfTTVx":"args.data.canReverse = true;\nargs.context.fieldDressing = true;","2zeP2nMSURjxrqYz":"let wounds = this.actor.system.status.wounds\nif (wounds.value == 0)\n  return this.script.notification(\"No effect at 0 Wounds\", \"error\")\n\nthis.script.notification(`Healed ${this.actor.characteristics.t.bonus} Wounds`)\nawait this.actor.modifyWounds(this.actor.characteristics.t.bonus)","33PWizq5F7pkKnQT":"if (args.item.type == \"spell\")\n{\n    args.item.cn.value = Math.floor(args.item.cn.value / 2)\n}","33US8YRgaMqYu2We":"return !args.context.handling","37UN17gb8suFeZIW":"this.script.message(await this.actor.applyBasicDamage(8, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}))","3CdYFcInQVCIBUiE":"args.actor.system.details.move.value += 2;\nargs.actor.system.status.carries.max = Math.floor(args.actor.system.status.carries.max * 0.5);\nargs.actor.system.details.price.gc *= 1.1;","3CeKfDcMEVgQlcXm":"await this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.5hH73j2NgPdsLCZN\", this.effect, {name: \"Hatred (All enemies)\"});","3Cn2TlRahlm5LkSj":"args.fields.successBonus += 1;","3D5ImpMgpOTPucvv":"if (args.test.options.cardsharp && args.test.succeeded)\n{\n\nlet SL = Math.floor(args.test.target / 10) - Math.floor(args.test.result.roll / 10)\nlet ones = Number(args.test.result.roll.toString().split(\"\").pop())\n\nif (ones > SL)\n   args.test.result.other.push(`<span class=\"hide-option\"><b>${this.effect.name}</b>: ${ones + args.test.successBonus + args.test.slBonus} SL</span>`)\n}","3IGO7xEjRjat937X":"let fatigue = this.actor.hasCondition(\"fatigued\")\nif (fatigue)\n{\n   this.script.notification(\"Removing Fatigued Condition, disabled effect\")\n    this.effect.update({disabled : true})\n   await this.actor.removeCondition(\"fatigued\")\n}","3JEzEzF1SeYA9lsV":"let choice = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.locations, this.effect.img), 1, \"Choose Location\");\nif (choice[0])\n{\n    this.effect.updateSource({name : `${this.effect.name} (${choice[0].name})`})\nthis.effect.updateSource({\"flags.wfrp4e.location\" : choice[0].id})\n}\n\nlet location = choice[0].id;\n\nif ([\"lArm\", \"rArm\"].includes(location))\n{\n    let dropped = this.actor.itemTypes.weapon.filter(i => i.isEquipped & i.system.usesHands.includes(location));\n\n    if (dropped.length)\n    {\n        this.script.notification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}\n\nif (location == \"body\")\n{\n    await this.actor.addCondition(\"fatigued\");\n    test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"hard\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed)\n    {\n        this.actor.addCondition(\"prone\");\n    }\n}\n\nif (location == \"head\")\n{\n    await this.actor.addCondition(\"stunned\");\n    test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed)\n    {\n        this.actor.addCondition(\"unconscious\");\n    }\n}","3LLiSgj6KGtgqcmo":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Language\"));","3R6Y4NpNTqPc83wh":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.IPKRMGry6WotuS1G\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","3SuLF6SImYWEHMo2":"args.context.doombolt = true;","3TesBGh8HnlGuafu":"let modifier = this.effect.sourceTest?.result.overcast.usage.other.current || 0\n\nlet test = await this.actor.setupCharacteristic(\"dex\", {fields: {modifier}, skipTargets: true, appendTitle :  \" - \" + this.script.label});\n\ntest.roll();","3Vbe6gdW8N0bIvXJ":"if (args.item.type == \"weapon\" || args.item.type == \"trait\")\n{\n    args.item.qualities.value.push({name : \"penetrating\"})\n    args.item.qualities.value.push({name : \"impale\"})\n}","3aEzK0DehSHtVykd":"this.effect.manualScripts[0].execute({actor : this.actor});","3eSaX0BeaUalNkEP":"return args.context.mutate","3fdCQ3h3iVuhdDs9":"args.fields.slBonus += this.actor.characteristics.ag.bonus;","3hfMQkUKYI4rCuBy":"return args.skill?.name != game.i18n.localize(\"NAME.CharmAnimal\") && !args.skill?.name.includes(game.i18n.localize(\"NAME.AnimalTraining\"));","3ixqbsEMfSSTzAXU":"const test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {\n  difficulty: \"challenging\",\n  context: {\n    failure: \"Suffered @Condition[Fatigued] because of nightmares.\",\n    success: \"Suffered nightmares, but slept well enough.\"\n  }\n});\nawait test.roll();\n\nif (test.failed) {\n  await this.actor.addCondition(\"fatigued\");\n}","3jm0NoYpgB6ZuUSl":"args.context.useOnesAttractive = true;","3l7MQSa10Kve2K3P":"this.script.message(await this.actor.applyBasicDamage(Math.ceil(CONFIG.Dice.randomUniform() * 10) + 6, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true}))\nthis.actor.addCondition(\"ablaze\");","3nTSOcCmNZpQWK8b":"this.actor.addCondition(\"blinded\", 3);","3na3lnAt3bfysvcD":"const blinded = this.actor.hasCondition(\"blinded\");\nif (!blinded)\n  this.actor.addCondition(\"blinded\");","3plV9WFqs2prfAdp":"return ![\"NAME.Evaluate\", \"NAME.Gamble\"].map(i => game.i18n.localize(i)).includes(args.skill?.name)","3sfD1nedXLzuYoXJ":"if (this.actor.hasCondition(\"surprised\"))\n{\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"average\"}, skipTargets: true, appendTitle :  \" - \" + this.effect.name}).then(test => test.roll())\n}\n","3tE8gFSl28EhCmo5":"await args.actor.addCondition(\"ablaze\")\nawait args.actor.addCondition(\"prone\")","42UATqzohYML6a9t":"if ( !this.actor.hasCondition(\"poisoned\") ) {\n\tthis.effect.delete();\n}","454x3Q95pLvZm0Kx":"return args.skill?.name == game.i18n.localize(\"NAME.ConsumeAlcohol\");","4AO7Fowek5sSmE4g":"const venomUUID = \"Compendium.wfrp4e-core.items.gFkRm9wS65qe18Xv\";\nconst venom = this.actor.itemTags.trait.find(t => t.name === \"Venom\");\n\nif (venom) {\n  await this.effect.setFlag(\"wfrp4e-tribes\", \"venom\", {\n    _id: venom.id,\n    \"system.specification.value\": venom.system.specification.value\n  });\n  await venom.update({\"system.specification.value\": \"Difficult\"});\n} else {\n  await this.actor.addEffectItems(venomUUID, this.effect, {\n    \"system.specification.value\": \"Challenging\"\n  });\n}","4FGKZk2f0xrmIDnp":"return args.skill?.name != game.i18n.localize(\"NAME.Research\") && !args.skill?.name?.includes(game.i18n.localize(\"NAME.Language\"));","4HN98hMdQJxM35pA":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.gz2xy41OSVZ8YBgI\");\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data])\n","4JVIy5xtVwvadoqv":"this.actor.details.move.run *= 2","4MQ7u4INxp51oyyR":"let characteristics = {\n    \"ws\" : 25,\n    \"bs\" : 10,\n    \"s\" : 15,\n    \"t\" : 15,\n    \"i\" : 25,\n    \"ag\" : 20,\n    \"dex\" : 0,\n    \"int\" : 10,\n    \"wp\" : 25,\n    \"fel\" : 10\n}\nlet skills = [\"Cool\", \"Dodge\", \"Intimidate\", \"Intuition\", \"Leadership\", \"Lore (Warfare)\", \"Perception\"]\nlet skillAdvancements = [15, 15, 15, 15, 15, 10, 10]\nlet talents = [\"Combat Aware\", \"Combat Reflexes\", \"Feint\", \"Inspiring\", \"Resolute\", \"War Leader\"]\nlet trappings = [\"Hand Weapon\", \"Shield\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","4OlwxU60UqKg81yb":"const target = args.actor;\n\nif (target.has(\"Ethereal\") || target.has(\"Corruption\")) {\n  args.totalWoundLoss += 6;\n  args.modifiers.other.push({label: this.effect.name, value: 6})\n}","4QoxhoekgVeZcQA7":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.M5QSWOYt2Rbv2yxW\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","4XrAeL2DitxE8OaK":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.0hn6UaKq8CoZP2zD\")\nlet data = item.toObject();    \nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});","4ZR7p8G3OzOBWx0L":"return args.skill?.name !== game.i18n.localize(\"NAME.Endurance\");","4cOZzUvu1nytcqNn":"args.initiative = \"-10\"","4cumLUlcuJ7m8C6t":"let item = args.actor.items.find(i => i.name.includes(\"Smoothing\"));\nlet smoothing = item?.effects.find(e => e.name === \"Smoothing\");\nif (smoothing)\n  smoothing.disabled = true;","4drWKXjMgasxY7Jy":"args.actor.system.details.price.gc += Math.floor(args.actor.system.details.price.gc * 0.1);","4fnTKgl0HW9ZrWyJ":"this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty : \"average\"}}).then(async test =>\n{\n     await test.roll()\n     if (test.failed)\n     {\n         let char = Math.ceil(CONFIG.Dice.randomUniform() * 2) == 2 ? \"s\" : \"t\";\n         this.script.message(`<strong>${this.actor.name}</strong> lost 1 point of ${game.wfrp4e.config.characteristics[char]}`)\n         this.actor.update({[`system.characteristics.${char}.initial`] : this.actor.system.characteristics[char].initial - 1})\n     }\n})","4gkz3LR7CK1b8ulK":"return args.item?.system.attackType != \"ranged\" || this.actor.uuid != this.effect.sourceActor.uuid","4iu3CmOI19soOYuA":"let characteristics = {\n    \"ws\" : -10,\n    \"bs\" : -10,\n    \"s\" : 0,\n    \"t\" : 0,\n    \"i\" : -10,\n    \"ag\" : -10,\n    \"dex\" : 0,\n    \"int\" : -200,\n    \"wp\" : -200,\n    \"fel\" : -200\n}\nlet traits = [ {name:\"Armour\", value: 2}, {name:\"Construct\"}, {name:\"Dark Vision\"}, {name:\"Fear\", value: 2}, {name:\"Painless\"},{name:\"Undead\"},{name:\"Unstable\"} ];\nlet items = [];\n\nlet updateObj = this.actor.toObject();\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nupdateObj.system.characteristics.int.initial = 0;\nupdateObj.system.characteristics.wp.initial = 0;\nupdateObj.system.characteristics.fel.initial = 0;\n\nfor (let trait of traits)\n{\n    let traitItem = await game.wfrp4e.utility.find(trait.name, \"trait\")\n    if (traitItem)\n    {   \n        let t = traitItem.toObject();\n        t.system.specification.value = trait.value;\n        if (trait.disabled)\n        {\n            t.system.disabled = true;\n        }\n        items.push(t);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trait.name}`, {permanent : true})\n    }\n}\n    \n\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n","4iuTz0uInAfMaoGl":"return args.skill?.name?.includes(game.i18n.localize(\"NAME.Language\")) || args.type == \"cast\"","4jLe2XZQVUB8LztP":"args.fields.slBonus += this.effect.getFlag(\"wfrp4e\", \"slBonus\") || 0;","4otpLq2TnDdgzpvc":"args.actor.system.details.man -= 3;","4pQW4WLyhjbZR85k":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"average\"}, context : {failure: \"1 Corruption Point Gained\"}})\nawait test.roll();\nif (test.failed && this.actor.type == \"character\")\n{\n    this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + 1})\n    this.script.message(\"Gained a Corruption point\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","4rTmV3TNxctUe0ly":"let test = await this.actor.setupCharacteristic(\"ag\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\nif (test.failed)\n{\n   this.actor.addCondition(\"bleeding\");\n}\n","4rb7LfMq9CTnlrpn":"if (args.totalWoundLoss > 0)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name})\n    await test.roll();\n    if (test.failed)\n    {\n        args.totalWoundLoss += 5;\n        args.modifiers.other.push({label : this.effect.name, value : 5})\n    }\n}","4rhxLzau7jZ4SDxg":"await args.actor.addCondition(\"grappling\")\nawait args.actor.addCondition(\"entangled\")","4uAUUZmLgxBKSmXA":"if (args.totalWoundLoss > 0) \n  this.effect.delete();","4ylzjgUdHY5D0yVh":"let characteristics = {\n    \"ws\" : 25,\n    \"bs\" : 10,\n    \"s\" : 15,\n    \"t\" : 15,\n    \"i\" : 25,\n    \"ag\" : 20,\n    \"dex\" : 0,\n    \"int\" : 10,\n    \"wp\" : 25,\n    \"fel\" : 10\n}\nlet skills = [\"Cool\", \"Dodge\", \"Intimidate\", \"Intuition\", \"Language (Battle)\", \"Leadership\", \"Lore (Warfare)\", \"Perception\"]\nlet skillAdvancements = [15, 15, 15, 15, 10, 15, 10, 10]\n\nlet talents = [\"Combat Aware\", \"Combat Master\", \"Combat Reflexes\", \"Inspiring\", \"Resolute\", \"War Leader\"]\nlet trappings = [\"Hand Weapon\",  \"Shield\", \"Plate Breastplate\", \"Plate Bracers\", \"Plate Helm\", \"Plate Leggings\"]\nlet specialItems = []    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWFRP4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nlet filters = [\n    {\n        property : \"type\",\n        value : \"weapon\"\n    },\n    {\n        property : \"system.weaponGroup.value\",\n        value : [\"twohanded\", \"polearm\"]\n    }\n]\n\nitems = items.concat(await ItemDialog.createFromFilters(filters, 1, {text : \"Choose an appropriate Polearm or Two-Handed Weapon\"}))\n\nlet ride = await foundry.applications.api.DialogV2.confirm({title : \"Skill\", content : \"Add Chaos Steed and +20 Ride (Horse)?\", window : {title : this.effect.name}})\n\nif (ride)\n{\n    let skill = await game.wfrp4e.utility.findSkill(\"Ride (Horse)\")\n    skill = skill.toObject();\n    skill.system.advances.value = 20;\n    items = items.concat({name : \"Chaos Steed\", type: \"trapping\", \"system.trappingType.value\" : \"misc\"}, skill)\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","52kbfuWrOh6dsTtd":"if (!this.actor.hasCondition(\"blinded\"))\n\tthis.actor.addCondition(\"blinded\", 1, {\"flags.wfrp4e.flockOfDoom\" : true})","52mwb33mGrQjq89B":"return args.skill?.name != game.i18n.localize(\"NAME.Research\");","53HFDNuMnX1Aw1a4":"return [\"ws\", \"bs\", \"s\", \"ag\", \"dex\", \"int\", \"wp\", \"fel\"].includes(args.characteristic)","55eYGvSXetDMK80S":"const diseaseIds = this.actor.items.filter(i => i.type == \"disease\").map(i => i.id)\nthis.actor.deleteEmbeddedDocuments(\"Item\", diseaseIds)","58rFc9HiBoX66J6p":"let sourceActor = this.effect.sourceActor;\nlet damage = args.totalWoundLoss;\nlet tb = sourceActor.system.characteristics.t.bonus\nargs.abort = `<strong>${this.effect.name}</strong>: Damage applied to ${sourceActor.name}`;\n\nlet message = await sourceActor.applyBasicDamage(damage - tb, {damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true})\n\nthis.script.message(message.replace(`${tb} TB`, `${tb} × 2 TB`))\nargs.abort = true;","5DI6cHAg1LHo54Yv":"if (args.opposedTest.result.differenceSL >= 0 && args.opposedTest.result.differenceSL <= 2 && args.opposedTest.result.winner == \"attacker\")\n{ \n   this.actor.update({\"system.status.fortune.value\" : Math.max(0, (this.actor.system.status.fortune?.value - 1) || 0)})\n    this.script.message(`Fortune point stolen from <strong>${this.actor.name}</strong>`, {blind : true, whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n\n}","5Fe1ELaS6Gnvy0Cj":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\")) || args.type == \"channelling\" || args.skill?.name == game.i18n.localize(\"NAME.Charm\") || args.skill?.name.includes(`${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})`) || args.type == \"cast\"","5GHQxfxlmjyt1fNq":"let item1 = await fromUuid(\"Compendium.wfrp4e-core.items.Item.EO05HX7jql0g605A\")\nlet item2 = await fromUuid(\"Compendium.wfrp4e-core.items.Item.Bvd2aZ0gQUXHfCTh\")\nlet ids = await this.actor.createEmbeddedDocuments(\"Item\", [item1, item2], {fromEffect : this.effect.id})\nthis.actor.updateEmbeddedDocuments('Item', [ {_id: ids[0].id, 'system.specification.value': 16} ] )","5GP9UJMvBZv6kWtI":"this.script.message(await this.actor.applyBasicDamage(8, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}))\n\n\nlet msg = ``\nlet weapons = args.actor.itemTypes.weapon.filter(i => !i.system.location.value);\nlet armour = args.actor.itemTags.armour.filter(i => !i.system.location.value);\nfor(let item of weapons)\n{\n\tif (item.system.properties.qualities.shield)\n\t{\n\t\tawait item.system.damageItem(1, \"shield\");\n\t}\n\telse \n\t{\n\t\tawait item.system.damageItem(1);\n\t}\n\tmsg += `<p><strong>${item.name}</strong> damage by 1</p>`\n}\nfor(let item of armour)\n{\n\tawait item.system.damageItem(1);\n\tmsg += `<p><strong>${item.name}</strong> damage by 1</p>`\n}\nif (msg)\n{\n\tthis.script.message(msg, {speaker : {alias : args.actor.name}});\n}","5IoYTyedCMYwt3ys":"args.fields.slBonus += 2;","5JWC0l3JEpOsqbR9":"let characteristics = {\n    \"ws\" : 0,\n    \"bs\" : 5,\n    \"s\" : 0,\n    \"t\" : 0,\n    \"i\" : 10,\n    \"ag\" : 10,\n    \"dex\" : 0,\n    \"int\" : 0,\n    \"wp\" : 5,\n    \"fel\" : 0\n}\nlet skills = [\"Dodge\", \"Perception\"]\nlet skillAdvancements = [10, 10]\nlet talents = [\"Flee!\", \"Marksman\"]\nlet trappings = [\"Hand Weapon\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","5JvKJZPcd6Hz5zvn":"let characteristics = {\n    \"ws\" : 10,\n    \"bs\" : 0,\n    \"s\" : 10,\n    \"t\" : 10,\n    \"i\" : 20,\n    \"ag\" : 10,\n    \"dex\" : 0,\n    \"int\" : 0,\n    \"wp\" : 15,\n    \"fel\" : 0\n}\nlet skills = [\"Cool\", \"Dodge\", \"Intimidate\", \"Leadership\"]\nlet skillAdvancements = [15, 15, 10, 5]\nlet talents = [\"Combat Aware\", \"Combat Reflexes\", \"Feint\", \"Resolute\"]\nlet trappings = [\"Mail Coat\", \"Mail Chausses\", \"Mail Coif\", \"Hand Weapon\", \"Shield\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = this.effect.name + \" \" + updateObj.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","5KVslRqhqzuFLyk4":"if (!this.actor.has(\"Bless (Taal)\", \"talent\")) return;\n\nthis.actor.system.characteristics.wp.modifier += 15;","5LdJCKfQem1AQK24":"\nif (!args.flags.howlingWarpGale)\n{\n    args.fields.modifier -= 10;\n    args.flags.howlingWarpGale = true; // prevent double application\n}","5M6IgCUncCwyxHok":"let etiquette = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.sYbgpSnRqSZWgwFP\")).toObject();\netiquette.name += ` (Followers of Tzeentch)`;\n\nlet animosity = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.0VpT5yubw4UL7j6f\")).toObject();\nanimosity.system.specification.value = \"Followers of Nurgle\";\n\nlet roll = await new Roll(\"ceil(1d10 / 3)\").roll({allowInteractive : false});\n\nroll.toMessage(this.script.getChatData());\n\nlet mutations = [];\nlet msg = `<p><strong>Mutations Gained</strong></p>`\nfor(let i = 0; i < roll.total; i++)\n{\n    let item;\n    let uuid;\n    let result;\n    if (i % 2 == 0)\n    {\n        result = await game.wfrp4e.tables.rollTable(\"mutatemental\", {hideDSN: true}, \"Tzeentch\")\n    }\n    else \n    {\n        result = await game.wfrp4e.tables.rollTable(\"mutatephys\", {hideDSN: true}, \"Tzeentch\")\n    }\n    uuid = `Compendium.${result.object.documentCollection}.${result.object.documentId}`;\n    item = await fromUuid(uuid);\n    if (item)\n    {\n        msg += `<p>@UUID[${uuid}]{${item.name}}</p>`\n        mutations.push(item.toObject());\n    }\n}\nthis.actor.createEmbeddedDocuments(\"Item\", mutations.concat([etiquette, animosity]), {fromEffect : this.effect.id})\nthis.script.message(msg);","5MxRDXzUBPfp2KKD":"args.context.useOnesSupportive = true;","5ScjIdRUOxblHdWS":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'challenging';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","5XAYjiq1i4M7Ky7j":"const trait = this.actor.itemTags.trait.find(t => t.name === \"Regenerate\");\nconst name = \"Rotten Regeneration\";\n\nif (!trait) return;\n\nconst effect = trait.effects.find(e => e.name === \"Regenerate\");\nconst scriptData = effect.system.scriptData;\n\nscriptData[0].script = `  \n  let chatData = {whisper: ChatMessage.getWhisperRecipients(\"GM\")};\n  let message = \"\";\n  \n  let wounds = foundry.utils.duplicate(this.actor.status.wounds);\n  let regenRoll = await new Roll(\"1d10\").roll({allowInteractive : false});\n  let regen = regenRoll.total;\n  \n  if (wounds.value >= wounds.max)\n    return;\n  \n  if (wounds.value > 0) {\n    wounds.value += Math.floor(regen / 2);\n    if (wounds.value > wounds.max) {\n      wounds.value = wounds.max;\n    }\n    message += \\`<b>\\${this.actor.name}</b> regains \\${regen} Wounds.\\`;\n  \n    if (regen === 10) {\n      message += \"<br>Additionally, they regenerate a Critical Wound.\";\n    }\n  } else if (regen >= 8) {\n    message += \\`<b>\\${this.actor.name}</b> rolled a \\${regen} and regains 1 Wound.\\`;\n    wounds.value += 1;\n    if (regen === 10) {\n      message += \"<br>Additionally, they regenerate a Critical Wound.\";\n    }\n  } else {\n    message += \\`<b>\\${this.actor.name}</b> Regenerate roll of \\${regen} - No effect.\\`;\n  }\n  \n  await this.actor.update({\"system.status.wounds\": wounds});\n  this.script.message(message, {whisper: ChatMessage.getWhisperRecipients(\"GM\")});\n`\n\nawait effect.update({\n  name,\n  \"system.scriptData\": scriptData\n});\n\nawait trait.update({name});","5Zxc13GBaJaxCf48":"const visor = this.item.getFlag('wfrp4e', 'visor');\n\nif (!visor)\n  args.fields.modifier -= 10;\nelse\n  args.fields.modifier -= 20;","5dR7Erj3nwsxLAV7":"let characteristics = {\n    \"ws\" : 35,\n    \"bs\" : 10,\n    \"s\" : 25,\n    \"t\" : 30,\n    \"i\" : 30,\n    \"ag\" : 25,\n    \"dex\" : 0,\n    \"int\" : 15,\n    \"wp\" : 35,\n    \"fel\" : 15\n}\nlet skills = [\"Cool\", \"Dodge\", \"Intimidate\", \"Intuition\", \"Leadership\", \"Lore (Warfare)\", \"Perception\"]\nlet skillAdvancements = [25, 15, 25, 25, 30, 20, 20]\nlet talents = [\"Combat Aware\", \"Combat Reflexes\", \"Feint\", \"Inspiring\", \"Luck\", \"Resolute\", \"Unshakable\", \"War Leader\"]\nlet trappings = [\"Hand Weapon\", \"Shield\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","5gPAT5Bb2FvQwYNQ":"args.test.preData.other.push(`Thanks to the ${this.effect.name} you may reverse the result on this Test.`);\nargs.test.preData.canReverse = true;\nthis.effect.delete();","5lc1eHIYQNpSRWip":"if ([\"death\", \"necromancy\"].includes(args.spell?.system.lore.value))\n{\n    args.fields.successBonus += 1\n}\nelse if([\"life\", \"light\", \"heavens\"].includes(args.spell?.system.lore.value))\n{\n    args.fields.modifier -= 10;\n}","5lpR78CLhYH6Mjnu":"if (this.actor.has(\"Arboreal\",\"trait\")) return\n\nthis.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.rOV2s6PQBBrhpMOv\", this.effect)","5o1XiceC4rutjMms":"return !args.item?.name.includes(game.i18n.localize(\"NAME.Stealth\"))","5sI9iYh5j2nx2XyT":"return !([game.i18n.localize(\"NAME.AnimalCare\"), game.i18n.localize(\"NAME.CharmAnimal\")].includes(args.item?.name) || args.item?.name.includes(game.i18n.localize(\"NAME.Ride\")) || args.item?.name.includes(game.i18n.localize(\"NAME.AnimalTraining\")));","5sYpJkT2WXIe0gIZ":"const rating = parseInt(this.effect.name.match(/\\d+/)?.[0]) || 1;\n\nlet crewList = foundry.utils.duplicate(this.actor.system.passengers.list);\nlet selectedCrew = [];\n\nwhile (selectedCrew.length < rating && crewList.length) {\n  selectedCrew.push(crewList.splice(crewList.length * Math.random() | 0, 1)[0]);\n} \n\nfor (let member of selectedCrew) {\n  let actor = game.actors.get(member.id);\n  actor.applyBasicDamage(9, {\n    damageType: game.wfrp4e.config.DAMAGE_TYPE.NORMAL, \n    minimumOne: true, \n    loc: \"roll\", \n    suppressMsg: false, \n    hideDSN: false \n  });\n}","6136BMmiGLwZ16H1":"return !!args.skill","62Ky6bC1EnTllSJA":"if (this.effect.sourceActor.uuid != args.actor.uuid)\n{\n    this.script.message(await this.actor.applyBasicDamage(this.effect.sourceTest.result.overcast.usage.other.current, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg: true}));\n}","65o8pQj6oGNnXce6":"let ch = this.effect.getFlag(\"wfrp4e\", \"characteristic\")\nthis.actor.system.characteristics[ch].modifier += 10;","65xE9OV5sA1ZWT7j":"if (args.test.options.diceman && args.test.succeeded)\n{\n\nlet SL = Math.floor(args.test.target / 10) - Math.floor(args.test.result.roll / 10)\nlet ones = Number(args.test.result.roll.toString().split(\"\").pop())\n\nif (ones > SL)\n   args.test.result.other.push(`<span class=\"hide-option\"><b>${this.effect.name}</b>: ${ones + args.test.successBonus + args.test.slBonus} SL</span>`)\n}","6A6ddQDJo23oOWtK":"const SL = this.effect.getFlag(\"wfrp4e\", \"SL\") ?? 0;\n\nargs.fields.slBonus += SL;","6Aqq4F4Xui923sc6":"// Imbibing this substance grants the user the Painless Creature Trait.\nconst hasColdBlooded = this.actor.has(\"Cold Blooded\")\nif (hasColdBlooded === undefined) \n{\n  let item = await fromUuid(\"Compendium.wfrp4e-core.items.mCh1KK9jomwFZcLB\")\n  let data = item.toObject()\n  this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n  \n  this.script.message(`<p><strong>${this.actor.prototypeToken.name}</strong> has gained the Cold Blooded Creature Trait and may reverse any failed Willpower based Tests.</p>\n  <p>If they gain a Surprised Condition, this Condition is not lost the first time it should be (which is typically at the end of the Round or if they victim is attacked).</p>`, \n  {whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })   \n}","6AsCMHZ4IYPq7Uxf":"return args.skill?.name.includes(\"Channelling\");","6BmvV9c03FkfisnE":"// Apply changes when the mask is worn\n\nif (args.equipped) {  \n  this.actor.createEmbeddedDocuments(\"ActiveEffect\", [this.item.effects.contents[1]?.convertToApplied()])  \n  this.script.message(`${this.actor.name} dons the <strong>${this.item.name}</strong>. <br>\n      They gain +1 Corruption point if an exposure Test is failed, which will need to be manually applied.<br>If they wear the mask for more than an hour or benefit from any of its effects, they are exposed to @Corruption[moderate]{Moderate Corruption} \n      `,\n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n}\n\n// Notify of lingering effects when mask is removed\nelse if (!args.equipped)\n{\n    await this.item.effects.contents[0].delete();\n    await this.item.update({name : this.item.name += \" (Used)\"})\n    this.script.message(`<strong>${this.item.name}</strong> on ${this.actor.name} has been taken off and loses its properties. However, the effects last for [[1d10+4]] days, after which they should be manually removed.`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n    )\n    \n}","6EXkbVTRBhKTEu81":"if (!args.flags.bothEyes)\n{\n\targs.flags.bothEyes = true;\n\targs.fields.modifier -= 30\n}","6Fe8M5MdklKS2olx":"return args.characteristic != \"fel\"","6H6vNjzvMGl2ZqCR":"if (args.totalWoundLoss > 0)\n     this.script.message(`<b>Blade of Nurglitch: ${args.actor.name}</b> must pass an <b>Difficult (-10) Endurance</b> Test or gain a @UUID[Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb]{Festering Wound}`, {whisper: ChatMessage.getWhisperRecipients(\"GM\") })","6JrUjs3g5x6bFnj3":"let bite = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet sense = await fromUuid(\"Compendium.wfrp4e-core.items.9h82z72XGo9tfgQS\")\nlet biteData = bite.toObject();\nlet senseData = sense.toObject();\n\nbiteData.system.specification.value = 6 - this.actor.characteristics.s.bonus;\nsenseData.name = senseData.name += game.i18n.localize(\"SPEC.Smell\")\nthis.actor.createEmbeddedDocuments(\"Item\", [biteData, senseData], {fromEffect : this.effect.id})","6LMzIdmCSYctgmGx":"const stupid = this.actor.items.find(i => i.name === \"Stupid\");\n\nif (!stupid) return;\n\nawait stupid.update({\"system.disabled\": true});","6MSodMuZ5xk2JJJ9":"if (!this.actor.hasCondition(\"ablaze\"))\n{\n    this.effect.delete();\n}","6Mjy0jDqczA8BxhS":"return ![\"roll\", \"none\"].includes(args.fields.hitLocation)","6P2QNPKfwQ1xwxZT":"args.fields.slBonus ++","6QZUX7ZrFxOzqI0b":"let regenerate = this.actor.items.getName('Regenerate')\n\nif (regenerate)\n{\n    let effect = regenerate.effects.contents[0]\n    let scriptData = effect.system.scriptData;\n    \n    scriptData[0].script = scriptData[0].script.replace(\"1d10\", \"1d10 * 2\")\n}","6U8xox4mBrn5eYIp":"if (args.totalWoundLoss > 0)\n   args.actor.addCondition(\"ablaze\")","6V3qHON3mcerlBlB":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\");\n}","6Ws3ieQ7pG5poUyT":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create({text : \"Enter Spellcasting Lore\", title : this.effect.name}, \"\", Object.values(game.wfrp4e.config.magicLores));\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","6XWJWOUQPgKMsFul":"return args.item?.system.attackType != \"ranged\" || args.flags.howlingWarpGale","6ZS1rQLkNvMDO0Fp":"let roll = Math.ceil(CONFIG.Dice.randomUniform() * 10)\nif (args.test.isFumble && roll == 1 && !args.test.result.misfire)\n{\n  args.test.result.misfire = game.i18n.localize(\"Misfire\") + \" (Rolled 1)\"\n  args.test.result.misfireDamage = eval(parseInt(args.test.result.roll.toString().split('').pop()) + args.test.item.Damage)\n}\nelse if (args.test.isFumble && roll != 1)\n{\n    args.test.result.other.push(\"Misfire Roll: \" + roll)\n}\n\n","6elUNF58TaiYjxcx":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  \" - \" + this.effect.name, context : {failure: \"Gained a Stunned Condition\"}})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\");\n}","6fElmBxTjdAaubbK":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"average\"}});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}\n","6frithfMs7Nbv0IZ":"args.fields.slBonus += this.effect.sourceActor.system.characteristics.fel.bonus;","6gRixT3zIOAberJb":"const disease = await fromUuid(\"Compendium.wfrp4e-soc.items.Item.8Q9JYtR1y3B5J6UH\");\nconst data = disease.toObject();\ndata.system.incubation.value = 0;\ndata.system.duration.active = true;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id});","6hAgggYpNR3r4QWC":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Q2MCUrG2HppMcvN0\")\nitem = item.toObject()\nlet species = args.actor.Species || \" of your species\"\nitem.name = `Animosity (all not ${species})`\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","6jcTzK1XEuWqAacN":"args.abort = true;\nthis.script.notification(`Cannot use ${game.wfrp4e.config.locations[this.effect.getFlag(\"wfrp4e\", \"location\")]}!`, \"error\")","6jp8slPU33oBQe1V":"return args.context.crewTest?.system.handling !== true;","6kifXp2jXEaQVJsg":"let useWard = await foundry.applications.api.DialogV2.confirm({\n\tcontent : `<p>Use Ward provided by <strong>${this.effect.name}</strong>?`,\n\twindow : {\n\t\ttitle : this.effect.name,\n\t}\n})\n\nif (useWard)\n\targs.ward = 9;","6maNAmREdataXmo4":"if (this.actor.system.status?.ward?.value) {\n  this.actor.system.status.ward.value = Math.max(7, this.actor.system.status.ward.value-1);\n} else {\n  this.actor.system.status.ward.value = 9;\n}","6mpw9cGseG4W4eyd":"if (this.actor.system.status.advantage.value >= 2)\n{\n    await this.actor.modifyAdvantage(-2);\n    this.script.notification(\"Advantage Subtracted\")\n}\nelse \n{\n    return this.script.notification(\"Not enough Advantage!\", \"error\")\n}\n\nlet test = await this.actor.setupTrait(this.item)\nawait test.roll();","6nA5LPXneAahHX2W":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {skipTargets: true, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n\tlet sourceActor = this.effect.sourceActor;\n\tthis.script.message(await this.actor.applyBasicDamage(4 + sourceActor.system.characteristics.s.bonus, {suppressMsg : true}))\n}","6oSs8qKFNFz2lSmh":"if (args.actor.system.details.move.sail.value > 0)\n  args.actor.system.details.move.sail.value = 0;\n","6qJP0hpShEM43ohx":"const actor = args.actor;\n\nif (actor.itemTypes.skill.find(s => s.name === \"Lore (Oceans)\")) {\n  const loreTest = await actor.setupSkill('Lore (Oceans)',  {\n    appendTitle: ` – ${this.effect.name}`,\n    skipTargets: true,\n    fields: {difficulty: 'hard'},\n    characteristic: 'int',\n  });\n  await loreTest.roll();\n\n  if (loreTest.succeeded) {\n    loreTest.result.other.push(`<b>${actor.name}</b> recognizes lure of the Leviathan.`);\n    loreTest.renderRollCard();\n    return;\n  } \n}\n\nlet test = await actor.setupSkill('Cool',  {\n  appendTitle: ` – ${this.effect.name}`,\n  skipTargets: true,\n  fields: {difficulty: 'easy'},\n  characteristic: 'wp',\n});\nawait test.roll();\n\nif (!test.succeeded) {\n  test.result.other.push(`<b>${actor.name}</b> became @Condition[Stunned] by the sight.`);\n  test.renderRollCard();\n  actor.addCondition(\"stunned\");\n}","6qUKKep5vhFYmo1J":"return args.type == \"channelling\" || args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\"))","6tjn0RH4VyOPFneS":"return [\"NAME.Row\", \"NAME.Swim\"].map(i => game.i18n.localize(i)).includes(args.skill?.name);","6ubojp9zwbfJnosT":"args.actor.system.details.move.value += 1;","6uldpFvKOCoW92cC":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.uqGxFOEqeurwkAO3\")\nitem = item.toObject()\n\nitem.system.specification.value = 10;\nitem.name += \" (Fire)\"\nfoundry.utils.setProperty(item, \"flags.wfrp4e.breath\",  \"fire\")\n\nItem.create(item, {parent : this.actor, fromEffect: this.effect.id})","6xTtJEhRc4OjcDTf":"if (foundry.utils.getProperty(args.data, \"system.status.fortune.value\"))\n{\n\tthis.script.notification(\"Cannot update Fortune\");\n\tdelete args.data.system.status.wounds.value;\n}","715G1Bf0haOHvmYQ":"return !(args.skill?.name == game.i18n.localize(\"NAME.Bribery\") || args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\")))","71DmrxCTKGYL4Z7X":"return [\"fel\"].includes(args.characteristic)","7Ck0fkzE4WQ62qVe":"if (args.item.type  == \"skill\" && args.item.name == `${game.i18n.localize(\"NAME.Melee\")} (${game.i18n.localize(\"SPEC.Basic\")})`)\n{\n     args.item.system.modifier.value += 20;\n}","7F3miqRA0ceMUBIu":"return args.characteristic != \"int\" || args.skill","7F6aGxZJjwxm5e5P":"if (args.test.result.castOutcome == \"failure\")\n{\n    ValueDialog.create({text : \"Enter Wounds Lost to gain SL\", title : this.effect.name}, \"0\").then(async value => {\n        value = Math.clamp(value, 0, 3)\n        if (value == 0)\n        {\n            return;          \n        }\n        else if (Number.isNumeric(value))\n        {\n            this.script.notification(`Lost ${value} Wounds`)\n            this.actor.modifyWounds(-1 * value)\n            await this.item.system.toggleEquip();\n            args.test.addSL(value);\n            args.test.preData.other.push(`<strong>${this.effect.name}</strong>: +${value} SL`)\n        }\n    })\n}","7H6wYyJ6cpaoc2QQ":"return args.skill?.name == game.i18n.localize(\"NAME.Cool\");","7JW9t8AYSDkkzG2V":"// Apply changes when the mask is worn\n\nif (args.equipped) \n{  \n  this.actor.createEmbeddedDocuments(\"ActiveEffect\", [this.item.effects.contents[1]?.convertToApplied()])  \n  this.script.message(`${this.actor.name} dons the <strong>${this.item.name}</strong>. <br>\n      If they wear the mask for more than an hour or benefit from any of its effects, they are exposed to @Corruption[moderate]{Moderate Corruption}. \n      `,\n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n}\n\n// Notify of lingering effects when mask is removed\nelse if (!args.equipped)\n{\n    await this.item.effects.contents[0].delete();\n    await this.item.update({name : this.item.name += \" (Used)\"})\n    this.script.message(`<strong>${this.item.name}</strong> on ${this.actor.name} has been taken off and loses its properties. However, the effects last for [[1d10+4]] days, after which they should be manually removed.`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n    )\n    \n}","7OmrMjaU48o2FEZi":"\nthis.actor.characteristics.t.bonus = 10\n\nthis.actor.details.move.value = 0;\nthis.actor.details.move.walk= 0;\nthis.actor.details.move.run = 0;","7ScfB4o1QhXnNUfq":"return ![\"int\", \"wp\"].includes(args.characteristic)","7T3iXgrL72fea67C":"const bloodyFluxUUID = \"Compendium.wfrp4e-core.items.Item.herUmN51D9TiL2Vn\";\n\nconst test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {\n  skipTargets: true,\n  appendTitle: ` — ${this.effect.name}`,\n  fields: {difficulty: \"easy\"},\n  context: {\n    success: `Butcher is healed.`,\n    failure: `Butcher contracts @UUID[${bloodyFluxUUID}].`\n  }\n});\n\nawait test.roll();\n\nif (test.failed) {\n  await this.actor.addEffectItems(bloodyFluxUUID, this.effect);\n} else {\n  const SL = test.result.SL;\n  const heal = 1 + SL;\n  await this.actor.modifyWounds(heal);\n  this.script.message(`Butcher healed ${heal} Wounds.`);\n}","7UUS0gX2Pbi0HHiz":"return args.skill?.name !== game.i18n.localize(\"NAME.Swim\");","7VAhXHov6pR1SkgD":"return args.item?.name == game.i18n.localize(\"NAME.Endurance\");","7WR2hJjHPhHhHxAq":"let poisoned = args.actor.hasCondition(\"poisoned\")\nif (poisoned)\n{\n   this.script.notification(`Removed ${poisoned.conditionValue} Poisoned Conditions`)\n   poisoned.delete();  \n}\nelse\n  this.script.notification(`No Poisoned Conditions`)","7ZoFUMDG2WJd8RMg":"this.script.message(`Claimed <strong>${this.effect.name}</strong> Bonus`);","7ateEtT5HXg1vObY":"const uuids = [\n  \"Compendium.wfrp4e-core.items.Item.AcnFuDKRemLI9ey7\",     // Nose for Trouble\n  \"Compendium.wfrp4e-core.items.Item.WoXShzaYkV5F6c48\",         // Master of Disguise\n];\n\nconst items = await Promise.all(uuids.map(uuid => fromUuid(uuid)));\nawait this.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect: this.effect.id});","7e8FgQUF2oANANmx":"return args.skill?.name == game.i18n.localize(\"NAME.MeleeBrawling\") || args.item?.weaponGroup?.value == \"brawling\"","7f6OsttTzE7Hvzfk":"if (this.actor.statuses.has(\"infighting\") && !args.flags.infighter) \n{\n    args.fields.modifier += 10;\n    args.flags.infighter = true;\n}\n\nargs.fields.successBonus += 1; ","7n3SEAGRA5ESK8gV":"args.context.disarm = true;","7szLG4VALuuy1cPm":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"easy\"}})\nawait test.roll();\nif (test.failed)\n{ \n  await this.actor.addCondition(\"fatigued\")\n} ","7w7QA7GBhzZ98OS0":"const sin = this.effect.sourceActor.system.status.sin.value;\nconst result = await WFRP_Tables.rollTable(\"manann-mood-made-meaningless\", sin);\nlet match = result.description.match(/b>([^<]+)/i);\nlet key = match[1];\nlet roll = new Roll(\"5d10\");\nlet value = undefined;\n\nawait this.script.message(result.description, {flavor: result.title});\n\nswitch (key) {\n  case 'Stromfels Triumphant!':\n    value = 0;\n    break;\n  case 'Stromfels Ascends!':\n    await roll.evaluate();\n    if (this.actor.system.status.mood.value > 0)\n      value = -roll.total;\n    else if (this.actor.system.status.mood.value < 0)\n      value = roll.total;\n    break;\n  case 'No effect.':\n    break;\n  case 'Manann Provoked!':\n    await roll.evaluate();\n    value = -roll.total;\n    break;\n}\n\nif (roll._evaluated)\n  await roll.toMessage();\n\nawait this.effect.setFlag(\"wfrp4e-soc\", \"m4result\", {result: key, value});","7wBWUw05q0igh508":"// Imbibing this substance grants the user the Painless Creature Trait.\nconst hasPainless = this.actor.has(\"Painless\");\nif (hasPainless === undefined) \n{\n  let item = await fromUuid(\"Compendium.wfrp4e-core.items.wMwSRDmgiF2IdCJr\");\n  let data = item.toObject()\n  this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n  \n  this.script.message(\n  `<p><strong>${this.actor.prototypeToken.name}</strong> has gained the Painless Creature Trait. This\n    effect lasts for one hour, after which it dissipates and the full effect\n    of all the imbiber's wounds come crashing down at once.</p>\n    <p>Note that this does not prevent the user from acquiring a Critical\n    Wound or dying from one. It merely allows them to ignore most\n    of their effects.</p>`, \n    { whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true})\n}","84IB8CWa55XzoAkv":"return ([game.i18n.localize(\"NAME.AnimalCare\"), game.i18n.localize(\"NAME.CharmAnimal\")].includes(args.item?.name) || args.item?.name.includes(game.i18n.localize(\"NAME.Ride\")) || args.item?.name.includes(game.i18n.localize(\"NAME.AnimalTraining\")));","86ivOsBQAuu0UmFg":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"hard\"}, appendTitle : ` - ${this.effect.name}`, skipTargets: true});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"poisoned\");\n}","87rrZ3ojHrXa3lCn":"this.actor.modifyWounds(1)","8AoA4bnstBtglRGZ":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.wMwSRDmgiF2IdCJr\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","8ByuHnUZ4RNTdGVv":"let strLoss = Math.ceil(CONFIG.Dice.randomUniform() * 10)\nlet tghLoss = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n\nif (!this.actor.has(\"Undead\") && !this.actor.has(\"Daemonic\")) \n{\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), { appendTitle: \" - \" + this.effect.name, fields: { difficulty: \"average\" }, context: { failure: `Lost ${strLoss} Strength and ${tghLoss} Toughness` } }).then(async test => {\n        await test.roll();\n        if (test.failed) {\n            this.actor.update({ \"system.characteristics.s.initial\": this.actor.system.characteristics.s.initial - strLoss, \"system.characteristics.t.initial\": this.actor.system.characteristics.t.initial - tghLoss })\n        }\n    })\n\n}\nelse {\n    this.script.notification(`<strong>${this.actor.name}</strong> is immune to ${this.effect.name}`)\n}\n","8GyJgdHVBaLrHCY8":"let type = this.item.getFlag(\"wfrp4e\", \"breath\")\nlet types = {\n    none : \"None\",\n    cold : \"Cold\",\n    corrosion : \"Corrosion\",\n    fire : \"Fire\",\n    electricity : \"Electricity\",\n    poison : \"Poison\",\n    smoke : \"Smoke\",\n    various : \"Various\"\n}\nif (!type)\n{\n    type = (await ItemDialog.create(ItemDialog.objectToArray(types, this.item.img), 1, \"Choose Breath\"))[0]?.id;\n    this.item.updateSource({\"flags.wfrp4e.breath\" : type})\n}\n\nif (!this.item.name.includes(\"(\") && types[type] && type != \"none\")\n{\n    this.item.updateSource({name : this.item.name += ` (${types[type]})`, \"system.specification.value\" : this.item.system.specification.value.replace(\"(Type)\", \"\").trim()})\n}","8K9tpCwvFC9INk5V":"if ([\"t\", \"wp\"].includes(args.characteristic))\n{\n\targs.fields.modifier += 10;\n}\nelse if ([\"ag\", \"i\", \"int\"].includes(args.characteristic))\n{\n\targs.fields.modifier -= 10;\n}","8LmUVQxOwTLSeabg":"return args.data.targets.length > 0 || !args.weapon?.system.qualities.value.find(i => i.name == \"shield\") // Should count even if they don't have the skill","8N3Uqjq1ZxPxo4pk":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Lore\"))","8RNziYGGb4sp3BGQ":"if (!args.test.weapon?.name.includes(\"Drakefire\"))\n{\n    args.test.result.misfire = game.i18n.localize(\"Misfire\");\n    args.test.result.misfireDamage = (0, eval)(parseInt(args.test.result.roll.toString().split('').pop()) + args.test.weapon.system.Damage);\n}","8ShLVT0bK1eQpinj":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.k00PimCWkff11IA0\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data])","8TRiAJ8thIKE4IoL":"\nlet SL = Number(foundry.utils.getProperty(this.item, \"flags.wfrp4e.sourceTest.result.SL\") || 1)\n\nargs.actor.characteristics.i.modifier += 10 * SL\nargs.actor.characteristics.ag.modifier += 10 * SL","8ThudCYRqkjQIwJH":"if (args.opposedTest.attackerTest.result.critical)\n{\n   args.actor.addCondition(\"ablaze\")\n}","8WJsecxdndaHRxxS":"this.actor.status.addArmour(this.actor.characteristics.wp.bonus, {source: this.effect, magical : true})","8WeYU5e5LN9UeWFs":"if (args.item.type == \"spell\")\n{\n   let range = parseInt(args.item.Range)\n   if (Number.isNumeric(range))\n   {\n          args.item.system.range.value = \"2 * \" + args.item.system.range.value\n   }\n}","8ZAUBSH9CM9OTpTL":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Perception\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"easy\"}});\nawait test.roll();\n\nif (test.succeeded)\n{\n    this.actor.addCondition(\"stunned\")   \n}\nelse if (test.failed)\n{\n    this.actor.addCondition(\"poisoned\", 2);\n}","8araLuwmBq8GKEw3":"let APIgnored = args.AP.layers.reduce((prev, current) => prev + ((current.weakpoints && !current.ignored) ? current.value : 0), 0)\n\nif (APIgnored)\n{\n    args.modifiers.ap.ignored += APIgnored\n    args.modifiers.ap.details.push(`<strong>${this.effect.name}</strong>: Ignore AP with Weakpoints (${APIgnored})`)\n}","8fefDfiYKFOWdPER":"args.update({texture : {scaleX : 2, scaleY: 2, src: \"modules/wfrp4e-core/tokens/popout/gor.webp\"}});","8g2iitsgaJarKQpr":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.V0c3qBU1CMm8bmsW\")\nlet data = item.toObject()\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","8gCja0mfKt4nYVZc":"args.fields.slBonus += 2 ","8hIyWDyfbgGAig65":"return [\"ws\", \"bs\", \"s\", \"t\", \"ag\", \"dex\"].includes(args.characteristic)","8jvEVPUCg3rKG48Y":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9fq6p9Q6H02LjaSi\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","8noxHUQKR55Kx1YN":"this.actor.system.status.corruption.max += 1","8oE0DTzz0krOfFlV":"args.item.system.qualities.value.push({name : \"magical\"})\nargs.item.system.qualities.value.push({name : \"impact\"})\n","8rq4GL5d5nCn4kO7":"let caster = this.effect.sourceActor\nif (caster)\n{\n    let healed= caster.characteristics.wp.bonus\n    this.actor.modifyWounds(healed);\n    this.script.message(`<strong>${this.actor.prototypeToken.name}</strong> regains ${healed} Wounds`)\n}","8tyMXDfHR8AJBdDu":"let weakpointsAP = args.AP.layers.filter(i => !i.ignored && i.weakpoints).reduce((ap, layer) => ap + layer.value, 0);\n\nif (weakpointsAP > 0)\n{\n    args.modifiers.ap.ignored += weakpointsAP;\n    args.modifiers.ap.details.push(`${this.effect.name} - Ignore Weakpoints (${weakpointsAP})`);\n}","8vpAtJ93GIeye1qj":"return args.type == \"cast\"","8wG9l4T9fc1bM0TN":"let item = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.kJNAY1YRaCy9IgmT\")).toObject();\nitem.system.specification.value = 1;\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","8xqYrBIf1Zhlwizg":"const repaired_message = `<p>Finished raisint <em>the anchor</em>.</p>`;\nconst test = 'Strength';\nconst difficulty = 'vhard';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","8yBr6VbdKcrWUuqw":"this.actor.characteristics.i.value= \"-\"\nthis.actor.characteristics.int.value= \"-\"\nthis.actor.characteristics.wp.value= \"-\"\nthis.actor.characteristics.fel.value = \"-\"","8zTkDVziBPaNbMQX":"let filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = await ItemDialog.createFromFilters(filters, 6, {text : \"Choose 6 Petty Spells\"})\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"\"\n    }\n]\n\nlet arcane = await ItemDialog.createFromFilters(filters, 9, {text : \"Choose 9 Arcane Spells\"})\n\nlet items = petty.concat(arcane).map(i => i.toObject())\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","91S2GnBFYFbxmOCK":"this.actor.characteristics.s.bonus += 1\nthis.actor.characteristics.s.calculationBonusModifier -= 1","93K85NnVwjVNXlZq":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Trade\"));","94eDAi6pkMhG3Ex9":"this.actor.deleteEmbeddedDocuments(\"ActiveEffect\", [this.effect.id]);","956dUb5sd6OtbWZR":"args.fields.successBonus++;","96Y1yIH1lRjTs5hL":"if (args.test.failed && args.test.characteristicKey == \"wp\")\n{\n    this.actor.addCondition(\"broken\")\n}","98nKfcimlaPeM9h5":"await this.actor.addCondition(\"bleeding\")\nawait this.script.message(await this.actor.applyBasicDamage(10, {suppressMsg : true}));","9A7rYY3FKi5XLihG":"fromUuid(\"Compendium.wfrp4e-core.items.5QcrpLQWWrsbKR79\").then(item => {\n     let data = item.toObject();\n     data.system.tests.value = data.system.tests.value.replace(\"coins\", \"metal objects\");\n     data.system.description.value += \"<p>This Talent also extends to any metal object because of <strong>Metallic Affinity</strong></p>\"\n     this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n})","9AMoFRATTAfdKlKN":"const test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {\n  skipTargets: true,\n  appendTitle: ` — ${this.effect.name}`,\n  fields: {difficulty: \"challenging\"},\n  context: {\n    failure: `Received @Condition[Poisoned] Condition.`\n  }\n});\n\nawait test.roll();\n\nif (test.failed) {\n  args.actor.addCondition(\"poisoned\");\n  const speaker = ChatMessage.getSpeaker({actor: args.actor});\n  this.script.message(`<p>${speaker.alias} received 1 @Condition[Poisoned] Condition from Spider Venom.</p><p>Targets reduced to 0 wounds while suffering a @Condition[Poisoned] condition from these arrows become @Condition[Unconcious], but are not at risk of death from any remaining @Condition[Poisoned] conditions as would normally be the case.</p>`);\n}","9EVj4bmZJex45Mt7":"return args.skill?.name != game.i18n.localize(\"NAME.Athletics\");","9HWEDsnNxSykqbF5":"args.actor.system.details.move.value += 3;\nargs.actor.system.status.carries.max = Math.floor(args.actor.system.status.carries.max * 0.25);\nargs.actor.system.details.price.gc *= 1.1;","9JnPK1jNUEso7Pv8":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9h82z72XGo9tfgQS\")\nlet data = item.toObject();\ndata.name += ` (${game.i18n.localize(\"SPEC.Smell\")})`\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","9MDi3ok9gPwtbALf":"args.actor.details.move.value /= 2","9MwRUzRinhq1IjhG":"args.actor.addCondition(\"grappling\");","9RFoasDcFnYZ1txR":"return args.skill?.name == game.i18n.localize(\"NAME.Perception\");","9VfeubiCV83LN9iY":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")\nlet data = item.toObject();\ndata.name += ` (When Charging)`\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","9WZa63lr0K3SsP4G":"let sourceItem = this.effect.sourceItem;\n\nif (sourceItem)\n{\n\tthis.actor.applyEffect({effectUuids : [sourceItem.effects.contents[2].uuid]})\n\tthis.script.notification(\"Applied after effects\");\n}","9Yn9uViEjcuaESJ2":"if (this.item.getFlag(\"wfrp4e\", \"failedCool\"))\n{\n    this.item.name += \" (No AP)\"\n    this.item.system.AP = {\n        \"head\": 0,\n        \"lArm\": 0,\n        \"rArm\": 0,\n        \"lLeg\": 0,\n        \"rLeg\": 0,\n        \"body\": 0\n      }\n}","9ZFPDCk8M2TQxh7x":"args.fields.modifier += 20\n","9bJGJrLqslV5lBya":" return args.characteristic == \"bs\"","9eL5JbQQmCY030ba":"this.actor.addCondition(\"poisoned\");","9eWR4mdaoCSQawDT":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.GlShFJF2TpsNh1FX\");\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n","9fK07tqqZyPg7dpx":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty: \"veasy\"}})\nawait test.roll();\nif (test.failed)\n{\n      this.script.notification(\"Gained a <strong>Festering Wound</strong>\")\n      let item = await fromUuid(\"Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb\")\n      this.actor.createEmbeddedDocuments(\"Item\", [item.toObject()])\n}\nelse \n{\n    this.script.notification(\"Avoided a <strong>Festering Wound</strong>\")\n}\n","9fNHye2N2DORR0A3":"return !args.item.name.includes(\"Weapon\")","9nroaZDkW3WXNkB7":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.4MJJCiOKPkBByYwW\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","9ob2lPnk3PDot9Tx":"this.actor.addCondition(\"blinded\", this.effect.sourceTest.result.SL)","9qWUuEF8F5nehF1y":"args.item.system.qualities.value = args.item.system.qualities.value.concat([{name : \"magical\"}, {name : \"unbreakable\"}])\nargs.item.system.damage.value += ` + ${this.effect.sourceActor.system.characteristics.wp.bonus}`","A0OK0qAMmnf8iNJf":"if (args.test.result.SL < 0)\n{\n    this.script.message(`Gained ${Math.abs(args.test.result.SL)} Corruption points`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    if (args.test.failed && this.actor.type == \"character\")\n    {\n        this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + Math.abs(args.test.result.SL)})\n    }\n}","A1odAcuRbq9797ZB":"let choice1 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Basic)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 10\n                }\n            }\n        }\n    }\n]\nlet choice2 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Polearm)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 10\n                }\n            }\n        }\n    }\n]\n\nlet choice =  await foundry.applications.api.DialogV2.wait({\n    window : {\n        title : \"Choice\"\n    },\n    content : \n    `<p>\n    Select your choice\n    </p>\n    <ol>\n    <li>Melee (Basic)</li>\n    <li>Melee (Polearm)</li>\n    </ol> \n    `,\n    buttons : [\n        {\n            label : \"Basic\",\n            callback : () => {\n                return choice1;\n            }\n        },\n        {\n            label : \"Polearm\",\n            callback : () => {\n                return choice2;\n            }\n        }\n    ]\n})\n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            let equip = item.system.tags.has(\"equippable\");\n            item = item.toObject()\n            if (equip)\n            {\n                item.system.equipped.value = true;\n            }\n            items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","A3MW0UksYrHGa0Qw":"return [\"fel\", \"wp\", \"int\", \"t\"].includes(args.characteristic);","A3fvV69RS1lYgma0":"if (this.actor.type == \"character\")  \n  this.actor.corruptionDialog(\"minor\")\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\nif(test.failed)\n{\n    await this.actor.addCondition(\"unconscious\");\n    let secondTest = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"easy\"}, skipTargets: true, appendTitle :  \" - Despair\"})\n    await secondTest.roll();\n    if(secondTest.failed)\n    {\n         await this.actor.addCondition(\"fatigued\");\n    }\n}","A6DcKPzAGntzSCil":"let roll = await new Roll(\"1d10\").roll()\n\nroll.toMessage(this.script.getChatData({flavor : `${this.effect.name} (Duration)`}));\n\nthis.effect.updateSource({\"duration.rounds\" : roll.total})","ACgKpKrEEHoNGG0h":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\")) && args.type != \"channelling\"","ACtDCTLZXmd5uXjX":"let halve;\nif (args.opposedTest.attackerTest.item?.type != \"spell\")\n{\n    halve = await foundry.applications.api.DialogV2.confirm({window : {title : this.effect.name}, content : \"Halve Damage? (Halves all damage other than fire, cold, and magic)\"})\n}\nelse\n{\n    halve = false;\n}\n\nif (halve)\n{\n    args.totalWoundLoss /= 2;\n    args.modifiers.other.push({label : this.effect.name, details : \"Halved\", value : \"× 0.5\"})\n}","AFiB20FaOBmBv2Kz":"if (args.actorsystem.details.move.sail.value > 0)\n  args.actor.system.details.move.sail.value = Math.floor(args.actor.system.details.move.sail.value * .5);\n","AGD7zCyV4zruvnWu":"return args.type != \"cast\" || ![\"death\", \"necromancy\", \"life\", \"light\", \"heavens\"].includes(args.spell?.system.lore.value)","AHZ8f7dfN8jNsYk6":"let token = this.actor.getActiveTokens()[0];\nlet target = args.data.targets[0];\nlet weapon = args.weapon;\n\nif(!target || !token)\n{\n    return;\n}\n\nlet distance = canvas.grid.measureDistances([{ ray: new foundry.canvas.geometry.Ray({ x: token.center.x, y: token.center.y }, { x: target.center.x, y: target.center.y }) }], { gridSpaces: true })[0]\nlet currentBand\n\nfor (let band in weapon.range.bands) \n{\n  if (distance >= weapon.range.bands[band].range[0] && distance <= weapon.range.bands[band].range[1]) \n  {\n    currentBand = band;\n    break;\n  }\n}\n\nreturn [game.i18n.localize(\"Long Range\"), game.i18n.localize(\"Extreme\")].includes(currentBand)","AI6bFrjWk4NH9FBd":"this.actor.addCondition(\"entangled\", this.effect.sourceTest.result.overcast.usage.other.current)","AI7iVbQMPzXMP5on":"const hours = new Roll(\"2d10\");\nawait hours.toMessage({flavor: this.effect.name + \" (hours)\"});\n\nconst bonus = new Roll(\"2d10\");\nawait bonus.toMessage({flavor: this.effect.name + \" (bonus)\"});\n\n\nawait this.effect.update({\n  \"duration.seconds\": hours.total * 3600\n});\nawait this.effect.setFlag(\"wfrp4e-tribes\", \"bonus\", bonus.total);","ALuPRzf85dmkEfLo":"return args.skill?.name == game.i18n.localize(\"NAME.Intuition\");","AMI2wDJqsIZsoq1e":"if (args.opposedTest.result.differenceSL >= 0 && args.opposedTest.result.differenceSL <= 2 && args.opposedTest.result.winner == \"attacker\")\n{ \n    this.script.message(`Emits a cloud of foul-smelling blackpowder. Enable the <strong>Fellowship Penalty</strong> Active Effect on @UUID[${this.actor.uuid}].`, {blind : true, whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","AMxezwtYnWCF6Oza":"return args.skill?.name == `${game.i18n.localize(\"NAME.Ranged\")} (${game.i18n.localize(\"SPEC.Blackpowder\")})`","AS7CstSosuCrwZ19":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 20,\n      \"bright\": 10,\n      \"angle\": 360,\n      \"alpha\": 0.4,\n      \"animation\": {\n          \"speed\": 3,\n          \"intensity\": 3,\n          \"type\": \"torch\",\n      },\n      \"color\": \"#ffcc66\",\n  }}));","AV2Kj6jgmIc45zKi":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"));","AVROqafFhKjN6TPR":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.DrNUTPeodEgpWTnT\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","AWgZnm9xLyIWCDnp":"let robust = args.modifiers.other.find(i => i.key == \"robust\")\nif (robust)\n{\n\trobust.value--;\n}\nelse \n{\n\targs.modifiers.other.push({key: \"robust\", label : this.effect.name, value : -1})\n}\n","AYEiCx2Es3QtMY28":"let choice1 = [\n    {\n        type: \"trait\",\n        name: \"Bestial\",\n    },\n    {\n        type: \"trait\",\n        name: \"Regeneration\",\n    },\n    {\n        type: \"trait\",\n        name: \"Size (Large)\",\n    },\n    {\n        type: \"trait\",\n        name: \"Territorial\",\n    }\n]\n\nlet updateObj;\nlet actor;\n\nasync function addTrait(c) {\n    let items = [];\n    let existing;\n    if (c.type == \"trait\") {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type);\n    }\n    if (!existing) {\n        let item = await game.wfrp4e.utility.find(c.name, c.type);\n        if (item) {\n            item = item.toObject();\n            items.push(item);\n        }\n        else\n            ui.notifications.warn(`Could not find ${c}`, { permanent: true });\n    }\n    console.log(\"WISH LIST2\", choice1, items);\n    actor.createEmbeddedDocuments(\"Item\", items);\n}\n\nasync function dialogChoice() {\n    for (let c of choice1) \n    {\n        if (await foundry.applications.api.DialogV2.confirm({window : {title: \"Option\"}, content:`<p>Add Option?</p><ol><li>${c.name}</li></ol>`}))\n        {\n            addTrait(c)\n            c.valid = true;\n        }\n    }\n}\n\nupdateObj = this.actor.toObject();\nactor = this.actor\nawait dialogChoice();\n\n","AZGXrZOQ4EzjxRL9":"return true;","AaPPmnv7AtxsRVUs":"args.actor.details.move.value = 1;","Adgs6Zs0FdefO6qx":"if (args.test.options.pilot && args.test.result.reversed)\n{\n\targs.test.data.result.SL = \"+\" + Math.min(1, Number(args.test.data.result.SL))\n\targs.test.result.other.push(`<b>${this.effect.name}</b>: SL limited to 1`)\n}","Ah2wyywkL8hjJNXM":"args.context.healWounds = true;","AjC4dsiuhVCOnRGI":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MVI0lXcg6vvtooAF\")\nlet data = item.toObject();    \nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});","AmOMCUaWLJ2iJAt5":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.IFKWu98qmWpaSfUi\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","AmpDbT0BkDHeaRzf":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\");\nlet data = item.toObject();\ndata.system.specification.value = 1;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","ApaLcUhuty3EzJoP":"let fortunePoints = this.effect.sourceTest.result.overcast.usage.other.current\nlet current = this.actor.status.fortune.value\n\nthis.actor.update({\"system.status.fortune.value\" : fortunePoints + current})\n\nthis.script.message(`<b>${this.actor.prototypeToken.name}</b> fortune points increased from ${current} to ${fortunePoints + current}`)","AqHLHp4kH6KULk3e":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n    let effectData = this.item.effects.contents[0].convertToApplied();\n\teffectData.system.sourceData.item = this.item.uuid\n\tactor.applyEffect({effectData : [effectData]})\n}\nelse\n{\n\tthis.script.notification(\"None left!\", \"error\")\n}","AyNb5sj6FD2Z3Q5T":"this.actor.addCondition(\"dead\")\nthis.actor.setWounds(0);\nthis.script.message(await game.wfrp4e.tables.formatChatRoll(\"scatter\"))","AyS3iLljxHRKsHg4":"let broken = this.actor.hasCondition(\"broken\");\nlet fatigued = this.actor.hasCondition(\"fatigued\");\nawait broken?.delete();\nawait fatigued?.delete()\nlet drilled = await fromUuid(\"Compendium.wfrp4e-core.items.Item.J9MK0AIaTbvd5oF6\")\nlet fearless = await fromUuid(\"Compendium.wfrp4e-core.items.Item.8pVzgPkgWpTJvfhG\")\nlet stout = await fromUuid(\"Compendium.wfrp4e-core.items.Item.IogM5gnsoOX63w7j\")\nthis.actor.createEmbeddedDocuments(\"Item\", [drilled, fearless, stout], {fromEffect : this.effect.id})","B063u4vrbvzMaCQt":"args.item.system.flaws.value = args.item.system.flaws.value.concat([{name : \"bulky\"}, {name : \"unreliable\"}])","B1xgRS00RcTIZLnO":"return [\"cast\", \"channelling\"].includes(args.type) && this.actor.hasCondition(\"fatigued\")","B6ZbY3bxTPg6nCng":"return args.skill?.name == game.i18n.localize(\"NAME.Bribery\");","B87v1twc65qyvUWi":"args.fields.modifier += 10 * this.effect.conditionValue","B950b0XnIUYCdVwu":"let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\n\nif (test.succeeded)\n{\n    if (args.totalWoundLoss <= parseInt(test.result.SL))\n    {\n        args.abort = `<strong>${this.effect.name}</strong>: Attack deflected and reflected`\n    }\n    args.modifiers.other.push({label : this.effect.name, value : -1 * parseInt(test.result.SL)})\n}","BAOv7moTxsKlT3JS":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"easy\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"broken\")\n}","BD7bVTU2pVoRSRBe":"let symptoms = {\n    convulsions : \"Convulsions\",\n    coughsandsneezes : \"Coughs and Sneezes\",\n    fever : \"Fever\",\n    flux : \"Flux\",\n    nausea : \"Nausea\"\n}\n\nlet roll = await (new Roll(`max(0, 1d10 - ${this.actor.characteristics.wp.bonus})`).roll())\nroll.toMessage(this.script.getChatData());\n\nlet choices = await ItemDialog.create(ItemDialog.objectToArray(symptoms), roll.total, \"Choose Symptoms\");\n\nif (choices.length)\n{\n    let symptomEffects = foundry.utils.duplicate(game.wfrp4e.config.symptomEffects)\n    let added = []\n    for(let choice of choices)\n    {\n        let symptom = symptomEffects[choice.id];\n        symptom.origin = this.effect.uuid;\n        added.push(symptom);\n    }\n    this.actor.createEmbeddedDocuments(\"ActiveEffect\", added)\n}\nelse \n{\n    this.effect.delete();\n}\n\n","BEEvU2hE5ymcNOH9":"let fatigued = this.actor.hasCondition(\"fatigued\")\n                            if (!fatigued)\n                            {\n                                this.actor.addCondition(\"fatigued\")\n                                ui.notifications.notify(\"Fatigued added to \" + this.actor.name + \" which cannot be removed until the Malaise symptom is gone.\")\n                            }","BHbFqhJPzZI2txLs":"let lore = this.effect.name.split(\"(\")[1].split(\")\")[0].toLowerCase();\n\n// If channelling corresponding lore\nif (args.type == \"channelling\" && args.spell.system.lore.value == lore)\n    args.prefillModifiers.slBonus  += 2\n// If channelling or casting different lore\nelse if (args.spell.system.lore.value != lore && args.spell.system.lore.value != \"petty\")\n    args.prefillModifiers.slBonus  -= 1","BNJRV66jlrp51qZK":"args.abort = true;\nthis.script.notification(game.i18n.localize(\"SCRIPT.Sightstep\"));","BVNKF9omCppWPLys":"let actor = game.user.character ?? canvas.tokens.controlled[0]?.actor;\nif (!actor || !(actor.system instanceof StandardActorModel))\n  return ui.notifications.warn(\"You must control an Actor capable of performing a Strength Test\");\n\nlet test = await actor.setupCharacteristic(\"s\", {\n  skipTargets: true, \n  appendTitle:  \" - Bailing Out\", \n  fields: {\n    difficulty: \"challenging\"\n  },\n  context: {\n    success: \"Reduced the Holed rating!\"\n  }\n});\n\nawait test.roll();\nif (test.succeeded) {\n  let SL = parseInt(test.result.SL);\n  let name = this.effect.name.replace(/\\d+/, rating => parseInt(rating) - SL);\n  await this.effect.update({name});\n}\n\nlet rating = parseInt(this.effect.name.match(/\\d+/)?.[0]);\nif (rating <= 1) {\n  const scriptData = this.effect.system.scriptData\n  scriptData[2].trigger = '';\n  await this.effect.update({disabled: true, \"system.scriptData\": scriptData});\n}","BZETMpgrI5k1ol5b":"// If the creature currently has a Surprised, Unconscious, or Entangled Condition, it does not gain this Advantage.\nconst surprised = this.actor.hasCondition(\"surprised\")\nconst unconscious = this.actor.hasCondition(\"unconscious\")\nconst entangled = this.actor.hasCondition(\"entangled\")\nif (entangled || unconscious || surprised) return\n\n// If, at the beginning of its turn, this creature does not have at least Rating Advantage points, its Advantage pool immediately increases to Rating.\nconst grimRating = parseInt(this.item.specification.value) || 1\nif (grimRating > this.actor.status.advantage.value) {\n  this.actor.setAdvantage(grimRating)\n}\n","BcXTujburrHpjpwa":"args.fields.slBonus -= 3;","Be5rdfnZorbILhpC":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet data = item.toObject();\ndata.system.specification.value = 3 - this.actor.characteristics.s.bonus\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","Bexspr5viPhHiFmU":"let fatigued = this.actor.hasCondition(\"fatigued\");\nlet value = fatigued?.conditionValue || 0;\nargs.fields.modifier += value * 10;","Bj6bxItlgtI2sXVN":"let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\nroll.toMessage(this.script.getChatData());\nargs.totalWoundLoss = Math.max(0, args.totalWoundLoss - roll.total)\nargs.modifiers.other.push({label: this.effect.name, value : -1 * roll.total})\nthis.effect.update({disabled : true})","BtyFhdGMKiMamGhM":"let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nlet damage = parseInt(this.effect.sourceTest.result.SL)\n\nif (test.succeded)\n{\n   damage =  damage + 8 - parseInt(test.result.SL)\n}\n\nelse \n{\n   damage = damage + 10\n   this.actor.addCondition(\"entangled\", 3)\n}\nthis.script.message(await this.actor.applyBasicDamage(damage, {loc : \"roll\", suppressMsg: true}))\n","Bu0KUpGvfmFF7LJs":"let test = await this.actor.setupCharacteristic(\"s\", {appendTitle : ` - ${this.effect.name}`, fields : {difficulty : \"difficult\"}});\n\nawait test.roll();\n\nif (test.failed)\n{\n\n   if (test.isCriticalFumble == \"fumble\")\n   {\n\t return this.script.message(`<strong>${this.actor.name}</strong> dies as they are dragged into the Aethyr (unless they spend a Fate point`);\n   }\n\t\n    await this.script.message(await this.actor.applyBasicDamage(3, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg: true }))\n\n}","Bv3431tnG3VKaTJr":"if (args.test.result.castOutcome == \"success\")\n{\n    args.test.result.other.push(`@Fear[2,${this.actor.name}]`);\n}","ByhEa1BxQOyrOmqg":"return args.item?.attackType == 'melee'","BzDLuxBNw1QNIacg":"if (args.item.type == \"skill\")\n   args.item.system.advances.value = 0\n\nif (args.item.type == \"talent\")\n    args.item.system.tests.value = \"\"\n\nif (args.item.type == \"weapon\") \n   args.item.system.qualities.value = []","C4LZnaX0MYgwrszj":"return args.type !== \"channelling\" && !args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\")) && args.skill?.name !== `${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})` &&  args.skill?.name !== game.i18n.localize(\"NAME.OutdoorSurvival\");","C5NIkJwXL85Qbpe7":"args.weaponProperties.impale = true;","C69xngEMghfwUx13":"let easier = ['challenging', 'average', 'easy', 'veasy'];\nif (easier.includes(args.fields.difficulty))\n  args.fields.difficulty = \"difficult\";","CCK1iIfPmB398ziT":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Athletics\"), {fields : {difficulty : \"difficult\"}, skipTargets: true, appendTitle :  \" - Walking\"})\ntest.roll();","CCwuu3bPLCpVGAmb":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\n\n","CD4RnDpXZ9hnqVPQ":"if (!this.actor.hasCondition(\"entangled\"))\n  this.actor.addCondition(\"entangled\");","CDASLC4fWKSGQKf9":"let blinded = this.actor.hasCondition(\"blinded\");\nif (blinded?.getFlag(\"wfrp4e\", \"flockOfDoom\"))\n{\n    blinded.delete();\n}","CHnaBPHk6HdFS512":"let arm = await fromUuid(\"Compendium.wfrp4e-core.items.MnMZv7ZXoRqoH9dS\");\nlet leg = await fromUuid(\"Compendium.wfrp4e-core.items.k00PimCWkff11IA0\");\n\nlet choice = await ItemDialog.create([arm, leg], 1, \"Choose Limb\")\n\nthis.actor.createEmbeddedDocuments(\"Item\", choice, {fromEffect: this.effect.id})","CIxZYkHggBQ6EsHP":"this.script.notification(\"Effect Used\");\nthis.effect.delete();","CM43kvw5mIIE1OsB":"let key = this.item.system.location.key\n\nlet lostFingers = this.actor.flags.useless[key] || 0;\n\nlostFingers += 1\n\nthis.actor.flags.useless[key] = lostFingers;\n\nif (lostFingers >= 4)\n{\n\tthis.actor.flags.useless[key[0] + \"Arm\"] = true;\n}","CMUFtmNA1kkD1ay7":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 30,\n      \"bright\": 20,\n      \"angle\": 90,\n      \"alpha\": 0.6,\n      \"animation\": {\n          \"speed\": 3,\n          \"intensity\": 3,\n          \"type\": \"torch\",\n      },\n      \"color\": \"#ffcc66\",\n  }}));","CPQoK7NjzOwVTFXS":"for(let effect of this.actor.effects.filter(e => e.isCondition))\n{\n    if (effect.isCondition)\n    {\n        effect.delete();\n    }\n}","CS6O7UUjQcUJoOUP":"if (args.test.failed)\n                        {\n                          let SL = Number(args.test.result.SL)\n                          if (SL <= -2 && SL > -4)\n                            this.actor.addCondition(\"stunned\")\n                          else if (SL <= -4 && SL > -6)\n                            this.script.message(this.actor.prototypeToken.name + \" must make a <b>Willpower</b> Test or fall @Condition[Prone].\")\n                          else if (SL <= -6)\n                            this.actor.addCondition(\"unconscious\")\n                        }","CW5Vlr57OaMkKJ8Q":"if (this.actor.system.status.advantage.value >= 3)\n{\n    this.actor.modifyAdvantage(-3);\n    this.script.notification(\"Advantage Subtracted\")\n}\nelse \n{\n    return this.script.notification(\"Not enough Advantage!\", \"error\")\n}\n\nlet test = await this.actor.setupTrait(this.item)\nawait test.roll();","CWNGrg7se91RC95g":"if (args.totalWoundLoss > 0) {\n  args.opposedTest.result.other.push(\n  `@Corruption[minor]{Moderate Exposure to Corruption}`\n  )\n  this.script.message(`<strong>${this.effect.name}</strong>: \n      @Corruption[moderate]{Moderate Exposure to Corruption} <br/>\n      <strong>${args.actor.prototypeToken.name}</strong> must take an \n      <strong>Corruption (Moderate) Test</strong>`, \n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n  )\n}","Ca1fXHTA1e2QLx0D":"args.fields.modifier += 50;","CbfUDhUr5R4UnPPq":"if (this.actor && this.actor?.name !== \"Kurgorn Three-eyes\" && !this.actor.hasCondition(\"blinded\") && !args.itemUpdated)\n{\n  this.script.notification(`Cannot remove Blinded condition.`);\n  await this.actor.addCondition(\"blinded\", 1, {statuses : [\"blinded\", \"blind\"]})\n}","CiFeduksZJ6PRulx":"return args.skill?.name == `${game.i18n.localize(\"NAME.Ride\")} (${game.i18n.localize(\"SPEC.Horse\")})` || (args.context.dodge && this.actor.isMounted);","CicQ5REu9tbsc8wW":"const locations = [];\n\nfor (let [key, loc] of Object.entries(args.AP)) {\n  if (loc.layers?.some(i => !i.metal && i.source?.system.tags?.has(\"armour\")))\n    locations.push(key);\n}\n\nthis.actor.status.addArmour(1, {source: this.effect, magical: true, locations})","Cjj4iLkdY1NaZRCi":"if ((args.opposedTest.attackerTest.item && args.opposedTest.attackerTest.item.isMelee) || (args.opposedTest.attackerTest.item && !args.opposedTest.attackerTest.item.name.includes(\"Ranged\")))\n{\n    let choice = await foundry.applications.api.DialogV2.confirm({window : {title : this.effect.name}, content : `<p>Apply damage with <strong>${this.effect.name}</strong> to attacker?`})\n\n    if (choice)\n    {\n        this.script.message(await args.attacker.applyBasicDamage(this.actor.system.characteristics.wp.bonus, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true}));\n    }\n}","CkE8NZOhzPkuRrKJ":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MnMZv7ZXoRqoH9dS\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data])\n\n\n\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"hard\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n\tthis.actor.addCondition(\"unconscious\")\n}","ClkT2WG2UjVwQ97T":"if (args.actor.has(\"Daemonic\")) {\n  args.totalWoundLoss += 3;\n  args.modifiers.other.push({label: this.effect.name, value: 3});\n}\n\nlet test = await args.actor.setupSkill(\"Endurance\", {\n  appendTitle: ` – ${this.effect.name}`,\n  skipTargets: true,\n  characteristic: 't',\n  context: {\n    failure: \"Received 1 Blinded Condition\"\n  }\n});\nawait test.roll();\n\nif (test.failed) {\n  args.actor.addCondition(\"blinded\");\n}","CoImIH9OCMx9DfQZ":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.nbhn2wX35b7Jrcbg\")\nlet data = item.toObject();\ndata.system.location.value = \"Jaw\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","Cri5Q7ux6ni7zNVS":"// Cannot be Surprised in combat.\n\nif (this.actor.hasCondition(\"surprised\"))\n{\n    this.actor.removeCondition(\"surprised\")\n    ui.notifications.notify(`<strong>${this.effect.name}</strong>: Cannot be surprised`);\n}","CxsKWGwQqtAaQdzX":"return args.characteristic === \"fel\";","CynUM4ZEiB9QbNQq":"const bonus = game.settings.get(\"wfrp4e\", \"homebrew\").advantageBonus;\n\nargs.fields.modifier += 2 * bonus;","D5XmzrUGFa1JN0cl":"args.prefillModifiers.modifier += 10\n\n","DANLE5HxrkTNelhl":"args.wounds += 4;","DBafsY1HrclJRTtA":"return args.type != \"cast\"","DHxUKY9LMyifFgCi":"return args.skill?.name == \"Trade (Apothecary)\" || args.skill?.name == \"Trade (Alchemist)\"","DL9vYNft9aXdV2aW":"let tooth = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\ntooth = tooth.toObject()\ntooth.system.specification.value = 3\ntooth.system.qualities.value = [{name : \"magical\"}]\n \nlet claw = await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")\nclaw = claw.toObject()\nclaw.system.specification.value = 4\nclaw.system.qualities.value = [{name : \"magical\"}]\nclaw.name = \"Claw\"\n\nthis.actor.createEmbeddedDocuments(\"Item\", [tooth, claw], {fromEffect : this.effect.id})","DMQ0taEpBUJU5njV":"args.actor.status.fortune.value = 0","DTiHS6RfwhF4THbf":"return args.skill?.name != game.i18n.localize(\"NAME.Drive\") && !args.skill?.name.includes(game.i18n.localize(\"NAME.Ride\"));","DUFSlDO38fQWclBE":"// Characters wounded by the ravens gain the ability to read, understand and speak rudimentary Classical. \n// This ability does not last beyond this adventure.\n\nthis.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.61L9aX2z164cjm7K\", this.effect)\n\nthis.script.message(`<b>${args.actor.name}</b> gains the ability to read, understand and speak rudimentary @UUID[Compendium.wfrp4e-core.items.Item.61L9aX2z164cjm7K]{Classical}. This ability does not last beyond this adventure.`)","DVlZGbiuMIHEQOnM":"if (this.actor.getFlag(\"wfrp4e\", \"isAttached\")) \n{\n\tlet roll = await new Roll(\"1d10\").roll()\n\tawait roll.toMessage(this.script.getChatData());\n\tif (roll.total == 9 || roll.total == 10)\n\t{\n\t  this.script.message(`<strong>${this.actor.name}</strong> attached to <strong>${this.actor.getFlag(\"wfrp4e\", \"isAttached\")}</strong> gorges and falls off.`)\n\t  await this.actor.unsetFlag(\"wfrp4e\", \"isAttached\")      \n\t}\n  }","DWBxvzfWGcG7PVNP":"let letter = this.item.system.location.key[0]; // \"l\" or \"r\";\n\nthis.item.updateSource({\"system.location.key\" : letter + \"Finger\"})\n\n// We want the location to be Right or Left Hand, but the key to be rFinger or lFinger","DcSJNRBXE9ZBBY7T":"this.actor.addCondition(\"blinded\", Math.max(0, this.effect.sourceTest.result.SL))","Dew3Ks9yC4DynSMi":"return args.characteristic === \"s\" || args.characteristic === \"t\" || args.weapon?.system?.attackType === \"melee\";","DhZqJso1JWYtGrKk":"this.actor.addCondition(\"ablaze\")\nlet damage = this.effect.sourceTest.result.damage + this.effect.sourceTest.result.additionalDamage\nthis.script.message(await this.actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true}))","DmbWR9s5I8LHBwxB":"let column = await ValueDialog.create({text : \"Select the column to roll on to determine Beast Head\", title : \"Select Column\"}, \"\", [\"Undivided\", \"Khorne\", \"Nurgle\", \"Slaanesh\", \"Tzeentch\"]);\n\nif (column)\n{\n    let result = await game.wfrp4e.tables.rollTable(\"beasthead\", {}, column);\n    this.script.message(`<strong>${result.title}</strong><br>${result.result}`);\n    let uuid = `Compendium.${result.object.documentCollection}.${result.object.documentId}`;\n    let item = await fromUuid(uuid);\n    if (item)\n    {\n        this.actor.createEmbeddedDocuments(\"Item\", [item])\n        this.item.delete();\n    }\n}","DpdSEHM6NMN1ey6h":"if (parseInt(this.item.system.specification.value) > 0)\n{\n\tthis.actor.system.status.ward.value = parseInt(this.item.system.specification.value);\n}","DqJFo74trI916qXN":"let fatigued = args.actor.hasCondition(\"fatigued\")\nif (fatigued)\n{\n    fatigued.system.scriptData = fatigued.system.scriptData.filter(s => s.trigger != \"dialog\")\n    fatigued.system._scripts = null;\n}","DsE6rTSzxEn6uWMz":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"average\"}})\nawait test.roll();\nif (test.failed)\n{ \n  await this.actor.addCondition(\"blinded\");\n  await this.actor.addCondition(\"fatigued\")\n} ","DuM5l2Yb4bdvDeaG":"return args.skill?.name != game.i18n.localize(\"NAME.Athletics\")","DxM3NRgQYc7moMPc":"this.actor.reset()","DxQnamsb2AuW0p2e":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Lore\"));","DyZ1jH88EAp1ueOK":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.GlShFJF2TpsNh1FX\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\ndata.system.location.value = data.system.location.value.replace(\"Arm\", \"Wrist\")\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n","Dzi2CKpYapRGwNVr":"if (args.actor.system instanceof StandardActorModel) {\n  args.actor.addCondition(\"unconscious\");\n}","E0HHBSdQR3oH8KaL":"if (args.totalWoundLoss > 0) {\n  let frenzy = await fromUuid(\"Compendium.wfrp4e-core.items.Item.DrNUTPeodEgpWTnT\");\n  frenzy = frenzy.toObject(); \n  frenzy.effects[0].disabled = false;\n  this.actor.createEmbeddedDocuments(\"Item\", [frenzy], {fromEffect : this.effect.id}); \n  this.script.scriptMessage(\"Carnosaur gains Frenzy\");\n}","E1Xo4RVuN1YRRxg7":"return args.item?.attackType != \"ranged\"","E1vUepgop09FF5wy":"if (this.actor.system.status.advantage.value == 0)\n{\n    return this.script.notification(\"Not enough Advantage!\", \"error\")\n}\n\nlet hatred = await fromUuid(\"Compendium.wfrp4e-core.items.Item.aE3pyW20Orvdjzj0\")\nlet frenzy = await fromUuid(\"Compendium.wfrp4e-core.items.Item.yRhhOlt18COq4e1q\");\n\nif (this.actor.system.status.advantage.value >= 3)\n{\n    this.script.notification(`Adding ${frenzy.name}`)\n    this.actor.setAdvantage(0)\n    this.actor.createEmbeddedDocuments(\"Item\", [frenzy])\n}\nelse if (this.actor.system.status.advantage.value >= 1)\n{\n    let data = hatred.toObject();\n    data.system.specification.value = \"Close Combat opponents\"\n    this.script.notification(`Adding ${hatred.name}`)\n    this.actor.setAdvantage(0)\n    this.actor.createEmbeddedDocuments(\"Item\", [data])\n}","E2VfOVuju67qO3VL":"let blinded = this.actor.hasCondition(\"blinded\");\nif (blinded.getFlag(\"wfrp4e\", \"nightshroud\"))\n{\n    blinded.delete()\n}","E33J9JixYVGxaktQ":"if (this.effect.getFlag(\"wfrp4e\", \"fistsOfGork\") && args.item.type == \"skill\" && args.item.name == \"Melee (Brawling)\") {\n\targs.item.system.modifier.value += this.effect.getFlag(\"wfrp4e\", \"fistsOfGork\")\n}","E3om295BMQojnM2F":"let fatigued = this.actor.hasCondition(\"fatigued\")\nif (fatigued)\n{\n    fatigued.delete();\n    this.script.notification(\"Removed Fatigued\")\n}","E4CHDe1xfmcV3oGv":"return args.skill?.name == game.i18n.localize(\"NAME.Navigation\");","E6DMqfDeczqmVMFV":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"average\"}})\n\nawait test.roll();","E6v4YZrvFikbdXoO":"const locations = [];\n\nfor (let [key, loc] of Object.entries(args.AP)) {\n  if (loc.layers?.some(i => i.metal))\n    locations.push(key);\n}\n\nthis.actor.status.addArmour(1, {source: this.effect, magical: true, locations})","E7D4bxz8gy4e1wL7":"return [`${game.i18n.localize(\"NAME.Stealth\")} (${game.i18n.localize(\"SPEC.Rural\")})`, game.i18n.localize(\"NAME.Track\"), game.i18n.localize(\"NAME.OutdoorSurvival\"), game.i18n.localize(\"NAME.Swim\"), game.i18n.localize(\"NAME.Perception\"), game.i18n.localize(\"NAME.Intuition\")].includes(args.item?.name);","EBNrA6FNX4d05EUx":"return !args.context.crewTest;","EC8cZmqrE095cDc2":"const actor = args.actor;\n\nif (actor.itemTypes.skill.find(s => s.name === \"Lore (Riverways)\")) {\n  const loreTest = await actor.setupSkill('Lore (Riverways)',  {\n    appendTitle: ` – ${this.effect.name}`,\n    skipTargets: true,\n    fields: {difficulty: 'hard'},\n    characteristic: 'int',\n  });\n  await loreTest.roll();\n\n  if (loreTest.succeeded) {\n    loreTest.result.other.push(`<b>${actor.name}</b> recognizes lures of Lurkerfish.`);\n    loreTest.renderRollCard();\n    return;\n  } \n}\n\nlet test = await actor.setupSkill('Cool',  {\n  appendTitle: ` – ${this.effect.name}`,\n  skipTargets: true,\n  fields: {difficulty: 'easy'},\n  characteristic: 'wp',\n});\nawait test.roll();\n\nif (!test.succeeded) {\n  test.result.other.push(`<b>${actor.name}</b> became beguiled by the sight and unable to perform any action except moving towards the light.`);\n  test.renderRollCard();\n  actor.addCondition(\"unconscious\");\n}","ECUIJLcKt2TCSFS3":"return !args.weapon?.system?.attackType || game.settings.get(\"wfrp4e\", \"useGroupAdvantage\")","EDAMEOzdBfkoKHxP":"return args.skill?.name !== game.i18n.localize(\"NAME.Navigation\");","EGWF3LHav3e2zFL4":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Ranged\")) || args.item?.isRanged || args.item?.name == game.i18n.localize(\"NAME.Charm\");","EHfOyVwYhFGWNjw1":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {difficulty: \"difficult\"})\n  await test.roll();\n  if (!test.succeeded)\n  {\n    await this.actor.addCondition(\"poisoned\");\n  }","EJObiSth3WdcJOXN":"if (args.test.characteristicKey == \"wp\" && args.test.failed && args.test.result.SL <= -3)\n{\n    this.script.notification(\"Adding Prone\");\n    this.actor.addCondition(\"prone\")\n}","EJaBfqADqlo92Fx6":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.oGbDwnLOn3isPJpO\")\nlet data = item.toObject();\ndata.name += \" (To Be Determined)\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","EKkdyp51Wf4csw2B":"return this.actor.statuses.has(\"frenzy\");","ENGmwaItRXO5s0XY":"await this.actor.modifyWounds(this.actor.system.characteristics.t.bonus * 3)\nthis.script.message(`Heals ${this.actor.system.characteristics.t.bonus * 3} Wounds`)\n\nthis.actor.hasCondition(\"bleeding\")?.delete()\nthis.actor.hasCondition(\"fatigued\")?.delete()\n","EQ5dtGW5kQhtAb87":"await this.actor.addCondition(\"prone\")\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"hard\"}, skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\nif (test.failed)\n{\n\tawait this.actor.addCondition(\"stunned\")\n}","ERxrWzSpw8qwxFVi":"this.script.notification(`Cannot enter ${this.effect.name}!`); this.actor.addCondition(\"broken\");","ETfmit2Cx0Py77ai":"let characteristics = {\n    \"ws\" : -10,\n    \"bs\" : 0,\n    \"s\" : 0,\n    \"t\" : 0,\n    \"i\" : -25,\n    \"ag\" : -20,\n    \"dex\" : 0,\n    \"int\" : -200,\n    \"wp\" : -200,\n    \"fel\" : -200\n}\nlet traits = [ {name:\"Construct\"}, {name:\"Dark Vision\"}, {name:\"Fear\", value: 2}, {name:\"Painless\"},{name:\"Undead\"},{name:\"Unstable\"} ];\nlet items = [];\n\nlet updateObj = this.actor.toObject();\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nupdateObj.system.characteristics.int.initial = 0;\nupdateObj.system.characteristics.wp.initial = 0;\nupdateObj.system.characteristics.fel.initial = 0;\n\nfor (let trait of traits)\n{\n    let traitItem = await game.wfrp4e.utility.find(trait.name, \"trait\")\n    if (traitItem)\n    {   \n        let t = traitItem.toObject();\n        t.system.specification.value = trait.value;\n        items.push(t);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trait.name}`, {permanent : true})\n    }\n}\n\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n","EU5j0hnDTG9Z6d1e":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}})\nawait test.roll();\nif(test.failed)\n{\n    this.actor.addCondition(\"stunned\", 2)\n}","EVBSHEC5nmmj2X41":"return args.skill?.name != game.i18n.localize(\"NAME.Climb\")  && !args.skill?.name?.includes(game.i18n.localize(\"NAME.Stealth\"));","EXiqepAIXmbqMiKa":"if (args.opposedTest?.attackerTest?.weapon?.name.toLowerCase().includes(\"unarmed\")) {\n  const sl = this.effect.getFlag(\"wfrp4e-archives3\", \"sl\");\n  args.totalWoundLoss += sl;\n  args.modifiers.other.push({label: this.effect.name, value: sl});\n}","EYny6z5oTOhxGDfb":"args.fields.modifier -= 10;\n","EaSNOmXUxAkUHnm5":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","Eay7GpDyfsEE40jT":"if (args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"ablaze\")\n}","EdTChmSouS0MSmk5":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.succeeded)\n{\n    this.script.message(\"Can perform an Action or Move (choose one)\")\n}\nelse \n{\n    this.script.message(\"Cannot perform an Action or Move this round\")    \n}","EiLaZW4b4ypw5sLV":"// can't use Damage application type because that checks if wounds were dealt\nargs.actor.applyEffect({effectUuids : this.item.effects.contents[0].uuid})","ElHBPMMx37SZMvOC":"this.actor.addCondition(\"ablaze\");\nthis.script.scriptMessage(`${this.actor.name} has a received a @Condition[Ablaze]`)","EmXwcuycEH8slEn5":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}})\nawait test.roll();\nif(test.failed)\n{\n    this.actor.addCondition(\"unconscious\")\n}","EmmG49pMOPHRwDzR":"   let roll = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n   if (args.test.isFumble && roll == 1 && !args.test.result.misfire)\n  {\n          args.test.result.misfire = game.i18n.localize(\"Misfire\") + \" (Rolled 1)\"\n          args.test.result.misfireDamage = eval(parseInt(args.test.result.roll.toString().split('').pop()) + args.test.item.Damage)\n  }\n  else if (args.test.isFumble && roll != 1)\n      args.test.result.other.push(\"Misfire Roll: \" + roll)\n","EpdMj9d9SYPeP44q":"return args.characteristic != \"ag\"  && args.item?.id != this.item?.id","ErgOwSiVnm9VLVHN":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.DrNUTPeodEgpWTnT\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","Et4tPHlrkueLqP3T":"if (args.item.type == \"skill\") args.item.system.modifier.value -= 10","Ew3C2WmLCtc1KT46":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\")) || args.item?.id == this.item?.id","EwD053Fyy46b59ZI":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.6l3jvIAvrKxt0lA9\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","Eye6dranWpNsILjm":"if (this.actor.system.status.wounds.value <= 1)\n{\n    this.effect.delete();\n}","F2u4L4o0r1LTWeWK":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create({text : \"Enter Terror value\", title : this.effect.name});\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","F4aGsdzJ9SYcX57F":"if (args.equipped)\n{\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.HpFkVJ2lYPAWumUL\")\n    let data = item.toObject();\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n}\nelse \n{\n    this.effect.deleteCreatedItems();   \n}","F7BHb4a7fqWMnYxH":"args.test.data.result.other.push(`You may not use Fortune Points because of ${this.effect.name}`);","F8Bmh6w01YvKsBIO":"for (const weapon of args.actor.itemTags.weapon) {\n  weapon.system.qualities.value.push(\n    {name: \"impale\", value: null},\n    {name: \"penetrating\", value: null},\n  );\n}","F9P8Nh4AKnqSGg8C":"const uuids = [\n  \"Compendium.wfrp4e-core.items.Item.bxbTiLzbaz4vdukT\",          // Hunter's Eye\n  \"Compendium.wfrp4e-core.items.Item.XSb3QVB9ipPBFt56\",       // Shadow\n];\n\nconst items = await Promise.all(uuids.map(uuid => fromUuid(uuid)));\nawait this.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect: this.effect.id});","FAB12eLcSCAOOQwk":"this.script.scirptMessage(await this.actor.applyBasicDamage(20, {suppressMsg: true});","FAf4iXj5LkdvukS2":"fromUuid(\"Compendium.wfrp4e-wom.items.0Xdm4r7l2EwC4fcg\").then(item => Item.create(item.toObject(), {fromEffect : this.effect.id, parent : this.actor}))","FGIHAkNdYXbTnewG":"if (!game.settings.get(\"wfrp4e\", \"useGroupAdvantage\"))\n  return;\n\n\nawait this.actor.modifyAdvantage(1);\nthis.effect.delete();","FKEH7DeqU0FH4dkk":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {fields : {difficulty : \"hard\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\n\nif (test.failed) {\n  \tthis.script.scriptMessage(await this.actor.applyBasicDamage(20, {suppressMsg: true}));\n        this.script.scriptMessage(`${this.actor.name} is subject to @UUID[Compendium.wfrp4e-core.journals.JournalEntry.NS3YGlJQxwTggjRX.JournalEntryPage.WCivInLZrqEtZzF4#drowning-and-suffocation]{Suffocation}`);\n}","FMA16PvoObBV8vDl":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.EO05HX7jql0g605A\")\nitem = item.toObject()\nitem.system.specification.value = 20\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})\nthis.script.notification(item.name + \" added\")","FMSN5uRskkATexzB":"game.wfrp4e.tables.rollToChat(\"crithead\")","FPQp6XfbUH1BMafj":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Athletics\"), {fields : {difficulty : \"vhard\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed) \n{\n\tthis.actor.addCondition(\"prone\");\n    this.script.scriptMessage(\"Cannot move or act this Turn\");\n}","FPYNcxm21678boLT":"if (args.attackerTest.data.preData.rollClass !== \"CharacteristicTest\") return;\nif (args.attackerTest.data.preData.characteristic !== \"s\") return;\n\nconst SL = args.opposedTest.data.opposeResult.differenceSL;\n\nconst targetId = this.effect.getFlag(\"wfrp4e\", \"target\");\nconst target = canvas.scene.tokens.get(targetId);\n\nif (SL > 4) {\n  args.opposedTest.data.opposeResult.other.push(`<b>${args.defenderTest.actor.name}</b> was forced to let go of <b>${target.name}</b>.`);\n  return await this.effect.delete();\n}\n\nif (SL > 0) {\n  args.opposedTest.data.opposeResult.other.push(`<b>${args.defenderTest.actor.name}</b> was prevented from squeezing <b>${target.name}</b> for one turn.`);\n  let turns = this.effect.getFlag(\"wfrp4e\", \"turns\");\n  this.effect.setFlag(\"wfrp4e\", \"turns\", turns + 1);\n}","FSqUqSByMiztYOQM":"if (args.totalWoundLoss > 0)\n     this.script.message(`<b>Infected: ${args.actor.name}</b> must pass an <b>Easy (+2) Endurance</b> Test or gain a @UUID[Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb]{Festering Wound}`, {whisper: ChatMessage.getWhisperRecipients(\"GM\") })","FUgCtIoj1Stgqxt7":"return ![\"ws\", \"bs\", \"s\", \"ag\", \"t\", \"dex\"].includes(args.characteristic)","FX8ILw0VgbNxkObA":"const uuid = \"Compendium.wfrp4e-core.items.Item.mCvZAj5F6hfUZhzR\";\nconst item = await fromUuid(uuid);\nconst data = item.toObject();\ndata.name = this.effect.name;\ndata.type = 'trapping';\ndata.system.trappingType = {value: 'clothingAccessories'};\ndata.system.equipped = {value: true};\n\nconst effectData = this.effect.sourceItem.effects.find(e => e.disabled).toObject();\neffectData.disabled = false;\neffectData.system.transferData.equipTransfer = true;\ndata.effects = [effectData];\n\nconst dagger = await this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id});","FXuyiJoXdAh6WhRK":"return args.skill?.name == `${game.i18n.localize(\"NAME.Ride\")} (${game.i18n.localize(\"SPEC.Horse\")})` && game.combat?.active","FXwfqF0jpXlBQ9Y3":"return args.item?.system?.isMelee && this.actor.attacker","FYUPfYyTYZkxRLFT":"return ![\"NAME.Endurance\", \"NAME.Cool\"].map(i => game.i18n.localize(i)).includes(args.skill?.name)","FZFOC7bip0oiWEzk":"if (args.opposedTest.result.hitloc.value == this.item.system.location.key && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 2);\n    this.script.notification(\"Added Bleeding\")\n}","FbfJjYUyp0ArtZMb":"args.fields.modifier += 15","FciJSTq7dZsZIPgl":"if (args.equipped)\n{\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.SfUUdOGjdYpr3KSR\")\n    let data = item.toObject();\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n}\nelse \n{\n    this.effect.deleteCreatedItems();   \n}","FfTqCPxCoxwGDTQs":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.wMwSRDmgiF2IdCJr\")\nlet data = item.toObject()\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","FiD3mvWIBHNNIuO9":"if (args.opposedTest.result.hitloc.value == \"body\")\n{\n   if ((await new Roll(\"1d2\").roll()).total == 1)\n   {\n       args.opposedTest.result.hitloc.value = \"head\"\n       this.script.message(`Hit location changed to Head`)\n   }\n}","FkTwk8hfHpRLbAp2":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}","FmLx9pwOkzqqU7Ph":"return args.skill?.name == game.i18n.localize(\"NAME.Track\");","FqevMs0ukQ9WuUHl":"// Each time the blade is used, the GM should secretly roll a d10.\n// On a 1, its poison has run dry, \n// and the next time it is employed it will shatter.\n\nif (this.item.getFlag(\"wfrp4e\", \"brittle\"))\n{\n    ChatMessage.create({content: `<strong>${this.item.name}</strong> shatters!`})\n    this.item.update({name : `${this.item.name} (Shattered)`})\n}","FtZf56VI6Qsspu0D":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'difficult';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","FttdVBQiNssDAARh":"return args.data.targets[0]?.actor?.hasCondition(\"entangled\")","Fu8DTvSgLufcB5mr":"async function rollTable(characteristics, formula, name) {\n  const roll = new Roll(formula);\n  await roll.toMessage({flavor: name});\n\n  const values = roll.dice[0].values;\n\n  for (const value of values) {\n    let characteristic;\n    switch (value) {\n      case 1: case 2: characteristic = \"ws\"; break;\n      case 3: case 4: characteristic = \"i\"; break;\n      case 5: case 6: characteristic = \"int\"; break;\n      case 7: case 8: characteristic = \"fel\"; break;\n      case 9: case 10: characteristic = \"*\"; break;\n      default: continue;\n    }\n\n    if (characteristics.has(characteristic)) {\n      await rollTable(characteristics, \"1d10\", name);\n    } else {\n      characteristics.add(characteristic);\n    }\n  }\n}\n\nconst characteristics = new Set();\nawait rollTable(characteristics, \"2d10\", this.effect.name)\n\nif (characteristics.has(\"*\")) {\n  characteristics.delete(\"*\");\n  const availableChoices = foundry.utils.duplicate(game.wfrp4e.config.characteristics);\n\n  for (const ch of characteristics) delete availableChoices[ch];\n\n  const result = warhammer.apps.ValueDialog.create({\n    text: \"Choose a characteristic\",\n  }, \"\", availableChoices);\n\n  if (!result) return;\n\n  characteristics.add(result);\n}\n\nthis.effect.setFlag(\"wfrp4e\", \"characteristicsToSwap\", Array.from(characteristics));","Fvlc4RkeF4dHjW3m":"let caster = this.effect.sourceActor\nif (caster && (this.actor.has(game.i18n.localize(\"NAME.Undead\")) || this.actor.has(game.i18n.localize(\"NAME.Daemonic\")))) {\n    let wp = caster.system.characteristics.wp.value\n    if (wp > this.actor.system.characteristics.t.value) {\n        if (this.actor.has(game.i18n.localize(\"NAME.Unstable\"))) {\n            this.actor.update({ \"system.status.wounds.value\": 0 })\n            this.actor.addCondition(\"dead\")\n        }\n        else {\n            fromUuid(\"Compendium.wfrp4e-core.items.D0ImWEIMSDgElsnl\").then(item => {\n                this.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], { fromEffect: this.effect.id })\n                ChatMessage.create({ content: `Added Unstable to ${this.actor.prototypeToken.name}`, speaker: { alias: caster.name } })\n            })\n        }\n    }\n}","Fwk8WA8NfRivLFWJ":"return args.skill?.name === \"Entertain (Singing)\";","G1RletYc6BzigJrK":"let ablaze = parseInt(this.effect.sourceTest.result.SL) + 5\nargs.actor.addCondition(\"ablaze\", ablaze)","G7sFEnJlXZvfXL3V":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n    let effectData = this.item.effects.contents[1].convertToApplied();\n\teffectData.system.sourceData.item = this.item.uuid\n\tactor.applyEffect({effectData : [effectData]})\n}\nelse\n{\n\tthis.script.notification(\"None left!\", \"error\")\n}","GAO8AozttWOyRkta":"if (!args.flags.lostHand)\n{\n\targs.fields.lostHand = true;\n\targs.fields.modifier += -20;\n}","GEfWIFBSrXt0ldBM":"(await new Roll(\"1d10\").roll()).toMessage(this.script.getChatData())\nawait this.actor.addCondition(\"dead\")","GFaTz8f6PBNWrlad":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context : {failure : `<strong>Confused</strong>: Determine behaviour by @Table[bewilder] Table.`}})\nawait test.roll();\nreturn test.failed","GFkVnx4m9OwYsKGH":"args.actor.flags.ambi+= 1","GNl5Zk7BZ2jhRV1I":"if (args.item.type == \"armour\")\n{\n    args.item.system.AP.head = 0;\n}","GOq4TcnWbfyfCo2V":"this.script.notification(`Healed ${this.actor.characteristics.t.bonus * 2} Wounds`)\nawait this.actor.modifyWounds(this.actor.characteristics.t.bonus * 2)\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - Side Effects`,fields : {difficulty : \"difficult\"}})\nawait test.roll();\nif (test.failed)\n{\n    let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\n    await roll.toMessage(this.script.getChatData())\n    if (roll.total <= 3)\n    {\n        this.actor.addCondition(\"blinded\", 3)\n    }\n    else if (roll.total <= 6)\n    {\n        this.actor.addCondition(\"broken\");\n    }\n    else if (roll.total <= 9)\n    {\n        this.actor.addCondition(\"stunned\");\n    }\n    else if (roll.total == 10)\n    {\n        this.actor.addConditon(\"unconscious\")\n    }\n}","GRfCxtYzmEx2LYU7":"if (args.totalWoundLoss >= 1)\n{\n    let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\n    await roll.toMessage(this.script.getChatData());\n    if (roll.total == 9)\n    {\n        this.script.message(`Two @UUID[Compendium.wfrp4e-eis.actors.iDy8SDTwJSlCzZMl]{Blue Horror of Tzeentch} claw their way out of ${this.actor.name}'s screaming flesh, killing them in the process.`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    }\n}","GTZUO73pUJKpM1JB":"    let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\n    game.dice3d?.showForRoll(roll);\n    this.script.message(await this.actor.applyBasicDamage(roll.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true}))\n","GUkpYdPwoC5pc9BT":"return !args.weapon?.system.properties.flaws.crewed","GZFsuynUhgZqwTGo":"if (args.totalWoundLoss >= 1)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context: { failure: \"Gained a Poisoned Condition\", success: \"Resisted the poison\" }})\n    await test.roll();\n    if (test.failed)\n    {\n        args.actor.addCondition(\"poisoned\");\n    }\n}\n    ","GbPEy22VuCNzlNv2":"return !this.actor.isMounted || (!args.skill?.name?.includes(game.i18n.localize(\"NAME.Ride\")) && !args.context.dodge)","Gc8S5TYlVdV8NnOT":"let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name, context: { failure: \"Gained a Broken Condition\", success: \"Resisted the Broken Condition\" } })\n\n await test.roll();\n\n if (!test.succeeded)\n {\n    args.actor.addCondition(\"broken\");\n }","GcIQtshex11AMmh2":"if (this.item.system.isEquipped)\n{\n    let removeRepeater = false\n    if(!this.item.system.offhand.value) // main\n    {\n        let offhandUsed = this.actor.itemTypes.weapon.find(i => i.system.isEquipped && i.system.offhand.value)\n        if (offhandUsed)\n        {\n            removeRepeater = true;\n        }\n    }\n    else // offhand\n    {\n        let mainhandUsed = this.actor.itemTypes.weapon.find(i => i.system.isEquipped && !i.system.offhand.value)\n        if (mainhandUsed)\n        {\n           removeRepeater = true;\n        }\n    }\n    \n    if (removeRepeater)\n    {\n        this.item.system.qualities.value = this.item.system.qualities.value.filter(i => i.name != \"repeater\")\n    }\n}","GePFbu5kp2ymGYEQ":"await this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.IAWyzDfC286a9MPz\", this.effect);","Gh7OidY6UdpWBS1g":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.KII1gWnxIZ8HzmU5\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","GjkxWj9wCAclM9WA":"let effects = foundry.utils.deepClone(this.item.effects.contents.filter(e => e.active));\n\neffects.splice(effects.length - 1);\n\nif (effects.length == 0)\n{\n    return this.script.notification(\"All Effects have been used. Reset to select them again\")\n}\nlet choice = await ItemDialog.create(effects, 1, \"Choose Power to Gain\");\n\nif (choice[0])\n{\n    choice[0].update({disabled : true})\n    let effect = choice[0].convertToApplied();\n    effect.name += ` (${this.effect.name})`\n    this.actor.createEmbeddedDocuments(\"ActiveEffect\", [effect]);\n}","GrF6tQ08jgKmUH4i":"return ![\"ws\", \"bs\", \"s\", \"ag\", \"i\"].includes(args.characteristic)","GsAyB5xnK3ASeoah":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpentry)';\nconst difficulty = 'easy';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","GtfHQA9T1ip463le":"return ![\"ws\", \"bs\"].includes(args.characteristic)","GuUCErVbk5hrFzR3":"args.multiplier.tb += 1","GuxbvztcvzJz2oH1":"args.item.system.qualities.value = [];","GzSFlqL1YrIK1dxh":"let items = await Promise.all([\"Compendium.wfrp4e-wom.items.Item.EjGYZ4CgX2jZW7Ot\",\n\"Compendium.wfrp4e-wom.items.Item.O2v9RQiFf0obskP5\",\n\"Compendium.wfrp4e-wom.items.Item.2cv6hhZ57iV6z5Il\",\n\"Compendium.wfrp4e-wom.items.Item.YgDEUO0G0XcqQJqg\",\n\"Compendium.wfrp4e-wom.items.Item.J6K5TPxI8qIGQKKH\",\n\"Compendium.wfrp4e-wom.items.Item.K9FPtiDLwTkC7FuO\",\n\"Compendium.wfrp4e-wom.items.Item.CkMYRYCLrkMnyVm5\",\n\"Compendium.wfrp4e-wom.items.Item.0Xdm4r7l2EwC4fcg\"].map(fromUuid));\n\nlet choice = await game.wfrp4e.apps.ItemDialog.create(items, 1, \"Select Wind\")\n//this.actor.createEmbeddedDocuments(\"Item\", items);\n\nthis.item.update(choice[0]?.toObject(), {diff: false, recursive : false});\n\n//this.actor.items.getName(this.effect.item.name).delete() // For some reason this.effect.item.delete() throws an error\n\n","GzsuEg7gZy1f0ljy":"let bleeding = this.actor.hasCondition(\"bleeding\")\nif (bleeding)\n{\n   this.script.notification(`Cleared ${bleeding.conditionValue} Bleeding Conditions`)\n   bleeding.delete();  \n}\nelse \n{\n   this.script.notification(`No Bleeding Conditions`)\n}","H06Ysj7oPiemW7S6":"if (args.test.options.income && !args.test.options.criminal)\n{\n    args.test.options.criminal = true;\n    let currentCareer = args.test.actor.system.currentCareer;\n    let coin = {1 : \"b\", 2 : \"s\", 3 : \"s\", 4 : \"g\"}[currentCareer.system.level.value] // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)\n    let term = {1 : \"bp\", 2 : \"ss\", 3 : \"ss\", 4 : \"gc\"}[currentCareer.system.level.value] // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)\n    let dieAmount = {1 : \"2d10\", 2 : \"1d10\", 3 : \"2d10\", 4 : \"1\"}[currentCareer.system.level.value] // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)\n    dieAmount = parseInt(dieAmount[0]) * this.item.system.Advances;     // Multilpy that first letter by your standing (Brass 4 = 8d10 pennies)\n    if (coin != \"g\") // Don't roll for gold, just use standing value\n    {\n        dieAmount = dieAmount + \"d10\";\n    }\n    let moneyEarned = (await new Roll(dieAmount.toString()).roll()).total;\n    let moneyString = `${moneyEarned}${coin}`\n    let transactionString = `${moneyEarned}${term}`\n\n    this.script.message(`<a class=\"money-drag\" data-amt=\"${moneyString}\"><strong>Earned an additional ${game.wfrp4e.market.amountToString(game.wfrp4e.market.parseMoneyTransactionString(transactionString))}</strong></a>`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","H1z3nWW7Rj3Oisxy":"return args.type != \"channelling\"","H2CJvApKMnfGNNoo":" if (args.test.item?.type == \"skill\" && args.test.item.name.includes(game.i18n.localize(\"NAME.Stealth\")))\n{ \n     args.test.result.description = \"Astounding Failure\";\n     args.test.result.outcome = \"failure\";\n       ChatMessage.create({content : \"<em>SQUEAK</em>\", speaker : ChatMessage.getSpeaker({token: this.actor.getActiveTokens()[0]?.document, actor: this.actor})}, {chatBubble : true})\n        AudioHelper.play({ src: `${game.settings.get(\"wfrp4e\", \"soundPath\")}squeek.wav` }, true);\n}","H3Wls12aVWAWTp9J":"this.actor.setupCharacteristic(\"i\", {skipTargets: true, appendTitle :  \" - \" + this.effect.name}).then(test => {\n    test.roll();\n})","H3pZ9UeIzIz3luKh":"args.actor.addCondition(\"bleeding\")\n\nthis.actor.setFlag(\"wfrp4e\", \"isAttached\", args.actor.name)\n\nthis.script.message(`Attaches to <strong>${args.actor.name}</strong>`)","H7lcCU24gFDp7zK7":"let amount = this.effect.sourceTest.result.baseSL;\nargs.fields.successBonus += amount;","H85k4L3yICm7cfIk":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Sail';\nconst difficulty = 'easy';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","H8jDtK1Ewn4hL3A1":"args.fields.slBonus += 4;","HASsi6wYHVALExWq":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context: { failure: \"1 Corruption Point Gained\" } })\nawait test.roll();\n\nif (test.failed && args.actor.type == \"character\") \n{\n    let msg = \"\"\n    msg += `<p><b>${this.actor.prototypeToken.name}</b> gained a Corruption point</p>`\n    if (test.result.roll % 11 == 0 || test.result.roll == 100)\n    {\n        msg +=  `<b>${args.actor.prototypeToken.name}</b> gains a mutation (@Table[expandedmutatephys]{Physical} or @Table[expandedmutatemental]{Mental}) and gains @UUID[Compendium.wfrp4e-core.items.hiU7vhBOVpVI8c7C]{Chaos Magic (Tzeentch)}`\n    }\n    this.script.message(msg, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    await this.actor.update({ \"system.status.corruption.value\": parseInt(args.actor.status.corruption.value) + 1 })\n}","HG2fKOfruT5QV3A4":"let lore = await ValueDialog.create({text : \"Choose Lore\", title : \"Lore\"}, \"\", {\"fire\" : \"Fire\", \"death\" : \"Death\", \"metal\" : \"Metal\", \"shadow\" : \"Shadow\"});\n\nlet filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = await ItemDialog.createFromFilters(filters, 3, {text: \"Choose 3 Petty Spells\"})\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : [\"\"]\n    }\n]\n\nlet arcane = await ItemDialog.createFromFilters(filters, 6, {text: \"Choose 6 Arcane Spells\"})\n\nlet items = petty.map(i => i.toObject()).concat(arcane.map(i => {\n    let spell = i.toObject();\n    spell.img = `modules/wfrp4e-core/icons/spells/${lore}.png`\n    spell.system.lore.value = lore;\n    return spell;\n}));\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","HJ2X4ZtXei0BXbxf":"        let choices = await Promise.all([warhammer.utility.findItemId(\"PzimjNx9Ojq4g6mV\"), warhammer.utility.findItemId(\"rOPmyLWa37e7s9v6\")])\n        let items = await game.wfrp4e.apps.ItemDialog.create(choices, 1, \"Choose a Skill\")\n\n        items = items.map(i => i.toObject())\n        items.forEach(i => i.system.advances.value = 20)\n\nitems.forEach(i => i.system.equipped.value = true;)\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","HKhyn0kijKfzW6cw":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}})\nawait test.roll();\nthis.item.updateSource({\"flags.wfrp4e.passed\" : test.succeeded})","HMC6hPND9DWLFfZE":"if (this.item.name.includes(\"(\"))\n{\n\treturn;\n}\n\nlet index = game.packs\n.filter(i => i.metadata.type == \"Item\")\n.reduce((acc, pack) => acc.concat(pack.index.contents), [])\n.filter(i => i.type == \"skill\" && i.name.includes(game.i18n.localize(\"NAME.Lore\")))\n.map(i => {\n\ti.id = i._id\n\treturn i\n})\n\nlet choice = await ItemDialog.create(index, 1, \"Choose a Lore\")\nlet text;\nif (!choice[0])\n{\n    let custom = await ValueDialog.create({text : \"Enter Lore\", title : this.effect.name});\n    text = custom || \"\";\n}\nelse \n{\n    text = game.wfrp4e.utility.extractParenthesesText(choice[0].name)\n}\n\nawait this.item.updateSource({name : this.item.name + ` (${text})`, \"system.tests.value\" : this.item.system.tests.value.replace(\"chosen Lore\", text)})\nawait this.effect.updateSource({name : this.effect.name + ` (${text})`})","HOt2hHOiHDZ7oBgW":"if ([\"rLeg\", \"lLeg\"].includes(this.effect.getFlag(\"wfrp4e\", \"location\")))\n{\n\targs.actor.details.move.value /= 2\n}\n","HUKzssLxeQo1wbx9":"\n                            let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"average\"}, appendTitle : \" - Wounded\"})\n                            await test.roll();\n                            if (test.failed)\n                            {\n                                fromUuid(\"Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb\").then(disease => {\n                                    this.actor.createEmbeddedDocuments(\"Item\", [disease.toObject()])\n                                    this.script.notification(\"Gained \" + disease.name)\n                                })\n                            }\n                            ","HX6CjNapYdC0VmQ8":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.epPBu7x6BRWp2PHG\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","HXJKkmpfxQUOnWOS":"if (!this.item.system.twohanded.value)\n{\n    this.item.system.flaws.value = this.item.system.flaws.value.concat([{name : \"tiring\"}, {name : \"slow\"}])\n}","HYrl5aNMm8BAdqH7":"\n                            let modifier = 0\n                            if (this.effect.name.includes(\"Moderate\"))\n                                modifier = -20\n                            else\n                                modifier = -10\n                            args.fields.modifier += modifier\n                            ","Hcpn1gU58DIKIhty":"if (args.item.type  == \"skill\" && args.item.name == `${game.i18n.localize(\"NAME.Melee\")} (${game.i18n.localize(\"SPEC.Flail\")})`)\n{\n     args.item.system.modifier.value += 10;\n}","HdTuY2IGhdlMDOy3":"if (this.actor.system.details.experience.current < 100) {\n  return this.script.notification(game.i18n.localize(\"SCRIPT.NotEnoughXP\"))\n}\n\nlet item = await game.wfrp4e.utility.findItem(\"Animal Telepathy\", \"trait\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item]);\nlet expLog = foundry.utils.duplicate(this.actor.details.experience.log || []);\nexpLog.push({amount : 100, reason: item.name, spent: this.actor.details.experience.spent + 100, total: this.actor.details.experience.total, type: \"spent\"});\nthis.actor.update({\n    \"system.details.experience.spent\": this.actor.details.experience.spent + 100,\n    \"system.details.experience.log\": expLog\n  });","HfCxNd7mFGZH4s9Y":"// An opponent that takes more than a single Wound from a Warp Blade strike \n// in melee combat must make an Average (+20) Endurance Test \n// or take a Stunned Condition\n\n\nif (args.totalWoundLoss > 1) {\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if(test.failed)\n    {\n        await args.actor.addCondition(\"stunned\");\n    }\n}","HfZAQWoY8n3clLlo":"if (!args.itemCreated) return;\nif (args.itemCreated.type !== \"critical\") return;\nif (args.itemCreated.system.location.value.toLowerCase() !== \"head\") return;\nif (Number(args.itemCreated.system.wounds.value) > 0) {\n  this.script.message(game.i18n.format(\"SCRIPT.Sallet\", {name: args.itemCreated.parent.name, wounds: args.itemCreated.system.wounds.value}))\n}","Hi005w1Ul17Q8Uty":"let test = this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"average\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\nif (test.succeeded)\n{\n\tthis.effect.delete()\n}","HiMBS6GeOwEydWYN":"return args.skill?.name != game.i18n.localize(\"NAME.Climb\");","HmImVzvw6ecBy99l":"if (args.opposedTest.result.hitloc.value == \"body\" && args.totalWoundLoss > 0) \n{\n    args.actor.addCondition(\"bleeding\", 2)\n    this.script.notification(\"Added Bleeding\")\n}","HoNTnPphrJISSQr1":"ChatMessage.create({content : \"<em>Speak and be known to me</em>\", speaker : ChatMessage.getSpeaker({token: this.actor.getActiveTokens()[0]?.document, actor: this.actor})}, {chatBubble : true})","Hq1G30lhJYvtOSNb":"                 \n                            if (args.test.failed)\n                            {\n                                let applicableCharacteristics = [\"ws\", \"bs\", \"s\", \"fel\", \"ag\", \"t\", \"dex\"];\n                                if (applicableCharacteristics.includes(args.preData.characteristic))\n                                {\n                                    this.actor.addCondition(\"stunned\");\n                                }\n                            }","HrOBAXsEX073ReKl":"let skill = `${game.i18n.localize(\"NAME.Entertain\")} (${game.i18n.localize(\"SPEC.Singing\")})`;\nlet currentCareer = this.actor.system.currentCareer;\nlet existingSkill = this.actor.itemTypes.skill.find(i => i.name == skill);\n\nif (!currentCareer) return\n\n\nlet inCurrentCareer = currentCareer.system.skills.concat(currentCareer.system.addedSkills).includes(skill);\nlet perfectPitchAdded = this.actor.getFlag(\"wfrp4e\", \"perfectPitchAdded\") || {};\nif (existingSkill && inCurrentCareer && !perfectPitchAdded[existingSkill.name])\n{\n\texistingSkill.system.advances.costModifier = -5;\n}\nelse \n{\n\tperfectPitchAdded[skill] = true;\n\tcurrentCareer.system.addedSkills.push(skill);\n\tfoundry.utils.setProperty(this.actor, \"flags.wfrp4e.perfectPitchAdded\", perfectPitchAdded)\n}\n\n\n","HrYchgkdZBiu1yPF":"return args.skill?.name == game.i18n.localize(\"NAME.Climb\");","HwbgUIbpX0D8JLOR":"if (args.opposedTest.result.differenceSL >= 0 && args.opposedTest.result.differenceSL <= 2 && args.opposedTest.result.winner == \"attacker\")\n    this.actor.addCondition(\"bleeding\")","I0Jo6cbNAJtXUloc":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.J9MK0AIaTbvd5oF6\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id});","I0oRZ7AWde5KI5jw":"return ![\"t\", \"int\"].includes(args.characteristic)","I1J2m5uud84N50Lk":"if ([\"cast\", \"channelling\", \"pray\"].includes(args.type))\n{\n\targs.abort = true;\n\tthis.script.notification(\"Cannot cast Spells or use Prayers\");\n}\nelse return true;","I79D8V8OFzMCtL40":"const target = await ValueDialog.create({title: \"Select Target\", text: \"Select Target for Hatred\"}, \"Target\");\nawait this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.5hH73j2NgPdsLCZN\", this.effect, {name: `Hatred (${target})`});","I7ieW0hNYvvX0KFg":"return args.skill?.name != game.i18n.localize(\"NAME.Heal\");","I93i49wI9ZrDHT4n":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.jt0DmVK9IiF6Sd2h\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","I9QAPKbaXwMMMBT4":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty: \"average\"}, skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\nif(test.failed)\n{\n    await this.actor.addCondition(\"stunned\");\n    let secondTest = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty: \"easy\"}, skipTargets: true, appendTitle :  \" - Despair\"})\n    await secondTest.roll();\n    if(secondTest.failed)\n    {\n        this.effect.updateSource({name : \"Taste of Death\"})\n         await this.actor.addCondition(\"fatigued\");\n    }\n    else \n    {\n        return false;\n    }\n}","IAGla7HJlYN0wa4H":"if (args.test.characteristicKey == \"wp\") \n{\n    if (args.test.failed)\n    {\n        this.actor.addSystemEffect(\"convulsions\")\n        this.script.message(`Willpower Test failed, <b>${this.actor.prototypeToken.name}</b> gains @Symptom[Convulsions] for [[1d10]] hours`)\n    }\n}","ID8mCcjkl7PCQhDq":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\nif(test.failed)\n{\n    let damage = this.effect.sourceItem.system.computeSpellDamage(\"3\", true);\n    this.script.message(await this.actor.applyBasicDamage(damage, {suppressMsg: true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP}))\n}","IFXsTRAVDUeVvcRc":"let roll = await new Roll(\"1d100\")\nawait roll.evaluate()\nawait roll.toMessage({\"flavor\": `Wyssan's Dice Reversal`})\n\nif (roll.result % 11 === 0 || roll.result === 100) {\n  await this.item.setFlag(\"world\", \"inert\", true)\n}","IG4zYqtN9fRSYE7q":"args.actor.addCondition(\"ablaze\");","IKiZv9YSFmKmHo6a":"return args.spell?.system.lore.value == \"fire\"","ILqHxk7deotgI3KD":"if (args.item.type != \"weapon\")\n    return\n\nlet reach = args.item.reach.value\nlet reachNum = game.wfrp4e.config.reachNum[reach]\nreachNum = Math.min(reachNum + 2, 7)\n\nlet key = warhammer.utility.findKey(reachNum, game.wfrp4e.config.reachNum)\n\nargs.item.reach.value = key","IN4ZFOPooqJtNuIQ":"return args.characteristic !== \"s\" && args.characteristic !== \"t\" && args.weapon?.system?.attackType !== \"melee\";","IOroJBqTsWvoakJN":"if (args.actorsystem.details.move.oars.value > 0)\n  args.actor.system.details.move.oars.value -= 2;\n","IPPDvZdE8kn3H9z7":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\n\nif (test.failed)\n{\n   await this.actor.addCondition(\"grappling\")\n}","IR5URcjnCuWBFMoN":"// If a full dose is imbibed, \n// the victim must pass a Hard (-20) Endurance Test.\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"hard\"}})\nawait test.roll()\nif (test.failed)\n{\n    this.script.message(`<p><strong>${this.actor.prototypeToken.name}</strong> notices nothing amiss save that they become tired a little earlier than usual. At this point it is still possible to save the victim via a powerful antidote or magical means.</p>\n    <p>Once they fall asleep however, it is almost impossible. At this point the victim must make a <strong>Hard (-20) Endurance</strong> Test. If they fail, they never awaken.</p>`, \n    {\n      whisper: ChatMessage.getWhisperRecipients(\"GM\"), \n      blind: true \n    })\n}\nreturn test.failed;","IR86DuMbVdbGOJYt":"this.actor.addCondition(\"blinded\")","IfEu1hO8sKEZBpvg":"let value = parseInt(this.item.specification.value)\nlet name = this.actor.prototypeToken.name\n\nif (game.user.isGM && game.user.targets.size)\n{\n  game.user.targets.forEach(t => {\n    t.actor.applyFear(value, name)\n  })\n  game.canvas.tokens.setTargets([])\n\n}\nelse \n{\n  game.wfrp4e.utility.postFear(value, name)\n}","IkGegSuQwwVPhrjF":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\ndata.system.specification.value = 1\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","IkVcIRmmgQjsBUUf":"let roll = await new Roll(\"1d100\")\nawait roll.evaluate()\nawait roll.toMessage({\"flavor\": `Wyssan's Dice Reversal`})\n\nif (roll.result % 11 === 0 || roll.result === 100) {\n  await this.item.setFlag(\"world\", \"inert\", true)\n  this.script.message(`${this.item.name} loses its magical properties`, {blind: true, whisper: ChatMessage.getWhisperRecipients(\"GM\")})\n}","Ip8sctF9SIE1Z2vF":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.UnJ25lL8aUzem5JO\")\nlet data = item.toObject();\ndata.system.specification.value = 3\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","IpoOOjYJs6RmVrpb":"if (args.totalWoundLoss > 0)\n{\n    args.attacker.applyEffect({effectUuids : this.effect.sourceItem.effects.contents[1].uuid})\n}","IrkWq7IiFS65bTvC":"if (this.actor.flags.holed.half !== true) return;\nif (this.actor.flags.holed.reminded === true) return;\n\nconst speaker = ChatMessage.getSpeaker({actor: this.actor});\nthis.script.message(`<p><b>${speaker.alias}</b> sits heavily in the water. Unless the cargo is waterproof, it loses [[d10]]% of its value.</p>`);\n\nthis.actor.flags.holed.reminded  = true;","IsLAvY9ikR1cOJWw":"return ![\"NAME.Row\", \"NAME.Swim\"].map(i => game.i18n.localize(i)).includes(args.skill?.name);","IslMfFgpgQq2brpu":"if (this.actor.hasCondition(\"broken\"))\n{\n    this.actor.removeCondition(\"broken\")\n    this.script.notification(`Cannot have Broken`);\n}","IukS0clr1yAleacc":"this.actor.system.characteristics.ag.modifier -= parseInt(this.item.system.location.value) || 1\n\nthis.actor.system.characteristics.ws.modifier -= parseInt(this.item.system.location.value) || 1","IupskvzvoGyD2H5o":"if (this.actor.type != \"character\")\n{\n    return;\n}\n\nlet god = await ValueDialog.create({text : \"Enter a Deity\", title :  \"Blessed\"})\n\nif (god)\n{\n    let prayers = await warhammer.utility.findAllItems(\"prayer\", \"Loading Prayers\", true, [\"system.type.value\", \"system.god.value\"])\n    let blessings = prayers.filter(p => p.system.god.value.split(\",\").map(i => i.trim().toLowerCase()).includes(god.toLowerCase()) && p.system.type.value == \"blessing\")\n    let configBlessings = await Promise.all((game.wfrp4e.config.godBlessings[god.toLowerCase()] || []).map(fromUuid));\n    if (god == \"Old Faith\")\n    {\n        blessings = await ItemDialog.create(prayers.filter(i => i.system.type.value == \"blessing\"), 6, {text : \"Select any 6 Blessings\", title :  \"Blessed\"})\n    }\n    if (configBlessings.length)\n    {\n        // Combine blessings defined by config with actual blessing items found that specify this god, avoiding duplicates\n        blessings = blessings.concat(\n            configBlessings.map(i => {return {uuid : i.uuid, name : i.name}})\n            .filter(bls => !(blessings.find(i => i.uuid == bls.uuid)))\n        );\n    }\n    if (blessings.length)\n    {\n        this.script.notification(\"Adding \" + blessings.map(i => i.name).join(\", \"))\n        await this.actor.addEffectItems(blessings.map(i => i.uuid), this.effect)\n    }\n    else \n    {\n        this.script.notification(`Could not find any Blessings associated with ${god}.`)\n    }\n    if (this.item.name.includes(\"Any\"))\n        this.item.updateSource({name: this.item.name.replace(\"Any\", god)});\n    else\n        this.item.updateSource({name: this.item.name + ` (${god})`});\n    await this.actor.update({\"system.details.god.value\": god})\n}","IuxMr6SFdJhqFtVD":"this.actor.system.status.corruption.value += 3","IzZcsSngI8TZH4d8":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.fjd1u9VAgiYzhBRp\");\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","IzoOmDywGLqLNljN":"let skill = `Language (Magick)`\nlet currentCareer = this.actor.system.currentCareer;\nlet existingSkill = this.actor.itemTypes.skill.find(i => i.name == skill);\n\nif (!currentCareer) return\n\n\nlet inCurrentCareer = currentCareer.system.skills.concat(currentCareer.system.addedSkills).includes(skill);\nlet witchAdded = this.actor.getFlag(\"wfrp4e\", \"witchAdded\") || {};\nif (existingSkill && inCurrentCareer && !witchAdded[existingSkill.name])\n{\n\texistingSkill.system.advances.costModifier = -5;\n}\nelse \n{\n\twitchAdded[skill] = true;\n\tcurrentCareer.system.addedSkills.push(skill);\n\tfoundry.utils.setProperty(this.actor, \"flags.wfrp4e.witchAdded\", witchAdded)\n}","J0IWUhxada2ONowP":"return args.skill?.name == `${game.i18n.localize(\"NAME.Entertain\")} (${game.i18n.localize(\"SPEC.Sing\")})` || args.skill?.name == `${game.i18n.localize(\"NAME.Entertain\")} (${game.i18n.localize(\"SPEC.Singing\")})` || args.skill?.name.includes(game.i18n.localize(\"SPEC.Magick\")) || args.skill?.name.includes(game.i18n.localize(\"SPEC.Eltharin\") || args.skill?.name.includes(game.i18n.localize(\"SPEC.Cathayan\")));","J1FPDdrXGctKDTZz":"if (args.equipped)\n{\n    let ward = await fromUuid(\"Compendium.wfrp4e-core.items.Bvd2aZ0gQUXHfCTh\")\n    wardData = ward.toObject()\n    wardData.system.specification.value = \"8\"\n     \n    let mr = await fromUuid(\"Compendium.wfrp4e-core.items.yrkI7ATjqLPDTFmZ\")\n    mrData = mr.toObject()\n    mrData.system.specification.value = 2\n    \n    this.actor.createEmbeddedDocuments(\"Item\", [wardData, mrData], {fromEffect : this.effect.id})\n}\nelse\n{\n    this.effect.deleteCreatedItems()\n}","J8aPichsl25t1QZ9":"this.actor.addCondition(\"entangled\", this.effect.sourceTest.result.SL)","JBoKPBr27C3PMoSD":"return args.skill?.name === game.i18n.localize(\"NAME.Navigation\");","JEbs0WlqhKNDOo5A":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"unconscious\")\n}\n","JFgXyb6bKjZJLmF8":"return args.characteristic == \"ag\"","JQruHprM5R5vZ9DA":"let caster = this.effect.sourceActor;\nif (caster)\n{\n    let healed= caster.system.characteristics.wp.bonus + caster.system.characteristics.int.bonus\n    await this.actor.modifyWounds(healed);\n    this.script.message(`<strong>${this.actor.prototypeToken.name}</strong> regains ${healed} Wounds`)\n}\n \n let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"vhard\"}, context : {success : \"1 Corruption point that was gained within the last hour is removed.\", failure: \"Nothing happens\"}})\n await test.roll();","JXBUE0XuJOJNG7zE":"if (args.totalWoundLoss <= 7) return;\n\nlet options = {\n  appendTitle : \" – \" + this.effect.name,\n  skipTargets: true,\n  fields: {difficulty: 'average'},\n  characteristic: 'wp',\n}\n\nlet test = await args.actor.setupSkill('Cool', options);\nawait test.roll();\n\nif (!test.succeeded) {\n  const targetId = this.effect.getFlag(\"wfrp4e\", \"target\");\n  const target = canvas.scene.tokens.get(targetId);\n  await this.effect.delete();\n  args.extraMessages.push(`<b>${args.actor.name}</b> lost ${args.totalWoundLoss} Wounds to an attack, which caused it to let go of <b>${target.name}</b>.`);\n}","JZIn1dsKHFE3smJU":"let ablaze = parseInt(this.effect.sourceTest.result.SL) + 1\nargs.actor.addCondition(\"ablaze\", ablaze)","JaiC5P6nIgctOacH":"if (args.actor.system.details.species?.value?.toLowerCase() == \"dwarf\")\n{\n    args.weaponProperties.flaws.undamaging = true;\n}","JavuFNZ9Pj5elVLc":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet data = item.toObject();\ndata.system.specification.value = 4 - this.actor.characteristics.s.bonus\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","JeThJbOf6Xmbtgo1":"this.script.message(await this.actor.applyBasicDamage(8 + parseInt(this.effect.sourceTest.result.SL), {suppressMsg : true}))\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Athletics\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}","JfOodll9a2Lw0fWg":"let blinded = args.actor.hasCondition(\"blinded\")\nif (blinded)\n{\n    blinded.system.scriptData = blinded.system.scriptData.filter(s => s.trigger != \"dialog\")\n    blinded.system._scripts = null;\n}","JgCcgDVZX54slrWx":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Melee\")) || args.item?.isMelee || args.context.corruption","JhCMYHHYA860Kka8":"return !this.actor.attacker || args.item?.system?.attackType !== \"melee\" || args.skill?.name !== game.i18n.localize(\"NAME.Dodge\");","JhbZWZhOJ23yOBmG":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpentry)';\nconst difficulty = 'hard';\nconst target = 30;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","JibNjuQrJRnY0yf9":"return this.actor.flags.useless.rEye && this.actor.flags.useless.lEye && ([\"ws\", \"bs\"].includes(args.characteristic) || args.skill?.name?.includes(game.i18n.localize(\"NAME.Ride\")) || args.weapon || args.context.dodge)","JjDzMnUxaWQePIYh":"return args.characteristic != \"int\"","JjiPprLSlSmmB5Ga":"args.item.system.damage.value += \" + 1\"","Jjq3oPYbI26zjxME":"let location = this.item.system.location.key;\n\nif (location)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.notification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}\n\nlet roll = await new Roll(\"1d10\").roll()\n\nroll.toMessage(this.script.getChatData({flavor : `${this.effect.name} (Duration)`}));\n\nthis.effect.updateSource({\"duration.rounds\" : roll.total})","Jk7OHqx06oCUVAzb":"return ![`${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})`, `${game.i18n.localize(\"NAME.Channelling\")} (Hysh)`].includes(args.skill?.name)","JmZQRvdWjm9ykYfn":"if (this.actor.hasCondition(\"surprised\"))\n{\n    this.actor.removeCondition(\"surprised\")\n    this.script.message(`Cannot be Surprised`);\n}","Jnp5c09sPzDD61EK":"this.script.notification(`${args.actor.prototypeToken.name} must pass an <b>Average (+20) Willpower</b> Test to attack this target!`)\n\nreturn true; // No need to show this in the dialog","JstrA46EYSEuRSy5":"if (this.actor.has(game.i18n.localize(\"NAME.Undead\")) && this.actor.has(game.i18n.localize(\"NAME.Construct\")))\n   this.actor.addCondition(\"dead\")","JwYZJGkZMSM2M3Si":"if (args.totalWoundLoss > 0)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\n    await test.roll()\n    if (test.failed)\n    {\n        args.totalWoundLoss += this.effect.sourceActor.system.characteristics.wp.bonus\n        args.modifiers.other.push({label : this.effect.name, value : this.effect.sourceActor.system.characteristics.wp.bonus})\n    }\n}","JwgFQmPQtXWAP94i":"this.actor.addCondition(\"fatigued\");","JyTxUG5dNW670Sf7":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.7mCcI3q7hgWcmbBU\")\nlet data = item.toObject();\ndata.system.location.key= this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n   \nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\")\n}","K06v93N4FXb70mB7":"args.item.system.encumbrance.value = Math.max(0, args.item.system.encumbrance.value - 1);","KD4nCSdSXJVJmk0R":"this.script.message(await this.actor.applyBasicDamage(this.effect.sourceTest.result.damage, {suppressMsg : true}))\nawait this.actor.addCondition(\"ablaze\")","KF69WqF4PSEtpdb2":"args.fields.slBonus += 2;\n        ","KG4TxnXiLLpfWOQO":"args.fields.difficulty = \"average\"","KGK9vL1Yl0qmCeCN":"let specification = this.item.system.specification.value;\nlet choice = [];\n\nif (!specification || specification == \"Trained Skills\")\n{\n    choice = await ItemDialog.create(ItemDialog.objectToArray({\n        broken: \"Broken\",\n        drive: \"Drive\",\n        entertain: \"Entertain\",\n        fetch: \"Fetch\",\n        guard: \"Guard\",\n        home: \"Home\",\n        magic: \"Magic\",\n        mount: \"Mount\",\n        war: \"War\"\n    }, this.effect.img), \"unlimited\", \"Choose Training\");\n}\nelse \n{\n    choice = specification.split(\", \").map(i => {\n        return {\n            id : i.toLowerCase(),\n            name : i\n        }\n    });\n}\n\nif (choice.length)\n{\n    let changes = foundry.utils.deepClone(this.effect.changes);\n\n    for(let training of choice)\n    {\n        switch(training.id)\n        {\n            case \"broken\" : \n                let roll = await new Roll(\"2d10\").roll({allowInteractive : false});   \n                roll.toMessage(this.script.getChatData());\n                changes.push({value : roll.total, mode : 2, key : \"system.characteristics.fel.modifier\"})\n\n                if (this.actor.type == \"creature\")\n                {\n                    let bestial = this.actor.itemTypes.trait.find(i => i.name == \"Bestial\");\n                    if (bestial)\n                    {\n                        bestial.update({\"system.disabled\" : true})\n                    }\n                }\n                break;\n\n            case \"drive\" : \n\n                break;\n\n            case \"entertain\" : \n\n                break;\n\n            case \"fetch\" : \n\n                break;\n\n            case \"guard\" : \n                let territorial = await fromUuid(\"Compendium.wfrp4e-core.items.Item.JIAe7i7dqTQBu4do\");\n                await this.actor.createEmbeddedDocuments(\"Item\", [territorial], {fromEffect: this.effect.id})\n                foundry.utils.setProperty(args, \"options.keepId\", true);\n                break;\n\n            case \"home\" : \n\n                break;\n\n            case \"magic\" : \n\n                break;\n\n            case \"mount\" : \n\n                break;\n\n            case \"war\" : \n                changes.push({value : 10, mode : 2, key : \"system.characteristics.ws.modifier\"})\n                break;\n        }\n    }\n    this.effect.updateSource({name : `${this.effect.name} (${choice.map(i => i.name).join(\", \")})`, changes, \"flags.wfrp4e.trained\" : choice.map(i => i.id)})\n    this.item.updateSource({\"system.specification.value\" : `${choice.map(i => i.name).join(\", \")}`})\n}","KICZPwLvbUSxbDrE":"let table = game.wfrp4e.tables.findTable(\"mutatemental\");\nif (!table)\n{\n\tui.notifications.error(\"Cannot find table with key: mutatemental\")\n}\nlet result = (await table.roll()).results[0];\nlet uuid = `Compendium.${result.documentCollection}.${result.documentId}`\nlet item = await fromUuid(uuid);\n\nif (item)\n{\n    this.script.notification(`${item.name} added`)\n    this.actor.createEmbeddedDocuments(\"Item\", [item])\n}\nelse \n{\n    ui.notifications.error(\"Item could not be found: \" + uuid)\n}","KIoVBinAZK8sMOqD":"\n                            let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"average\"}, skipTargets: true, appendTitle :  \" - Wounded\"})\n                            await test.roll();\n                            if (test.failed)\n                            {\n                                fromUuid(\"Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb\").then(disease => {\n                                    this.actor.createEmbeddedDocuments(\"Item\", [disease.toObject()])\n                                    this.script.notification(\"Gained \" + disease.name)\n                                })\n                            }\n                            ","KJLAan0glJlyOyqF":"    this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 10,\n      \"bright\": 5,\n      \"alpha\": 0.5,\n      \"animation\": {\n          \"speed\": 4,\n          \"intensity\": 4,\n          \"type\": \"flame\",\n      },\n      \"color\": \"#ac9e6c\",\n  }}));","KPQfupKuaf4LCv4R":"const talents = await Promise.all([game.i18n.localize(\"NAME.Schemer\"), game.i18n.localize(\"NAME.SecondSight\")].map(game.wfrp4e.utility.findTalent))\nthis.actor.createEmbeddedDocuments(\"Item\", talents, {fromEffect : this.effect.id})","KQmb5B27eJ1lkbVL":"return this.item.system.quantity.value > 0 && args.type != \"channelling\"","KQzbrpb0T5a7it4k":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.vMYEkrWj0ip6ZOdv\");\nlet data = item.toObject();\ndata.name += ` (Disease)`;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","KSGIwJxR0qn10RLX":"this.actor.itemTags.template.find(t => t.name === \"Hungry Troll\").delete();","KSjsDlsx3DD6cT16":"return args.skill?.name != game.i18n.localize(\"NAME.Bribery\");","KT670CjGBEprx2fO":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.RWJrupj9seau0w31\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","KTBVDHUndI3qDOXM":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"))\nawait test.roll();\nif (!test.succeeded)\n{\n    args.actor.addCondition(\"stunned\")\n}","KUx0deSF3xNzMucL":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Art\"));","KVpDUEjHhd3nLa0f":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.script.message(await game.wfrp4e.tables.formatChatRoll(\"enrage-beast\"))\n}","KVuPduDztyMZQNt9":"args.fields.slBonus += this.actor.system.characteristics.ag.bonus","KXzDe7cN2vynHjJO":"this.actor.hasCondition(\"blinded\")?.delete();\nthis.actor.hasCondition(\"deafened\")?.delete()\nthis.actor.hasCondition(\"unconscious\")?.delete()","KkjkYAGI9Em1NgiQ":"if (this.item.system.quantity.value) \n{\n    this.item.system.reduceQuantity();\n    let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Heal\"), { appendTitle: ` - ${this.effect.name}`, skipTargets: true })\n    await test.roll();\n    if (test.succeeded) \n    {\n        let actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n        actor.applyEffect({ effectData: [this.item.effects.contents[0].convertToApplied()] })\n    }\n    else \n    {\n        this.script.notification(\"Heal Test failed!\", \"error\")\n    }\n}\nelse \n{\n    this.script.notification(\"None left!\", \"error\")\n}","KmngDrPD72xn22kZ":"if (this.actor.Species.toLowerCase() != \"skaven\") {\n    this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - Used ${this.effect.name}`, fields: { difficulty: \"difficult\" } }).then(async test => {\n      await test.roll()\n      if (test.failed) \n      {\n        let toughnessLost = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n        this.actor.update({ \"system.characteristics.t.initial\": this.actor.characteristics.t.initial - toughnessLost })\n        this.script.message(`<b>${this.actor.prototypeToken.name}</b> lost ${toughnessLost} Toughness`)\n      }\n    })\n  }","KnwYZbeRSBA94hfl":"if (!args.flags.lostFingers)\n{\n\targs.flags.lostFingers = true;\n\targs.fields.modifier -= 5 * this.actor.flags.useless[this.item.system.location.key]\n}","KuUkUmOOLf05I4Bp":"this.actor.hasCondition(\"broken\")?.delete();\n","KuuWAhoSzk0rCxxw":"args.fields.modifier += -20;","KxIRA51YA0rktcSP":"return args.characteristic === \"fel\"","KyUPYV1RXJxPOfyA":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"veasy\"}})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"fatigued\");\n}","KyswmGj1uG3QS3ng":"args.applyAP = false;","L1RMLvKtRPFtnczI":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MGEPI4jNhymNIRVz\");\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","L2cdQppcPwxz24hN":"return !args.weapon","L89UcafRHqUfxoux":"let injury = await fromUuid(\"Compendium.wfrp4e-core.items.3S4OYOZLauXctmev\")\ninjury.updateSource({\"system.location.key\" : this.item.system.location.key})\nthis.actor.createEmbeddedDocuments(\"Item\", [injury], {fromEffect: this.effect.id})","L9eAtDyaoHvqryk4":"return args.skill?.name != game.i18n.localize(\"NAME.Intimidate\");","LAyLbcC0lOPwZP3U":"this.actor.addCondition(\"ablaze\", parseInt(this.effect.sourceTest.result.SL))","LHUUXfZVLBhWqRvb":"this.actor.status.addArmour(5, {magical: true, source : this.effect})","LLqAT9wEUGMLfDhU":"return !args.item?.system.isRanged","LOL2TGf8p8KxP14D":"let wind = this.effect.name.split(\" \")[2]\nreturn args.type != \"cast\" || game.wfrp4e.config.magicWind[args.item.system.lore.value] != wind;","LQEWSN5KnHHATPsf":"if (args.totalWoundLoss > 0)\n{\n    this.script.message(`<b>${args.actor.name}</b> must pass an <b>Easy (+40) Endurance</b> Test or gain a @UUID[Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb]{Festering Wound}`, {whisper: ChatMessage.getWhisperRecipients(\"GM\")})\n}","LXEUhHuXe8keEPI9":"let test = await this.actor.setupCharacteristic(\"wp\", {fields: {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n\tlet stuns = Math.max(1, Math.abs(test.result.SL))\n\tthis.actor.addCondition(\"stunned\", stuns)\n}","LeKLtvEDrWh4yHsx":"return args.skill?.name == game.i18n.localize(\"NAME.CharmAnimal\") || args.skill?.name.includes(game.i18n.localize(\"NAME.AnimalTraining\"));","LedRsrVo2f7lm3Ix":"return args.skill?.name == game.i18n.localize(\"NAME.Intimidate\");","Lg1oRg4oNRvucsvi":"return !(args.skill?.name == game.i18n.localize(\"NAME.Climb\") || args.skill?.name == game.i18n.localize(\"NAME.Athletics\"))","LgYyLg0Y2AQ1SKcS":"let amount = this.effect.sourceTest.result.overcast.usage.other.current ?? 0;\n\nargs.fields.successBonus += 2 + amount;","LjXPlgdXBdllnA3i":"return ![\"s\", \"t\"].includes(args.characteristic)","LjfScVGBf0Egr70E":"let animalCare = this.actor.itemTypes.skill.find(s => s.name === game.i18n.localize(\"NAME.AnimalCare\"));\nlet animalTrainings = this.actor.itemTypes.skill.filter(s => s.name.includes(game.i18n.localize(\"NAME.AnimalTraining\")));\n\nif (animalCare) \n  animalCare.system.modifier.value += 20;\n\nfor (let training of animalTrainings) {\n  training.system.modifier.value += 30;\n}","LkPtgN9A36OI6Frh":"return args.skill?.name == game.i18n.localize(\"NAME.Leadership\");","LlRhPGorLl5qJCU8":"if (this.actor.hasCondition(\"prone\")) \n{\n    this.actor.addCondition(\"unconscious\");\n}\nelse \n{\n    this.actor.addCondition(\"prone\");\n}","Lm9IBkc918Duw3US":"let career = this.actor.itemTypes.career.find(c => c.getFlag(\"wfrp4e\", \"doubleLife\"))\n\nif(career)\n{\n    career.system.current.value = true;\n}","Lp261O9fgEXmgPf3":"// If this actor wins a defending test, swap the test\nif (!args.opposedTest.result.swapped && args.opposedTest.result.winner == \"defender\" && args.opposedTest.attackerTest.result.damage)\n{\n    await args.opposedTest.swap(this.effect.name);\n}","Lpv2N9LK9loeumiW":"if (this.actor.uuid != this.effect.sourceActor.uuid)\n{\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Athletics\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty: \"hard\"}, context : {failure : `<strong>${this.effect.name}</strong>: cannot move or take actions`}}).then(test => {\n       test.roll();\n    })\n}","Lrb1S2aK7SFVD0C7":"if (args.totalWoundLoss > 0)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed)\n    {\n        await args.actor.addCondition(\"fatigued\");\n    }\n}","Lu27iXtJVkrJ8bOx":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Stealth\"))","LxdLkPxH3SFvYrCJ":"if (args.effect.conditionId == \"ablaze\")\n{\n     args.data.formula += ` - ${this.actor.system.characteristics.t.bonus}`\n}","LyAK0dVDS5L09yq2":"let caster = this.effect.sourceActor\n\nif (caster)\n{\n    let bonus = caster.system.characteristics.wp.bonus\n    this.actor.modifyWounds(bonus)\n\n    this.script.message(`<strong>${this.actor.prototypeToken.name}</strong> regains ${bonus} Wounds`)\n}","M0XhKnWjG14pk3iH":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\")) && args.type != \"channelling\" && args.skill?.name != game.i18n.localize(\"NAME.Charm\") && !args.skill?.name.includes(`${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})`) && args.type != \"cast\"","M0eOB2Jg9KzcN1gz":"const uuids = [\n  \"Compendium.wfrp4e-core.items.Item.Nj3tC8A5fZ3zEdMR\",     // Holy Visions\n  \"Compendium.wfrp4e-core.items.Item.mNoCuaVbFBflfO6X\",       // Sixth Sense\n];\n\nconst items = await Promise.all(uuids.map(uuid => fromUuid(uuid)));\nawait this.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect: this.effect.id});","M2FshTX4PjKFVU8y":"args.flags.earCount = Number.isNumeric(args.flags.earCount) ? args.flags.earCount+1 : 1;\nif (args.characteristic == \"fel\")\n{\n\targs.fields.modifier -= 5;\n}\nif (args.flags.earCount == 2 && args.skill?.name == game.i18n.localize(\"NAME.Perception\"))\n{\n\targs.fields.modifier -= 20;\n}\n","M5bh0heeafA2fQQ8":"if (args.test.spell?.getFlag(\"wfrp4e\", \"boonOfTzeentch\"))\n{\n    if (args.test.result.minormis || args.test.result.majormis || args.test.result.catastrophicmis)\n    {\n        this.script.message(`<strong>${this.effect.name}</strong> quits your mind in disgust and erases itself from your grimoire!`)\n        this.effect.sourceItem.delete();\n    }\n}","M9VgeYGiUO97ZUW4":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.hCadFsTRvLN9faaY\")\nlet data = item.toObject();\ndata.system.location.value = \"Jaw\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (!test.succeeded)\n{\n\targs.actor.addCondition(\"unconscious\")\n}\n\n","MCK6WyjwYT28lsTN":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.u0CFf3xwiyidD9T5\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","MDLttXplnNthncGr":"return args.type == \"cast\" && [\"death\", \"necromancy\", \"life\", \"light\", \"heavens\"].includes(args.spell?.system.lore.value)","MFKhU9vp8bQpHP3I":"let value = parseInt(this.item.specification.value)\nlet name = this.actor.prototypeToken.name\n\nif (game.user.isGM && game.user.targets.size)\n{\n  game.user.targets.forEach(t => {\n    t.actor.applyTerror(value, name)\n  })\n  game.canvas.tokens.setTargets([])\n}\nelse \n{\n  game.wfrp4e.utility.postTerror(value, name)\n}","MI2GgNi3fZtUCtQD":"return [\"int\", \"wp\"].includes(args.characteristic)","MIhYSuJ6MI9B65UT":"let specification = Number(this.item.specification.value) || 1;\nargs.actor.system.status.wounds.max += Math.floor(args.actor.system.status.wounds.max * 0.3 * specification);\nargs.actor.system.status.carries.max -= Math.floor(args.actor.system.status.carries.max * 0.1 * specification);\nargs.actor.system.details.price.gc += Math.floor(args.actor.system.details.price.gc * 0.2 * specification);","MJB6WbZSF6Briz30":"return args.item?.name == game.i18n.localize(\"NAME.Leadership\")","MKxYbHOrv0UuA7JB":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"average\"}, appendTitle : \" - Wounded\"})\n                            await test.roll();\n                            if (test.failed)\n                            {\n                                fromUuid(\"Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb\").then(disease => {\n                                    this.actor.createEmbeddedDocuments(\"Item\", [disease.toObject()])\n                                    this.script.scriptNotification(\"Gained \" + disease.name)\n                                })\n                            }","MMv2B8TH7jxNCtdl":"let actor = this.actor;\n                            let effect = this.effect;\n                            let bleedingAmt;\n                            let bleedingRoll;\n                            let msg = \"\"\n\n                            let damage = effect.conditionValue;\n                            let scriptArgs = {msg, damage};\n                            await Promise.all(actor.runScripts(\"preApplyCondition\", {effect, data : scriptArgs}))\n                            msg = scriptArgs.msg;\n                            damage = scriptArgs.damage;\n                            msg += await actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, minimumOne : false, suppressMsg : true})\n\n                            if (actor.status.wounds.value == 0 && !actor.hasCondition(\"unconscious\"))\n                            {\n                                await actor.addCondition(\"unconscious\")\n                                msg += \"<br>\" + game.i18n.format(\"BleedUnc\", {name: actor.prototypeToken.name })\n                            }\n\n                            if (actor.hasCondition(\"unconscious\"))\n                            {\n                                bleedingAmt = effect.conditionValue;\n                                bleedingRoll = (await new Roll(\"1d100\").roll()).total;\n                                if (bleedingRoll <= bleedingAmt * 10)\n                                {\n                                    msg += \"<br>\" + game.i18n.format(\"BleedFail\", {name: actor.prototypeToken.name}) + \" (\" + game.i18n.localize(\"Rolled\") + \" \" + bleedingRoll + \")\";\n                                    await actor.addCondition(\"dead\")\n                                }\n                                else if (bleedingRoll % 11 == 0)\n                                {\n                                    msg += \"<br>\" + game.i18n.format(\"BleedCrit\", { name: actor.prototypeToken.name } ) + \" (\" + game.i18n.localize(\"Rolled\") + bleedingRoll + \")\"\n                                    await actor.removeCondition(\"bleeding\")\n                                }\n                                else\n                                {\n                                    msg += \"<br>\" + game.i18n.localize(\"BleedRoll\") + \": \" + bleedingRoll;\n                                }\n                            }\n\n                            await Promise.all(actor.runScripts(\"applyCondition\", {effect, data : {bleedingRoll}}))\n                            if (args.suppressMessage)\n                            {\n                                let messageData = game.wfrp4e.utility.chatDataSetup(msg);\n                                messageData.speaker = {alias: this.effect.name}\n                                messageData.flavor = this.effect.name;\n                                return messageData\n                            }\n                            else\n                            {\n                                return this.script.message(msg)\n                            }\n                            ","MMx8f5uJ15XOgJGg":"return args.skill?.name !== game.i18n.localize(\"NAME.Row\") && args.skill?.name !== game.i18n.localize(\"NAME.Swim\") && !args.skill?.name.includes(game.i18n.localize(\"NAME.Sail\"));","MOZn375tGD2060cC":"const diff = foundry.utils.diffObject(this.item.toObject(), args.data);\nif (args.data?.system?.APdamage?.head > this.item.system.APdamage.head) {\n  const result = await game.wfrp4e.tables.rollTable('armet-damage');\n  this.script.message(result.result);\n  if (result.total > 5) \n    delete args.data.system.APdamage.head;\n}","MSJWJEUrX7ZmMvAD":"return !(args.skill?.name.includes(game.i18n.localize(\"NAME.Ranged\")) || args.item?.isRanged || args.item?.name == game.i18n.localize(\"NAME.Charm\"))","McLR9YcgVUG3MooC":"args.applyTB = false;","Me1wS5XdqUEy7OGt":"let loc = (await game.wfrp4e.tables.rollTable(\"hitloc\")).result;\nlet critTable = `crit${this.generalizeTable(loc)`;\nlet crit = (await game.wfrp4e.tables.rollTable(critTable)).result;\n\nthis.script.message(`{this.actor.name} suffers a ${crit} (location : ${loc}). Do not apply bleeding or any additonnal wounds.`);","MfxWXZwaZUjGSBqw":"if (this.actor.hasCondition(\"ablaze\"))\n{\n    this.script.notification(\"Immune to Ablaze\")\n    await this.actor.hasCondition(\"ablaze\")?.delete()\n}","MfxzwJz2o9ho2hOM":"return args.skill?.name == \"Lore (Apothecary)\"","MgMMoC4Umpg7fmNI":"// Apply changes when the mask is worn\n\nif (args.equipped) {  \n  this.actor.createEmbeddedDocuments(\"ActiveEffect\", [this.item.effects.contents[1]?.convertToApplied()])  \n  this.script.message(`${this.actor.name} dons the <strong>${this.item.name}</strong>. <br>\n      They cannot cast Spells or pray for Blessings and Miracles.<br>\n      If they wear the mask for more than an hour or benefit from any of its effects, they are exposed to @Corruption[moderate]{Moderate Corruption}. \n      `,\n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n}\n\n// Notify of lingering effects when mask is removed\nelse if (!args.equipped)\n{\n    await this.item.effects.contents[0].delete();\n    await this.item.update({name : this.item.name += \" (Used)\"})\n    this.script.message(`<strong>${this.item.name}</strong> on ${this.actor.name} has been taken off and loses its properties. However, the effects last for [[1d10+4]] days, after which they should be manually removed.`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n    )\n    \n}\n\n\n\n","MgTqCMRjxhezT73T":"return args.fields.hitLocation == \"head\" && args.weapon?.system.properties.qualities.pummel","MgZreqq3Jua10c8s":"return ![\"ws\", \"bs\", \"s\", \"fel\", \"ag\", \"t\", \"dex\"].includes(args.characteristic)","Mhb67xufvA9uWO21":"let actorSize = game.wfrp4e.config.actorSizeNums[args.actor.details.size.value]\nlet attackerSize = game.wfrp4e.config.actorSizeNums[args.attacker.details.size.value]\n\nif (attackerSize > actorSize)\n{\n   args.actor.addCondition(\"prone\")\n   this.script.message(`<strong>Tail Attack</strong>: ${args.actor.prototypeToken.name} is now <strong>Prone</strong>`)\n}","Mir4FMHQRdVqazAF":"let actorSize = game.wfrp4e.config.actorSizeNums[args.actor.details.size.value]\nlet attackerSize = game.wfrp4e.config.actorSizeNums[args.attacker.details.size.value]\n\nif (attackerSize > actorSize)\n{\n   let msg = `<b>Tongue Attack</b>: ${args.actor.prototypeToken.name} is now @Condition[Entangled]`;\n   await args.actor.addCondition(\"entangled\");\n   if (actorSize <= 2)\n   {\n       msg += `and @Condition[Engaged]`\n   }\n   this.script.message(msg, {speaker : {alias: args.attacker.prototypeToken.name}})\n}","MkEcdViivk7abf1x":"args.actor.flags.meleeDamageIncrease += 1","MnXny8SCh6OceJc9":"return args.characteristic == \"int\"","MnqQkXVp20Lw84I1":"let test = await this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"difficult\"}})\nawait test.roll();\nif (test.failed)\n{\n    this.script.message(await this.actor.applyBasicDamage(3, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true}))\n}","Mp8UjuCLa9jdzhBS":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\nif (test.failed)\n{\n    if (!this.actor.hasCondition(\"fatigued\"))\n    {\n        await this.actor.addCondition(\"fatigued\");\n    }\n    else\n    {\n        await this.actor.addCondition(\"blinded\");\n        await this.actor.addCondition(\"deafened\");\n    }\n    \n    if (((this.actor.hasCondition(\"blinded\").conditionValue || 0) + (this.actor.hasCondition(\"deafened\").conditionValue || 0)) > this.actor.system.characteristics.i.bonus)\n    {\n        await this.actor.addCondition(\"unconscious\");        \n    }\n}","Msygc7oQQPB5fw0b":"let test = this.effect.sourceTest;\nif (test.failed && (test.result.roll % 11 == 0 || test.result.roll == 100))\n{\n\tlet points = await new Roll(\"1d10\").roll({allowInteractive : false});\n\tgame.dice3d?.showForRoll(points)\n\tthis.actor.update({\"system.status.corruption.value\" : this.actor.system.status.corruption.value + points.total})\n\tthis.script.message(`Gains ${points.total} Corruption`)\n}\nelse \n{\n\tlet points = this.effect.sourceTest.result.overcast.usage.other.current;\n\tthis.actor.update({\"system.status.corruption.value\" : this.actor.system.status.corruption.value - points})\n\tthis.script.message(`Loses ${points} Corruption`)\n}","MwUzyAgd0yPnmZCH":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.klCJX0mNpXYH5AIx\")\nlet data = item.toObject();   \ndata.name = data.name.replace(\"Target\", \"Strangers\");\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});","Myl1Ishu9GBraYUZ":"this.actor.removeCondition(\"bleeding\")","N2MeOlf0GjPiRcSb":"let test = await this.actor.setupCharacteristic(\"dex\", {context : {failure : \"Drops the item\"}})\nawait test.roll();","N7nGncsPrTz2ZbDA":"return !args.context.dodge || !this.actor.isMounted","N8hA6ysHCTlLd8Kj":"let characteristics = {\n    \"ws\" : 0,\n    \"bs\" : 0,\n    \"s\" : 0,\n    \"t\" : 5,\n    \"i\" : 15,\n    \"ag\" : 0,\n    \"dex\" : 10,\n    \"int\" : 15,\n    \"wp\" : 15,\n    \"fel\" : 0\n}\nlet skills = [\"Channelling\", \"Cool\", \"Dodge\", \"Entertain (Storytelling)\", \"Intuition\", \"Language (Magick)\", \"Lore (Magic)\", \"Perception\"]\nlet skillAdvancements = [5, 15, 10, 10, 15, 10, 10, 20]\nlet talents = [\"Arcane Magic\", \"Petty Magic\", \"Second Sight\"]\nlet trappings = [\"Hand Weapon\", \"Quarterstaff\", \"Ritual Dress incorporating many ingredients and fetishes\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        items.push({name : trapping, type : \"trapping\", \"system.trappingType.value\" : \"clothingAccessories\"})\n        //ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","N9kA46ZQ9LiRjy6T":"return args.skill?.name == game.i18n.localize(\"NAME.Haggle\") || args.skill?.name == game.i18n.localize(\"NAME.Gossip\");","NDvNGATDM2xPFJK0":"brokenbone = await fromUuid(\"Compendium.wfrp4e-core.items.hCadFsTRvLN9faaY\")\nteeth = await fromUuid(\"Compendium.wfrp4e-core.items.fBcZhOBn8IpoVqQ1\")\ntongue = await fromUuid(\"Compendium.wfrp4e-core.items.rkJA1DlK51QuRlJy\")\nbrokenbone = brokenbone.toObject();\nteeth = teeth.toObject();\ntongue = tongue.toObject();\n\n\nlet roll = await new Roll(\"1d10\").roll({allowInteractive : false});\nroll.toMessage(this.script.getChatData({flavor : \"Teeth Lost\"}))\n\nteeth.system.location.value = `${roll.total} ${teeth.system.location.value}`\nbrokenbone.system.location.value = \"Jaw\"\nthis.actor.createEmbeddedDocuments(\"Item\", [brokenbone, teeth, tongue])\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"vhard\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"unconscious\")\n}","NEKLTgJJsayC7tpF":"return [\"ws\", \"ag\"].includes(args.characteristic);","NI3ZzIAlpQfVSjvf":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create({text : \"Enter Fear value\", title : this.effect.name});\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","NMZ3Fb164tUfwChF":"return !args.data.targets[0]?.actor?.hasCondition(\"entangled\")","NNytXz5XFPrEF6dw":"if (args.opposedTest.result.hitloc.value == this.item.system.location.key && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 1);\n}\n    ","NQSvFWhmBQAyx5Zz":"return args.item?.isRanged","NTFpkiGyBpOtrV0s":"if (this.actor.uuid == this.effect.sourceActor.uuid)\n{\n\treturn;\n}\n\nif (this.actor.has(\"Cold Blooded\") && !this.actor.hasSystemEffect(\"nausea\")) { \n  let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {appendTitle : `- ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n\n  let myRoll = await new Roll(\"1d10\").roll({allowInteractive : false});\n  let duration = myRoll.total\n  this.actor.addSystemEffect(\"nausea\");\n  this.script.scriptMessage(`Nausea symptom added, duration : ${duration} hours`);\n}\n}\nreturn false;","NX9fApO15NQuTipW":"return [\"ws\", \"bs\"].includes(args.characteristic)","Na7Nanl9YmxZlTo7":"return args.type != \"cast\" && args.type != \"channelling\"","NdquQqyuOkGCj8Uo":"let darkvision = await fromUuid(\"Compendium.wfrp4e-core.items.Item.JQa5DLnTs2SEzRrc\")\nlet fear = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet acutesense = await fromUuid(\"Compendium.wfrp4e-core.items.Item.9h82z72XGo9tfgQS\")\nfear = fear.toObject();\nfear.system.specification.value = 1;\nacutesense = acutesense.toObject();\nacutesense.name += \" (Smell)\";\nthis.actor.createEmbeddedDocuments(\"Item\", [darkvision, fear, acutesense], {fromEffect : this.effect.id})","Nk6qAalTmc6UI2XQ":"const message = game.messages.get(args.options.message);\nconst sl = message.system.sl;\nthis.effect.setFlag(\"wfrp4e-archives3\", \"sl\", sl);","NkqtQaLEGYst0PUO":"if (this.actor.has(game.i18n.localize(\"NAME.MagicResistanceTalent\"), \"talent\")) \n    return\n\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.eowbsW6oHGSNJmxV\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","NnA4zpuO6iUXKhH7":"if ((args.opposedTest.attackerTest.item && args.opposedTest.attackerTest.item.isMelee) || (args.opposedTest.attackerTest.item && !args.opposedTest.attackerTest.item.name.includes(game.i18n.localize(\"NAME.Ranged\"))))\n{\n    let AP = parseInt(this.effect.sourceTest.result.SL)\n    args.modifiers.ap.value += AP;\n    args.modifiers.ap.magical += AP;\n    args.modifiers.ap.details.push(`${this.effect.name} (${AP})`)\n}","NnDq4miIPNEtZUWb":"args.test.result.critModifier = args.test.result.critModifier || 0;\nargs.test.result.critModifier += 20;\n\nif (args.test.result.critical)\n{\n    args.test.result.critical = `${game.i18n.localize(\"Critical\")} (+${args.test.result.critModifier})`\n}","Np25JqEiaoqerEk8":"if (test.result.tables.miscast) {\n  test.result.other.push(`<b>${this.effect.name}:</b> You may reroll any result from the @Table[waaagh-miscast]{Waaagh! Miscast Table}.`);\n}","Np8P8IPT2GYlrh6G":"return args.skill?.name !== `${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})` && args.type !== \"channelling\";","NrVFrIXM8GnIbojv":"args.item.system.damage.value += `+ ${this.actor.system.characteristics.fel.bonus}`;","O45vpR4jDbQQnmvJ":"let items = [];\n\nlet etiquette = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.sYbgpSnRqSZWgwFP\")).toObject();\netiquette.name += \" (Followers of Khorne)\";\n\nitems.push(etiquette);\n\nlet animosity = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.Q2MCUrG2HppMcvN0\")).toObject();\nanimosity.name = animosity.name.replace(\"(Target)\", \"(Followers of Slaanesh)\");\n\nitems.push(animosity);\n\nawait this.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect : this.effect.id});\n","O7lXFZLrLdFaShGR":"args.context.catfall = true;","O9fc0hLHdkTgSuLg":"let bite = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet venom = await fromUuid(\"Compendium.wfrp4e-core.items.gFkRm9wS65qe18Xv\")\nlet biteData = bite.toObject();\nlet venomData = venom.toObject();\n\nbiteData.system.specification.value = 3 - this.actor.characteristics.s.bonus;\nvenomData.system.specification.value = \"Average\"\nthis.actor.createEmbeddedDocuments(\"Item\", [biteData, venomData], {fromEffect : this.effect.id})","OBF6r2CsMOEokAsS":"args.weaponProperties.damaging = true;\nargs.weaponProperties.impale = true;","OCFrGXAYfo9OYnhc":"return args.item?.system.magicMissile?.value || args.item?.system.attackType","OEy2lxvic37dRBEt":"let filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = await ItemDialog.createFromFilters(filters, 3, {text : \"Choose 3 Petty Spells\"})\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"\"\n    }\n]\n\nlet arcane = await ItemDialog.createFromFilters(filters, 3, {text : \"Choose 3 Arcane Spells\"})\n\nlet items = petty.concat(arcane).map(i => i.toObject())\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","OFViRemr1cpnO3af":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"difficult\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\nif (!test.succeeded)\n{\n    await this.actor.addCondition(\"bleeding\");\n}","OGX4BneaYAnV25TO":"let chatData = { whisper: ChatMessage.getWhisperRecipients(\"GM\") }\nlet message = \"\"\n\nlet wounds = foundry.utils.duplicate(this.actor.status.wounds)\nlet regenRoll = await new Roll(\"1d10\").roll({allowInteractive : false});\nlet regen = regenRoll.total;\n\nif (wounds.value >= wounds.max)\n    return\n\nif (wounds.value > 0) \n{\n    wounds.value += regen\n    if (wounds.value > wounds.max)\n    {\n        wounds.value = wounds.max\n    }\n    message += `<b>${this.actor.name}</b> regains ${regen} Wounds.`\n\n    if (regen == 10)\n    {\n        message += `<br>Additionally, they regenerate a Critical Wound.`\n    }\n}\nelse if (regen >= 8) \n{\n    message += `<b>${this.actor.name}</b> rolled a ${regen} and regains 1 Wound.`\n    wounds.value += 1\n    if (regen == 10)\n    {\n        message += `<br>Additionally, they regenerate a Critical Wound.`\n    }\n}\nelse \n{\n    message += `<b>${this.actor.name}</b> Regenerate roll of ${regen} - No effect.`\n}\n\nawait this.actor.update({ \"system.status.wounds\": wounds })\nthis.script.message(message, { whisper: ChatMessage.getWhisperRecipients(\"GM\") })","OJMgS8ZQv0j4tEFf":"return [\"ws\", \"bs\", \"s\", \"fel\", \"ag\", \"t\", \"dex\"].includes(args.characteristic)","OMAUX1fnHyIpplul":"return ![\"fel\", \"dex\"].includes(args.characteristic)","OXoqtpOdfkURZbuL":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.yRhhOlt18COq4e1q\")\nlet data = item.toObject()\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","OYLqLl6vikJD8flg":"const crowd = this.effect.getFlag(\"wfrp4e\", \"crowd\") ?? 0;\nconst bonus = 2 + Math.floor(crowd * 0.1);\n\nargs.fields.slBonus += bonus ;","Oa9FmLXRRZRpLrrq":"let test = await this.actor.setupTrait(this.item); \nawait test.roll();","OcQe0zfksf1DCJYe":"args.actor.system.characteristics.s.value += 30\nargs.actor.system.characteristics.t.value += 30\n\nargs.actor.system.characteristics.s.bonus += 3\nargs.actor.system.characteristics.t.bonus += 3\n\nif (args.actor.system.characteristics.s.value > 100)\n{\n   args.actor.system.characteristics.s.value = 100\n   args.actor.system.characteristics.s.bonus = 10\n}\n\nif (args.actor.system.characteristics.t.value > 100)\n{\n   args.actor.system.characteristics.t.value = 100\nargs.actor.system.characteristics.t.bonus = 10\n}","OeCgX3hIsfLfmGvC":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Perception\"))\nawait test.roll();\nif (test.succeeded)\n{\n    this.actor.removeCondition(\"surprised\");\n}","OeKeQAAcJhdI4Qky":"if (this.actor.hasCondition(\"stunned\") || this.actor.hasCondition(\"unconscious\"))\n{\n\tthis.script.notification(\"Disabled!\");\n\tawait this.effect.update({\"disabled\" : true})\n}","Ofn6vDbP3fZ4UlSc":"args.fields.modifier += -20;\n        ","OgSI0Z6SHjYuqKIz":"let blows = this.item.getFlag(\"wfrp4e\", \"blows\") || 0\nlet difficulties = Object.keys(game.wfrp4e.config.difficultyLabels)\n\nblows = Math.clamp(blows, 0, difficulties.length - 1)\nif (this.item.system.protects[args.opposedTest.result.hitloc.value])\n{\n    let difficulty = difficulties[blows];\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields: {difficulty}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test => {\n        await test.roll();\n        if (test.failed)\n        {\n            this.script.message(`${this.actor.name} must break from combat and flee until they pass a <strong>Challenging (+0) Willpower</strong> Test`);\n            this.item.setFlag(\"wfrp4e\", \"failedCool\", true);\n        }\n    })\n}","OicQSEVZBbqLtrcf":"let choice = await ItemDialog.create(this.actor.itemTypes.critical, (this.effect.sourceTest.result.overcast.usage.other.current || 1), \"Choose the Critical Wounds to heal (cannot reattach body parts)\")\n\nthis.script.message(`Healed <strong>${choice.map(i => i.name).join(`, `)}</strong>`);\nthis.actor.deleteEmbeddedDocuments(\"Item\", choice.map(i => i.id))","OnkEe4ISru1hjJWP":"this.actor.flags.useless[this.item.system.location.key] = true;","Op88kMtimSEWlY2h":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[1].convertToApplied()]})\n}\nelse\n{\n\tthis.script.notification(\"None left!\", \"error\")\n}","OqLKL0PiCvYH2QxW":"if (args.test.options.wallcrawler)\n{\n\tif (parseInt(args.test.result.SL) < 0 || args.test.failed)\n\t{\n\t\tif (parseInt(args.test.result.SL) < 0)\n\t\t{\n\t\t\targs.test.result.SL = \"+0\";\n\t\t\targs.test.result.description = game.i18n.localize(\"ROLL.MarginalSuccess\");\n\t\t}\n\t\targs.test.result.outcome = \"success\"\n        args.test.result.other.push(`<strong>${this.effect.name}</strong>: Minimum +0 SL`)\n\t}\n}","OqxeuZfZDfm9ax6h":"this.actor.system.status.addArmour(1, {locations : \"head\", source : this.effect})","OsLXutfXyQCAkhAf":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Sail';\nconst difficulty = 'average';\nconst target = 30;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      \n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","OvIELZLvnlN2H2uw":"args.update({light : {\n    \"dim\": 2,\n    \"bright\": 1,\n    \"alpha\": 0.5,\n    \"animation\": {\n        \"speed\": 4,\n        \"intensity\": 4,\n        \"type\": \"pulse\",\n    },\n    \"color\": \"#949bff\",\n}});","OxsBnnVI3Smpknpb":"if (this.actor.status.advantage.value && !this.actor.sameSideAs(this.effect.sourceActor))\n{\n    this.actor.modifyAdvantage(-1);\n    this.script.notification(`${this.actor.name} loses 1 Advantage`);\n}","Oz7pWF9mEc1pQypj":"let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\nroll.toMessage({flavor : this.effect.name, speaker : {alias : this.actor.prototypeToken.name}})\nthis.actor.addCondition(\"stunned\", roll.total)","P29tT1eMMdAw3CPF":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.3S4OYOZLauXctmev\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"hard\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n\tthis.actor.addCondition(\"unconscious\")\n}","PBW6IZtwawNHxB6y":"return args.context.dodge && this.actor.isMounted","PI1QNaKFeqood6d7":"if (args.attackerTest.weapon && args.defenderTest.weapon)\n{\n\n   let attackerReach = game.wfrp4e.config.reachNum[args.attackerTest.weapon.reach.value]\n   let defenderReach = game.wfrp4e.config.reachNum[args.defenderTest.weapon.reach.value]\n   \n   if (attackerReach == defenderReach)\n      attackerReach = attackerReach < 7 ? attackerReach + 1 : attackerReach\n\n   attackerReach = warhammer.utility.findKey(attackerReach, game.wfrp4e.config.reachNum)\n   defenderReach = warhammer.utility.findKey(defenderReach, game.wfrp4e.config.reachNum)\n\n  args.attackerTest.weapon.reach.value = attackerReach\n  args.defenderTest.weapon.reach.value = defenderReach\n}","PMISUsaEDBA7D3od":"// After consumption, the user gains the Magic Resistance 3 Creature Trait, \n// reducing the SL of any spell affecting it by 3. \n// This effect lasts for one hour.\nconst hasMagicResistance = this.actor.has(\"Magic Resistance\")\n\nif (hasMagicResistance === undefined) {\n  fromUuid(\"Compendium.wfrp4e-core.items.yrkI7ATjqLPDTFmZ\").then(trait => {\n    let traitItem = trait.toObject()\n    traitItem.system.specification.value = 2\n    this.actor.createEmbeddedDocuments(\"Item\", [traitItem], {fromEffect: this.effect.id})\n  })\n  this.script.message(`<p><strong>${this.actor.prototypeToken.name}</strong> has gained the Magic Resistance Trait. This effect lasts for one hour.</p>`, {whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })   \n}\n\nif (hasMagicResistance) {\n  // Multiple doses may be consumed at once, with each one adding an additional 1 to the Magic Resistance rating and increasing the duration by one hour.  \n  let msg = `<p><strong>${this.actor.prototypeToken.name}</strong> has enhanced their Magic Resistance by 1 to Rating ${parseInt(hasMagicResistance.system.specification.value)}. This effect lasts for one hour.</p>`\n\n  // Resist toxic effect\n  this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {\n    fields: {difficulty: \"challenging\"}\n  }).then(async test => {\n    await test.roll()\n\n    // If they fail ...\n    if (!test.succeeded) {\n      msg += `<p>However, they begin to ooze the thick, poisonous slime that coats every Dreadmaw.  They have gained 1 Poisoned Condition now and should continue to receive an additional @Condition[Poisoned] Condition at the end of each of the round.</p>\n      <p>If they are still alive at the end of 10 rounds, the effect ends and all Poisoned Conditions gained from ${this.effect.name} are removed.</p>`\n      this.actor.addCondition(\"poisoned\", 1)\n    }\n    this.script.message(msg, {whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })\n  })\n}\n","PMNjdEAusVBfam09":"return args.skill?.name === game.i18n.localize(\"NAME.Charm\");","PVjaKAHTKDA0rA9J":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();","PdClojv7yNgQpOUc":"return args.skill?.name != game.i18n.localize(\"NAME.Endurance\");","PeZYj8b0vedyJj00":"// This script needs to be separate because equipTransfer is off on the other effect, and thus won't execute when added to an actor\n\nlet mainEffect = this.item.effects.contents[0];\nif (mainEffect.name.includes(\"(Lore)\"))\n{\n    let choice = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.magicLores, this.item.img), 1, \"Choose Lore\");\n    if (choice.length)\n    {\n        mainEffect.update({name : mainEffect.name.replace(\"Lore\", choice[0].name)})\n        this.item.update({name : this.item.name += ` (${choice[0].name})`})\n    }\n}\n\nthis.effect.delete();","Pg9C6nJX5QHIdqa9":"return !args.item?.system.attackType\n","Ph3TdQw1lGiFr049":"    if (!args.test.context.phantasmal && \n      (this.actor.isOpposing || args.test.context.defending) && \n      args.test.result.roll % 11 == 0 && \n      args.test.succeeded && \n      [\"Language (Magick)\", \"Dodge\"].includes(args.test.item?.name))\n    {\n         args.test.context.phantasmal = true; // Flag so items aren't readded if test is edited\n         let text = `<strong>${this.effect.name}</strong>: Adding Unstable and  Ward`\n         args.test.result.other.push(text)  \n        this.script.notification(text);\n     \n        let ward = await fromUuid(\"Compendium.wfrp4e-core.items.Bvd2aZ0gQUXHfCTh\")\n        let wardData = ward.toObject();\n        wardData.system.specification.value = 9;\n        \n        let unstable = await fromUuid(\"Compendium.wfrp4e-core.items.D0ImWEIMSDgElsnl\")\n        let unstableData = unstable.toObject();\n        this.actor.createEmbeddedDocuments(\"Item\", [wardData, unstableData], {fromEffect: this.effect.id})\n    }\n","PjOi61gB2nSYooLs":"return this.sourceActor.uuid === this.actor.uuid || !args.item?.system?.isRanged;","PjRxGuUDKGmSmVDc":"fromUuid(\"Compendium.wfrp4e-core.items.EO05HX7jql0g605A\").then(item => {\n   item = item.toObject()\n   item.system.specification.value = this.actor.characteristics.ag.value\n   this.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})\n})","PmELrzD3RmF9qKkO":"if (this.item.system.specification.value == \"Size\")\n{\n    let size = this.item.specifier;\n    if (!size)\n    {\n        let choice = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.actorSizes, this.item.img), 1, \"Choose Size\");\n        if (choice[0])\n        {\n            size = choice[0]?.name;\n        }\n    }\n    this.item.updateSource({\"system.specification.value\" : size, name : this.item.baseName})\n    this.effect.updateSource({name : this.effect.name + ` (${size})`})\n}","Pn5fekTbkwlr61XU":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Engineer)';\nconst difficulty = 'easy';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      \n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","PoNnT5EqvLj2r5yf":"return args.skill?.name != game.i18n.localize(\"NAME.OutdoorSurvival\") && args.skill?.name != game.i18n.localize(\"NAME.Track\");","PsO7aTdELJt35eHP":"let morale = await new Roll(\"-1d10\").roll({allowInteractive : false});\nlet mood = await new Roll(\"-2d10\").roll({allowInteractive : false});\n\nmorale.toMessage(this.script.getChatData({flavor : \"Morale\"}));\nmood.toMessage(this.script.getChatData({flavor : \"Manann's Mood\"}));\n\nawait this.actor.system.status.morale.addEntry(\"Albatross Died\", morale.total)\nawait this.actor.system.status.mood.addEntry(\"Albatross Died\", mood.total);\n\nthis.effect.delete();","PwqTmw7rsG8hzqCS":"if (args.test.result.critical && args.test.result.roll % 10 == 0) \n{\n    game.wfrp4e.tables.findTable(\"knuckleduster-diseases\").roll().then(roll => {\n      let results = roll.results[0]\n\n      this.script.message(`<strong>${this.actor.name}</strong> contracts @UUID[Compendium.${results.documentCollection}.${results.documentId}]{${results.text}}`, {blind : true, whisper: ChatMessage.getWhisperRecipients(\"GM\") })\n    })\n\n  }\n\n","Q1trEhtqjIiDvFPF":"args.prefillModifiers.modifier -= 10 * this.effect.system.condition.value","Q4EQgP4gZR8TTm7S":"let penalty = 0\nif (args.item?.system.attackType)\n{\n   penalty -= 30\n}\nif (args.actor.has(game.i18n.localize(\"NAME.SecondSight\"), \"talent\"))\n    penalty += 10\n\nargs.prefillModifiers.modifier += penalty","Q5gh5Y9dCdclcwsD":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\")) && args.skill?.name != `${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})`","Q68WiUWY7GxiXBbT":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9GNpAqgsKzxZKJpp\")\nlet data = item.toObject();\ndata.system.specification.value = \"When Alone\";\ndata.effects[0].disabled = true;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","Q7eULXQ9AfDRmUGO":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'difficult';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      \n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","Q9EmlWmuDac83cJw":"return args.skill?.name == game.i18n.localize(\"NAME.Climb\")  || args.skill?.name?.includes(game.i18n.localize(\"NAME.Stealth\"));","QBBrzcSAe8QqE4WP":"const SL = this.effect.sourceTest.result.SL;\nconst damage = 8 + SL;\n\nawait this.actor.applyBasicDamage(damage, {loc: \"roll\"});\n\nconst test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {\n  skipTargets: true,\n  appendTitle: ` - ${this.effect.name}`,\n  fields: {difficulty: \"challenging\"},\n  context: {\n    failure: `Receives @Condition[Ablaze] Condition.`\n  }\n})\n\nawait test.roll();\nif (test.failed) {\n  await this.actor.addCondition(\"ablaze\");\n}","QF8LanKNoAlTkQG0":"this.actor.system.status.encumbrance.max += 2","QHQ7XmFOjT9wXgw1":"if (args.actorsystem.details.move.oars.value > 0)\n  args.actor.system.details.move.oars.value -= 1;\n\nargs.actor.system.details.man -= 2;","QKTA2TqZ77pvHWSJ":"    this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 0,\n      \"bright\": 0,\n      \"alpha\": 0.5,\n      \"animation\": {\n          \"type\": \"\",\n      },\n      \"color\": \"#000000\",\n  }}));","QKjR6P1WEHXf4K77":"args.fields.slBonus -= 2\n","QLBxcP85duX1Z7LX":"if (!args.item.actor?.has(\"Bless (Taal)\", \"talent\")) return;\n\nargs.item.system.AP.head = 3;","QLUaOkwuSPvBp7jU":"this.script.scriptNotification(\"Cannot attack targets that are not Entangled\")\nargs.abort = true;","QNxmImpLTou6WdMQ":"let test = args.test\nif (test.result.minormis || test.result.majormis || test.result.catastrophicmis)\n         test.result.other.push(\"Can make a <b>Difficult (-10) Willpower</b> Test to prevent the Miscast\")","QPVVDPcJ4Xi5FmQl":"if(this.actor.hasCondition(\"fatigued\") && args.opposedTest.result.hitloc.value == \"head\" && (args.opposedTest.attackerTest.result.critical || args.actor.status.wounds.value - args.totalWoundLoss < 0))\n{\n    let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), { fields: { difficulty: \"average\" }, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed)\n    {\n        this.actor.addCondition(\"unconscious\")\n    }\n}","QQ2gHThZHdO4yLLX":"return args.skill?.name == game.i18n.localize(\"NAME.Swim\");","QQPiREc50HT5W2Tr":"if (args.item.type == \"weapon\" && args.item.weaponGroup.value == \"brawling\")\n    args.item.damage.value += \" + 1\"","QRSACifDrvojIXHB":"if (!this.actor.effects.find(e => e.isCondition))\n{\n\treturn this.script.notification(\"No Conditions on this Actor\")\n}\n\nlet choice = await ItemDialog.create(this.actor.effects.filter(i => i.isCondition), 1, \"Choose a Condition\")\n\nif (choice[0])\n{\n\tthis.actor.removeCondition(choice[0].conditionId)\n}\n","QaEUhlvxFPzowH0v":"args.actor.characteristics.ag.modifier -= 10;\n\n                            if (args.actor.details.move.value > 3)\n                            {\n                                args.actor.details.move.value -= 1;\n                                if (args.actor.details.move.value < 3)\n                                    args.actor.details.move.value = 3\n                            }","QaGNsqKm2Nf0zGVm":"return [\"t\", \"int\", \"wp\", \"fel\"].includes(args.characteristic)","QbIYnshWeP1U8SUy":"args.applyAP = false;\nargs.applyTB = false;","QfTBRGXVfwQSghmd":"fromUuid(this.effect.origin).then(caster => {\n   if (caster) {\n      if (actor.items.find(it => it.name == game.i18n.localize(\"Bestial\"))) {\n         let healed = caster.characteristics.wp.bonus\n         let wounds = foundry.utils.duplicate(args.actor.status.wounds)\n         wounds.value += healed\n\n         if (wounds.value > wounds.max)\n            wounds.value = wounds.max\n\n         args.actor.update({ \"system.status.wounds\": wounds })\n         ChatMessage.create({ content: `${this.actor.prototypeToken.name} regains ${healed} Wounds`, speaker: { alias: this.effect.name } })\n      } else {\n         ui.notifications.warn(\"Target actor has no Bestial trait\")\n      }\n   }\n})\n\n","Qgn92fZyc3Psn8QJ":"if (args.test.options.useOnesAttractive && (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target)) {\n\n   let SL = Math.floor(args.test.target / 10) - Math.floor(args.test.result.roll / 10)\n   let ones = Number(args.test.result.roll.toString().split(\"\").pop())\n\n   if (ones == 0) {\n      ones = 10;\n   }\n\n   if (ones > SL) {\n      args.test.data.result.SL = \"+\" + (ones + args.test.successBonus + args.test.slBonus)\n      args.test.result.other.push(`<b>${this.effect.name}</b>: Used unit dice as SL`)\n   }\n}","Qk7t2l5ep9RDVpgE":"args.context.diceman= true;","QoEOxRruQXYrZrv3":"let filters = [\n    {\n        property : \"type\",\n        value : \"skill\"\n    },\n    {\n        property : \"name\",\n        value : /Melee/gm,\n        regex: true\n    }\n]\n\nlet items = await ItemDialog.createFromFilters(filters, 2, {text: \"Choose 2 Skills to add +20\"})\nitems = items.map(i => i.toObject())\nitems.forEach(i => i.system.advances.value = 20)\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","QqkE7rlqhkeRohFD":"return !([\"cast\", \"channelling\"].includes(args.type) && this.actor.hasCondition(\"fatigued\"))","QqybHxNCzPEzG1Qh":"return args.context.dualWieldOffhand","QwHoqu2oO8QO8Mad":"let content = `<b>${this.effect.name}</b>: All targets engaged with <b>${this.actor.prototypeToken.name}</b> take [[/r 1d10]] Damage, modified by TB and AP.`\n\nthis.script.message(content)","R32U01LBjBrK1pns":"        const templateMap = {\n            'P2e7Yx98bK3u110a' : \"\",\n            'iuMp3KLaMT2WCmie' : \"4s01nHFKVKTEZd3B\", \n            'RBuYcT5tppwcmnC5' : \"h3yuJDWnixliXeBG\", \n            'vcGpNwNbhvfzVveQ' : \"7QrsbofccMOE1YsF\", \n            'jmhKZy0w9TzkEK9c' : \"scVTPVyDDbli4WZL\", \n            '9Byj6k7SmdTYis2V' : \"4Cd7Dknee2WjReOo\", \n            'laJwc2l9tzJPgaaJ' : \"2hJ2a5YjbwZWWYrd\",\n        }\n        let template = (await game.wfrp4e.tables.rollTable(\"hireling-templates\", {hideDSN: true})).object;\n        let physicalQuirk = (await game.wfrp4e.tables.rollTable(\"physical-quirks\", {hideDSN: true})).text;\n        let workEthic = (await game.wfrp4e.tables.rollTable(\"work-ethic\", {hideDSN: true})).text;\n        let personalityQuirk = (await game.wfrp4e.tables.rollTable(\"personality-quirks\", {hideDSN: true})).text;\n\n\n        let templateItem = await warhammer.utility.findItemId(templateMap[template._id]);\n\n        let bio = \n        `\n        <p><strong>Template</strong>: ${template.text}</p>\n        <p><strong>Phsyical Quirk</strong>: ${physicalQuirk}</p>\n        <p><strong>Work Ethic</strong>: ${workEthic}</p>\n        <p><strong>Personality Quirk</strong>: ${personalityQuirk}</p>\n        `\n        \n        this.script.message(bio, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n\n        await this.actor.update({\"system.details.gmnotes.value\" : bio})\n\n        if (templateItem)\n        {\n            this.actor.createEmbeddedDocuments(\"Item\", [templateItem.toObject()])\n        }","R3OfRdi6xv0e9mzB":"return args.item.name.includes(\"Weapon\")","R5dOZWFxE2n6tooX":"return this.item.system.usesLocation(args.weapon)","R6SnyF3y4Vsq6oga":"let lore = this.effect.name.split(\"(\")[1].split(\")\")[0].toLowerCase();\n\n// If channelling corresponding lore\nif (args.type == \"channelling\" && args.spell.system.lore.value == lore)\n    args.prefillModifiers.slBonus  += 1\n// If channelling or casting different lore\nelse if (args.spell.system.lore.value != lore && args.spell.system.lore.value != \"petty\")\n    args.prefillModifiers.slBonus  -= 1","R8FBHZaaARA3z9pB":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'hard';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      \n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","R8ecKGRzOr4ThvVa":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Maintenance Crew Test';\nconst difficulty = 'hard';\nconst target = 80;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","R95pDZMHnD9iHAl8":"return args.skill?.name.includes(this.item.system.tests.value);","RDtJXji3hgcKnEBk":"let as = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.9h82z72XGo9tfgQS\")).toObject();\nlet hv = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.Nj3tC8A5fZ3zEdMR\")).toObject();\nlet ms = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.6w30u0VPsAicrqb5\")).toObject();\nlet ss = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.OEjUvJKi0xmBwbS2\")).toObject();\n\nas.name += ` (${game.i18n.localize(\"SPEC.Sight\")})`;\n\nlet roll = (await new Roll(\"1d10\").roll());\nroll.toMessage(this.script.getChatData())\nlet items = []\n\nif (roll.total <= 2)\n{\n    items = items.concat([as]);\n}\nelse if (roll.total <= 4)\n{\n    items = items.concat([hv]);\n}\nelse if (roll.total <= 6)\n{\n    items = items.concat([ms]);\n}\nelse if (roll.total <= 8)\n{\n    items = items.concat([ss]);\n}\nelse if (roll.total <= 10)\n{\n    items = items.concat([as, hv, ms, ss]);\n}\n\nthis.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect: this.effect.id})","RHyBLYT5oHf7EPnG":"let skills = this.actor.itemTypes.skill.filter(i => i.name.includes(game.i18n.localize(\"NAME.Melee\")))\n\nlet skill = await ItemDialog.create(skills, 1, \"Select the skill used by the weapon\")\nlet group = game.wfrp4e.utility.extractParenthesesText(skill[0]?.name)\nlet groupKey = warhammer.utility.findKey(group, game.wfrp4e.config.weaponGroups)\n\nlet weapon = {\n\tname : this.effect.name,\n\ttype : \"weapon\",\n\timg : this.effect.img,\n\tsystem : {\n\t\t\"damage.value\" : this.actor.system.characteristics.wp.bonus,\n\t\t\"weaponGroup.value\" : groupKey || \"basic\",\n\t\t\"twohanded.value\" : [\"polearm\", \"twohanded\"].includes(groupKey),\n\t\t\"reach.value\" : \"average\",\n\t\t\"qualities.value\" : [{name : \"magical\"}]\n\t},\n}\n\nItem.implementation.create(foundry.utils.expandObject(weapon), {parent : this.actor, fromEffect : this.effect.id})\nthis.script.notification(\"Item created. Further customization must be done manually within the Item's sheet\");","RI8crJxeD8JLDwMh":"return args.weapon?.system?.weaponGroup?.value != \"fencing\"","RJpglw5eVRM1f9t0":"args.wounds *= 5","RKIFGN583PQnqHGk":"if (args.opposedTest.result.hitloc.value == \"body\" && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 2)\n    this.script.message(\"Gained 2 Bleeding Conditions\")\n}","RNHrSTfMLXm5sXkC":"return [\"ws\", \"bs\", \"s\", \"ag\"].includes(args.characteristic)","RNr9CwyvLhlnwD2h":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Sail\"));","ROXCqAFSTLouJniL":"if (args.test.spell.name == \"Warp Lightning\")\n{\n    if (args.test.result.minormis || args.test.result.majormis || args.test.result.catastrophicmis)\n    {\n        this.script.message(`<strong>${this.item.name}</strong> Overloads!`)\n    }\n}","RPqgRUkiLY5thVbC":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Strength';\nconst difficulty = 'average';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        \n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","RRK91ySi5SzYCRvy":"return args.weapon?.system.isRanged","RSsGiDFibuqg3sHr":"let diseaseIndex = game.packs\n.filter(i => i.metadata.type == \"Item\")\n.reduce((acc, pack) => acc.concat(pack.index.contents), [])\n.filter(i => i.type == \"disease\")\n.map(i => {\n\ti.id = i._id\n\treturn i\n})\n\nlet choice = await ItemDialog.create(diseaseIndex , 1, \"Choose a Disease\")\n\nif (choice[0])\n{\n\tawait this.item.updateSource({\"system.specification.value\" : choice[0].name})\n}","RZlMkxJz5apn0mUj":"return args.item?.system.attackType != \"ranged\"","ReJpL0IVesKUbXgj":"args.fields.slBonus -= 8;","RgNdS87nO7RVawuw":"this.actor.removeCondition(\"fatigued\", 1);","RlVvlmhOfscaJqCd":"const deletes = this.actor.itemTags.armour.map(a => {\n  return {_id: a._id}\n});\nconst armourTrait = this.actor.itemTags.trait.find(t => t.name === game.i18n.localize(\"NAME.TraitArmour\"));\n\nif (armourTrait)\n  deletes.push({_id: armourTrait._id});\n\nthis.actor.deleteEmbeddedDocuments(\"Item\", deletes);","RlhOAKfN0ghrrooR":"let holed = this.actor.appliedEffects.filter(e => e.name.includes(\"Holed\"));\n\nfor (let effect of holed) {\n  await effect.update({name: effect.name.replace(/\\d+/, rating => parseInt(rating) * 2)});\n}\n\nthis.script.notification(`Holed Ratings of ${this.actor.name} have been doubled.`);","Rnpw6UQdJifLeuna":"this.effect.updateSource({\"system.transferData.type\" : \"crew\"})","RprZWlnopSqZt7KZ":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"));","RqWnhnwFxaHubgiA":"await args.actor.addCondition(\"blinded\");\nawait args.actor.addCondition(\"deafened\");\nawait args.actor.addCondition(\"stunned\");","RrchOMpEdIvceJxl":"return args.skill?.name == `${game.i18n.localize(\"NAME.Stealth\")} (${game.i18n.localize(\"SPEC.Rural\")})`","RsWXCcYHONf3ANlD":"this.actor.addCondition(\"stunned\", 1);\n","RuW1PWUFxIbbSlIm":"return ![\"t\", \"wp\", \"ag\", \"i\", \"int\"].includes(args.characteristic)","RvipIYj9H7n4UDMe":"let characteristics = {\n    \"ws\" : -10,\n    \"bs\" : -10,\n    \"s\" : -5,\n    \"t\" : -5,\n    \"i\" : -10,\n    \"ag\" : -10,\n    \"dex\" : -10,\n    \"int\" : 0,\n    \"wp\" : 0,\n    \"fel\" : 0\n}\nlet skills = []\nlet skillAdvancements = []\nlet talents = []\nlet trappings = []\nlet items = []\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","RwMw848y13Jq2L4f":"let test = await this.actor.setupSkill(\"Endurance\", {fields : {difficulty : \"difficult\"}, appendTitle : ` - ${this.effect.name}`});\nawait test.roll();\nif (test.failed)\n{\n\tawait this.actor.addCondition(\"blinded\");\n}\n\nlet msg = ``\nlet armour = args.actor.itemTags.armour.filter(i => i.system.isMetal && i.system.isEquipped);\nfor(let item of armour)\n{\n\tfor(let key in item.system.AP)\n\t{\n\t\tlet AP = item.system.AP[key]\n\t\tlet damage = Math.floor(AP / 2);\n\t\tawait item.system.damageItem(damage, [key]);\n\t}\n\tmsg += `<p><strong>${item.name}</strong> AP reduced by half</p>`\n}\nif (msg)\n{\n\tthis.script.message(msg, {speaker : {alias : args.actor.name}});\n}","RyQtuiRykUCQ6Xag":"if (!this.item.actor.name.includes(\"Brunner\")) return;\n\nargs.actor.addCondition(\"ablaze\");","S1QihXuvdEVzeRtB":"let dice = await new Roll(\"1d10\").roll()\nlet roll = dice.total\nlet talent \nlet message\nlet modifier = 0\n\nif (roll <= 3)\n{\n    item = await fromUuid(\"Compendium.wfrp4e-core.items.mNoCuaVbFBflfO6X\")\n}\n\nelse if (roll <= 6)\n{\n    item = await fromUuid(\"Compendium.wfrp4e-core.items.OEjUvJKi0xmBwbS2\")\n    modifier = -3\n}\n\nelse if (roll <= 9)\n{\n    item = await fromUuid(\"Compendium.wfrp4e-core.items.mdPGZsn2396dEpOf\")\n    modifier = -3\n}\n\nelse if (roll = 10)\n{\n    item = await fromUuid(\"Compendium.wfrp4e-core.items.qdMbxW09FUoYBzmB\")\n    modifier = -5\n}\n\nmessage = `${roll} Rolled, gain ${item.name}, ${modifier} Strength`\ndice.toMessage(this.script.getChatData())\n\nlet changes = foundry.utils.duplicate(this.effect.changes)\nchanges[0].value = modifier\n\nthis.effect.updateSource({changes})\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id})\n\nthis.script.notification(message)","S3DCTw4yJ85eSaKp":"this.actor.setupCharacteristic(\"s\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(test => test.roll())","S3Dev4hleOYqDNe9":"if (args.test.options.healWounds) {\n if (args.test.succeeded) \n {\n   let wounds = this.actor.characteristics.int.bonus + Number(args.test.result.SL)\n   if (args.test.options.fieldDressing && args.test.result.reversed)\n   {\n      wounds = this.actor.characteristics.int.bonus + Math.min(1, Number(args.test.result.SL))\n   }\n\targs.test.result.woundsHealed = wounds\n\targs.test.result.other.push(`<b>${this.actor.name}</b> healed <b>${wounds}</b> wounds of the patient.`)\n   }\n   else if (this.actor.characteristics.int.bonus + Number(args.test.result.SL) < 0)\n   {\n      args.test.result.other.push(`The patient contracts a @UUID[Compendium.wfrp4e-core.items.Item.1hQuVFZt9QnnbWzg]{Minor Infection}.`)\n   }\n}","S4793DLFhjMxpM8x":"return ![\"ws\", \"bs\"].includes(args.characteristic) && !args.item?.system.attackType && !args.context.dodge","S6tUyFJvGMV19mvP":"this.actor.status.addArmour(2, {source: this.effect})","S95QqpX1cZyIVCPy":"if (parseInt(this.item.system.specification.value) > 0)\n{\n\tthis.actor.system.status.ward.value = parseInt(this.item.system.specification.value);\n}\n\n","SGr50Hq1AHIEzIFN":"let choice = await ItemDialog.create(ItemDialog.objectToArray({\n    int : game.wfrp4e.config.characteristics.int,\n    fel : game.wfrp4e.config.characteristics.fel\n}, this.effect.img), 1, \"Choose Characteristic\");\n\nthis.effect.updateSource({\"flags.wfrp4e.characteristic\" : choice[0].id})","SK8paBvnvc5YLFI1":"if (args.test.options.doombolt && !args.test.options.doomboltRolled)\n{\n\targs.test.options.doomboltRolled = true;\n\n\tlet test = await this.actor.setupSkill(`${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})`, {fields : {difficulty : \"hard\"}, context : {failure : \"@Table[majormis]{Major Miscast}\"}});\n\tawait test.roll();\n\n\tif (test.succeeded)\n\t{\n\t\targs.test.preData.additionalDamage = 4;\n\t}\n}","SLy1Fs3oXcHgFgjK":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\nlet value = foundry.utils.getProperty(this.effect.sourceTest, \"result.overcast.usage.other.current\") || 1\ndata.system.specification.value = value\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","SNjG7IvgQzvCGczR":"if (this.actor.system.details.experience.current < 100) {\n  return this.script.notification(game.i18n.localize(\"SCRIPT.NotEnoughXP\"))\n}\n\nlet item = await game.wfrp4e.utility.findItem(\"Messenger\", \"trait\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item]);\nlet expLog = foundry.utils.duplicate(this.actor.details.experience.log || []);\nexpLog.push({amount : 100, reason: item.name, spent: this.actor.details.experience.spent + 100, total: this.actor.details.experience.total, type: \"spent\"});\nthis.actor.update({\n    \"system.details.experience.spent\": this.actor.details.experience.spent + 100,\n    \"system.details.experience.log\": expLog\n  });","SO4Aa9argKbuO9rQ":"args.prefillModifiers.modifier -= 20","SPOkFWZWziZk5b7A":"return args.item?.system?.attackType != \"melee\"","SRmfstEs278bP9Pz":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.yRhhOlt18COq4e1q\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","SSqGxyN9hw0HDmED":"this.actor.addCondition(\"prone\");","SThruXFhxUdNKCG4":"const test = await this.actor.setupCharacteristic(\"int\", {fields: {difficulty: \"easy\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\n\nif (test.failed) {\n   this.actor.addCondition('stunned');\n}\n\nthis.script.scriptNotification(`${this.actor.name} failed the Intelligence Test and gained Stunned Condition!`);","SUfCkHdJg7rttdM1":"let amount = this.effect.sourceActor.system.characteristics.fel.bonus;\nargs.actor.addCondition(\"blinded\",  amount);","SWIJjM2RCmzfr64u":"if (args.test.result.hitloc.result == \"head\" && args.test.result.critical)\n{\n args.test.result.critModifier = args.test.result.critModifier ? args.test.result.critModifier + 40 : 40\n\n  args.test.result.critical += ` (+${args.test.result.critModifier})`\n}\n","SefcrhXsdYGFcCW6":"args.actor.system.details.move.value -= 3;\nargs.actor.system.details.man -= 2;\nargs.actor.system.status.carries.max *= 2;","SrCHfOJFZwDickqa":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"average\"}});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}","Ssn21dxoMQiqD1y4":"return args.type == \"cast\" && args.item.lore.value == \"fire\"","StAderQaQQsxb6Rv":"let target = await game.wfrp4e.tables.rollTable(\"fixations\")\nif (target)\n{\n    this.script.notification(target.result);\n    let hatred = this.actor.items.find(i => i.getFlag(\"wfrp4e\", \"fromEffect\") == this.effect.id)\n    if (hatred)\n    {\n        hatred.update({\"system.specification.value\" : target.result})\n    }\n}","SvFKt9hMcFQjeILA":"args.actor.addCondition(\"entangled\", this.effect.sourceTest.result.overcast.usage.other.current)","T0KBl8iEkcPq08RI":"if (args.applyAP && args.modifiers.ap.magical) \n{\n    args.modifiers.ap.ignored += args.modifiers.ap.magical\n    args.modifiers.ap.details.push(\"<strong>\" + this.effect.name + \"</strong>: Ignore Magical AP (\" + args.modifiers.ap.magical + \")\");\n}","T3RfSt3VMEat3iDD":"return args.skill?.name !== game.i18n.localize(\"NAME.Perception\");","T4JEEDYCEIUbVHv4":"let fatigued = this.actor.hasCondition(\"fatigued\")\n                            if (!fatigued)\n                            {\n                                this.actor.addCondition(\"fatigued\")\n                                ui.notifications.notify(\"Fatigued added to \" + this.actor.name + \" which cannot be removed until the Malaise symptom is gone.\")\n                            }","T5fiTzhXEQAv9Drf":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.rlDZZTj5PXjuRXa2\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key;\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n\nlet location = this.item.system.location.key;\n\nif (location)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.notification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}","T74FEjfFrh3f6MKv":"args.wpb = args.sb;","TAw9vXnfyIAl5DGs":"if (this.item.system.quantity.value)\n{\n    CorruptionMessageModel.createCorruptionMessage(\"minor\", this.script.getChatData());\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[1].convertToApplied()]})\n}\nelse\n{\n\tthis.script.notification(\"None left!\", \"error\")\n}","TBpNFRL5uehs0fze":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[0]]})\n}\nelse\n{\n\tthis.script.notification(\"None left!\", \"error\")\n}","TCgEBuMPPd5SLAsc":"args.fields.modifier -= 15","TCtXPvDpbfz1yrVZ":"let choice1 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Basic)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 20\n                }\n            }\n        }\n    }\n]\nlet choice2 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Two-Handed)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 20\n                }\n            }\n        }\n    }\n]\n\n    let choice = await foundry.applications.api.DialogV2.wait({\n        window : {title : \"Choice\"},\n        content : \n        `<p>\n        Select your choice\n        </p>\n        <ol>\n        <li>Melee (Basic)</li>\n        <li>Melee (Two-Handed)</li>\n        </ol> \n        `,\n        buttons : [\n            {\n                action : \"basic\",\n                label : \"Basic\",\n                callback : () => {\n                    return choice1\n                }\n            },\n            {\n                action : \"twoHanded\",\n                label : \"Two-Handed\",\n                callback : () => {\n                    return choice2\n                }\n            }\n        ]\n    })\n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            item = item.toObject()\n            items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","TEiNj5FgkoD3YbhS":"this.actor.hasCondition(\"bleeding\")?.delete()","TGN070HeJLl3gSMY":"let test = await this.actor.setupCharacteristic(\"ag\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context: { failure: \"Goes Prone\" }})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\");\n}","TIoUbjOtj7PTK2t8":"const test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {\n  skipTargets: true,\n  appendTitle: ` — ${this.effect.name}`,\n  fields: {difficulty: \"challenging\"},\n  context: {\n    failure: `Butcher loses teeth.`\n  }\n});\n\nawait test.roll();\n\nif (test.failed) {\n  const SL = Number(test.result.SL);\n  this.script.message(`Butcher loses ${SL} teeth.`);\n}","TNWmIkuubqBn38he":"this.effect.deleteCreatedItems();","TOyQLrugFGzwc5nY":"return !(args.skill?.name.includes(game.i18n.localize(\"NAME.Melee\")) || args.item?.isMelee || args.context.corruption);","TQRL4mZhZohXg1Au":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\ntest.roll();","TU2xjbJ0zFtytF3J":"return args.skill?.name == game.i18n.localize(\"NAME.CharmAnimal\");","TXce477AiXHKbepk":"return args.type !== \"pray\" || args.item?.system?.type?.value !== \"miracle\" || args.item?.system?.god?.value?.toLowerCase() !== \"taal\";","TY0xSQ00XXyEr49r":"args.fields.slBonus += 1;","TcqumwUFAL6V0cty":"if (this.item.getFlag(\"wfrp4e\", \"failedCool\"))\n{\n    this.item.system.AP = {\n        \"head\": 0,\n        \"lArm\": 0,\n        \"rArm\": 0,\n        \"lLeg\": 0,\n        \"rLeg\": 0,\n        \"body\": 0\n      }\n}","TdjlJro0RRVSh8g8":"return args.skill?.name != game.i18n.localize(\"NAME.Gamble\") && args.skill?.name != game.i18n.localize(\"NAME.SleightOfHand\");","TmaS8o33825QUMrx":"let stomp = game.wfrp4e.config.systemItems.stomp;\nlet test = await this.actor.setupTrait(stomp)\nawait test.roll();","TnFobCxG4pxlYmKr":"let gorCharacteristics = {\n    \"ws\": 45,\n    \"bs\": 30,\n    \"s\": 35,\n    \"t\": 45,\n    \"i\": 30,\n    \"ag\": 35,\n    \"dex\": 25,\n    \"int\": 25,\n    \"wp\": 30,\n    \"fel\": 25\n}\nfor (let char in this.actor.characteristics) {\n    if (this.actor.characteristics[char].initial < gorCharacteristics[char])\n        this.actor.characteristics[char].initial = gorCharacteristics[char]\n}","ToKlHDAjJOsC51ag":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.GlShFJF2TpsNh1FX\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n   \nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}});\nawait test.roll();\nif (test.failed)\n{\n    args.actor.addCondition(\"unconscious\")\n}","TpZItJ5Ugbazaobd":"let locations = [];\n\nwhile (locations.length < 2)\n{\n    let loc = await game.wfrp4e.tables.rollTable(\"hitloc\", {hideDSN : true})\n    if (!locations.includes(loc.result))\n    {\n        locations.push(loc.result);\n    }\n}\n\nlocationText = locations.map(i => game.wfrp4e.config.locations[i]).join(\", \")\n\nthis.item.updateSource({name : this.item.name += ` (${locationText})`, \"flags.wfrp4e.locations\" : locations})\nthis.effect.updateSource({\"flags.wfrp4e.locations\" : locations})","Tq45Nd8J3eTvHT41":"return args.skill?.name != game.i18n.localize(\"NAME.Perception\") && args.skill?.name != game.i18n.localize(\"NAME.SetTrap\");","TrIYdcG3jDER4WgY":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.xsGbDFqK2qh7lsIj\")\nlet data = item.toObject();\ndata.system.specification.value = game.i18n.localize(\"Minor\");\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","TwgdEucxcHloc4cX":"let choice1 = [\n    {\n        type : \"armour\",\n        name : \"Mail Chausses\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coat\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coif\"\n    },\n]\nlet choice2 = [\n    {\n        type : \"armour\",\n        name : \"Mail Chausses\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coat\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coif\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Leggings\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Skullcap\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Jack\"\n    },\n]\nlet choice3 = [\n    {\n        type : \"armour\",\n        name : \"Plate Breastplate\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Bracers\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Helm\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Leggings\"\n    },\n]\n\n\nlet choice = await foundry.applications.api.DialogV2.wait({\n    window : {title : \"Choice\"},\n    content : \n    `<p>\n    Select your choice\n    </p>\n    <ol>\n    <li>Mail</li>\n    <li>Mail & Leather</li>\n    <li>Plate</li>\n    </ol> \n    `,\n    buttons : [\n        {\n            action : 1,\n            label : \"Mail\",\n            callback : () => {\n                return choice1\n            }\n        },\n        {\n            action : 2,\n            label : \"Mail & Leather\",\n            callback : () => {\n                return choice2\n            }\n        },\n        {\n            action : 3,\n            label : \"Plate\",\n            callback : () => {\n                return choice3\n            }\n        }\n    ]\n})\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            let equip = item.system.tags.has(\"equippable\");\n            item = item.toObject()\n            if (equip)\n            {\n                item.system.equipped.value = true;\n            }\n            items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${c.name}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","TwwKxFjK6TNGKbRB":"this.script.message(await this.actor.applyBasicDamage(12, {damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true}))\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"hard\"}})\nawait test.roll();\nif (test.failed)\n{\n   this.actor.addSystemEffect(\"cold1\")\n}\n\n","TxfmxDGBj04AQQpt":"let weapon = args.opposedTest.defenderTest.weapon\nif (\n    !args.opposedTest.result.swapped && \n    args.opposedTest.result.winner == \"defender\" && \n    args.opposedTest.attackerTest.result.damage && \n    weapon && \n    weapon?.system.properties.qualities.fast\n    )\n{\n    await args.opposedTest.swap(this.effect.name);\n}","TzgmYRXFXRspIo1i":"this.effect.delete();","U1RUcgP8LD2qeGTm":"return !args.context.reload","U1UpSRJOSjPpO4HS":"let mutations = await warhammer.utility.findAllItems(\"mutation\", \"Loading Mutations\", true)\n\nlet roll = Math.floor(CONFIG.Dice.randomUniform() * mutations.length);\n\nthis.actor.createEmbeddedDocuments(\"Item\", [(await fromUuid(mutations[roll].uuid)).toObject()]);\nthis.script.notification(`Added ${mutations[roll].name}`)","U26XMie3Kjoddisj":"let stunned = this.actor.hasCondition(\"stunned\")\nif (stunned)\n{\n   this.script.notification(`Cleared 1 Stunned Condition`)\n   this.actor.removeCondition(\"stunned\");\n}\nelse \n{\n\tthis.script.notification(`No Stunned Conditions`)\n}","U2xKn7R1gm8kiQm8":"this.actor.hasCondition(\"broken\")?.delete();\n\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.8pVzgPkgWpTJvfhG\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","U4A8FDNmwBGTuQZO":"if (args.attacker.has(game.i18n.localize(\"NAME.Undead\")) && !args.attacker.has(game.i18n.localize(\"NAME.Ethereal\")))\n{\n    args.totalWoundLoss =  Math.floor(args.totalWoundLoss / 2)\n    args.modifiers.other.push({label : this.effect.name, details : game.i18n.localize(\"Halved\"), value : \"× 0.5\"})\n}","U5ndCwcJ1s3Ns26w":"args.item.system.qualities.value.push({name : \"magical\"});\nargs.item.system.damage.value += ` + ${parseInt(this.effect.sourceTest.result.SL)}`;\nargs.item.name += ` (${this.effect.name})`","U78c4oUjKwyUu6jT":"return (args.skill?.name != game.i18n.localize(\"NAME.Perception\") && args.characteristic != \"fel\")","U7lRf56BFaTfsC6B":"const type = await ValueDialog.create({\n  title: game.i18n.localize(\"SCRIPT.FellstaveDialogTitle\"),\n  text: game.i18n.localize(\"SCRIPT.FellstaveDialogText\")\n}, \"\");\n\nawait this.effect.item.update({name: `${this.effect.item.name} (${type})`});\nconst updates = this.effect.item.effects.map(e => {\n  return {_id: e.id, name: e.name + ` (${type})`}\n});\nthis.effect.item.updateEmbeddedDocuments(\"ActiveEffect\", updates);","U9xh2wriSqCosugW":"if (args.test.options.stag)\n{\n\tif (parseInt(args.test.result.SL) < 0 || args.test.failed)\n\t{\n\t\tif (parseInt(args.test.result.SL) < 0)\n\t\t{\n\t\t\targs.test.result.SL = \"+0\";\n\t\t\targs.test.result.description = game.i18n.localize(\"ROLL.MarginalSuccess\");\n\t\t}\n\t\targs.test.result.outcome = \"success\"\n        args.test.result.other.push(`<strong>${this.effect.name}</strong>: Minimum +0 SL`)\n\t}\n}","UC6G3pFQwzUhrw6F":"return args.skill?.name != game.i18n.localize(\"NAME.CharmAnimal\");","UDPsaymtZf39UsMk":"\n                            let fatigued = this.actor.hasCondition(\"fatigued\")\n                            if (!fatigued)\n                            {\n                                this.actor.addCondition(\"fatigued\")\n                                ui.notifications.notify(\"Fatigued added to \" + this.actor.name + \" which cannot be removed until the Malaise symptom is gone.\")\n                            }","UH5MIzqi2MvEqTwj":"if (args.totalWoundLoss > 0)\n{\n    let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\n    roll.toMessage(this.script.getChatData());\n    args.totalWoundLoss += roll.total;\n    args.modifiers.other.push({label : this.effect.name, value : roll.total})\n}","ULmZMLezDamerN04":"let spells = await warhammer.utility.findAllItems(\"spell\", \"Loading Spells\", true, [\"system.lore.value\"])\n\nlet lore = (await game.wfrp4e.tables.rollTable(\"random-caster\", {hideDSN: true})).text\nthis.script.notification(lore)\nif (lore == \"GM's Choice\") {\n   return\n}\n\nelse if (lore == \"Arcane Magic\") {\n    lore = \"Arcane\"\n}\n\nelse if (lore == \"Petty Magic\") {\n    lore = \"petty\"\n}\n\nelse {\n    lore = lore.toLowerCase();\n}\n\nlet spellsWithLore = []\nif (lore == \"Arcane\") {\n    spellsWithLore = spells.filter(i => !i.system.lore.value)\n}\nelse {\n    spellsWithLore = spells.filter(i => i.system.lore.value == lore)\n}\n\nlet selectedSpell = spellsWithLore[Math.floor(CONFIG.Dice.randomUniform() * spellsWithLore.length)]\nItem.implementation.create(selectedSpell.toObject(), { parent: this.actor}).then(item => {\n    this.actor.setupCast(item).then(test => test.roll());\n})","UQtXuQmUlTyDKqhe":"let characteristics = {\n    \"ws\" : 10,\n    \"bs\" : 20,\n    \"s\" : 0,\n    \"t\" : 10,\n    \"i\" : 15,\n    \"ag\" : 0,\n    \"dex\" : 0,\n    \"int\" : 40,\n    \"wp\" : 45,\n    \"fel\" : 10\n}\nlet skills = [\"Channelling\", \"Cool\", \"Intimidate\", \"Language (Magick)\", \"Language (Nehekharan)\", \"Lore (Magic)\", \"Perception\"]\nlet skillAdvancements = [10, 20, 15, 15, 10, 10, 10]\nlet talents = [\"Arcane Magic\", \"Hardy\", \"Menacing\", \"Petty Magic\", \"Read/Write\", \"Second Sight\"]\nlet trappings = [\"Hand Weapon\"]\nlet specialItems = [ \n    {name: \"Mouldering Robes\", type: \"trapping\", trappingType: \"clothingAccessories\" }, \n    {name: \"Pouches containing ritual components\", type: \"trapping\", trappingType: \"clothingAccessories\" }, \n    {name: \"Staff\", type: \"weapon\", damage: \"SB+2\"}, \n    {name: \"Dark Magic (Necromancy)\", type: \"talent\"},\n]   \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nlet filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = (await ItemDialog.createFromFilters(filters, 3, {text: \"Choose 3 Petty Spells\"})).map(i => i.toObject());\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"\"\n    }\n]\n\nlet arcane = (await ItemDialog.createFromFilters(filters, 2, {text : \"Choose 2 Arcane Spells\"})).map(i => i.toObject());\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"name\",\n        value: /^((?!\\().)*$/gm, // Remove all spells with parentheses (all arcane spells spells)\n        regex: true\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"necromancy\"\n    }\n]\n\nlet necromancy = (await ItemDialog.createFromFilters(filters, 1, {text : \"Choose 1 Necromancy Spell\"})).map(i => i.toObject());\n\narcane.forEach(i => {\n    i.img = \"modules/wfrp4e-core/icons/spells/necromancy.png\";\n    i.system.lore.value = \"necromancy\";\n})\nlet spells = [...petty, ...necromancy, ...arcane];\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items.concat(spells));\n","UTlgF4azrGQZsoDv":"const talents = await Promise.all([game.i18n.localize(\"NAME.Ambi\"), game.i18n.localize(\"NAME.Distract\")].map(game.wfrp4e.utility.findTalent))\nthis.actor.createEmbeddedDocuments(\"Item\", talents, {fromEffect : this.effect.id})","UUHQRPRrrRSr9MIA":"const venomFlag = this.effect.getFlag(\"wfrp4e-tribes\", \"venom\");\n\nif (venomFlag) {\n  this.actor.updateEmbeddedDocuments(\"Item\", [venomFlag]);\n}","UWrzokgabRKUpnkG":"return [\"t\", \"wp\", \"ag\", \"i\", \"int\"].includes(args.characteristic)","UXdlnmwVgjc1QpF2":"args.actor.system.details.move.value += 1;\nargs.actor.system.status.carries.max = Math.floor(args.actor.system.status.carries.max * 0.75);","UYLXm2W6jVn21Age":"args.fields.modifier += 40;","UaImulhbPURkLJg2":"return this.actor.attacker && (args.skill?.name == `${game.i18n.localize(\"NAME.Melee\")} (${game.i18n.localize(\"SPEC.Basic\")})` || (args.type == \"weapon\" && args.item?.system.weaponGroup.value == \"basic\"))","UfkysrAftCs09Fct":"return args.skill.name !== game.i18n.localize(\"NAME.Gamble\")","UgQW0UMPOZ0jwfVJ":"let current = this.actor.status.fortune.value\n\nthis.actor.update({\"system.status.fortune.value\" : 1 + current})\n\nthis.script.message(`<b>${this.actor.prototypeToken.name}</b> fortune points increased from ${current} to ${1 + current}`)","UlRSaZG4ZUU6fMND":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'challenging';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        \n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","UlygtNPSDlWPIFCI":",args.fields.slBonus++;,args.fields.slBonus++;,args.fields.slBonus++;","Um6xMMiUftLXJxEt":"return [\"fel\", \"dex\"].includes(args.characteristic)","UnqnWi0dZYLf5fTT":"let choice1 = [\n    {\n        type : \"armour\",\n        name : \"Mail Chausses\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coat\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coif\"\n    },\n]\nlet choice2 = [\n    {\n        type : \"armour\",\n        name : \"Mail Chausses\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coat\"\n    },\n    {\n        type : \"armour\",\n        name : \"Mail Coif\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Leggings\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Skullcap\"\n    },\n    {\n        type : \"armour\",\n        name : \"Leather Jack\"\n    },\n]\nlet choice3 = [\n    {\n        type : \"armour\",\n        name : \"Plate Breastplate\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Bracers\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Helm\"\n    },\n    {\n        type : \"armour\",\n        name : \"Plate Leggings\"\n    },\n]\n\nlet choice = await foundry.applications.api.DialogV2.wait({\n    window : {title : \"Choice\"},\n    content : \n    `<p>\n    Select your choice\n    </p>\n    <ol>\n    <li>Mail</li>\n    <li>Mail & Leather</li>\n    <li>Plate</li>\n    </ol> \n    `,\n    buttons : [\n        {\n            action : 1,\n            label : \"Mail\",\n            callback : () => {\n                return choice1\n            }\n        },\n        {\n            action : 2,\n            label : \"Mail & Leather\",\n            callback : () => {\n                return choice2\n            }\n        },\n        {\n            action : 3,\n            label : \"Plate\",\n            callback : () => {\n                return choice3\n            }\n        }\n    ]\n})\n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            let equip = item.system.tags.has(\"equippable\");\n            item = item.toObject()\n            if (equip)\n            {\n                item.system.equipped.value = true;\n            }\n            items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${c.name}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","UsAHQecRlWL5PhP6":"this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty : \"average\"}}).then(async test =>\n{\n     await test.roll()\n     if (test.failed)\n     {\n         this.actor.corruptionDialog(\"moderate\")    \n     }\n})","UsuwsmU1TUQLQVM2":"let lore = this.effect.name.split(\"(\")[1].split(\")\")[0].toLowerCase();\nreturn !args.spell || (args.type == \"cast\" && [\"petty\", lore].includes(args.spell.system.lore.value));","UtqUthabeQ4rHDLQ":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.tNWrJUOArwfWXsPw\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id});","Uvk1X7sEhvv77YkD":"if (!args.flags.distractingApplied)\n{\n    args.fields.modifier -= 20;\n    args.flags.distractingApplied = true;\n}","UvycHOjSPm5Zv9KJ":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nlet baseDamage = \"4\";\nif (test.succeeded)\n    baseDamage = \"0\";\n   \nlet damage = this.effect.sourceItem.system.computeSpellDamage(baseDamage, true) + parseInt(this.effect.sourceTest.result.SL);\n\nthis.script.message(await this.actor.applyBasicDamage(damage, {suppressMsg : true}))\nthis.actor.addCondition(\"ablaze\")","UwjkHRAQHESdYXJs":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n    \"dim\": 2,\n    \"bright\": 1,\n    \"alpha\": 0.5,\n    \"animation\": {\n        \"speed\": 4,\n        \"intensity\": 4,\n        \"type\": \"pulse\",\n    },\n    \"color\": \"#949bff\",\n}}));","Ux4buMc7llF1Kg8p":"if (!this.actor.hasCondition(\"stunned\") && !this.actor.hasCondition(\"unconcscious\"))\n{\n    this.effect.delete();\n}","UxVfVoH7cbC9ESDr":"const test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {\n  skipTargets: true,\n  appendTitle: ` — ${this.effect.name}`,\n  fields: {difficulty: \"challenging\"},\n  context: {\n    failure: `Gained @Condition[Stunned] Condition.`\n  }\n});\n\nawait test.roll();\n\nif (test.failed)\n  args.actor.addCondition(\"stunned\");","V1D2Uo3WDKYQePU3":"let damage = this.effect.sourceTest.result.damage;\n        \nlet loc = \"head\"\nlet APatLoc = this.actor.system.status.armour[loc];\n\nlet metalAP = APatLoc.layers.reduce((metal, layer) => metal += (layer.metal ? layer.value : 0), 0)\n\nlet APused = Math.max(0, APatLoc.value - metalAP); // remove metal AP at location;\n\ndamage -= (APused + this.actor.system.characteristics.t.bonus)\n\nlet msg = await this.actor.applyBasicDamage(damage, {suppressMsg : true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL});\nmsg += ` (ignored ${metalAP} metal AP on ${game.wfrp4e.config.locations[loc]})`\nthis.script.message(msg)\n","V2lsVTi6q28eL5jl":"args.fields.slBonus += parseInt(this.effect.sourceTest.result.SL)","V4PcjtHde941wv6J":"await this.actor.addCondition(\"prone\");\nconst SL = this.effect.sourceTest.result.slOver;\nconst stunned = 1 + SL;\nawait this.actor.addCondition(\"stunned\", stunned);\n\nif (stunned > this.actor.system.characteristics.t.bonus) {\n  const crit = `<a data-action=\"clickTable\" class=\"action-link critical\" data-table=\"crithead\" data-modifier=\"0\"><i class=\"fas fa-list\"></i> Critical</a>`;\n  \n  const test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {\n    skipTargets: true,\n    appendTitle: ` - ${this.effect.name}`,\n    fields: {difficulty: \"average\"},\n    context: {failure: `Receives ${crit} to the head.`}\n  })\n  \n  await test.roll();\n}","V7qmFwUMCY2tfziH":"this.actor.addCondition(\"stunned\")","V9wD9FWHWxZUOGSI":"let roll = await (new Roll(`max(0, 1d10 - ${this.actor.characteristics.wp.bonus})`).roll())\nlet fatigued = roll.total\nroll.toMessage(this.script.getChatData());\nif (fatigued > this.actor.characteristics.wp.bonus)\n{\n    this.actor.addCondition(\"unconscious\")\n    this.script.notification(`Fell Unconscious`)\n}\nelse \n{\n    fatigued = Math.max(0, fatigued)\n    if (fatigued)\n        this.actor.addCondition(\"fatigued\", fatigued)\n    this.script.notification(`Gained ${fatigued} conditions`)\n}","V9xm4X1x3lPYTQaI":"if (args.extendedTest?.getFlag(\"wfrp4e\", \"fear\"))\n{\n\tthis.script.notification(\"Immune to Fear\");\n\targs.extendedTest.delete();\n\targs.abort = true;\n}","V9zm2hKUVLVZtAcN":"let characteristics = {\n  \"ws\" : -10,\n  \"bs\" : -10,\n  \"s\" : 0,\n  \"t\" : 15,\n  \"i\" : 15,\n  \"ag\" : -20,\n  \"dex\" : 0,\n  \"int\" : 20,\n  \"wp\" : 10,\n  \"fel\" : 10\n}\nlet skills = [\"Charm\", \"Channelling\", \"Entertain (Prophecy)\", \"Intuition\"]\nlet skillAdvancements = [0, 0, 20, 10]\nlet talents = [\"Detect Artefact\", \"Menacing\", \"Sixth Sense\"]\nlet traits = [\"Dooming\", \"Spellcaster (Lore of Life)\", \"Ward\"]\nlet trappings = []\nlet items = [];\nlet spells = [\"Forest of Thorns\"];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n  updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n  let skill = skills[index]\n  let skillItem;\n  skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n  if (skillItem)\n      skillItem.system.advances.value += skillAdvancements[index]\n  else \n  {\n      skillItem = await game.wfrp4e.utility.findSkill(skill)\n      skillItem = skillItem.toObject();\n      skillItem.system.advances.value = skillAdvancements[index];\n      items.push(skillItem);\n  }\n}\n\nfor (let talent of talents)\n{\n  let talentItem = await game.wfrp4e.utility.findTalent(talent)\n  if (talentItem)\n  {\n      items.push(talentItem.toObject());\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n  }\n}\n\nconst traitRegex = /(?:,?(.+?)(\\+?\\d{1,2}\\+?)?\\s*?(?:\\((.+?)\\)\\s*(\\+?\\d{1,2})?|,|$))/gm\nfor (let trait of traits)\n{\n  let traitMatches = trait.matchAll(traitRegex).next().value\n  let traitName = traitMatches[1]\n  let traitVal = traitMatches[2] || traitMatches[4] // could be match 2 or 4 depending on if there's a specialization\n  let traitSpec = traitMatches[3]\n\n  let traitItem;\n  try {\n      traitItem = await WFRP_Utility.findItem(traitName, \"trait\")\n  }\n  catch { }\n  if (!traitItem) {\n      ui.notifications.warn(`Could not find ${trait}`, {permanent : true})\n  }\n  traitItem = traitItem.toObject()\n\n  if (Number.isNumeric(traitVal))\n  {\n      traitItem.system.specification.value = traitName.includes('Weapon','Horns','Tail','Tentacles','Bite') ? traitVal - parseInt(characteristicValues[3]/10) : traitVal;\n      traitItem.name = (traitItem.name +  ` ${traitSpec ? \"(\"+ traitSpec + \")\" : \"\"}`).trim()\n  }\n  else \n      traitItem.system.specification.value = traitSpec\n\n  items.push(traitItem)\n\n}\n\nfor (let trapping of trappings) \n{\n  let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n  if (trappingItem)\n  {\n      trappingItem = trappingItem.toObject()\n\n      trappingItem.system.equipped.value = true;\n\n      items.push(trappingItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n  }\n}\n\nfor (let spell of spells) \n{\n  let spellItem = await game.wfrp4e.utility.findItem(spell)\n  if (spellItem)\n  {\n      spellItem = spellItem.toObject()\n\n      items.push(spellItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${spell}`, {permanent : true})\n  }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","VAPsww9x3HAw1sKP":"return !args.context.dodge","VAs1nXvicdQK18Do":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Language\"));","VCnNWmRBH28Rx0JH":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"))","VGuZMIR1lE8I1F1y":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"difficult\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed) {\n        this.actor.addCondition(\"stunned\");\n}","VINX6TBAJQznhVcN":"const repaired_message = `<p>Finished replacing <em>${this.item.name}</em> with a makeshift one.</p>`;\nconst test = 'Maintenance Crew Test';\nconst difficulty = 'hard';\nconst target = 80;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      \n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","VKpKq4RSbI1KkUQK":"this.actor.flags.useless[this.effect.getFlag(\"wfrp4e\", \"location\")] = true;","VLdF2HPnCrNIgp7a":"let items = [];\n\nlet etiquette = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.sYbgpSnRqSZWgwFP\")).toObject();\netiquette.name += \" (Followers of Khorne)\";\n\nitems.push(etiquette);\n\nlet animosity = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.0VpT5yubw4UL7j6f\")).toObject();\n  animosity.system.specification.value = \"Followers of Slaanesh\";\n\nitems.push(animosity);\n\nawait this.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect : this.effect.id});\n","VNOKTzCrFbZ6PJUj":"return ![game.i18n.localize(\"NAME.CharmAnimal\"), game.i18n.localize(\"NAME.Endurance\"), game.i18n.localize(\"NAME.OutdoorSurvival\")].includes(args.skill?.name)","VQaC6ynouW5EQCbC":"let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\n\nawait roll.toMessage(this.script.getChatData());\n\nthis.script.message(await this.actor.applyBasicDamage(roll.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true}));\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name});\nawait test.roll();\n\nif (test.succeeded)\n{\n    return false;\n}","VTS4RzbmReI87K9a":"args.fields.slBonus = Math.floor(this.item.system.total.value * 0.1);","VTzpExK3QSCaFQPf":"if (args.equipped) \n{\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.SfUUdOGjdYpr3KSR\")\n    let regen = item.toObject();\n    item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.kJNAY1YRaCy9IgmT\");\n    let terror = item.toObject();\n    terror.system.specification.value = 2;\n    this.actor.createEmbeddedDocuments(\"Item\", [regen, terror], {fromEffect : this.effect.id});\n} \nelse \n{\n  this.effect.deleteCreatedItems();\n}","VXERNoc5IazQGuGO":"if (args.applyAP && args.modifiers.ap.metal)\n{\n    args.modifiers.ap.ignored += args.modifiers.ap.metal\n    args.modifiers.other.push({value : args.modifiers.ap.metal, label : this.effect.name, details : \"Add Metal AP to Damage\" })\n    args.modifiers.ap.details.push(\"<strong>\" + this.effect.name + \"</strong>: Ignore Metal (\" + args.modifiers.ap.metal + \")\");\n    args.modifiers.ap.metal = 0\n}","Vb7rgl8T4VRswbnZ":"this.actor.status.addArmour(parseInt(this.item.system.specification.value) || 0, {source: this.effect, damage : this.item.getFlag(\"wfrp4e\", \"APdamage\")})","VbI0Al6rJfypV3qY":"const failure = game.i18n.localize(\"ROLL.ImpressiveFailure\");\nconst success = game.i18n.localize(\"ROLL.AstoundingSuccess\");\n\nargs.test.result.description = args.test.succeeded ? success : failure;","VbL0TgaBAmYjrezZ":"const talents = await Promise.all([game.i18n.localize(\"NAME.Hardy\")].map(game.wfrp4e.utility.findTalent))\nthis.actor.createEmbeddedDocuments(\"Item\", talents, {fromEffect : this.effect.id})","VcE8Hie2jbpuyuM3":"const vomit = this.actor.itemTags.trait.find(t => t.name === \"Vomit\");\nconst name = \"Bileful Vomit\";\n\nif (!vomit) return;\n\nconst effect = vomit.effects.find(e => e.name === \"Vomit\");\nconst scriptData = effect.system.scriptData;\n\n// REMINDER\n\nscriptData.push({\n  label:  'Spell Rules Reminder'\n  trigger: 'rollTest',\n  script: ` \n    args.test.result.other.push(\"This Vomit attack follows the rules for the Lore of Nurgle spell @UUID[Compendium.wfrp4e-core.items.Item.XhyZ140R1iA1J7wZ].\");\n  `\n});\n\n// /REMINDER\n\n// update Effect's name\nawait effect.update({\n  name,\n  \"system.scriptData\": scriptData\n});\n\n\n// update Trait's name\nawait vomit.update({name});\n\n// copy effect from Stream of Corruption spell\nconst effectData = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.XhyZ140R1iA1J7wZ.ActiveEffect.KAXAHr5NdusLTz6k\")).toObject();\n\nawait vomit.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);","Vkuu70BZV4DPYO2Q":"return args.item?.system?.attackType != \"ranged\"","VlFUDaKUYoBYKYn0":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context : {failure: \"1 Corruption Point Gained\"}})\nawait test.roll();\nif (test.failed && this.actor.type == \"character\")\n{\n    this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + 1})\n    this.script.message(\"Gained a Corruption point\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","VlHuDIAvPr8JM1P5":"return args.skill?.name !== game.i18n.localize(\"NAME.Row\");","Vns6WrafVq8NjX7t":"return args.skill?.name != game.i18n.localize(\"NAME.Heal\")","VqTrKPtxv9hpn0Hr":"return args.skill?.name != `${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})`","VuE1mhrB6X6MYTzg":"return args.characteristic == \"fel\"","VurA2XNqC0d9U49C":"this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test =>\n{\n     await test.roll()\n     if (test.failed)\n     {\n         this.actor.addCondition(\"fatigued\")    \n     }\n})","VzO0ZDcTWvaBn4vm":"if (args.test.preData.skillName?.includes(game.i18n.localize(\"NAME.Language\")) || args.test instanceof game.wfrp4e.rolls.CastTest)\n{\n\tif (parseInt(args.test.result.SL) > 0 || args.test.succeeded)\n\t{\n\t\tif (parseInt(args.test.result.SL) > 0)\n\t\t{\n\t\t\targs.test.result.SL = \"-0\";\n\t\t\targs.test.result.description = game.i18n.localize(\"ROLL.MarginalFailure\");\n\t\t}\n\t\targs.test.result.outcome = \"failure\"\n        args.test.result.other.push(`<strong>${this.effect.name}</strong>: Maximum -0 SL`)\n\t}\n}","VzgTGb5QXKoyPNh3":"if (args.attackerTest.weapon && args.defenderTest.weapon)\n{\n   let attackerReach = game.wfrp4e.config.reachNum[args.attackerTest.weapon.reach.value]\n   let defenderReach = game.wfrp4e.config.reachNum[args.defenderTest.weapon.reach.value]\n   \n   if (attackerReach == defenderReach)\n      defenderReach  = defenderReach < 7 ? defenderReach  + 1 : defenderReach \n\n   attackerReach = warhammer.utility.findKey(attackerReach, game.wfrp4e.config.reachNum)\n   defenderReach = warhammer.utility.findKey(defenderReach, game.wfrp4e.config.reachNum)\n\n  args.attackerTest.weapon.reach.value = attackerReach\n  args.defenderTest.weapon.reach.value = defenderReach\n}","W5qtA7Ul5cOj18Nd":"this.item.update({\"system.AP\" : {lArm : 3, rArm : 3, lLeg : 3, rLeg: 3}});","W9nyUNQStMr1pUHJ":"if (args.opposedTest.result.hitloc.value == this.item.system.location.key)\n{\n    args.actor.addCondition(\"bleeding\", 1);\n    this.script.notification(\"Added Bleeding\")\n}","WB6sIpLEPC8YPX67":"if (args.context.dodge)\n{\n\targs.abort = true;\n\tthis.script.notification(\"Cannot Dodge!\")\n}\nreturn [\"t\", \"int\", \"wp\", \"fel\"].includes(args.characteristic)","WJkwIrdj4NceOYe8":"return args.characteristic !== 'fel';","WKXyVHQwQCNTfSKv":"if ((args.item.type == \"weapon\" || args.item.system.attackType) && !args.item.isMagical )\n{\n    args.item.system.qualities.value.push({name : \"magical\"})\n}","WO5n7Vbx8AgoVrwC":"let characteristics = {\n    \"ws\" : 0,\n    \"bs\" : 0,\n    \"s\" : 0,\n    \"t\" : 0,\n    \"i\" : 10,\n    \"ag\" : 0,\n    \"dex\" : 0,\n    \"int\" : 10,\n    \"wp\" : 5,\n    \"fel\" : 5\n}\nlet skills = [\"Intuition\", \"Lore (Local)\", \"Perception\"]\nlet skillAdvancements = [10, 10, 10]\nlet talents = []\nlet trappings = [\"Mail Coat\", \"Mail Chausses\", \"Mail Coif\", \"Hand Weapon\"]\nlet items = []\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","WOpRJluHKER1MdgI":"let difficulty = \"\"\n                            if (this.effect.name.includes(\"Moderate\"))\n                                difficulty = \"easy\"\n                            else if (this.effect.name.includes(\"Severe\"))\n                                difficulty = \"average\"\n                            else\n                                difficulty = \"veasy\"\n        \n                            let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {context : {failure : this.actor.name + \" dies from Blight\"}, fields: {difficulty}, appendTitle : \" - Blight\"})\n                            await test.roll();\n                            if (test.failed)\n                            {\n                                this.actor.addCondition(\"dead\");\n                            }","WPQbVpD1uwSLAXq1":"if (this.actor.system.status.wounds.value == 0)\n{\n\tthis.actor.addCondition(\"dead\");\n}","WR0Kqn8CF5iwToak":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Tailor)';\nconst difficulty = 'difficult';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      \n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","WRe1eGmGVGejPcS8":"let wind = this.effect.name.split(\" \")[2]\nreturn args.type == \"cast\" && game.wfrp4e.config.magicWind[args.item.system.lore.value] == wind;","WTRYAEzwxRuGENyI":"        // Every living creature within 10 yards, other than the wielder of the hammer,\n        // must make a Challenging (+0) Endurance Test \n\n        let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {\n            skipTargets: true, appendTitle :  \" - \" + this.effect.name,\n            fields: {difficulty: \"challenging\"}\n        })\n        \n        await test.roll();\n        if (test.failed)\n        {\n            // or gain a Deafened Condition \n            this.actor.addCondition(\"deafened\");\n            // and suffer 1d10 Wounds which bypass armour but not Toughness Bonus.\n            let damage = (await new Roll(\"1d10\").roll());\n            await damage.toMessage(this.script.getChatData());\n            this.script.message(await this.actor.applyBasicDamage(damage.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}))\n        }","WY3DajPRGcMNt158":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MVI0lXcg6vvtooAF\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id})","WaeL2I8VVJmBBKHk":"const vomit = this.actor.itemTags.trait.find(t => t.name === \"Vomit\");\nconst name = \"Corrupting Vomit\";\n\nif (!vomit) return;\n\nconst effect = vomit.effects.find(e => e.name === \"Vomit\");\nconst scriptData = effect.system.scriptData;\n\nscriptData[0].script = `\nargs.actor.addCondition(\"stunned\");\nargs.actor.corruptionDialog(\"moderate\");\n`\n\nawait effect.update({\n  name,\n  \"system.scriptData\": scriptData\n});\n\nawait vomit.update({name});","WeTlTniskT3Ej6vg":"args.modifiers.other.push({label : this.effect.name, value : 2})","Wh1VV3javfzcV3bP":"let spells = await warhammer.utility.findAllItems(\"spell\", \"Loading Spells\", true, [\"system.lore.value\"]);\n\nspells = spells.filter(i => [\"dark\", \"light\", \"fire\", \"life\", \"beasts\", \"shadows\", \"death\", \"heavens\", \"metal\"].includes(i.system.lore.value)).sort((a, b) => a.name > b.name ? 1 : -1);\n\nlet choices = await ItemDialog.create(spells, 7, {text : \"Choose 7 taken from any combination of spells from Colour Magic Lore, the Lore of Witchcraft, or Lore of Dark Magic\", title : this.effect.name})\n\nthis.actor.addEffectItems(choices.map(i => i.uuid), this.effect)","WiYtNU2Y5BJfIpeM":"let location = this.item.system.location.key;\n\nif (location)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.notification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}","WnWA0e0bgqBsZp2L":"this.item.update({\"system.twohanded.value\" : !this.item.system.twohanded.value})","Wo4wQKUxSItAhRzZ":"let lore = this.effect.name.split(\"(\")[1].split(\")\")[0].toLowerCase();\n\n// If channelling corresponding lore\nif (args.type == \"channelling\" && args.spell.system.lore.value == lore)\n    args.prefillModifiers.slBonus  += 3\n// If channelling or casting different lore\nelse if (args.spell.system.lore.value != lore && args.spell.system.lore.value != \"petty\")\n    args.prefillModifiers.slBonus  -= 1","Wqff6ICWYzvLDYC8":"if (this.actor.system.details.experience.current < 100) {\n  return this.script.notification(game.i18n.localize(\"SCRIPT.NotEnoughXP\"))\n}\n\nlet item = await game.wfrp4e.utility.findItem(\"Sensory Sharing\", \"trait\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item]);\nlet expLog = foundry.utils.duplicate(this.actor.details.experience.log || []);\nexpLog.push({amount : 100, reason: item.name, spent: this.actor.details.experience.spent + 100, total: this.actor.details.experience.total, type: \"spent\"});\nthis.actor.update({\n    \"system.details.experience.spent\": this.actor.details.experience.spent + 100,\n    \"system.details.experience.log\": expLog\n  });","WtbSIghR0q4euE7J":"if (args.effect.conditionId == \"ablaze\")\n{\n    args.data.formula = `(${args.data.formula}) * 2`;\n}","WwxXgsNxlccmqTze":"this.actor.addCondition(\"dead\")","WzMmwjZbhyCbHxyZ":"this.actor.status.encumbrance.state += 2\nthis.actor.status.encumbrance.pct = 100;","X08401eOhKJrhNf1":"const grim = this.actor.items.find(i => i.type === \"trait\" && i.name.includes(\"Grim\"));\n\nif (args.options?.deltaAdv > 0 && this.actor.hasCondition(\"engaged\") && grim.specification.value !== 4) {\n  grim.update({\"system.specification.value\": 4});\n}\n\nif (!this.actor.hasCondition(\"engaged\") && grim.specification.value !== 2) {\n  grim.update({\"system.specification.value\": 2});\n}","X3bLbOfcJAftOMa7":"return [\"ws\", \"bs\", \"ag\"].includes(args.characteristic)","X3vpmNUj9SL2CDnF":"let item = args.actor.items.find(i => i.name.includes(\"Flying Jib\"));\nitem.name += ` (Disabled by ${this.item.name})`;","X7ikFOGKYzTMr4d1":"args.fields.difficulty = \"difficult\"","XCAfy460IotarQek":"return false;","XClTZOjuhcxWLF51":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"difficult\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\")\n}\n\n\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.4lj1ik958mbgAlaF\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","XO9m2AvFRAAeEuty":"if (args.test.options.fieldDressing && args.test.result.reversed)\n{\n\targs.test.data.result.SL = \"+\" + Math.min(1, Number(args.test.data.result.SL))\n\targs.test.result.other.push(`<b>${this.effect.name}</b>: SL limited to 1`)\n}","XPpHYTTT0hqYuSfa":"fromUuid(\"Compendium.wfrp4e-core.items.IAWyzDfC286a9MPz\").then(item => {\n   item = item.toObject()\n   this.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})\n})","XPxAKqPpPYE4E6B5":"args.fields.modifier -= 10 * this.effect.conditionValue","XRrGBbplNLZpXnCH":"let item;\nlet items = []\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.rOV2s6PQBBrhpMOv\")\n{\n    let data = item.toObject();\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.VUJUZVN3VYhOaPjj\")\n{\n    let data = item.toObject();\n    data.system.specification.value = 2\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.GbDyBCu8ZjDp6dkj\")\n{\n    let data = item.toObject();\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.a8MC97PLzl10WocT\")\n{\n    let data = item.toObject();\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\n{\n    let data = item.toObject();\n    data.system.specification.value = 1;\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")\n{\n    let data = item.toObject();\n    data.system.specification.value = 1;\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.fjd1u9VAgiYzhBRp\")\n{\n    let data = item.toObject();\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.mDgEMOoJpi8DkRYb\")\n{\n    let data = item.toObject();\n    items.push(data)\n}\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")\n{\n    let data = item.toObject();\n    data.system.specification.value = 2;\n    items.push(data)\n}\n\nthis.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect : this.effect.id})\n","XXnzUdsIYQ9Wjyu0":"return args.item?.system.attackType != \"ranged\" || args.flags.howlingWarpGale || this.actor.sameSideAs(this.effect.sourceActor)","XYaYeiVkc5GKYTjC":"return args.spell?.system.lore.value != \"fire\"","XcvDYNZgJ2rpAdDV":"\n                            let fatigued = this.actor.hasCondition(\"fatigued\")\n                            if (!fatigued)\n                            {\n                                this.actor.addCondition(\"fatigued\")\n                                ui.notifications.notify(\"Fatigued added to \" + this.actor.name + \" which cannot be removed until the Malaise symptom is gone.\")\n                            }","Xe8ijqWU3bbtq7ZY":"if (args.opposedTest.defenderTest.actor.Species.toLowerCase().includes(\"skaven\"))\n{\n    args.addImpact = true;\n    args.opposedTest.result.other.push(\"Impact against Skaven\")\n}","Xf4FcZ4ZLdWmOXBa":"return args.skill?.name != game.i18n.localize(\"NAME.Perception\") && !args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"));","XfRvVBTVIuAm8RaZ":"return args.item?.name != game.i18n.localize(\"NAME.CharmAnimal\")","XfSxXatjEYlPEbaK":"const broken = this.actor.hasCondition(\"broken\");\n\n//broken?.delete();","Xg4qHLsyXGuUZfT8":"this.actor.hasCondition(\"ablaze\")?.delete();","Xk9XPklxxTvFlwpI":"args.context.useOnesArgumentative = true;","XthZ3GCC3WhsEI2g":"args.update({light : {\n    \"dim\": 10,\n    \"bright\": 5,\n    \"alpha\": 0.5,\n    \"animation\": {\n        \"speed\": 4,\n        \"intensity\": 4,\n        \"type\": \"flame\",\n    },\n    \"color\": \"#ac9e6c\",\n}});","Xu5cED1MhT4ba7da":"args.fields.modifier += 10\n","XuFxKPYheYF4WMmQ":"return args.skill?.name != game.i18n.localize(\"NAME.Cool\");","Y27MmN5KFw45d5vQ":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {difficulty: \"challenging\"})\nawait test.roll();\nif (!test.succeeded)\n{   \n    let rollResult = await (await fromUuid(\"RollTable.GL7rKOEThauPUK0E\")).roll({allowInteractive : false});\n    let diseaseId = rollResult.results[0].documentId;\n    let disease = await fromUuid(\"Item.\"+diseaseId);\n    obj = disease.toObject();\n    this.actor.createEmbeddedDocuments(\"Item\", [obj]);\n}","Y6ppJBerpM3TtSic":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.g4Q6AtzZuo5iIvD4\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id});","Y7McxsHFeGhwQx0J":"this.actor.createEmbeddedDocuments(\"Item\", [foundry.utils.expandObject({\n    name : \"Ghostly Flame\",\n    type : \"weapon\",\n    img : this.effect.img,\n    system : {\n        \"weaponGroup.value\" : \"throwing\",\n        \"damage.value\" : \"SB + WPB\",\n        \"qualities.value\" : [{name : \"magical\"}],\n        \"equipped\" : true\n    }\n})], {fromEffect: this.effect.id})","Y8J66v8VTKUASGuK":"if (!this.actor.effects.find(e => e.isCondition))\n{\n\treturn this.script.notification(\"No Conditions on this Actor\")\n}\n\nlet choice = await ItemDialog.create(this.actor.effects.filter(i => i.isCondition), 1, \"Choose a Condition\")\n\nif (choice[0])\n{\n\tawait this.actor.removeCondition(choice[0].conditionId)\n}\n\nif (this.actor.effects.find(e => e.isCondition))\n{\n    return false; // Delete the effect if there are still conditions, otherwise, effect remains and provides the bonus\n}","YDANERWYHyJ2ACeo":"args.fields.modifier -= 25","YDqpKJVy8ijEKdLX":"return !(this.actor.attacker && (args.skill?.name.includes == `${game.i18n.localize(\"NAME.Melee\")} (${game.i18n.localize(\"SPEC.Basic\")})` || (args.type == \"weapon\" && args.item?.system.weaponGroup.value == \"basic\")))","YEBw2CzHYxsTpTy5":"return args.skill?.name == game.i18n.localize(\"NAME.Haggle\");","YFSgWRXel0bWE3EE":"return [\"ag\", \"ws\", \"bs\"].includes(args.characteristic) || args.skill?.name == game.i18n.localize(\"NAME.Climb\");","YHEIkBKWXKNPqglh":"if (args.test.result.castOutcome == \"success\")\n{\n    CorruptionMessageModel.createCorruptionMessage(\"moderate\", this.script.getChatData())\n}\n","YJX7WnxzXXIVdH6P":"let lore = await ValueDialog.create({text : \"Choose Lore\", title:  \"Lore\"}, \"\", {\"fire\" : \"Fire\", \"death\" : \"Death\", \"metal\" : \"Metal\", \"shadow\" : \"Shadow\"});\n\nlet filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = await ItemDialog.createFromFilters(filters, 6, {title : this.effect.name, text : \"Choose 6 Petty Spells\"})\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : [\"\"]\n    }\n]\n\nlet arcane = await ItemDialog.createFromFilters(filters, 12, {title : this.effect.name, text : \"Choose 12 Arcane Spells\"})\n\nlet items = petty.map(i => i.toObject()).concat(arcane.map(i => {\n    let spell = i.toObject();\n    spell.img = `modules/wfrp4e-core/icons/spells/${lore}.png`\n    spell.system.lore.value = lore;\n    return spell;\n}));\n\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","YMaxpXnml01bLGpO":"return args.item?.name.includes(game.i18n.localize(\"NAME.Stealth\"))","YN8719gme9AxYtyY":"let characteristics = {\n    \"ws\" : 10,\n    \"bs\" : 0,\n    \"s\" : 5,\n    \"t\" : 15,\n    \"i\" : 20,\n    \"ag\" : 15,\n    \"dex\" : 20,\n    \"int\" : 35,\n    \"wp\" : 30,\n    \"fel\" : 10\n}\nlet skills = [\"Channelling\", \"Cool\", \"Dodge\", \"Entertain (Storytelling)\", \"Intuition\", \"Language (Magick)\", \"Leadership\", \"Lore (Magic)\", \"Lore (Theology)\", \"Perception\"]\nlet skillAdvancements = [20, 25, 20, 25, 30, 25, 15, 20, 10, 30]\n\nlet talents = [\"Aethyric Attunement\", \"Instinctive Diction\", \"Instinctive Diction\", \"Luck\", \"Magical Sense\", \"Menacing\", \"Arcane Magic\", \"Petty Magic\", \"Second Sight\", \"Sixth Sense\"]\nlet trappings = [\"Hand Weapon\", \"Robes\", \"Quarterstaff\"]\nlet specialItems = [ \n    {name: \"Magic Item\", type: \"trapping\", trappingType: \"misc\" }, \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWFRP4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nlet ride = await foundry.applications.api.DialogV2.confirm({window : {title : \"Skill\"}, content : \"Add Chaos Steed and +20 Ride (Horse)?\"})\n\nif (ride)\n{\n    let skill = await game.wfrp4e.utility.findSkill(\"Ride (Horse)\")\n    skill = skill.toObject();\n    skill.system.advances.value = 20;\n    items = items.concat({name : \"Chaos Steed\", type: \"trapping\", \"system.trappingType.value\" : \"misc\"}, skill)\n}\n\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","YOKoZFlBEpFavfOS":"return args.type == \"channelling\"","YQ2LnLxp0xgy3meI":"if (args.test.preData.options?.corruption && args.test.failed) {\n  args.test?.result?.other.push(\"Gain additional +1 Corruption from \" + this.effect.name)\n}","YRUTliBzAQvncGNX":"this.actor.addCondition(\"fatigued\");\nthis.script.notification(\"Added Fatigued\")","YaKnYEbmmZZtByJc":"if (args.opposedTest.attackerTest.options.ballockKnife)\n{\n    args.weaponProperties.impale = true;\n    args.extraMessages.push(`<strong>${this.item.name}</strong>: Impale Added`)\n}","YdiQFkm8j48Xs7gI":"if (args.totalWoundLoss > 0 && args.opposedTest.attackerTest.result.critical && args.opposedTest.result.hitloc.value == \"head\") {\n    let brainRot = await fromUuid(\"Compendium.wfrp4e-lustria.items.Item.IsNQH867Y58pZgq6\");\n    args.test.targets[0].createEmbeddedDocuments(\"Item\", [brainRot], {fromEffect : this.effect.id});\n    this.script.scriptMessage(`${args.test.targets[0].name} has been infected by Brain Rot`);\n}","Yf2MmOzazzMdmoPU":"let armour = await fromUuid(\"Compendium.wfrp4e-core.items.VUJUZVN3VYhOaPjj\")\nlet armourData = armour.toObject()\narmourData.system.specification.value = 1\n \nlet fury = await fromUuid(\"Compendium.wfrp4e-core.items.fjd1u9VAgiYzhBRp\");\nlet furyData = fury.toObject();\n\nlet horns = await fromUuid(\"Compendium.wfrp4e-core.items.BqPZn6q3VHn9HUrW\")\nlet hornsData = horns.toObject()\nhornsData.system.specification.value = 6\n\nthis.actor.createEmbeddedDocuments(\"Item\", [armourData, furyData, hornsData], {fromEffect : this.effect.id})","YhhiWEQbox3WZA3Q":"return args.skill?.name == game.i18n.localize(\"NAME.Heal\") && game.combat?.active","YjAIsFlxKTJvYs60":"this.item.system.reduceQuantity();","YjJcRdytVRm88qLn":"args.context.additionalDamage = 1","YrXhk2YJaWSChMhp":"// Brawling management\nlet base = this.actor.characteristics.ws.value;\nlet melee = this.actor.has(\"Melee (Brawling)\", \"skill\");\nif (!melee) {\n  melee = await fromUuid(\"Compendium.wfrp4e-core.items.Item.jLyoyqwmBVPjRjhM\");\n  melee = melee.toObject();\n  melee.system.modifier.value = 55 - base;\n  await this.actor.createEmbeddedDocuments(\"Item\", [melee], {fromEffect : this.effect.id});\n} else {\n  //this.actor.updateEmbeddedDocuments(\"Item\", { _id: melee.id, 'system.modifier.value': 55-base});\n  await this.effect.update({\"flags.wfrp4e.fistsOfGork\" : 55 - base})\n}\n\n// Weapon management\nbase = this.actor.characteristics.s.bonus;\nweapon = await fromUuid(\"Compendium.wfrp4e-core.items.Item.AtpAudHA4ybXVlWM\");\nweapon = weapon.toObject();\nweapon.name = \"Fists of Gork\";\nweapon.img = this.effect.img;\nweapon.system.rollable.skill = \"Melee (Brawling)\";\nweapon.system.specification.value = 9 - base;\nawait this.actor.createEmbeddedDocuments(\"Item\", [weapon], {fromEffect : this.effect.id});\n\n//this.script.scriptMessage(`${this.actor.name} now has Melee (Brawling) 55 and Weapon (Fists) +9`);","YsS2RZsl2ZsqjhWV":"return !args.fields.charging","YsUdMhQ2AArcJIqy":"let choice1 = [\n    {\n        type: \"trait\",\n        name: \"Corruption (Minor)\",\n        diff : {\n            system : {\n                specification : {\n                    value : \"Minor\"\n                }\n            }\n        }\n    },\n    {\n        type: \"trait\",\n        name: \"Infected\",\n    },\n    {\n        type: \"trait\",\n        name: \"Territorial\",\n    }\n]\n\nlet updateObj;\nlet actor;\n\nasync function addTrait(c) {\n    let items = [];\n    let existing;\n    if (c.type == \"trait\") {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type);\n    }\n    if (!existing) {\n        let item = await game.wfrp4e.utility.find(c.name, c.type);\n        if (item) {\n            item = item.toObject();\n            foundry.utils.mergeObject(item, c.diff);\n            items.push(item);\n        }\n        else\n            ui.notifications.warn(`Could not find ${c}`, { permanent: true });\n    }\n    actor.createEmbeddedDocuments(\"Item\", items);\n}\n\nasync function dialogChoice() {\n    for (let c of choice1) \n    {\n        if (await foundry.applications.api.DialogV2.confirm({window : {title: \"Option\"}, content:`<p>Add Option?</p><ol><li>${c.name}</li></ol>`}))\n        {\n            addTrait(c)\n            c.valid = true;\n        }\n    }\n}\nupdateObj = this.actor.toObject();\nactor = this.actor\nawait dialogChoice();\n\n","YwLEw4BiKq4EMy57":"let i_gain = (await new Roll(\"2d10\").roll()).total\nlet fel_gain = 0\nif (args.actor.characteristics.fel.value <= 0)\n{\n   fel_gain += (await new Roll(\"2d10\").roll()).total\n}\n\nlet msg = `<b>${this.actor.prototypeToken.name}</b> gains ${i_gain} Intelligence`\n\nif (fel_gain)\n   msg += ` and ${fel_gain} Fellowship`\n\n\nlet newInt = i_gain + args.actor.characteristics.int.modifier\nlet newFel = fel_gain + args.actor.characteristics.fel.modifier\n\nargs.actor.update({\"system.characteristics.int.modifier\" : newInt, \"system.characteristics.fel.modifier\" : newFel})\n\nthis.script.message(msg)","YyKU2rIRmFSCqSlW":"let newEffect = this.effect.sourceItem.effects?.contents[1]\n\nif (newEffect)\n{\n    this.actor.createEmbeddedDocuments(\"ActiveEffect\", [newEffect.convertToApplied()]);\n}","YySjPfSAPdMAfjsh":"let talents = [\"Berserk Charge\", \"Combat Aware\", \"Combat Reflexes\", \"Furious Assault\", \"Implacable\", \"Magic Resistance\", \"Resistance (Magic)\", \"Resolute\", \"Strike Mighty Blow\", \"Warrior Born\"];\nlet currentCareer = this.actor.system.currentCareer;\n\nif (!currentCareer) return;\n\nfor (let talent of talents) {\n  if (currentCareer.system.talents.includes(talent))\n    continue;\n  currentCareer.system.talents.push(talent);\t\n}\n\n","Z1zriXibT0mAmdhb":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.BqPZn6q3VHn9HUrW\")\nitem = item.toObject()\nitem.name = this.effect.name\nitem.system.specification.value = this.actor.characteristics.s.bonus\nitem.system.description.value = \"\"\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","Z30zYayPryXOjT5N":"args.item.system.damage.value = \"SB + 6\";","Z41L3MwOpJdAjVaj":"if (args.actorsystem.details.move.sail.value > 0)\n  args.actor.system.details.move.sail.value -= 2;\n","Z4WrrlVGpPY4iUbG":"await this.actor.addCondition(\"ablaze\")","Z52yZDm6lP6fOP3O":"let ablaze = this.actor.hasCondition(\"ablaze\")\nif (ablaze)\n{\n    this.script.notification(\"Immune to Ablaze\");\n    ablaze.delete()\n}","Z6OmmC0irJzxSnMH":"let chatData = { whisper: ChatMessage.getWhisperRecipients(\"GM\") }\nlet message = \"\"\n\nlet wounds = foundry.utils.duplicate(this.actor.status.wounds)\nlet regenRoll = await new Roll(\"1d10\").roll({allowInteractive : false});\nlet regen = regenRoll.total;\n\nif (wounds.value >= wounds.max)\n    return\n\nif (wounds.value > 0) \n{\n    wounds.value += regen\n    if (wounds.value > wounds.max)\n    {\n        wounds.value = wounds.max\n    }\n    message += `<b>${this.actor.name}</b> regains ${regen} Wounds.`\n\n    if (regen == 10)\n    {\n        message += `<br>Additionally, they regenerate a Critical Wound.`\n    }\n}\nelse if (regen >= 8) \n{\n    message += `<b>${this.actor.name}</b> rolled a ${regen} and regains 1 Wound.`\n    wounds.value += 1\n    if (regen == 10)\n    {\n        message += `<br>Additionally, they regenerate a Critical Wound.`\n    }\n}\nelse \n{\n    message += `<b>${this.actor.name}</b> Regenerate roll of ${regen} - No effect.`\n}\n\nawait this.actor.update({ \"system.status.wounds\": wounds })\nthis.script.message(message, { whisper: ChatMessage.getWhisperRecipients(\"GM\") })\n\nif (this.actor.Species?.toLowerCase() != \"ogre\")\n{\n   this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name, fields : {difficulty : \"average\"}}).then(test => {\n       test.roll()\n   })\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","Z6jNlyZMECkW4Hon":"let spells = await warhammer.utility.findAllItems(\"spell\", \"Loading Spells\", true);\n\nlet choice = await ItemDialog.create(spells, 1);\n\nif (choice[0])\n{\n    this.script.message(`Chose @UUID[${choice[0].uuid}]{${choice[0].name}}`)\n    let spell = (await fromUuid(choice[0].uuid)).toObject(); // Might be an index so retrieve item object for sure\n    foundry.utils.setProperty(spell, \"flags.wfrp4e.boonOfTzeentch\", true);\n    spell.system.wind.value = \"Channelling (Dhar)\";\n    spell.system.memorized.value = true;\n    this.actor.createEmbeddedDocuments(\"Item\", [spell], {fromEffect: this.effect.id})\n}","ZCBcwbVFHFTFRntb":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpentry)';\nconst difficulty = 'easy';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      \n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","ZCkYe5XMVY1RWMXG":"args.context.wallcrawler = true;","ZCrfdLPOxiNDCDSg":"this.actor.effects.get(this.effect.id).delete(); // can't use this.effect because it thinks it's parent is the item, but it actually is the actor","ZCuOjLAeENKN1Q4L":"let halve;\nif (args.opposedTest.attackerTest.item?.type != \"spell\")\n{\n    halve = await foundry.applications.api.DialogV2.confirm({window : {title : this.effect.name}, content : \"Halve Damage? (Halves Damage from all fire)\"})\n}\nelse\n{\n    halve = args.opposedTest.attackerTest.item?.system.lore?.value == \"fire\";\n}\n\nif (halve)\n{\n    args.totalWoundLoss /= 2;\n    args.modifiers.other.push({label : this.effect.name, details : \"Halved\", value : \"× 0.5\"})\n}","ZEXhYJqqxF6QAixX":"return args.context.terror || args.extendedTest?.getFlag(\"wfrp4e\", \"fear\");","ZEdDcBka21rnMuz5":"let initiativeSetting = game.settings.get(\"wfrp4e\", \"initiativeRule\")\n\nswitch (initiativeSetting) {\n  case \"default\":\n    args.initiative += \"+10\"\n    break;\n\n  case \"sl\":\n    args.initiative += \"+1\"\n    break;\n\n  case \"d10Init\":\n    args.initiative += \"+10\"\n    break;\n\n  case \"d10InitAgi\":\n    args.initiative += \"+1\"\n    break;\n}","ZGlJnrIemqul24j7":"let infected = await fromUuid(\"Compendium.wfrp4e-core.items.V0c3qBU1CMm8bmsW\")\nlet bite = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet biteData = bite.toObject();\nlet infectedData = infected.toObject();\n\nbiteData.system.specification.value = 4 - this.actor.characteristics.s.bonus\n\nthis.actor.createEmbeddedDocuments(\"Item\", [biteData, infectedData], {fromEffect : this.effect.id})","ZI2YnAAGoLpmVDIL":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.aE3pyW20Orvdjzj0\")\nlet data = item.toObject();\ndata.system.specification.value = \"Religion\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","ZJy2rvpKmUHXGrAi":"args.actor.details.move.run *= 1.5","ZLspFT2I3ZdWWr2H":"return args.skill?.name !== game.i18n.localize(\"NAME.Leadership\");","ZMwJad6v4G13SgjR":"return args.type == \"cast\" || args.type == \"channelling\"","ZNW3ubbKIYXAyE48":"let wounds = this.actor.itemTypes.disease.filter(i => i.name == \"Festering Wound\" && i.system.duration.active);\nlet selected;\nif (wounds.length == 0)\n{\n    return this.script.notification(\"No Festering Wounds!\");\n}\nelse if (wounds.length == 1)\n{\n    selected = wounds[0];\n}\nelse if (wounds.length >= 2)\n{\n    selected = (await ItemDialog.create(wounds, 1))[0];\n}\n\nif (selected)\n{\n    let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"average\"}})\n    await test.roll();\n    if (test.succeeded)\n    {\n        let SL = parseInt(test.result.SL);\n        if (SL >= 0)\n        {\n            selected.update({\"system.duration.value\" : selected.system.duration.value - SL})\n            this.script.message(`<strong>${selected.name}</strong> duration reduced by ${SL}!`)\n        }\n    }\n}","ZNu4B0OdjkM9lmtu":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.9h82z72XGo9tfgQS\")\nlet data = item.toObject();\ndata.name = data.name += \" (Vision)\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","ZOgtDW3mkTfeyc5M":"args.actor.system.details.price.gc += args.actor.system.details.price.gc * 0.1;","ZRoG7GiMDQWso6gN":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpentry)';\nconst difficulty = 'difficult';\nconst target = 30;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      \n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","ZTE8LdRblyG4yYoE":"if (args.test.result.castOutcome == \"success\")\n{\n    // Wait till after chat card is posted\n    warhammer.utility.sleep(500).then(() => {\n        game.wfrp4e.utility.postTerror(1, this.effect.name)\n        game.wfrp4e.utility.postTerror(2, this.effect.name)\n    })\n}","ZURBQYTYcP5jci5k":"const broken = this.actor.hasCondition(\"broken\");\n\nbroken?.delete();","ZYsMgB4BwXBJcpYf":"// The wearer of the cloak causes Fear 2 \n// in Wolves, Lions, Goats, and Chimeras.\ngame.wfrp4e.utility.postFear(2, this.effect.name)\n","ZbuW8y7t9Y8oUFWq":"return !((args.type == \"weapon\" && (args.item.system.weaponGroup.value == \"blackpowder\" || args.item.system.weaponGroup.value == \"engineering\")) || (args.type == \"cast\" && args.item.system.lore.value == \"fire\"))","ZdHvGvSJBsIuPphF":"return !args.data.dualWieldingOption && !args.context.dualWieldOffhand","Ze9E2zR1GFGWGMVH":"return [game.i18n.localize(\"NAME.PickLock\"), game.i18n.localize(\"NAME.SleightOfHand\"), `${game.i18n.localize(\"NAME.Channelling\")} (Ulgu)`].includes(args.skill?.name)","ZgF1sYdbAKaOuHmK":"return args.skill?.name !== game.i18n.localize(\"NAME.Charm\");","ZhuitY1KOU1Xe7cP":"return !args.weapon?.system.properties.qualities.pummel","ZqTW093qENOwGONP":"let msg = \"\"\n\nlet SL = parseInt(this.effect.sourceTest.result.SL);\n\nfor(let i = 0; i < SL; i++)\n{\n    msg += `<p>${await this.actor.applyBasicDamage(3, {suppressMsg : true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP})}</p>`\n}\n\nthis.script.message(msg);","ZrePyV2spv3v65Tg":"return args.type != \"weapon\" && !this.actor.statuses.has(\"infighting\")","ZsOHDb7XwmuUUWPL":"return args.characteristic === 'fel';","ZsQR3AVKi0v5U593":"args.actor.addCondition(\"ablaze\", 2)","ZuoIVv3nmlGhhdx0":"let rating = parseInt(this.effect.name.match(/\\d+/)?.[0]) || 1;\nlet holed = this.actor.flags.holed || {holed: 0};\nholed.holed += rating;\nthis.actor.flags.holed = holed;\n","ZvbBM4gTJHPdU8jU":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\nawait test.roll();\nreturn test.failed","Zxh4RAENoaAQAaNg":"return !this.actor.flags.useless.rEye || !this.actor.flags.useless.lEye || [\"wp\", \"t\", \"s\"].includes(args.characteristic)","ZxtOdwsM2Sqj9Zam":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")\nlet data = item.toObject();\ndata.system.specification.value = 0\ndata.name = this.effect.name;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","a02tlRCXpaoaDjSN":"let careers = await warhammer.utility.findAllItems(\"career\", \"Loading Careers\", true);\ncareers.forEach(c => {\n    if (!c.id)\n    {\n        c.id = c._id;\n    }\n});\nlet choice = await ItemDialog.create(careers, 1, {text : \"Choose Double Life Career\", title : this.effect.name, indexed : true});\nif (choice[0])\n{\n    let career = choice[0];\n    let data = career.toObject();\n    foundry.utils.setProperty(data, \"flags.wfrp4e.doubleLife\", true);\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n    this.effect.updateSource({name : this.effect.setSpecifier(data.name)})\n}\n","a0YU3whUm16wGBNu":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"average\"}})\nawait test.roll();\n\nif (test.failed)\n{\n    this.actor.addCondition(\"fatigued\");\n}","a4Aza4a9v8JMU8dC":"const talents = await Promise.all([game.i18n.localize(\"NAME.Frenzy\"), game.i18n.localize(\"NAME.MagicResistanceTalent\")].map(game.wfrp4e.utility.findTalent))\nthis.actor.createEmbeddedDocuments(\"Item\", talents, {fromEffect : this.effect.id})","a6gacHsvgwtsIFSQ":"if (args.test.item && args.test.item.name == game.i18n.localize(\"NAME.Research\"))\n    args.test.preData.canReverse = true","a7pEvCycVnFBXGAQ":"let test = await this.actor.setupCharacteristic(\"i\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"easy\"}})\nawait test.roll();\n\nif (!test.succeeded)\n{\n\tthis.actor.addCondition(\"stunned\");\n}","a8RabrnJ08O07rDX":"if (args.totalWoundLoss > 0)\n{\n    // I'm assuming the endurance test specified is for the end-round check\n    await args.actor.addCondition(\"poisoned\", 2);\n}","a8i0sA1RBnD8nHZt":"let caster = this.effect.sourceActor\nlet targetedItem = this.effect.system.itemTargets[0];\n\nlet qualities = foundry.utils.deepClone(game.wfrp4e.config.itemQualities);\nlet flaws = foundry.utils.deepClone(game.wfrp4e.config.itemFlaws);\n\nif (targetedItem.type == \"weapon\")\n{\n    foundry.utils.mergeObject(qualities, game.wfrp4e.config.weaponQualities)\n    foundry.utils.mergeObject(flaws, game.wfrp4e.config.weaponFlaws)\n}\nelse if (targetedItem.type == \"armour\")\n{\n    foundry.utils.mergeObject(qualities, game.wfrp4e.config.armorQualities)\n    foundry.utils.mergeObject(flaws, game.wfrp4e.config.armorFlaws)\n}\n\nfor(let q in qualities)\n{\n    // If the weapon already has a flaw, don't put it in the dialog\n    if (targetedItem.system.properties.qualities[q])\n    {\n        delete qualities[q]\n    }\n}\nfor(let f in flaws)\n{\n    // If a weapon doesn't have a flaw, don't put it in the dialog\n    if (!targetedItem.system.properties.flaws[f])\n    {\n        delete flaws[f]\n    }\n}\n            \nlet added = await ItemDialog.create(ItemDialog.objectToArray(qualities), \"unlimited\", \"Choose Qualities to add\");\nlet removed = []\nif (!foundry.utils.isEmpty(flaws))\n{\n    removed = await ItemDialog.create(ItemDialog.objectToArray(flaws), \"unlimited\", \"Choose Flaws to remove\");\n}\n\nthis.effect.updateSource({\"flags.wfrp4e.propertiesChanged\" : {added : added.map(i => i.id), removed : removed.map(i => i.id)}})\n","aAvJrAKLzXhS9qN6":"return args.item?.name == game.i18n.localize(\"NAME.Climb\")","aCVtaW8ag1WibcAr":"args.attacker.modifyWounds(1)\nthis.script.message(`<strong>${args.attacker.prototypeToken.name}</strong> recovers 1 Wound.`)","aIYUsBIDKWJ3CEtj":"this.script.message(await this.actor.applyBasicDamage(20, {suppressMsg: true}));","aMHGjWyn6BXCI4pw":"let frenzy = await fromUuid(\"Compendium.wfrp4e-core.items.Item.hXcfygzujgyMN1uI\");\nthis.actor.createEmbeddedDocuments(\"Item\", [frenzy], {fromEffect: this.effect.id})","aPZiVhgwR0Xql6AM":"let effectsToEnable = this.actor.items.filter(i => i.type == \"disease\").reduce((effects, item) => effects.concat(item.effects.contents), []).concat(this.actor.effects.contents.filter(i => i.isCondition)).filter(i => i.disabled);\n\nif (effectsToEnable.length)\n{\n    this.script.notification(`Re-enabling ${effectsToEnable.map(i => i.name).join(\", \")}.`);\n    effectsToEnable.forEach(i => i.update({disabled : false}))\n}","aRvJUcgYqhRmmWYC":"this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.e3McIND4Rrsn5cE6\", this.effect, {\"system.advances.value\" : 1}, {skipExperienceChecks : true})","abLWYtNTu1UVDQAs":"if (args.opposedTest.result.hitloc.value == this.effect.flags.wfrp4e.location) // e.g. 'head', rLeg, 'lArm'\n{\n     this.message(`Gains a @Condition[Blinded] condition as their <strong>${this.item.name}</strong> was hit`);\n     this.actor.addCondition(\"blinded\");\n}","abVIvJBzuskNzCQv":"let amount = this.effect.sourceTest.result.overcast.usage.other.current;\n\nlet sss = await fromUuid(\"Compendium.wfrp4e-core.items.MGEPI4jNhymNIRVz\");\nlet strider = await fromUuid(\"Compendium.wfrp4e-core.items.1dUizIgLBgn4jICC\");\n\nlet items = Array(amount).fill(sss).concat(Array(amount).fill(strider))\n\nthis.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect: this.effect.id})","aeBetniKqq5SD9Ou":"let characteristics = {\n    \"ws\" : 30,\n    \"bs\" : 20,\n    \"s\" : 20,\n    \"t\" : 25,\n    \"i\" : 20,\n    \"ag\" : 0,\n    \"dex\" : 0,\n    \"int\" : 30,\n    \"wp\" : 40,\n    \"fel\" : 30\n}\nlet skills = [\"Intimidate\", \"Language (Classical)\", \"Leadership\", \"Lore (Warfare)\", \"Lore (History)\", \"Perception\"]\nlet skillAdvancements = [20, 30, 20, 30, 20, 20]\nlet talents = [\"Combat Aware\", \"Combat Reflexes\", \"Drilled\", \"Menacing\", \"Robust\", \"Strike Mighty Blow\", \"Strike Mighty Blow\", \"War Leader\"]\nlet trappings = [\"Hand Weapon\", \"Plate Breastplate\", \"Plate Helm\", \"Plate Leggings\"]\nlet specialItems = [ \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWFRP4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nconsole.log(\">>>>>>><\", items)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","afdmOvPGMpEdZvCb":"return (args.skill?.name == game.i18n.localize(\"NAME.Perception\") || args.characteristic == \"fel\")","agsm3NI1NDtHRG4y":"this.actor.getActiveTokens().forEach(t => t.document.update({texture : this.actor.prototypeToken.texture}, {animate : false}));","ahbA7o5G9dzMFl76":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.SfUUdOGjdYpr3KSR\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","alJgj25l3239h2SW":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.hTgrGkWnmIR4xhVe\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","araS9qYWOAVrV8F7":"args.actor.system.details.man -= 3;\nargs.actor.system.details.move.value -= 2;","ayIbw2Vw2t9xg33P":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.EaqlLRQigwnsEAXX\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","b1zMefdoZYtzCm7i":"return [\"roll\", \"none\"].includes(args.fields.hitLocation) || args.item?.attackType != \"ranged\"","b2Kb4IuD22RhKhR0":"let actor = Array.from(game.user.targets)[0]?.actor;\n\nif (actor)\n{\n    actor.applyEffect({effectUuids : this.effect.sourceItem.effects.contents[0].uuid})\n}\nelse\n{\n    this.script.notification(\"No target!\", \"error\")\n}","b2WaqRna5CFXmbDG":"args.context.stag = true;","b4CIeJF2L4E1qikC":"return !args.skill","b5DfAWtpV1x2R8If":"this.script.message(await this.actor.applyBasicDamage(this.effect.sourceTest.result.damage, {suppressMsg: true}))","b5prg1FLjCAvBjLy":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.zyocWSzEZEC826NS\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data])\n\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty: \"hard\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    await this.actor.addCondition(\"prone\")\n    await this.actor.addCondition(\"stunned\")\n}","b787rIfyHF5LnALd":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.HbrwGhUl0ZXz4kLA\")\nlet hardy = item.toObject();\n\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.Item.VUJUZVN3VYhOaPjj\")\nlet armour = item.toObject();\narmour.system.specification.value = 1;\nthis.actor.createEmbeddedDocuments(\"Item\", [armour, hardy], {fromEffect : this.effect.id});","b8G4cjfn3RG2tEYX":"this.actor.addCondition(\"ablaze\", 3);","b8XFmEUu1d2YNQ7F":"const {targetUuid, characteristicsToSwap} = this.effect.flags.wfrp4e;\n\nif (!characteristicsToSwap) return;\n\nconst target = fromUuidSync(targetUuid);\n\nif (!target) return;\n\nfor (const char of characteristicsToSwap) {\n  args.actor.system.characteristics[char].advances = target.system.characteristics[char].advances;\n  args.actor.system.characteristics[char].bonus = target.system.characteristics[char].bonus;\n  args.actor.system.characteristics[char].bonusMod = target.system.characteristics[char].bonusMod;\n  args.actor.system.characteristics[char].calculationBonusModifier = target.system.characteristics[char].calculationBonusModifier;\n  args.actor.system.characteristics[char].initial = target.system.characteristics[char].initial;\n  args.actor.system.characteristics[char].modifier = target.system.characteristics[char].modifier;\n  args.actor.system.characteristics[char].value = target.system.characteristics[char].value;\n}","bBdXzBmxgFFBwMMS":"if(args.opposedTest.attackerTest.item?.isRanged && args.applyAP && !args.sureShot)\n{\n   if (args.modifiers.ap.value)\n   {\n    args.sureShot = true;\n    args.modifiers.ap.details.push(`${this.effect.name} (Ignore ${this.item.Advances})`)\n    args.modifiers.ap.ignored += this.item.Advances;\n   }\n}","bDS62ctjfnTU4xIu":"return args.skill.name !== game.i18n.localize(\"NAME.Leadership\")","bEVlJOOA1kLlzpWx":"let characteristics = {\n    \"ws\" : 10,\n    \"bs\" : 0,\n    \"s\" : 5,\n    \"t\" : 15,\n    \"i\" : 20,\n    \"ag\" : 15,\n    \"dex\" : 20,\n    \"int\" : 35,\n    \"wp\" : 30,\n    \"fel\" : 10\n}\nlet skills = [\"Channelling\", \"Cool\", \"Dodge\", \"Entertain (Storytelling)\", \"Intuition\", \"Language (Magick)\", \"Leadership\", \"Lore (Magic)\", \"Lore (Theology)\", \"Perception\"]\nlet skillAdvancements = [20, 25, 20, 25, 30, 25, 15, 20, 10, 30]\nlet talents = [\"Aethyric Attunement\", \"Arcane Magic\", \"Instinctive Diction\", \"Instinctive Diction\", \"Luck\", \"Magical Sense\", \"Menacing\", \"Petty Magic\", \"Second Sight\", \"Sixth Sense\"]\nlet trappings = [\"Hand Weapon\", \"Quarterstaff\", \"Ritual Dress incorporating many ingredients and fetishes\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        items.push({name : trapping, type : \"trapping\", \"system.trappingType.value\" : \"clothingAccessories\"})\n        //ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","bL98Sr1TRLMPEdlk":"if (args.test.failed)\n{\n\tthis.actor.addCondition(\"fatigued\");\n}","bLkt8VpTTPoTxW0W":"if (args.opposedTest.result.hitloc.value == \"body\" && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 1);\n    this.script.notification(\"Added Bleeding\")\n}\n","bMEFHPCei2evnZZw":"// Victims that take at least 1 Wound from a Fell Dagger\n// immediately take a Poisoned Condition \n// resisted with a Difficult (-10) Endurance Test. \n\n// TODO: Add Venom strength to message\n\nif (args.totalWoundLoss > 0) \n{\n  args.actor.addCondition(\"poisoned\")\n  this.script.message(`\n      <strong>${this.effect.name}</strong>:<br>\n      <strong>${args.actor.name}</strong> has been given a @Condition[Poisoned] Condition, which can be resisted with a <strong>Difficult (-10) Endurance</strong> Test.`, \n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")})\n}\n","bQyVajMN1ETwlzvM":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.aE3pyW20Orvdjzj0\")\nlet data = item.toObject();\nlet target = await game.wfrp4e.tables.rollTable(\"fixations\")\nif (target)\n{\n    data.system.specification.value = target.result\n    this.script.notification(target.result);\n}\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","bRiFHPC1StKxqNIC":"if (isNaN(parseInt(this.item.system.specification.value))) {\n  let value = await ValueDialog.create({title : \"Sturdy Value\", text : \"Enter the Sturdy value\"});\n  if (value) {\n    this.item.updateSource({\"system.specification.value\" : value});\n  }\n}","bRtZH0xRh8dgqMeW":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.BqPZn6q3VHn9HUrW\")\nlet data = item.toObject();\ndata.system.specification.value = 7 - this.actor.characteristics.s.bonus\ndata.name = item.name.replace(\"(Feature)\", \"\");\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","bWr8leucbWslBCYG":"return args.characteristic != \"s\"","bgLeMqihLya2iobP":"const river = this.actor.itemTags.template.find(t => t.name === \"River Troll\");\n\nif (!river) { \n  args.options.abortItemCreation = true;\n  this.script.notification(\"Can only be applied to River Troll.\", 'warning');\n}","bh2qDCKiAIWM0UPi":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"))","bhXUW7IJtEaUGAoV":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();  \nif (test.failed)\n{\n    this.actor.addCondition(\"prone\");\n}\n  ","bidoOQSAofp4NPf6":"return args?.skill?.name !== game.i18n.localize(\"NAME.Cool\")","bkbWgG9COvZWZbAX":"args.context.addChargingDice = true;","brNRqfpPqD2Ki0cM":"args.prefillModifiers.modifier -= 10","btPrQkGRKUkhNe3N":"return args.skill?.name == \"Trade (Apothecary)\"","bwtQOSWn120NICkf":"let test = await this.actor.setupCharacteristic(\"ag\", {fields : {difficulty : \"hard\"}});\nawait test.roll();\n\nif (test.failed)\n{\n   await this.actor.addCondition(\"bleeding\")\n   await this.actor.addCondition(\"entangled\")\n}","bwx9wuEOJPF7btD1":"return args.skill?.name != game.i18n.localize(\"NAME.Navigation\");","bzaoWcieMFaU5B5l":"return !this.actor.flags.useless[this.item.system.location.key] || [\"fel\", \"wp\", \"int\", \"t\"].includes(args.characteristic)","c31hjp7k0hlpdGBC":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.yRhhOlt18COq4e1q\");\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","c3KA1knL2NYNUEww":"return args.skill?.name != game.i18n.localize(\"NAME.Evaluate\");","c7HTWfg3CbjN9e1M":"this.actor.name = this.actor.name.replace(\"Common Troll\", \"Troll\");","c9xxdOCaQSwooK8n":"if (!this.actor.has(\"Blessing of Battle\",\"prayer\")) this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.ElmLfnrXliStS9CP\", this.effect)","cAKqUBuJBsU85erO":"return args.skill?.name !== game.i18n.localize(\"NAME.Stealth\");","cAioHYtlxuOCwRLh":"let ablaze = Number(args.opposedTest.attackerTest.result.SL) + 1\nargs.actor.addCondition(\"ablaze\", ablaze)","cApfxL7Ic0NKdoSr":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.rOV2s6PQBBrhpMOv\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","cBSy9CR5NZvcLRg8":"\n        args.prefillModifiers.modifier += 0;\n        args.prefillModifiers.slBonus += 0;\n        args.prefillModifiers.successBonus += 0;\n        ","cDBhmHn5kjgWBAlT":"let num = (this.effect.sourceTest.result.overcast.usage.other.current || 1)\n\nthis.actor.addCondition(\"entangled\", num)","cEg09bnvZD6Ysnpc":"let item = await fromUuid(\"Compendium.wfrp4e-archives2.items.anIlqJXFOIEzIOo1\")\nlet data = item.toObject();\ndata.name = this.item.name;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","cJFDnq1HI4gXWcJo":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create({text: \"Enter Ward value\", title : this.effect.name});\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","cK1Jysfu5IMUUH0C":"if (!args.ward)\n{\n\targs.ward = (this.effect.getFlag(\"wfrp4e\", \"ward\") || 0);\n\tif (args.wardRoll >= args.ward && args.ward > 3)\n    {\n        let newWard = Math.max(3, args.ward - 1)\n        this.script.message(\"<strong>Ward</strong> improved to \" + newWard)\n        this.effect.setFlag(\"wfrp4e\", \"ward\", newWard)\n    }\n\n}","cOuukVo8WakDZIUj":"args.prefillModifiers.slBonus += 1","cTYNaKbepMwqYsZ8":"\n                            let difficulty = \"\"\n                            if (this.effect.name.includes(\"Moderate\"))\n                                difficulty = \"easy\"\n                            else if (this.effect.name.includes(\"Severe\"))\n                                difficulty = \"average\"\n                            else\n                                difficulty = \"veasy\"\n        \n                            let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {context : {failure : this.actor.name + \" dies from Blight\"}, fields: {difficulty}, appendTitle : \" - Blight\"})\n                            await test.roll();\n                            if (test.failed)\n                            {\n                                this.actor.addCondition(\"dead\");\n                            }\n                            ","cUFCL02JoaZObRcX":"let sl = this.effect.sourceTest.result.slOver;\n\nthis.actor.system.characteristics.s.modifier += sl * 10;\nthis.actor.system.characteristics.s.calculationBonusModifier -= sl;","cUnbADgOQ4fMKgrH":"let group\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.5hH73j2NgPdsLCZN\");\nlet data = item.toObject();\n\nif (this.item.name.includes(\"(\"))\n{\n\tgroup = this.item.parenthesesText\n}\n\nelse \n{\n\tgroup = await ValueDialog.create({text : \"Enter Hatred Group\", title : \"Hatred Group\"})\n\n\tthis.item.updateSource({name : this.item.name + ` (${group})`, \"system.tests.value\" : this.item.system.tests.value.replace(\"Group\", group)})\n\tthis.effect.updateSource({name : this.effect.name + ` (${group})`})\n}\n\n\ndata.name = data.name.replace(\"Target\", group);\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id});","cV9JiAgUPOeUHKnS":"args.fields.successBonus++;\nif (args.skill?.name != game.i18n.localize(\"NAME.SleightOfHand\"))\n{\n    args.fields.modifier += 10;\n}","cYPIXzl86a3LFsTE":"if (args.item.type == \"spell\")\n{\n   args.item.cn.value -=2\n   if (args.item.cn.value < 0)\n      args.item.cn.value = 0\n}","cZVrzR4fxV86lxNW":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.yrkI7ATjqLPDTFmZ\")\nlet res = item.toObject();\nres.system.specification.value = 1;\n\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.Item.mNoCuaVbFBflfO6X\")\nlet ss = item.toObject();\nawait this.actor.createEmbeddedDocuments(\"Item\", [res, ss], {fromEffect : this.effect.id})","cgmA2N0MkjA7qIZy":"return args.type != \"cast\" || args.item?.system.lore?.value != \"shadow\"","ch5SD2XOQfcYo0X5":"if (args.sizeDiff <= -2 && args.opposedTest.attackerTest.result.critical)\n        args.damageMultiplier = Math.abs(args.sizeDiff)\n\n      let sBonusDiff = args.opposedTest.defenderTest.actor.characteristics.t.bonus - args.opposedTest.attackerTest.actor.characteristics.s.bonus\n     let weapon = args.opposedTest.attackerTest.item\n      if (sBonusDiff > 0 && weapon && weapon.damage.value.includes(\"SB\"))\n      {\n        args.damage += sBonusDiff\n        args.breakdown.other.push({label : this.effect.name, value : sBonusDiff});\n      }","chUpiI3el8IO8MSs":"if (args.opposedTest.attackerTest.item?.name.includes(\"Bite\"))\n{\n    let woundsGained = args.totalWoundLoss;\n    this.script.message(`Gains ${woundsGained} Wounds`, { whisper: ChatMessage.getWhisperRecipients(\"GM\") })\n    this.actor.modifyWounds(woundsGained)\n}","cipTp0OS2bfKLjZS":"if (args.totalWoundLoss > 0) {\n    await args.actor.addCondition(\"bleeding\")\n    await args.actor.addCondition(\"poisoned\")\n}","ckKbPfaTiQ2qBZdR":"console.log(\"DAMAGE\", this)","cqYgZQk1C3kMARy5":"return args.skill?.name !== game.i18n.localize(\"NAME.Haggle\");","csLKDJKZaUK9vwLT":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.7rBhIRo96Mydo0Cv\")\nlet data = item.toObject();\ndata.system.location.value = \"Back\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n","ct6WGaRMfrcnHhyv":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\ndata.system.specification.value = 2;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","cuqCtQsfLBBAGjnu":"args.fields.slBonus -= (Number(this.item.specification.value) || 0)","cysQDjlDzT8HdNeo":" args.prefillModifiers.slBonus += 1","d29mu8vRt9AQUm0L":"this.actor.characteristics.i.value = Math.min(this.actor.characteristics.i.value, 10);\nthis.actor.characteristics.i.bonus = 1;\n\nfor(let skill of this.actor.itemTypes.skill.filter(i => i.system.characteristic.value == \"i\"))\n{\n    skill.system.total.value= Math.min(skill.system.total.value, 10)\n}","d6mVm08o8SeklAcW":"this.actor.system.status.ward.value = 9;","d9iU08yvqcffF026":"return args.weapon.system.usesHands.includes(this.effect.getFlag(\"wfrp4e\", \"location\"))","dAMtbn3uQwF8KpKU":"return args.skill?.name != game.i18n.localize(\"NAME.Charm\") && args.skill?.name != game.i18n.localize(\"NAME.Gossip\");","dIxYt421K010eogY":"\n                            let modifier = 0\n                            if (this.effect.name.includes(\"Moderate\"))\n                                modifier = -20\n                            else\n                                modifier = -10\n                            args.fields.modifier += modifier\n                            ","dM449AU0FQRnOc3l":"if (args.opposedTest.result.hitloc.value == \"head\")\n{\n  args.abort = \"Missed - Headless\"\n}","dM8FbRH2V8CpOkXw":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.QluSTTTq3viHJJUh\")\nlet data = item.toObject();\ndata.system.location.value = \"Ribs\";\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","dSmRhZ6o1bUcOSF9":"return args.skill?.name != game.i18n.localize(\"NAME.Leadership\");","dULCkRxtisuzQyuK":"if (args.options.condition) \n  this.effect.delete();","dVF5ywnzeiZQx9ke":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"hard\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed) \n{\n\tthis.script.scriptMessage(await this.actor.applyBasicDamage(15, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}))\n}","dWr3tkFoIzsAgelu":"let injury = this.effect.itemTargets[0]\nif (injury && this.effect.sourceTest.result.outcome == \"success\") {\n let days = new Roll(injury.system.duration.value).evaluateSync().total\n let num = 1 + Number(this.effect.sourceTest.result.SL);\n let roll = await new Roll(num+'d10').roll()\n await roll.toMessage(this.script.getChatData())\n let newDays = Math.max(days - roll.total, 1)\n this.actor.updateEmbeddedDocuments(\"Item\", [{_id: injury.id, 'system.duration.value': newDays} ])\n let message = \"Injury reduces to \"+newDays+\" (-\" + roll.total + \") instead of \"+days\n this.script.message(message)\n}\n","dXGosSxdoYbET2O8":"await this.actor.addCondition(\"fatigued\");\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"))\n\nawait test.roll();\n\nif (!test.succeeded)\n{\n    await this.actor.addCondition(\"fatigued\");\n    await this.actor.addCondition(\"broken\");\n}","dZ4c5pKDqQV02aIK":"if (args.effect.conditionId == \"ablaze\")\n{\n     args.data.formula += ` + parseInt(this.effect.sourceTest.result.SL)`\n}","dbHv7dAXgB2Oy1Fg":"let nbBleeding = 1 + Number(this.effect.sourceTest.result.SL);\nthis.actor.removeCondition(\"bleeding\", nbBleeding);\nconsole.log(this.actor);\n","dbOSvpgcPjsc2uvq":"let menacing = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.0hn6UaKq8CoZP2zD\")).toObject();\nlet sense = (await fromUuid(\"Compendium.wfrp4e-core.items.Item.9h82z72XGo9tfgQS\")).toObject();\n\nsense.name += \" (Sight)\";\nsense.system.tests.value = sense.system.tests.value.replace(\"Sense\", \"Sight\")\n\nthis.actor.createEmbeddedDocuments(\"Item\", [menacing, sense], {fromEffect : this.effect.id})","dbYjr4oG67Z880To":"if (args.test.isFumble)\n{\n    args.test.result.other.push(\"@Table[warpfire-thrower-fumble]\")\n}","dcwY8dCd3PNCEzk6":"let current = this.actor.status.fate.value\n\nthis.actor.update({\"system.status.fate.value\" : current + 1})\n\nthis.script.message(`<b>${this.actor.prototypeToken.name}</b> fate points increased from ${current} to ${current + 1}`)","dfEgat3jz4EtWszH":"return args.skill?.name == `${game.i18n.localize(\"NAME.Stealth\")} (${game.i18n.localize(\"SPEC.Urban\")})`","dfnCK8jCPXNLM7Gh":"let aoeDamage = this.effect.sourceTest.result.damage - 5 // Easily handle magic missile damage by just subtracting 5 from the item's (which has +10 base)\n\nthis.script.message(await this.actor.applyBasicDamage(aoeDamage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true}))\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {skipTargets: true, appendTitle :  ` - Ablaze`})\n\nawait test.roll();\n\nif (!test.succeeded)\n{\n    this.actor.addCondition(\"ablaze\");\n}","dh5mAlaOOLCBC0YQ":"args.actor.system.details.length.value += args.actor.system.details.length.value * 0.1;","dk02qSJfJaIo3Geh":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.EO05HX7jql0g605A\");\nlet data = item.toObject();\ndata.system.specification.value = this.actor.characteristics.ag.value\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","dkY7WRYjFVh8GB0m":"return ['ws', 'bs', 'ag'].includes(args.characteristic)","dkiNmwFXztIVbuxg":"let currentCareer = this.actor.system.currentCareer;\n\nif (!currentCareer || currentCareer.system.talents.includes(game.i18n.localize(\"NAME.Frenzy\")))\n{\n    return\n}\n\ncurrentCareer.system.talents.push(game.i18n.localize(\"NAME.Frenzy\"));","dqvHDMlcitLx1pUx":"this.actor.system.details.move.value /= 2;","dr9VJKGY3TeGuzXj":"this.script.message(`Allies of ${this.actor.name} gain +20 Initiative for the first round.`)","dsXGavzXLerXR8Xg":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Sail\")) && !args.skill?.name.includes(game.i18n.localize(\"NAME.Row\"))","dt85W8pzZ09w1QLi":"if (this.actor.sameSideAs(this.effect.sourceActor))\n    args.fields.slBonus += 2;\nelse\n    args.fields.slBonus -= 2;","dtFvpY96RPzNnphq":"return !(args.skill?.name == `${game.i18n.localize(\"NAME.Melee\")} (${game.i18n.localize(\"SPEC.Basic\")})` || (args.type == \"weapon\" && args.item?.system.weaponGroup.value == \"basic\"))","dwSgcFxKN3S0hLJL":"return args.skill?.name != game.i18n.localize(\"NAME.MeleeBrawling\") && args.item?.weaponGroup?.value != \"brawling\"","dxt3p07po06J9fO1":"const metal = () => {\n  for (const [key, loc] of Object.entries(this.actor.armour)) {\n    if (!loc.layers) continue;\n\n    for (const layer of loc.layers) {\n      if (layer.metal)\n        return true;\n    }\n  }\n\n  return false;\n};\n\nargs.fields.slBonus -= metal() ? 2 : 1;","dxxDFXNNqUsuMyUD":"args.fields.slBonus += 1","e0TuMgYuI7ZtGoQr":"args.applyAP = false;\n\nawait args.actor.addCondition(\"ablaze\", 2);\nawait args.actor.addCondition(\"prone\");","e2JlsKoW8oaFjn6Y":"const roll = new Roll(\"1d10\");\n\nawait roll.evaluate();\nroll.toMessage();\n\nconst slBonus = Number(this.effect.sourceTest.result.SL) + roll.total;\n\nthis.effect.setFlag(\"wfrp4e\", \"slBonus\", slBonus);","e34s1XxHckAWfwHt":"if (args.test.options.beatBlade && (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target))\n{\n   args.test.result.other.push(`<b>${this.effect.name}</b>: Opponent loses ${Number(args.test.result.SL) + 1} Advantage`)\n}","e3dBud1keWyhw6nw":"const stupid = this.actor.items.find(i => i.name === \"Stupid\");\n\nif (!stupid) return;\n\n\nif (this.item.system.disabled) {\n  await stupid.update({\"system.disabled\": false});\n} else {\n  await stupid.update({\"system.disabled\": true});\n}","e4HotRnEiyXR0pIu":"this.actor.applyEffect({effectUuids : this.item.effects.contents[1].uuid})","e7IxnxePdXSy6L4E":"if (args.opposedTest.result.hitloc.value == \"head\")\n{\n     this.script.message(`<b>${this.actor.prototypeToken.name}</b> receives a @Table[crithead]{Critical Wound} if one was not caused already.`)\n}","eAtqyBd1HsDWuBuI":"this.actor.system.characteristics.fel.modifier -= parseInt(this.item.system.location.value) || 1","eC61buStv62b3sN9":"args.fields.slBonus += 8;","eGQAyzCFZAEQhyJl":"const roll = new Roll(\"2d10\");\nawait roll.evaluate();\nconst money = game.wfrp4e.market.addMoneyTo(this.actor, `${roll.total}b`);\nawait this.actor.updateEmbeddedDocuments(\"Item\", money);\nthis.script.message(game.i18n.format(\"SCRIPT.Silvertide\", {name: this.actor.name, pennies: roll.total}));","eHRv7f2BTtle6Y1K":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.sJ3yX1kvzu2hgNq5\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","eHgk3HZ6eyLFTZ9o":"return !args.item?.system.magicMissile?.value && !args.item?.system.attackType","eIiiDhJohYez26qY":"const {targetUuid} = this.effect.flags.wfrp4e;\n\nif (args.actor.uuid !== targetUuid) return;\n\nconst recordedWounds = this.effect.getFlag(\"wfrp4e\", \"damageToReturn\");\n\nif (!recordedWounds) return;\n\nargs.modifiers.other.push({label: this.effect.name, value: recordedWounds});\nargs.totalWoundLoss += recordedWounds\n\nthis.effect.unsetFlag(\"wfrp4e\", \"damageToReturn\");","eLxdRg8LX3AdYSEq":"let sumArmour = 0;\nfor (let key in this.actor.system.status.armour) {\n  let armour = this.actor.system.status.armour[key];\n  sumArmour += Number(armour?.value || 0);\n}\nlet damage = Math.floor(Number(sumArmour)/2);\nif (damage > 0 ) { \n\tthis.script.scriptMessage(await this.actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}))\n}","ePPgxQOqL1Uhz2k9":"let addOption = await foundry.applications.api.DialogV2.confirm({\n    window : {title : \"Option\"},\n    content : \n    `\n    Add Option?\n    <p>\n    Ranged (Bow) +10 and a Longbow with 12 Arrows\n    </p>\n    `,\n})\n\nlet choice = []\n\nif (addOption)\n{\n    choice = [\n        {\n            type : \"skill\",\n            name : \"Ranged (Bow)\",\n            diff : {\n                system : {\n                    advances : {\n                        value : 10\n                    }\n                }\n            }\n        },\n        {\n            type : \"weapon\",\n            name : \"Longbow\",\n        },\n        {\n            type : \"ammunition\",\n            name : \"Arrow\",\n        }\n    ];\n}\n\n\n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            let equip = item.system.tags.has(\"equippable\");\n            item = item.toObject()\n            if (equip)\n            {\n                item.system.equipped.value = true;\n            }\n            items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","eRVVn8YtU8nnOW2q":"await this.actor.addCondition(\"prone\");\n\nconst test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {\n  skipTargets: true,\n  appendTitle: ` - ${this.effect.name}`,\n  fields: {difficulty: \"difficult\"},\n  context: {\n    failure: `Receives 8 Damage.`,\n    success: `Receives 4 Damage.`\n  }\n})\n\nawait test.roll();\nconst damage = test.failed ? 8 : 4;\n\nawait this.actor.applyBasicDamage(damage, {damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, loc: \"roll\"});","eTHJSRutCEpuyPkR":"return args.weapon?.system?.attackType !== \"melee\" || game.settings.get(\"wfrp4e\", \"useGroupAdvantage\")","eWWLmA2xINR321aK":"args.item.system.qualities.value.push({name : \"magical\"})","eb69QPmNQEJXtk4l":" return args.characteristic != \"bs\"","ebDQH0MdGAG02CHl":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.SYjWiKDzMS6CtROJ\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nif (this.item.system.location.key == \"rArm\")\n{\n\tdata.system.location.value = \"Right Hand\"\n\tdata.system.location.key = \"rHand\"\n}\nelse if (this.item.system.location.key == \"lArm\")\n{\n\tdata.system.location.value = \"Left Hand\"\n\tdata.system.location.key = \"lHand\"\n}\nthis.actor.createEmbeddedDocuments(\"Item\", [data])","ed7Sud9HM3uB2j6b":"ChatMessage.create({content : \"<em>Yield or die!</em>\", speaker : ChatMessage.getSpeaker({token: this.actor.getActiveTokens()[0]?.document, actor: this.actor})}, {chatBubble : true})\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\ndata.system.specification.value = 2;\nthis.script.notification(\"Adding \" + data.name);\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id});\ngame.wfrp4e.utility.postFear(2, this.actor.prototypeToken.name)","egDtqMxe3iekc6hv":"let trait = args.opposedTest.attackerTest.item\nlet woundLossEffect = this.item.effects.get(\"7Amhi75wLv0PvGjd\")\nif (trait && trait.name.includes(\"Bite\") && woundLossEffect)\n{\n    args.actor.applyEffect({effectUuids : woundLossEffect.uuid})\n}","eh1J3s0s4A2AxoFp":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.8pVzgPkgWpTJvfhG\");\nlet data = item.toObject();\ndata.name += \" (Enemy)\";\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","eieFcF4BxIvDTN3C":"args.abort = `Cannot perform Ranged Attacks within ${this.effect.name}`;","ekjJQHyMbZT2vqdc":"let uses = this.item.getFlag(\"wfrp4e\", \"uses\") || 0;\nuses++;\nthis.script.notification(`Used ${uses} times`)\nthis.item.setFlag(\"wfrp4e\", \"uses\", uses);\nif (uses >= 3)\n{\n\tthis.effect.update({\"system.transferData.type\" : \"other\"})\n\tthis.script.notification(`Used up`);\n}\n","eq32dKXeTAbKhhLf":"if (args.totalWoundLoss > 0)\n{\n   args.actor.addCondition(\"ablaze\", Math.max(1, parseInt(args.opposedTest.attackerTest.result.SL) + 1))\n}","eqxE7nBO13yJS7hc":"let roll = (await new Roll(\"1d10\").roll())\nroll.toMessage({flavor: \"Wounds Healed\", speaker : {alias : this.actor.name}})\n\nthis.actor.modifyWounds(roll.total)\n\nthis.actor.hasCondition(\"bleeding\")?.delete();","esuLwq4g5T8k1kLT":"await args.actor.addCondition(\"ablaze\"); await args.actor.addCondition(\"prone\");","ezGqDoC9hNRBnFTB":"let choices = await Promise.all([warhammer.utility.findItemId(\"1zaqojk0Oq1m8vYv\"), warhammer.utility.findItemId(\"zIuarD5mB0EF0ji0\")])\nlet items = await game.wfrp4e.apps.ItemDialog.create(choices, 1, \"Choose a Weapon\")\nitems = items.map(i => i.toObject())\n\nitems.forEach(i => i.system.equipped.value = true);\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","f062aa2BNClx08D6":"let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\n    await test.roll();\n    if (test.failed) \n    {\n      let toughnessLost = parseInt(this.effect.sourceTest.result.SL)\n\n      let currentModifier = this.actor.characteristics.t.modifier\n\n      await this.actor.update({ \"system.characteristics.t.modifier\": currentModifier - toughnessLost })\n      this.script.message(`<b>${this.actor.prototypeToken.name}</b> lost ${toughnessLost} Toughness`)\n      if (this.actor.system.characteristics.t.value <= 0)\n      {\n          this.actor.addCondition(\"dead\");\n      }\n\n    }","f29Pv6TQtgILxt1h":"if (args.test.options.healWounds) {\n if (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target) {\n   let wounds = this.actor.characteristics.int.bonus + ~~args.test.result.SL\n   if (args.test.options.fieldDressing && args.test.result.reversed)\n      wounds = this.actor.characteristics.int.bonus + Math.min(1, Number(args.test.result.SL))\n\targs.test.result.woundsHealed = wounds\n\targs.test.result.other.push(`<b>${this.actor.name}</b> healed <b>${wounds}</b> wounds of the patient.`)\n   }\n   else if (this.actor.characteristics.int.bonus + args.test.result.SL < 0)\n      args.test.result.other.push(`The patient contracts a @UUID[Compendium.wfrp4e-core.items.Item.1hQuVFZt9QnnbWzg]{Minor Infection}.`)\n}","f3rXusHh6VIpVPUl":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Language\")) && args.type != \"cast\"","f4vvAGQ8OGoEbrgy":"let SL = args.opposedTest.attackerTest.result.SL - args.opposedTest.attackerTest.item.cn.value\nlet difficulty = \"challenging\"\nif (SL >= 1)\n   difficulty = \"difficult\"\nif (SL >= 2)\n   difficulty = \"hard\"\nif (SL >= 3)\n   difficulty = \"vhard\"\n   \n\nlet test = await args.actor.setupCharacteristic(\"wp\", {fields: {difficulty}, skipTargets: true, appendTitle :  \" - \" + this.effect.name, context : {failure: \"Gain a Stunned Condition\"}})\nawait test.roll();\nif (test.failed)\n{\n    args.actor.addCondition(\"stunned\");\n}","f5Mp3kXwCFdPkW6N":"return args.skill?.name != `${game.i18n.localize(\"NAME.Entertain\")} (${game.i18n.localize(\"SPEC.Sing\")})` && args.skill?.name != `${game.i18n.localize(\"NAME.Entertain\")} (${game.i18n.localize(\"SPEC.Singing\")})` && !args.skill?.name.includes(game.i18n.localize(\"NAME.Language\"));","f6WnrJvoNkfoNN9Y":"return args.item?.attackType != 'melee'","f7WZvYle9iqefRsh":"return args.weapon?.system?.attackType != \"melee\"","f8cnfvGKJH3bYVGN":"return [\"s\", \"t\"].includes(args.characteristic)","fA1dIV1ANo4RVEqy":"if (args.equipped) \n{\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.4mF5Sp3t09kZhBYc\");\n    let champion = item.toObject();\n    this.actor.createEmbeddedDocuments(\"Item\", [champion], {fromEffect : this.effect.id})\n} \nelse \n{\n  this.effect.deleteCreatedItems();\n}","fEFfHFeJxkR0aIJK":"if (args.opposedTest.result.differenceSL >= 0 && args.opposedTest.result.differenceSL <= 3 && args.opposedTest.result.winner == \"attacker\")\n{ \n    this.script.message(`Everyone within 20 feet loses 1 Wound and makes a <strong>Difficult (-10) Endurance</strong> or gains @Condition[Deafened]`, {blind : true,  whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}\n    ","fEyKQqCjDwml3DXO":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.M8XyRs9DN12XsFTQ\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})","fFGuTi0HLjwneMcJ":"return args.item?.system.isRanged","fFi9JD4uCY9DPC5B":"let specification = Number(this.item.specification.value) || 1;\nargs.actor.system.characteristics.t.initial += 10 * specification;\nargs.actor.system.status.carries.max -= Math.floor(args.actor.system.status.carries.max * 0.1 * specification);\nargs.actor.system.details.price.gc += Math.floor(args.actor.system.details.price.gc * 0.1 * specification);","fIUxKZMWJ8HMPmH9":"return [\"wp\", \"ag\", \"i\", \"int\"].includes(args.characteristic)","fKzlu6fFE2th9uIJ":"return args.item?.name == game.i18n.localize(\"NAME.ConsumeAlcohol\")","fLg90csmdOOKmEE6":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.EO05HX7jql0g605A\")\nlet data = item.toObject();\ndata.system.specification.value = 16\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.Bvd2aZ0gQUXHfCTh\")\nlet data = item.toObject();\ndata.system.specification.value = 8\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","fNUiKELi9e1vg7KY":"args.actor.removeCondition(\"fatigued\", 99);\nargs.actor.removeCondition(\"bleeding\", 99);","fP2edYbj6QjPPAjL":"return [game.i18n.localize(\"NAME.CharmAnimal\"), game.i18n.localize(\"NAME.Endurance\"), game.i18n.localize(\"NAME.OutdoorSurvival\")].includes(args.skill?.name)","fPKYkBllp7Et62lX":"if (args.test.spell.name == \"Warp Lightning\")\n{\n    args.test.preData.canReverse = true;\n}","fSTjJIqg5tvbwxKt":"const uuid = \"Compendium.wfrp4e-core.items.Item.ahlxlfIl8xUhBkic\";\nconst item = await fromUuid(uuid);\nconst data = item.toObject();\ndata.name = this.effect.name;\ndata.system.equipped.value = true;\n\nconst effectData = this.effect.sourceItem.effects.find(e => e.disabled).toObject();\neffectData.disabled = false;\ndata.effects = [effectData];\n\nconst dagger = await this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id});","fTw3mpSUOlkqVVUC":"this.actor.applyEffect({effectUuids : this.item.effects.contents[0].uuid})","fUD4gMdKe6P3sFdJ":"this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.Zh68gzYMLW8vZgVo\", this.effect)","fY0TsQwnU14fdPl2":"args.fields.modifier += 30;","fYLSe6CrYciap5y8":"let characteristics = {\n    \"ws\" : 0,\n    \"bs\" : 0,\n    \"s\" : 10,\n    \"t\" : 10,\n    \"i\" : 0,\n    \"ag\" : 10,\n    \"dex\" : 0,\n    \"int\" : 0,\n    \"wp\" : 0,\n    \"fel\" : 0\n}\nlet skills = [game.i18n.localize(\"NAME.ConsumeAlcohol\"), game.i18n.localize(\"NAME.Row\"), game.i18n.localize(\"NAME.Sail\"), game.i18n.localize(\"NAME.Swim\")]\nlet skillAdvancements = [10, 10, 10, 10]\nlet talents = []\nlet trappings = []\nlet items = []\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","faRFSsrQylQRZFLk":"return args.bleedingHand || !args.weapon || !this.actor.hasCondition(\"bleeding\")","fcY3pa72dELnOFXV":"return !args.context.reload\n","feMPZhhFeXRtKdKY":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectUuids : this.item.effects.contents[0]?.uuid})\n}\nelse\n{\n\tthis.script.notification(\"None left!\", \"error\")\n}","ffvcCEazZBinHlUX":"args.update({texture : {tint : \"#FFD700\"}});\n","fiF9sM5UpcHMYa33":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.vMYEkrWj0ip6ZOdv\");\nlet data = item.toObject();\ndata.name += \" (Poison, Disease, Chaos)\"\nthis.actor.createEmbeddedDocuments(\"Item\", Array(this.effect.sourceTest.result.overcast.usage.other.current).fill(data), {fromEffect: this.effect.id})","fkFmNcesqqNTMhVn":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.2iult41Jehz0F1O8\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key;\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","fl762icfKrt9ear2":"this.actor.removeCondition(\"broken\", parseInt(this.effect.sourceTest.result.SL)+1)","fq2fqlWlrVfitkcB":"let characteristics = {\n    \"ws\" : 0,\n    \"bs\" : -200,\n    \"s\" : 20,\n    \"t\" : 20,\n    \"i\" : 0,\n    \"ag\" : -5,\n    \"dex\" : -5,\n    \"int\" : 0,\n    \"wp\" : 0,\n    \"fel\" : 0\n}\nlet traits = [ {name:\"Corruption\"}, {name:\"Painless\"}, {name:\"Stupid\"}, {name:\"Swarm\"}, {name:\"Bestial\", disabled : true}, {name:\"Regenerate\", disabled : true}, {name:\"Size\", value: \"Large\", disabled : true}, {name:\"Territorial\", disabled: true} ];\nlet items = [];\n\nlet updateObj = this.actor.toObject();\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let trait of traits)\n{\n    let traitItem = await game.wfrp4e.utility.find(trait.name, \"trait\")\n    if (traitItem)\n    {   \n        let t = traitItem.toObject();\n        t.system.specification.value = trait.value;\n        if (trait.disabled)\n        {\n            t.system.disabled = true;\n        }\n        items.push(t);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trait.name}`, {permanent : true})\n    }\n}\n\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n","ft0LaRWZT5WtnptP":"let advantage = this.actor.system.status.advantage.value;\nif (advantage > 0)\n{\n    await this.actor.setAdvantage(0);\n    this.script.notification(\"Advantage Subtracted\")\n}\nelse \n{\n    return this.script.notification(\"Not enough Advantage!\", \"error\")\n}\n\nlet test = await this.actor.setupTrait(this.item, {fields : {slBonus : advantage}})\nawait test.roll();","fve7tiyF5X9B7mHJ":"args.fields.slBonus -= 2;","fzTB7t3x4bLmAXji":"let roll = await new Roll(\"1d10 + 1\").roll()\nawait roll.toMessage(this.script.getChatData());\nthis.script.notification(`Healed ${roll.total} Wounds`)\nthis.actor.corruptionDialog(\"moderate\")\nawait this.actor.modifyWounds(roll.total)","g07HI7vyqiFXPB0o":"// A Drinker must take a Difficult (-10) Endurance Test.\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"difficult\"}})\nawait test.roll()\n// If they fail, they acquire 2 Poisoned Conditions. \nif (test.failed) \n{\n    this.actor.addCondition(\"poisoned\", 2)\n    this.script.message(`<p><strong>${this.actor.prototypeToken.name}</strong> has gained 2 @Condition[Poisoned] Conditions.</p>\n        <p>Any being with the Bestial Creature Trait that bites them and takes damage will not bite them again during a hostile encounter, though the creature may still attack them in other ways.</p>`, \n    {\n      whisper: ChatMessage.getWhisperRecipients(\"GM\"), \n      blind: true \n    })\n}\n  // If they succeed, for a number of rounds equal to 3+ their SL, they have the Corrosive Blood Creature Trait.\nelse if (test.succeeded) \n{\n    // Don't attempt to add Corrosive Blood if actor already has it\n    const hasCorrosiveBlood = this.actor.has(\"Corrosive Blood\")\n    if (hasCorrosiveBlood !== undefined) return   \n\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.M5QSWOYt2Rbv2yxW\")\n    let data = item.toObject()\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n    \n    const duration = 3 + parseInt(test.result.SL)\n    this.script.message(`<p><strong>${this.actor.prototypeToken.name}</strong> gains the Corrosive Blood Trait for ${duration} rounds.</p>`, \n      { whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })    \n}","g0SzfsLyW7aD2F19":"if (this.item.system.tests.value.includes(\"(Social Group)\"))\n{\n    let tests = this.item.system.tests.value\n    let name = this.item.name\n\n    // If name already specifies, make sure tests value reflects that\n    if (name.includes(\"(\") && !name.toLowerCase().includes(\"(any)\"))\n    {\n        let group = name.split(\"(\")[1].split(\")\")[0]\n        tests = `${tests.split(\"(\")[0].trim()} (${group})`\n    }\n    else\n    {\n        let value = await ValueDialog.create({text : \"Enter Etiquette Group\", title : this.effect.name});\n        if (value)\n        {\n            name = `${name.split(\"(\")[0].trim()} (${value})`\n            tests = this.item.system.tests.value.replace(\"Social Group\", value);\n        }\n    }\n    this.item.updateSource({name, \"system.tests.value\" : tests})\n}","g1L8OYO9nCOhdKGL":"// Everything within Fellowship Bonus yards \n// of the target point is splashed with mystic poison, \n// suffering 1d10 + SL damage which ignores Armour Points\n\nlet damage = (await new Roll(`1d10 + ${parseInt(this.effect.sourceTest.result.SL)}`).roll())\n\nawait damage.toMessage(this.script.getChatData())\n\nthis.script.message(await args.actor.applyBasicDamage(\n  damage.total,\n  {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}\n))\n\n// ... and gains the Poisoned Condition\n\nthis.actor.addCondition(\"poisoned\")","g4t56A09yrpZaJQ2":"    let amberTalons = foundry.utils.deepClone(game.wfrp4e.config.systemItems.unarmed);\n    amberTalons.name = \"Amber Talons\";\n    amberTalons.img = this.effect.img;\n    amberTalons.system.damage.value = \"SB + WPB\"\n    amberTalons.system.equipped = true;\n    amberTalons.system.qualities.value.push({name : \"magical\"})\n    amberTalons.effects.push({\n        name : \"Amber Talons\",\n        transfer: false,\n        img : \"modules/wfrp4e-core/icons/spells/amber-talons.png\" ,\n        system: {\n          transferData : {\n                  documentType : \"Item\"\n              },\n              scriptData : [{\n                  trigger : \"applyDamage\",\n                  script : \"if (args.totalWoundLoss >= 1)\\n{ \\n    args.actor.addCondition(\\\"bleeding\\\")\\n}\"\n              }]\n          }\n      })\n    this.actor.createEmbeddedDocuments(\"Item\", [amberTalons], {fromEffect: this.effect.id})","g5y0tdoHCDs7cBy7":"return ![\"NAME.Endurance\", \"NAME.Cool\"].map(i => game.i18n.localize(i)).includes(args.skill?.name) \n  || !this.actor.sameSideAs(this.effect.sourceActor)\n  || this.actor.system.details.status.tier !== \"b\"","gFUXBbTskQBKjxqm":"if (this.actor.hasCondition(\"entangled\"))\n{\n     this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"average\"}}).then(async test => {\n        await test.roll();\n        if (test.failed)\n             this.actor.addCondition(\"fatigued\")    \n     })\n}","gKIPujyuFSn0No9v":"for(let e of this.item.effects.contents)\n{\n    e.update({disabled: false})\n}\nthis.script.notification(\"Reset Powers\")","gKPL3t4vlZAsvtGr":"return args.skill?.name == `${game.i18n.localize(\"NAME.Stealth\")} (${game.i18n.localize(\"SPEC.Underground\")})`","gL0ftUnK5TNXBRRt":"return this.effect.sourceActor.uuid == args.actor.uuid","gMIenSmLklAkB2Zm":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create({text : \"Enter Venom Strength\", title : this.effect.name}, \"\", Object.values(game.wfrp4e.config.difficultyNames));\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","gOm8utR3HLQBT5hA":"let {value} = this.effect.getFlag(\"wfrp4e-soc\", \"m4result\") || {};\n\nif (value === 0)\n  args.actor.system.status.mood.value = 0;\nelse if (value !== undefined)\n  args.actor.system.status.mood.value += value;","gPQrszvIgGlW9yM4":"if (args.test.characteristicKey == \"wp\")\n   args.test.preData.canReverse = true","gSDhsSB8573joL64":"if (args.equipped) {\n  const spell = await game.wfrp4e.utility.findItem(\"Vindictive Glare\", \"spell\");\n  const skillUUID = \"Compendium.wfrp4e-core.items.Item.e3McIND4Rrsn5cE6\";\n\n  await this.actor.addEffectItems([skillUUID, spell.uuid], this.effect, [{\n  \"system.advances.value\": 75 - this.actor.system.characteristics.int.value\n}, {}]);\n} else {\n  this.effect.deleteCreatedItems();\n}","gVpFUka7qfGiEC1v":"    this.actor.getActiveTokens().forEach(t => t.document.update({texture : {tint : \"#FFD700\"}}));\n","ga6bQzPuoIiQQrKg":"if (args.totalWoundLoss > 0)\n{\n    \n    let test = await args.actor.setupCharacteristic(\"t\",  {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\n    await test.roll()\n    if (test.failed)\n    {\n        args.totalWoundLoss += this.effect.sourceActor.system.characteristics.wp.bonus\n        args.modifiers.other.push({label : this.effect.name, value : this.effect.sourceActor.system.characteristics.wp.bonus})\n    }\n}","gbhxWXboV9CytWNU":"await this.actor.addCondition(\"blinded\", 2)","gh2KS1prBKcsSK6M":"if (args.opposedTest.attackerTest.result.critical)\n   args.actor.addCondition(\"ablaze\")","gnVpxOeBZpNF4HIF":"if (args.test.result.roll.toString().includes(\"9\") || args.test.result.roll.toString().includes(\"8\"))\n{\n    args.test.result.fumble = game.i18n.localize(\"Fumble\")\n}","goz8yTlMozlsz3uY":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Strength';\nconst difficulty = 'easy';\nconst target = 10;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","gpPaCe6yER79l4u8":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.SfUUdOGjdYpr3KSR\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","gpuBg3y9rocJL7yT":"this.actor.status.addArmour(1, {locations: [\"head\"], source: this.effect})","gqZLfIr6svrtdwdC":"return args.skill?.name != game.i18n.localize(\"NAME.SleightOfHand\") && args.skill?.name != game.i18n.localize(\"NAME.MeleeBrawling\") && args.weapon?.system?.weaponGroup?.value != \"brawling\"","groEX1wJ9l00PkDF":"let turns = this.effect.getFlag(\"wfrp4e\", \"turns\");\nif (turns <= 0) return;\nturns--;\n\nconst speaker = ChatMessage.getSpeaker({actor: this.actor});\nconst targetId = this.effect.getFlag(\"wfrp4e\", \"target\");\nconst target = canvas.scene.tokens.get(targetId);\n\nif (turns > 0) {\n  this.effect.setFlag(\"wfrp4e\", \"turns\", turns);\n\n  return this.script.message(`<p><b>${speaker.alias}</b> continues wrapping itself around <b>${target.name}</b>. It will be able to start crushin in ${turns} turns.</p>`);\n}\n\nif (this.actor.items.find(i => i.type === \"extendedTest\" && i.name === this.effect.name)) {\n  this.script.message(`<p><b>${speaker.alias}</b> can resume crushing <b>${target.name}</b> with the Extended Test.</p>`);\n\n  return;\n}\n\nconst extendedTestData = {\n  name: this.effect.name,\n  type: \"extendedTest\",\n  img: this.effect.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target.actor.system.status.wounds.value\n    },\n    test: {\n      value: 'Strength'\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: \"challenging\"\n    }\n  }\n};\n\nconst extendedTests = await this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\nconst extendedTest = extendedTests[0];\n\nthis.script.message(`<p><b>${speaker.alias}</b> finished wrapping itself around <b>${target.name}</b>. It can now begin crushing via the @UUID[${extendedTest.uuid}] Extended Test.</p>`);\n\nlet effect = {\n  name: extendedTest.name,\n  img: extendedTest.img,\n  system: {\n    transferData : {\n        type: \"document\",\n        documentType: \"Item\"\n      },\n      scriptData: [\n        {\n          label: extendedTest.name,\n          script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.effects.find(e => e.id === id);\n              const speaker = ChatMessage.getSpeaker({actor: this.actor});\n              const targetId = effect.getFlag(\"wfrp4e\", \"target\");\n              const target = canvas.scene.tokens.get(targetId);\n              this.script.message(\\`<p><b>${speaker.alias}</b> crushed the <b>${target.name}</b>. Boat shatters, reduced to a mass of flotsam.</p>\\`);\n              await effect.delete();\n                          `,\n          trigger: \"deleteEffect\"\n        }\n      ]\n  }\n}\n\nawait extendedTests[0].createEmbeddedDocuments(\"ActiveEffect\", [effect]);","gsCnd3mf1vXFU2ei":"this.actor.system.status.ward.value = 4;","gu72JaTs9GrSiVTd":"return !(args.skill?.name == game.i18n.localize(\"NAME.Haggle\") || args.skill?.name == game.i18n.localize(\"NAME.Gossip\"))","gull3qgCahzk2xYu":"this.actor.addCondition(\"fatigued\", parseInt(this.effect.sourceTest.result.SL))\n\nlet test = await this.actor.setupSkill(\"Cool\", {fields : {difficulty: \"challenging\"}, appendTitle : ` - ${this.effect.name}`});\n\nawait test.roll();\n\nif (test.failed)\n{\n\tthis.actor.addCondition(\"broken\");\n}","gxuBeGHwjZ7WfPeu":"let specification = Number(this.item.specification.value) || 1;\nargs.fields.slBonus -= specification;","h0DfPwUUOBjyAHMZ":"return args.skill?.name != game.i18n.localize(\"NAME.Perception\");","h1XKoMuVnS0bagRO":"return args.item?.name != game.i18n.localize(\"NAME.Endurance\");","h2GSoiCQ2ZSlTjf7":"const uuid = \"Compendium.wfrp4e-core.items.Item.JQa5DLnTs2SEzRrc\";\nconst item = await fromUuid(uuid);\nawait this.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id});","h766UvswLCsxcMow":"let characteristics = {\n  \"ws\" : 5,\n  \"bs\" : 0,\n  \"s\" : -15,\n  \"t\" : 0,\n  \"i\" : 20,\n  \"ag\" : 0,\n  \"dex\" : 0,\n  \"int\" : 5,\n  \"wp\" : 10,\n  \"fel\" : 10\n}\nlet skills = [\"Charm\", \"Intimidate\", \"Melee (Basic)\"]\nlet skillAdvancements = [7, 60, 7]\nlet talents = [\"Menacing\", \"Shadow\"]\nlet traits = [\"Distracting\"]\nlet trappings = []\nlet items = [];\nlet spells = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n  updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n  let skill = skills[index]\n  let skillItem;\n  skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n  if (skillItem)\n      skillItem.system.advances.value += skillAdvancements[index]\n  else \n  {\n      skillItem = await game.wfrp4e.utility.findSkill(skill)\n      skillItem = skillItem.toObject();\n      skillItem.system.advances.value = skillAdvancements[index];\n      items.push(skillItem);\n  }\n}\n\nfor (let talent of talents)\n{\n  let talentItem = await game.wfrp4e.utility.findTalent(talent)\n  if (talentItem)\n  {\n      items.push(talentItem.toObject());\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n  }\n}\n\nconst traitRegex = /(?:,?(.+?)(\\+?\\d{1,2}\\+?)?\\s*?(?:\\((.+?)\\)\\s*(\\+?\\d{1,2})?|,|$))/gm\nfor (let trait of traits)\n{\n  let traitMatches = trait.matchAll(traitRegex).next().value\n  let traitName = traitMatches[1]\n  let traitVal = traitMatches[2] || traitMatches[4] // could be match 2 or 4 depending on if there's a specialization\n  let traitSpec = traitMatches[3]\n\n  let traitItem;\n  try {\n      traitItem = await WFRP_Utility.findItem(traitName, \"trait\")\n  }\n  catch { }\n  if (!traitItem) {\n      ui.notifications.warn(`Could not find ${trait}`, {permanent : true})\n  }\n  traitItem = traitItem.toObject()\n\n  if (Number.isNumeric(traitVal))\n  {\n      traitItem.system.specification.value = traitName.includes('Weapon','Horns','Tail','Tentacles','Bite') ? traitVal - parseInt(characteristicValues[3]/10) : traitVal;\n      traitItem.name = (traitItem.name +  ` ${traitSpec ? \"(\"+ traitSpec + \")\" : \"\"}`).trim()\n  }\n  else \n      traitItem.system.specification.value = traitSpec\n\n  items.push(traitItem)\n\n}\n\nfor (let trapping of trappings) \n{\n  let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n  if (trappingItem)\n  {\n      trappingItem = trappingItem.toObject()\n\n      trappingItem.system.equipped.value = true;\n\n      items.push(trappingItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n  }\n}\n\nfor (let spell of spells) \n{\n  let spellItem = await game.wfrp4e.utility.findItem(spell)\n  if (spellItem)\n  {\n      spellItem = spellItem.toObject()\n\n      items.push(spellItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${spell}`, {permanent : true})\n  }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","hA8PzeiCsHqqlUZm":"this.actor.createEmbeddedDocuments(\"ActiveEffect\", [game.wfrp4e.config.symptomEffects[\"nausea\"]])\nthis.script.message(`Gains @Condition[Nausea] for [[1d10]] hours`, {whisper: ChatMessage.getWhisperRecipients(\"GM\")})","hCzxUyO6mjLNIpaM":"let woundsGained = Math.min(args.totalWoundLoss, args.actor.status.wounds.value)\n\nwoundsGained = Math.floor(woundsGained / 2)\n\nargs.attacker.update({ \"system.status.wounds.value\": args.attacker.status.wounds.value + woundsGained })\n\nthis.script.message(`Gains ${woundsGained} Wounds`)","hDC6lroDEPVBituR":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\nif (test.failed)\n{\n    this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + 1})\n    this.script.message(\"Gained a Corruption point\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    if (test.result.roll % 11 == 0 || test.result.roll == 100)\n    {\n        this.script.message(`<strong>Fumble</strong>: immediately gain 1 @Table[mutatemental]{Mental Mutation}, and may not take a Short-term Ambition for the next [[1d10]] weeks.`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    }\n}","hK0YMJfYbpbJZizO":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 0,\n      \"bright\": 0,\n      \"angle\": 360,\n      \"alpha\": 0.5,\n      \"animation\": {\n          \"speed\": 0,\n          \"intensity\": 0,\n          \"type\": \"none\",\n      },\n      \"color\": \"\",\n  }}));","hL3JUSY3xMA4zj2Q":"if (this.sourceActor.uuid === this.actor.uuid) return;\n\nconst test = await this.actor.setupCharacteristic(\"t\", {\n  skipTargets: true, \n  appendTitle:  ` — ${this.effect.name}`, \n  fields: {\n    difficulty: \"difficult\"\n  },\n  context: {\n    success: \"Is able to stand!\",\n    failure: \"Fallen Prone!\",\n  }\n});\n\nawait test.roll();\nif (test.failure) {\n  await this.actor.addCondition(\"prone\");\n}","hObTbWi4ZdwXimIW":"if (args.item.type == \"spell\")\n{\n    args.item.system.cn.value = Math.floor(args.item.system.cn.value / 2);\n}","hOgha3ir8K9TVphO":"return args.characteristic !== \"fel\";","hR1qD2kpFHF8JT8h":"return args.skill?.name == `${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})`","hSImyYjL0CENTvXf":"let test = await this.actor.setupSkill(\"Endurance\", {fields : {difficulty : \"difficult\", appendTitle : ` - ${this.effect.name}`}});\nawait test.roll();\nif (test.failed)\n{\n\tawait this.actor.addCondition(\"blinded\");\n}\n\nlet msg = ``\nlet armour = args.actor.itemTags.armour.filter(i => i.system.isMetal && i.system.isEquipped);\nfor(let item of armour)\n{\n\tfor(let key in item.system.AP)\n\t{\n\t\tlet AP = item.system.AP[key]\n\t\tlet damage = Math.floor(AP / 2);\n\t\tawait item.system.damageItem(damage, [key]);\n\t}\n\tmsg += `<p><strong>${item.name}</strong> AP reduced by half</p>`\n}\nif (msg)\n{\n\tthis.script.message(msg, {speaker : {alias : args.actor.name}});\n}","hSlEY2oh8quVmdXR":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\ndata.system.specification.value = 2\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","hTsnYKgw0kK10PiC":"args.fields.modifier += 5","hWWvkPbgIN3lxz1u":"return args.item?.system?.attackType !== \"melee\";","hYNWp75ggWSTht55":"if (args.test.result.hitloc.value != \"head\" && args.test.result.critical)\n{\n\twarhammer.utility.sleep(200).then(() => {\n\t\tthis.script.message(\"Can roll on the @Table[crithead]{Head Critical Hits} instead of the normal hit location\")\n\n\t})\n}","hZAax4emLahEEqcZ":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.BqPZn6q3VHn9HUrW\")\nlet data = item.toObject();\ndata.system.specification.value = 7 - this.actor.characteristics.s.bonus\ndata.name = item.name.replace(\"(Feature)\", \"(Tusks)\")\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","hfO4INH3EeETDTFt":"this.actor.status.addArmour(1, {locations: this.effect.flags.wfrp4e.locations, source: this.effect})","hhCs5VBKx50S5IsY":"return !args.context.mutate","hhv7PrRdlf9sfC82":"let characteristics = {\n    \"ws\" : 5,\n    \"bs\" : 0,\n    \"s\" : 5,\n    \"t\" : 5,\n    \"i\" : 10,\n    \"ag\" : 0,\n    \"dex\" : 0,\n    \"int\" : 0,\n    \"wp\" : 0,\n    \"fel\" : 0\n}\nlet skills = [\"Cool\", \"Dodge\"]\nlet skillAdvancements = [10, 10]\nlet talents = [\"Combat Reflexes\"]\nlet trappings = [\"Leather Jack\", \"Leather Skullcap\", \"Leather Leggings\", \"Shield\"]\nlet items = []\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","hj7tI212neKIu9dh":"this.actor.system.status.ward.value = 7;","hlHKeFWrOA8CsLr9":"args.data.canReverse = true;\nargs.context.pilot = true;","hluehsCuBZYc1Ejt":"return args.characterisic != \"fel\"","hmk8zV1LTElHUI8A":"let msg = `<b>${this.actor.prototypeToken.name}</b> loses 1 Wound.<br>`\n  if (this.actor.status.wounds.value <= 1)\n  {\n    msg += `<b>${this.actor.prototypeToken.name}</b> goes unconscious.<br>`\n    await this.actor.addCondition(\"unconscious\")\n  }\n  this.script.message(msg)\n  this.actor.modifyWounds(-1)","hnsmzvcuiUYB065I":"this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {appendTitle: ` - ${this.effect.name}`, context: { failure : \"May not flee Combat\"}}).then(test => test.roll())","hpbraeEbjkXnmD75":"args.fields.hitLocation = \"lLeg\"\nargs.fields.modifier += 20;","hpwJRAhCsXTp9bd9":"let choice1 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Basic)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 20\n                }\n            }\n        }\n    }\n]\nlet choice2 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Polearm)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 20\n                }\n            }\n        }\n    }\n]\n\nlet choice3 = [\n    {\n        type : \"skill\",\n        name : \"Melee (Two-Handed)\",\n        diff : {\n            system : {\n                advances : {\n                    value : 20\n                }\n            }\n        }\n    }\n]\n\nlet choice = await foundry.applications.api.DialogV2.wait({\n        window : {title : \"Choice\"},\n        content : \n        `<p>\n        Select your choice\n        </p>\n        <ol>\n        <li>Melee (Basic)</li>\n        <li>Melee (Polearm)</li>\n        <li>Melee (Two-Handed)</li>\n        </ol> \n        `,\n        buttons : [\n            {\n                label : \"Basic\",\n                action : \"basic\",\n                callback : () => {\n                    return choice1\n                }\n            },\n            {\n                label : \"Polearm\",\n                action : \"polearm\",\n                callback : () => {\n                    return choice2\n                }\n            },\n            {\n                label : \"Two-Handed\",\n                action : \"two-handed\",\n                callback : () => {\n                    return choice3\n                }\n            }\n    ]\n})\n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            let equip = item.system.tags.has(\"equippable\");\n            item = item.toObject()\n            if (equip)\n            {\n                item.system.equipped.value = true;\n            }\n            items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","ht7csu1KImHzpzL5":"return args.item?.actor?.type !== \"vehicle\" || args.item?.type !== \"weapon\" || !args.item.name.includes(\"Cannon\");","huJcVpVn6Q7sQkFC":"if (args.actorsystem.details.move.sail.value > 0)\n  args.actor.system.details.move.sail.value -= 1;\n","hwHpIunCq3ifk2QU":"if (args.item.type == \"spell\")\n{\n   let range = parseInt(args.item.Duration)\n   if (Number.isNumeric(range))\n   {\n          args.item.system.duration.value = \"2 * \" + args.item.system.duration.value\n   }\n}","hwOZxgt7e65iWvYz":"let test = await this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    let damage = this.effect.sourceTest.result.damage\n\n    this.script.message(await this.actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true}))\n}","hxmwtw5zAHyS2upG":"this.script.message(await game.wfrp4e.tables.formatChatRoll(\"giftofthebeast\"))","i59IpmZNLJEPWZ3L":"return args.spell","i5AN97A7IOeygEFA":"if (args.applyAP && args.modifiers.ap.metal) \n{\n    args.modifiers.ap.ignored += args.modifiers.ap.metal\n    args.modifiers.other.push({value : args.modifiers.ap.metal, label : this.effect.name, details : \"Add Metal AP to Damage\" })\n    args.modifiers.ap.details.push(\"<strong>\" + this.effect.name + \"</strong>: Ignore Metal (\" + args.modifiers.ap.metal + \")\");\n    args.modifiers.ap.metal = 0\n}","i7xl0jNpLnBT2h2l":"args.actor.characteristics.dex.value = 0","i93PGV1lDSdi3BJu":"let effectsToDisable = this.actor.items.filter(i => i.type == \"disease\").reduce((effects, item) => effects.concat(item.effects.contents), []).concat(this.actor.effects.contents.filter(i => i.isCondition)).filter(i => i.active);\n\nif (effectsToDisable.length)\n{\n    this.script.notification(`Disabling ${effectsToDisable.map(i => i.name).join(\", \")}.`);\n    effectsToDisable.forEach(i => i.update({disabled : true}))\n}","iAo3wxMLA64rsKjj":"this.script.message(await game.wfrp4e.tables.formatChatRoll(\"skavenbrew\"))","iBEPQ3NwtI9DfkEy":"let locations = [];\n\nwhile (locations.length < 2)\n{\n    let loc = await game.wfrp4e.tables.rollTable(\"hitloc\", {hideDSN : true})\n    if (!locations.includes(loc.result))\n    {\n        locations.push(loc.result);\n    }\n}\n\nlocationText = locations.map(i => game.wfrp4e.config.locations[i]).join(\", \")\n\nthis.item.updateSource({name : this.item.name += ` (${locationText})`})","iHn3YzvqNfbwzjZz":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")\nlet data = item.toObject();\ndata.system.specification.value = this.actor.characteristics.s.bonus\ndata.system.description.value = \"\"\ndata.name = this.effect.name;\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","iLpq4yCFN6YACrYA":"if (args.test.result.castOutcome == \"success\")\n{\n    this.script.message(await game.wfrp4e.tables.formatChatRoll(\"demonic-mien\"))\n}","iM4B3IZ4VtpZsl09":"args.size = \"sml\"","iM6JLF8jDXMViReZ":"return ![game.i18n.localize(\"Name.PickLock\"), game.i18n.localize(\"NAME.SleightOfHand\"), `${game.i18n.localize(\"NAME.Channelling\") (Ulgu)}`].includes(args.skill?.name)\n","iMDZLr7ueJWBnilj":"args.actor.flags.rangedDamageIncrease += 1","iMu8BZ7eHMAbPEO1":"let healed = args.totalWoundLoss\n\nthis.script.message(`<b>this.actor.prototypeToken.name</b> healed ${healed} Wounds`);\n\nthis.actor.modifyWounds(healed)","iNAQJa5HyaEckknX":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\n\nlet opposedResult = test.opposedMessages[0]?.system.opposedHandler?.resultMessage?.system.opposedTest?.result\n\nif (opposedResult?.winner == \"attacker\")\n{\n    let spells = this.actor.itemTypes.spell;\n    if (spells.length)\n    {\n        let chosen = spells[Math.floor(CONFIG.Dice.randomUniform() * spells.length)]\n        this.script.message(`Loses access to <strong>${chosen.name}</strong>`)\n        chosen.update({name : chosen.name += \" (LOST)\"})\n    }\n}\n\n\n","iO2hCDwyQ7v4qrOI":"if (args.test.options.staunchBleeding) {\n if (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target) {\n   let staunch =  ~~args.test.result.SL + 1\n   if (args.test.options.fieldDressing && args.test.result.reversed)\n     staunch =  Math.min(1, Number(args.test.result.SL)) + 1\n   args.test.result.other.push(`<b>${this.actor.name}</b> removed <b>${staunch}</b> Bleeding conditions from the patient.`)\n   }\n   else if (this.actor.characteristics.int.bonus + args.test.result.SL < 0)\n      args.test.result.other.push(`The patient contracts a @UUID[Compendium.wfrp4e-core.items.Item.1hQuVFZt9QnnbWzg]{Minor Infection}.`)\n}","iT0h3VZLEBQnn5Bx":"return args.skill?.name != game.i18n.localize(\"NAME.Charm\") && args.skill?.name != game.i18n.localize(\"NAME.Gossip\") && args.skill?.name != game.i18n.localize(\"NAME.ConsumeAlcohol\");","iT3C15fMyQrj1RmG":"if (this.actor.has(game.i18n.localize(\"NAME.Undead\")) && this.actor.has(game.i18n.localize(\"NAME.Ethereal\")))\n{\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name}).then(async test => {\n           await test.roll();\n           if(test.failed)\n               this.actor.addCondition(\"stunned\")\n    })\n}","iVhi3Z6zPaf1bf8g":"return [\"t\", \"i\", \"ag\", \"dex\", \"int\", \"wp\"].includes(args.characteristic)","iX0ctHYHg12pjaCU":"let result = await game.wfrp4e.tables.rollTable(\"gift-of-slaanesh\")\n\nif (result.object.documentId && result.object.documentCollection)\n{\n    let item = await fromUuid(`Compendium.${result.object.documentCollection}.${result.object.documentId}`);\n    if (item)\n    {  \n        let data = item.toObject();\n        // Some items need sourceTest for their effects\n        foundry.utils.setProperty(data, \"flags.wfrp4e.sourceTest\", this.effect.sourceTest);\n        await this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});\n    }\n}\n\nthis.script.message(game.wfrp4e.tables.formatChatRoll(\"gift-of-slaanesh\", {lookup : result.roll, hideDSN: true}));","id9ZdkERMZnZTWXt":"if (args.extendedTest?.getFlag(\"wfrp4e\", \"fear\"))\n{\n\tthis.script.notification(\"Immune to Fear\");\n\targs.extendedTest.delete();\n\targs.abort = true;\n}\nreturn args.context.terror || args.extendedTest?.getFlag(\"wfrp4e\", \"fear\")","igVAVU7DOuzhNG14":"return args.item?.system.isMelee","imKVsCy8rya2gkwO":"// Any Characteristic penalties due to failed Consume Alcohol Tests\n// or the state of being Stinking Drunk are eliminated. \nawait this.actor.removeSystemEffect(\"consumealcohol1\")\nawait this.actor.removeSystemEffect(\"consumealcohol2\")\nawait this.actor.removeSystemEffect(\"consumealcohol3\")\nawait this.actor.removeSystemEffect(\"stinkingdrunk1\")\n\n// The drinker is thereafter Fatigued \n// for a number of hours equal to 10 minus their Toughness Bonus — \n// nothing but time and rest can eliminate this penalty.\nawait this.actor.addCondition(\"fatigued\")\nconst duration = 10 - parseInt(this.actor.system.characteristics.t.bonus)\nthis.effect.updateSource({\"duration.rounds\" : duration});\nthis.script.message(`<p><strong>${this.actor.prototypeToken.name}</strong> has lost all alcohol related penalties and gains the Fatigued Condition for ${duration} hours.</p>`, \n{\n  whisper: ChatMessage.getWhisperRecipients(\"GM\"), \n  blind: true \n})    ","inPxRSx0CDj1nwAm":"if (args.test.result.fumble && !this.actor.itemTypes.talent.find(i => i.name == \"Arcane Magic (Fire)\"))\n{\n    this.actor.addCondition(\"ablaze\");\n}","ioeTj5mx8jlA5EX5":"args.actor.addCondition(\"stunned\")","ipkkRffJh61WE7zR":"if (!args.flags.amputatedFootOrLeg)\n{\n\targs.flags.amputatedFootOrLeg= true;\n\targs.fields.modifier -= 20;\n}","iqUvV1Vu81M3WyZ4":"let SL = Number(this.effect.sourceTest.result.SL);\nfor (let i=0; i<SL; i++) {\n\t\n}","iuSoKntfJ4eAPafQ":"let spells = await warhammer.utility.findAllItems(\"spell\", \"Loading Spells\", true, [\"system.lore.value\"])\nspells = spells.filter(s => [\"fire\", \"heavens\", \"beasts\", \"shadow\", \"light\", \"life\", \"death\", \"metal\"].includes(s.system.lore.value)).sort((a, b) => a.system.lore.value > b.system.lore.value ?  1 : -1)\n\nlet choice = await ItemDialog.create(spells, 1, {text : \"Choose Spell\", title : this.effect.name});\nif (choice[0])\n{\n    this.actor.addEffectItems(choice.map(i => i.uuid), this.effect)\n}\n","iuYuf05BNuZ5fllI":"if (args.test.isFumble)\n{\n    args.test.result.other.push(\"@Table[poisoned-wind-globe]\")\n}","ivxpmCKu3pEMG05c":"if (this.actor.inCombat)\n{\n\tthis.actor.characteristics.s.bonus += 2\t\t\n\tthis.actor.characteristics.s.calculationBonusModifier -= 2\n}","j1AmrY1SxFJQyapo":"if (this.actor.status.advantage.value > 0 && args.item.system.attackType)\n{\n    args.item.system.qualities.value.push({name : \"penetrating\"})\n}","j3c6Y5aeA7nlFr9F":"const uuids = [\n  \"Compendium.wfrp4e-core.items.Item.wBhPFggGqIXwbx1r\",     // Alley Cat\n  \"Compendium.wfrp4e-core.items.Item.q58lK4kULJZB5GjE\",         // Rover\n];\n\nconst items = await Promise.all(uuids.map(uuid => fromUuid(uuid)));\nawait this.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect: this.effect.id});","j3zDMWkns32Yrxn3":"this.effect.updateSource({\"flags.wfrp4e.ward\" :  9})","j6Bf1iivH8cqSnnK":"let target = args.data.targets[0]\nreturn target?.actor.hasCondition(\"prone\") || target.hasCondition(\"surprised\")","j98hvy6r9G2Vjmid":"if (args.totalWoundLoss > 0) \n{\n  args.opposedTest.result.other.push(\n  `@Corruption[minor]{Minor Exposure to Corruption}`\n  )\n  this.script.message(\n  `<strong>${this.effect.name}</strong>: \n    @Corruption[minor]{Minor Exposure to Corruption} <br/>\n    <strong>${args.actor.prototypeToken.name}</strong> must take an \n    <strong>Average (+20%) Corruption (Minor) Test</strong>`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")})\n}","jC8o5PbnqEvOoZ9N":"this.actor.addCondition(\"poisoned\", 2)","jFwema0iwzBphxie":"let woundsGained = Math.min(args.actor.status.wounds.value, args.totalWoundLoss)\nwoundsGained = Math.ceil(woundsGained / 2)\n\nargs.attacker.update({\"system.status.wounds.value\" : args.attacker.system.status.wounds.value + woundsGained})\n\nargs.actor.addCondition(\"fatigued\")\nargs.attacker.hasCondition(\"fatigued\")?.delete();\n\nthis.script.message(`<b>${args.attacker.prototypeToken.name}</b> gains ${woundsGained} Wounds`);","jGDk7avWFSnyFoql":"let broken = this.actor.hasCondition(\"broken\");\nlet item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.IAWyzDfC286a9MPz\");\n\nif (broken && !broken.getFlag(\"wfrp4e\", \"blasted-mind\") && !this.actor.has(item.name))\n{\n    await broken.delete();\n    this.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id})\n    this.script.notification(`Removed ${broken.name}, added ${item.name} (${Math.ceil(CONFIG.Dice.randomUniform() * 10)} Rounds)`)\n}","jHgxpe6TJDlP3oTn":"let spells = await warhammer.utility.findAllItems(\"spell\", \"Loading Spells\", true, [\"system.lore.value\"])\nspells = spells.filter(s => [\"slaanesh\"].includes(s.system.lore.value))\n\nlet choice = await ItemDialog.create(spells, 1, {text : \"Choose Spell\", title : this.effect.name});\nif (choice[0])\n{\n    this.item.updateSource({name : this.item.name + ` (${choice[0].name})`})\n    this.actor.addEffectItems(choice.map(i => i.uuid), this.effect)\n}\n","jLsL4KRI6LEG9Ii2":"if (args.test.result.critical && ['rLeg', 'lLeg'].includes(args.test.result.hitloc.result))\n{\n    args.test.result.critModifier = args.test.result.critModifier ? args.test.result.critModifier + 20 : 20\n    args.test.result.critical += ` (+${args.test.result.critModifier})`\n}","jOCLEsjNzERyVLsP":"if(args.test.result.majormis)\n{\n    args.test.result.nullmajormis = game.i18n.localize(\"ROLL.MajorMis\")\n    args.test.minormis = game.i18n.localize(\"ROLL.MinorMis\")\n}","jOSCsBRUO117spv8":"args.abort = `Only gunpowder or artillery weapons can attack targets within the ${this.effect.name}`;","jObJanFoev4N6ZRv":"if (!args.opposedTest.attackerTest.item?.system?.isMagical)\n\targs.abort = `<strong>${this.effect.name}</strong>: Ignored`","jOm7RxGFm1y6mCpN":"return args.context.crewTest.name.includes(\"Batten Down\");","jRSgPhpfN7MH7TTp":"if (args.totalWoundLoss > 0)\n{\n    let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context: { failure: \"1 Poisoned Condition Gained\", success: \"Resisted Poisoned Condition\" } })\n    await test.roll();\n    if (test.failed)\n    {   \n        args.actor.addCondition(\"poisoned\");\n        if (args.actor.system.status.wounds.value - args.totalWoundLoss <= 0)\n        {\n            args.actor.addCondition(\"unconscious\")\n        }\n    }\n}\n\n    // else\n    //     this.actor.setupCharacteristic(\"t\", { context: { failure: \"1 @Condition[Poisoned] Condition Gained\", success: \"Resisted @Condition[Poisoned] Condition\" } }).then(testCallback)\n","jW87rmQLtROdVEhW":"  if ([\"orc\", \"ork\", \"goblin\", \"hobgoblin\", \"snotling\", \"greenskin\"].includes(args.opposedTest.defender.details.species.value.toLowerCase()))\n    {\n      args.addImpact = true\n      args.opposedTest.result.other.push(\"<b>Rune of Goblin Bane</b>: Impact Added\")\n    }","jWkfoVpHLiRaHTza":"if (args.test.succeeded)\n{\n    args.test.result.other.push(`<strong>${this.effect.name}</strong>: @Terror[1,${this.actor.prototypeToken.name}]`)\n}","jXbrIGxznqf1SNxZ":"const speaker = ChatMessage.getSpeaker({actor: this.actor});\n\nthis.script.message(`<p><b>${speaker.alias}</b> is Immersed within a Sea Elemental and suffers from @UUID[Compendium.wfrp4e-core.journals.JournalEntry.NS3YGlJQxwTggjRX.JournalEntryPage.WCivInLZrqEtZzF4#drowning-and-suffocation]{Suffocation}</p><p>They may attempt to escape by freeing themselves from the @Condition[Entangled} Condition as if they were @UUID[Compendium.wfrp4e-core.journals.JournalEntry.NS3YGlJQxwTggjRX.JournalEntryPage.wmA76Q2zJJ9HrkvA#grappling]{Grappled} by the Sea Elemental, making an <b>Opposed Strength Test</b> against its Strength of 59.</p>`);","jYJRO5XPyG7y6fih":"await this.actor.addCondition(\"blinded\")\nawait this.actor.addCondition(\"deafened\")\nawait this.actor.addCondition(\"fatigued\")","jbZPLb4wuqJpHLUx":"this.item.system.flaws.value.push({name : \"dangerous\"})","jdS2u1tQPYeO55WI":"let type = this.item.getFlag(\"wfrp4e\", \"breath\");\n\nif (type == \"cold\")\n{\n\tlet stunned = Math.max(1, Math.trunc(args.totalWoundLoss / 5))\n\tawait args.actor.addCondition(\"stunned\", stunned);\n}\n\nif (type == \"corrosion\")\n{\n    let damageItems = await foundry.applications.api.DialogV2.confirm({window: {title : this.item.name}, content : `<p>Damage all Items carried?</p>`})\n\tif (damageItems)\n\t{\n\t\tlet msg = ``\n\t\tlet weapons = args.actor.itemTypes.weapon.filter(i => i.isEquipped);\n\t\tlet armour = args.actor.itemTags.armour.filter(i => i.isEquipped);\n\t\tlet trappings = args.actor.itemTypes.trapping.filter(i => i.isEquipped);\n\t\tfor(let item of weapons)\n\t\t{\n\t\t\tif (item.system.properties.qualities.shield)\n\t\t\t{\n\t\t\t\tawait item.system.damageItem(1, \"shield\");\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tawait item.system.damageItem(1);\n\t\t\t}\n\t\t\tmsg += `<p><strong>${item.name}</strong> damage by 1</p>`\n\t\t}\n\t\tfor(let item of armour)\n\t\t{\n\t\t\tawait item.system.damageItem(1);\n\t\t\tmsg += `<p><strong>${item.name}</strong> damage by 1</p>`\n\t\t}\n\t\tfor(let item of trappings)\n\t\t{\n\t\t\tawait item.system.damageItem(1);\n\t\t\tmsg += `<p><strong>${item.name}</strong> damage by 1</p>`\n\t\t}\n\t\tif (msg)\n\t\t{\n\t\t\tthis.script.message(msg, {speaker : {alias : args.actor.name}});\n\t\t}\n\t}\n}\n\nif (type == \"fire\")\n{\n\tawait args.actor.addCondition(\"ablaze\");\n}\n\nif (type == \"electricity\")\n{\n\tawait args.actor.addCondition(\"stunned\");\n}\n\nif (type == \"poison\")\n{\n\tawait args.actor.addCondition(\"poisoned\");\n}\n\nif (type == \"warpfire\")\n{\n\tawait this.actor.corruptionDialog(\"moderate\")\n\tthis.actor.applyEffect({effectUuids : this.item.effects.getName(\"Warpfire\").uuid})\t\n}","jfk5VDKMTIf4ee0v":"if (args.totalWoundLoss > 0)\n    args.actor.addCondition(\"poisoned\")","jgO1Kf60Ctt6R0qO":"return args.item?.name != game.i18n.localize(\"NAME.Leadership\")","jmxlpyLrIuoxQtvU":"    this.actor.getActiveTokens().forEach(t => t.document.update({texture : {scaleX : 2, scaleY: 2, src: \"modules/wfrp4e-core/tokens/popout/gor.webp\"}}));\n","jpcU8FFWSlQ3gD0L":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Trade\"))","jrvj7bRyMBB9LixP":"this.actor.addCondition(\"fatigued\", 3)","jsgLEVYvMieyYT6L":"let tokenImg = \"\"; // Put path to token image here, inbetween the quotation marks\nif (tokenImg)\n{\n    if (this.effect.getFlag(\"wfrp4e\", \"transformed\"))\n    {\n        await this.effect.setFlag(\"wfrp4e\", \"transformed\", false);\n        this.actor.getActiveTokens().forEach(t => t.document.update({texture : {src: this.actor.prototypeToken.texture.src}}));   \n    }\n    else \n    {\n        await this.effect.setFlag(\"wfrp4e\", \"transformed\", true);\n        this.actor.getActiveTokens().forEach(t => t.document.update({texture : {src: tokenImg}}));\n    }\n}\nelse \n{\n    this.script.notification(\"No Token Image path configured. The image path should be set in the first line of this script.\", \"error\");\n}","k0AkkBLtE8oZhBwn":"if (isNaN(parseInt(this.item.system.specification.value))) {\n  let value = await ValueDialog.create({title : \"Armoured Value\", text : \"Enter the Armoured value\"});\n  if (value) {\n    this.item.updateSource({\"system.specification.value\" : value});\n  }\n}","k1Wdehpgdc0hP63E":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.aE3pyW20Orvdjzj0\")\nlet hatred = item.toObject();\nhatred.system.specification.value = \"Skaven\"\n\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.Item.3wCtgMDNnu8MFmyk\")\nlet immunity = item.toObject();\nimmunity.system.specification.value = \"Poison\"\n\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.Item.oRx92ByVNEBN6YkK\")\nlet berserk = item.toObject();\nawait this.actor.createEmbeddedDocuments(\"Item\", [hatred, immunity, berserk], {fromEffect : this.effect.id})","k3FqFgsF6a3TkxAD":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\ntest.roll();\nreturn true;","k7ldJfyW201HgRFh":"args.item.system.qualities.value.push({name : \"magical\"});","k8TC0yzp4xfOXD2n":"if (args.totalWoundLoss > 0)\n{\n    let test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\n    await test.roll();\n    if (test.failed)\n    {\n\t    args.actor.addCondition(\"stunned\");\n    }\n\targs.actor.hasCondition(\"bleeding\")?.delete()\n}","k9SvH4Lm3ZuI8S1N":"return ![\"wp\", \"ag\", \"i\", \"int\"].includes(args.characteristic)","kBXVEnSWzaQZLkJH":"if(args.test.result.critical)\n{\n   args.test.result.damage +=1 \n   args.test.result.additionalDamage += 1\n}","kEaBLoIHt1FpQVKq":"if (this.actor.system.details.experience.current < 100) {\n  return this.script.notification(game.i18n.localize(\"SCRIPT.NotEnoughXP\"))\n}\n\nlet item = await game.wfrp4e.utility.findItem(\"Invisibility\", \"trait\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item]);\nlet expLog = foundry.utils.duplicate(this.actor.details.experience.log || []);\nexpLog.push({amount : 100, reason: item.name, spent: this.actor.details.experience.spent + 100, total: this.actor.details.experience.total, type: \"spent\"});\nthis.actor.update({\n    \"system.details.experience.spent\": this.actor.details.experience.spent + 100,\n    \"system.details.experience.log\": expLog\n  });","kIM4Fs1lFVV7TSnj":"this.actor.modifyAdvantage(1);","kMSdRskYDI2J1gnp":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();  \nif (test.failed)\n{\n    this.actor.addCondition(\"prone\");\n}\n  ","kWynO1lQzjiSs8RK":"return args.skill?.name != game.i18n.localize(\"NAME.Haggle\");","kYTEqcs8JpO2OmB9":"if (args.equipped)\n    await this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.Bvd2aZ0gQUXHfCTh\", this.effect, {\"system.specification.value\": \"10\"});\nelse\n    await this.effect.deleteCreatedItems()","kYiDBPRKIokFkr4Z":"if (args.item.type  == \"skill\" && args.item.name == `${game.i18n.localize(\"NAME.Ranged\")} (${game.i18n.localize(\"SPEC.Bow\")})`)\n{\n     args.item.system.modifier.value += 20;\n}","kYmscP2HuXjDovBD":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"))\n","kbXDGAmWWD4CZJHB":"const sin = this.effect.sourceActor.system.status.sin.value;\nconst roll = new Roll(`2d10 - ${sin}`);\nawait roll.evaluate();\nawait roll.toMessage({flavor: `${this.effect.name}`});\nthis.actor.system.status.mood.addEntry(`${this.effect.name} (${this.effect.sourceActor.name})`, roll.total);","kiJ6AiaYVUjt6aV6":"teeth = await fromUuid(\"Compendium.wfrp4e-core.items.fBcZhOBn8IpoVqQ1\")\nteeth = teeth.toObject();\n\nlet roll = await new Roll(\"1d10\").roll({allowInteractive : false});\nroll.toMessage(this.script.getChatData({flavor : \"Teeth Lost\"}))\nteeth.system.location.value = `${roll.total} ${teeth.system.location.value}`\nthis.actor.createEmbeddedDocuments(\"Item\", [teeth])","kkC5EhqA05U6U0gU":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\n// Kind of insane but whatever\nlet opposedResult = test.opposedMessages[0]?.system.opposedHandler?.resultMessage?.system.opposedTest?.result\n\nif (opposedResult?.winner == \"attacker\")\n{\n    if (opposedResult.differenceSL < 6)\n    {\n        this.actor.addCondition(\"fatigued\", Math.floor(opposedResult.differenceSL / 2))\n    }\n    else if (opposedResult.differenceSL >= 6)\n    {\n        this.actor.addCondition(\"broken\");\n    }\n}","kmsGLWGxCY8Z8jVG":"return args.skill?.name != game.i18n.localize(\"NAME.Intuition\");","knq8lNYLw0v757dQ":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.9fq6p9Q6H02LjaSi\")\nlet data = item.toObject();\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});","kvaN100w0nBUlLbj":"let poisoned = this.actor.hasCondition(\"poisoned\")\nif (poisoned)\n{\n    this.script.message(\"Immune to Poisoned\")\n    poisoned.delete()\n}","kvnZz8yqdTZbErkr":"args.actor.system.details.move.value -= 2;\nargs.actor.system.details.man -= 1;\nargs.actor.system.status.carries.max *= 1.5;","kvqJbHBvFr6iGLcI":"this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.3wCtgMDNnu8MFmyk\",null,[{\"system.specification.value\":\"Poison\"}])","l1ntrpa8RE3Lg5xE":"return args.skill?.name === game.i18n.localize(\"NAME.Perception\");","l8qFKSnMpy4P7XQR":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"));","lCOdnKz8XpnkDs6Q":"let test = await this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();","lFO6XdfUODmFArqx":"args.actor.addCondition(\"bleeding\")","lII4KMRblqwFBlsV":"let characteristics = {\n  \"ws\" : 10,\n  \"bs\" : 0,\n  \"s\" : 0,\n  \"t\" : 0,\n  \"i\" : 10,\n  \"ag\" : 0,\n  \"dex\" : 0,\n  \"int\" : 20,\n  \"wp\" : 10,\n  \"fel\" : 15\n}\nlet skills = [\"Channelling\", \"Charm\", \"Perform (Dancing)\"]\nlet skillAdvancements = [0, 6, 3]\nlet talents = [\"Attractive\", \"Distract\", \"Mimic\"]\nlet traits = [\"Distracting\", \"Flight (6)\", \"Spellcaster (Petty)\"]\nlet trappings = []\nlet items = [];\nlet spells = [\"Marsh Lights\", \"Sleep\"];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n  updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n  let skill = skills[index]\n  let skillItem;\n  skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n  if (skillItem)\n      skillItem.system.advances.value += skillAdvancements[index]\n  else \n  {\n      skillItem = await game.wfrp4e.utility.findSkill(skill)\n      skillItem = skillItem.toObject();\n      skillItem.system.advances.value = skillAdvancements[index];\n      items.push(skillItem);\n  }\n}\n\nfor (let talent of talents)\n{\n  let talentItem = await game.wfrp4e.utility.findTalent(talent)\n  if (talentItem)\n  {\n      items.push(talentItem.toObject());\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n  }\n}\n\nconst traitRegex = /(?:,?(.+?)(\\+?\\d{1,2}\\+?)?\\s*?(?:\\((.+?)\\)\\s*(\\+?\\d{1,2})?|,|$))/gm\nfor (let trait of traits)\n{\n  let traitMatches = trait.matchAll(traitRegex).next().value\n  let traitName = traitMatches[1]\n  let traitVal = traitMatches[2] || traitMatches[4] // could be match 2 or 4 depending on if there's a specialization\n  let traitSpec = traitMatches[3]\n\n  let traitItem;\n  try {\n      traitItem = await WFRP_Utility.findItem(traitName, \"trait\")\n  }\n  catch { }\n  if (!traitItem) {\n      ui.notifications.warn(`Could not find ${trait}`, {permanent : true})\n  }\n  traitItem = traitItem.toObject()\n\n  if (Number.isNumeric(traitVal))\n  {\n      traitItem.system.specification.value = traitName.includes('Weapon','Horns','Tail','Tentacles','Bite') ? traitVal - parseInt(characteristicValues[3]/10) : traitVal;\n      traitItem.name = (traitItem.name +  ` ${traitSpec ? \"(\"+ traitSpec + \")\" : \"\"}`).trim()\n  }\n  else \n      traitItem.system.specification.value = traitSpec\n\n  items.push(traitItem)\n\n}\n\nfor (let trapping of trappings) \n{\n  let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n  if (trappingItem)\n  {\n      trappingItem = trappingItem.toObject()\n\n      trappingItem.system.equipped.value = true;\n\n      items.push(trappingItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n  }\n}\n\nfor (let spell of spells) \n{\n  let spellItem = await game.wfrp4e.utility.findItem(spell)\n  if (spellItem)\n  {\n      spellItem = spellItem.toObject()\n\n      items.push(spellItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${spell}`, {permanent : true})\n  }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","lMRsQRgjMexY9dxE":"return [\"NAME.Endurance\", \"NAME.Cool\"].map(i => game.i18n.localize(i)).includes(args.skill?.name)","lOIHiAIDtj91kllN":"const chanties = await warhammer.utility.findAllItems('wfrp4e-soc.chanty', \"Loading Chanties\", true);\nlet choice = await ItemDialog.create(chanties, 1, {text : \"Choose Chanty\", title : this.effect.name});\nif (choice.length) \n{\n  this.actor.addEffectItems(choice.map(i => i.uuid), this.effect)\n}","lOzkngzye4RmvALp":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.DrNUTPeodEgpWTnT\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id});\nthis.script.notification(\"Added \" + item.name)","lPudo1grrVp05i7a":"let loc = Math.floor(CONFIG.Dice.randomUniform() * 2) == 0 ? \"head\" : \"body\"\nlet damage = this.actor.system.characteristics.s.bonus + 6\n\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name}).then(async test => {\n           await test.roll();\n           if(test.failed)\n           {\n               await this.actor.addCondition(\"stunned\")\n               this.script.message(await this.actor.applyBasicDamage(damage, {loc, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}))\n           }\n    })","lQJ68n3y1xDyNicE":"return !args.context.sizeModifier && args.item?.system?.attackType != \"ranged\"","lRZhkh8pcu93QTKz":"if (args.test.spell)\n{\n\targs.test.preData.SL = -10\n}","lSOAZ4FG44bT4jh1":"let infected = await fromUuid(\"Compendium.wfrp4e-core.items.V0c3qBU1CMm8bmsW\")\nlet fear = await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")\n\nlet infectedData = infected.toObject();\nlet fearData = fear.toObject();\nfearData.system.specification.value = 2;\nthis.actor.createEmbeddedDocuments(\"Item\", [fearData, infectedData], {fromEffect : this.effect.id})","lU4s3UTtBkU38djI":"this.actor.addCondition(\"entangled\")\nlet msg = `<b>${this.actor.prototypeToken.name}</b> loses 1 Wound and gains 1 <strong>Entangled</strong> Condition.`\nthis.script.message(msg)\nthis.actor.modifyWounds(-1)","lYYkGzqNshiYc7WI":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"poisoned\")\n}","lZuavewrJzOehrJQ":"let test = await this.actor.setupSkill('Endurance',  {\n  appendTitle: ` – ${this.effect.name}`,\n  skipTargets: true,\n  fields: {difficulty: 'easy'},\n  characteristic: 't',\n  context: {failure: \"Mast shattered!\"}\n});\nawait test.roll();\n\nif (test.failed) {\n  let crit = await fromUuid(\"Item.d4bCnR1zINTNF9VC\");\n  await this.actor.createEmbeddedDocuments(\"Item\", [crit]);\n  this.effect.update({disabled: true});\n}","laptAldsT0Fm1rDt":"let blunt = await foundry.applications.api.DialogV2.confirm({window: {title : this.effect.name}, content :`<p>Apply blunt damage reduction? (-3)</p>`})\n\nif (blunt)\n{\n    args.modifiers.other.push({label : this.effect.name, details : \"Blunt Damage Reduction\", value : -3})\n}","lhemR8EP5tGNKout":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields: {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context : {failure : \"Suffer Creeping Irrationality\"}})\nawait test.roll();\nif (test.failed)\n{\n    msg = `<p>@UUID[${this.effect.sourceItem.uuid}]{Creeping Irratitonality} Roll: <a class=\"inline-roll\"><i class=\"fas fa-dice-d20\"></i>${Math.ceil(CONFIG.Dice.randomUniform() * 10)}</a></p>`\n    if (test.result.roll % 11 == 0 || test.result.roll == 100)\n    {\n        msg += `<p><b>${this.actor.prototypeToken.name}</b> also gained 1 Corruption Point. If mutating, this results in a @Table[mutatemental]{Mental Corruption}</p>`\n        let newCorruption = Number(this.actor.status.corruption.value) + 1\n        this.actor.update({\"system.status.corruption.value\" : newCorruption})\n    }\n\n    this.script.message(msg);\n}\n","lj7vOpa6tHHZ9bBB":"return this.actor.attacker","ljGX2w8hCTyLAjRp":"let specification = Number(this.item.specification.value) || 1;\nargs.actor.system.details.price.gc -= Math.floor(args.actor.system.details.price.gc * 0.1 * specification);","ljpM7muMyxGD04EX":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MVI0lXcg6vvtooAF\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","lmBAZCtofsC8hHHG":"let SL = 1;\n\ndo {\n  const signedSL = SL >= 0 ? `+${SL}` : \"SL\";\n  const content = `\n  <div>\n    <p style=\"font-weight: bold;\">You have accrued ${signedSL} ${SL > 1 ? \"SLs\" : \"SL\"}. Do you want to roll d10?</p>\n    <p>1–6: add +1 SL</p>\n    <p>7–10: lose all accrued SLs and perform next Test at –1 SL</p>\n  </div>\n`;\n  const choice = await foundry.applications.api.DialogV2.confirm({\n    yes: {label: \"Roll\", icon: \"fas fa-dice\"},\n    no: {label: `Keep ${signedSL} SL`, icon: \"fas fa-check\"},\n    content,\n  });\n\n  if (!choice) break;\n\n  const roll = new Roll(\"1d10\");\n  await roll.toMessage({flavor: this.effect.name});\n\n  if (roll.total >= 7) {\n    SL = -1;\n    break;\n  }\n\n  SL++;\n} while (true);\n\nthis.effect.setFlag(\"wfrp4e\", \"SL\", SL);","lol5J6h0pErzM71s":"return args.weapon?.system.properties.flaws.crewed","lvjcddwRiN9iGruy":"let test = await this.actor.setupCharacteristic(\"t\", { appendTitle: ` - ${this.effect.name}`, fields: { difficulty: \"challenging\" } })\nawait test.roll();\n\nif (test.failed) \n{\n    let ageAdded = Math.ceil(CONFIG.Dice.randomUniform() * 10) + Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let ws = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let bs = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let s = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let t = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let ag = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let dex = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n\n    let currentAge = parseInt(this.actor.system.details.age.value)\n\n    let inline = `<a class=\"inline-roll\" data-tooltip=\"@TT\"><i class=\"fas fa-dice-d20\"></i>@ROLL</a>`\n    let msg =\n        `<p><b>${this.actor.prototypeToken.name}</b> ages by ${inline.replace(\"@ROLL\", ageAdded).replace(\"@TT\", \"2d10\")} and loses</p>\n      <p>${inline.replace(\"@ROLL\", ws).replace(\"@TT\", \"1d10\")} <b>Weapon Skill</b></p>\n      <p>${inline.replace(\"@ROLL\", bs).replace(\"@TT\", \"1d10\")} <b>Ballistic Skill</b></p>\n      <p>${inline.replace(\"@ROLL\", s).replace(\"@TT\", \"1d10\")} <b>Strength</b></p>\n      <p>${inline.replace(\"@ROLL\", t).replace(\"@TT\", \"1d10\")} <b>Toughness</b></p>\n      <p>${inline.replace(\"@ROLL\", ag).replace(\"@TT\", \"1d10\")} <b>Agility</b></p>\n `\n    this.script.message(msg);\n\n    let characteristics = foundry.utils.duplicate(this.actor.system.characteristics)\n\n    characteristics.ws.initial -= ws\n    characteristics.bs.initial -= bs\n    characteristics.s.initial -= s\n    characteristics.t.initial -= t\n    characteristics.ag.initial -= ag\n    characteristics.dex.initial -= dex\n\n    this.actor.update({ \"system.characteristics\": characteristics, \"data.details.age.value\": ageAdded + currentAge })\n}","lwVhn4bSXJ3eoT9q":"if (this.item.system.weaponGroup.value == \"basic\")\n{\n    let slash = this.item.system.qualities.value.find(i => i.name == \"slash\")\n    if (slash)\n    {\n        slash.value = \"2A\"\n    }\n}","m3qEVO5fseV6KHXa":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.qn4ZpvTQIX4rcJDl\")\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","m4eagTrVOXtotonR":"// Get the size\nlet size = this.actor.sizeNum \nlet diff = \"difficult\";\nif (size < 5) { // 5 = Monstrous\n   diff = \"hard\";\n}\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : diff}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed) {\n        this.actor.addSystemEffect(\"fear\")\n}","m58MpMZBblpq5LJu":"args.prefillModifiers.slBonus++;\nargs.prefillModifiers.successBonus++;\n","m84kG5cEPEByqHdd":"const uuid = \"Compendium.wfrp4e-core.items.Item.SfUUdOGjdYpr3KSR\";\nconst item = await fromUuid(uuid);\nawait this.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect: this.effect.id});","m8qBlbH7ROoqa22o":"return args.context.reload","mBcLf11upaHS8AQq":"this.actor.status.addArmour(1, {source: this.effect})","mGHKBkDp4omSaBlD":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 20,\n      \"bright\": 10,\n      \"angle\": 360,\n      \"alpha\": 0.4,\n      \"animation\": {\n          \"speed\": 3,\n          \"intensity\": 3,\n          \"type\": \"torch\",\n      },\n      \"color\": \"#ffcc66\",\n  }}));","mJ9eMPub4epJSf00":"return args.weapon?.system.qualities.value.find(i => i.name == \"shield\") && this.actor.attacker","mPxmCsXYirAIT913":"let key = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.characteristics, this.effect.img), 1, \"Choose Characteristic\");\n\nthis.effect.updateSource({changes : [{key : `system.characteristics.${key[0].id}.modifier`, mode : 2, value : 10}]})","mRvLsSVxNyt8LVZb":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.GRRN3XAKIpEVCY7z\")\nlet data = item.toObject();\ndata.name += \" (To Be Determined)\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","mT7PDcjF3cJTDbjR":"args.actor.system.details.move.value -= 1;\nargs.actor.system.status.carries.max *= 1.25;","mTnmPcjWmvScIBWY":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\")) || args.type == \"channelling\"","mV4Tmc0yfpL09KV7":"args.actor.addCondition(\"entangled\")","mXvtf3qhJjshpopX":"return [\"weapon\", \"cast\", \"channelling\"].includes(args.type)","mYL4i1vNlMl4vFYy":"return args.skill?.name != game.i18n.localize(\"NAME.Perception\") && args.skill?.name != game.i18n.localize(\"NAME.Track\");","ma0sWhebqwdRHWvY":"if (!args.flags.trained)\n{\n    args.flags.trained = true;\n    args.fields.modifier += 10;\n}","maKr58mvvyKxFyC3":"if (args.item.type == \"prayer\" && (args.item.damage.value || args.item.damage.dice))\n    args.item.damage.value += \"+1\"","masOBNgSi5HYkf3m":"return args.type != \"cast\" && args.type != \"channelling\"","mgLGN1XPzPE4dReN":"args.fields.slBonus--;","mlulnXQo8XU8vKLD":"if (isNaN(parseInt(this.item.system.specification.value)))\n{\n    let value = await ValueDialog.create({tetx : \"Enter Grim value\", title : this.effect.name});\n    if (value)\n    {\n     this.item.updateSource({\"system.specification.value\" : value});\n    }\n}","mr8qm5Bg6k1idZ6Q":"return args.item?.name == `${game.i18n.localize(\"NAME.Play\")} (${game.i18n.localize(\"SPEC.Lute\")})`","mziJBUYcsrhkdcCJ":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{  \n    this.actor.addCondition(\"prone\")\n}","n5RJqJL9fdRIxkuN":"if (this.actor.system.status.advantage.value > 0)\n{\n    await this.actor.modifyAdvantage(-1);\n    this.script.notification(\"Advantage Subtracted\")\n}\nelse \n{\n    return this.script.notification(\"Not enough Advantage!\", \"error\")\n}\n\nlet test = await this.actor.setupTrait(this.item)\nawait test.roll();","n5wowuDE8Dz1uBZn":"let damage = this.effect.sourceActor.characteristics.int.bonus + 6;\nif (this.actor.has(game.i18n.localize(\"NAME.Undead\")) || this.actor.has(game.i18n.localize(\"NAME.Daemonic\"))) { \n   damage += 6\n}\nthis.script.scriptMessage(await this.actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg: true}));\n\nlet test = await this.actor.setupCharacteristic(\"int\", {fields : {difficulty : \"average\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed) {\n\tthis.actor.addCondition(\"stunned\");\n}","nCWAflBj7Si2BI1Q":"if (args.item.type == \"spell\" && args.item.system.lore.value != \"petty\")\n{\n    args.item.cn.value = Math.max(4, args.item.cn.value * 2)\n}","nD2QVg3DrPK3foMf":"args.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), { fields: { difficulty: \"average\" } }).then(async test => {\n      await test.roll();\n      if (test.failed) {\n        await args.actor.addCondition(\"bleeding\")\n        await args.actor.addCondition(\"entangled\")\n      }\n    })","nEaF3jbCiVYD8jia":"return args.skill?.name != game.i18n.localize(\"NAME.Charm\") && !args.skill?.name.includes(game.i18n.localize(\"NAME.Lore\"));","nGTxNWBUBgTr87wU":"if (args.opposedTest.result.differenceSL >= 0 && args.opposedTest.result.differenceSL <= 2 && args.opposedTest.result.winner == \"attacker\")\n{ \n    this.script.message(`Becomes lodged in the armour or flesh of the opponent. See @UUID[${this.item.uuid}]{${this.item.name}}.`, speaker : {alias : this.item.name}, {blind: true, whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}\n    ","nHJdlqbOP0ECgywb":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.CnydL8p3PVAuF98w\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","nIOeK0BrtdZeZW8X":"console.log(\"SKILL\", this)\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {fields : {difficulty : \"challenging\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\n\nlet rollD10 = await new Roll(\"1d10\").roll()\nrollD10.toMessage(this.script.getChatData())\n\n\nif (test.succeeded)\n{\n  //...\n}\nelse if (test.failed)\n{\n  //...\n}\n","nNwAFEURKlFhPcvA":"CorruptionMessageModel.createCorruptionMessage(\"minor\", this.script.getChatData());","nSXzktHyNjGUXjaw":"return args.item?.system.isRanged","nYtAjSArsNbrU2ob":"if ([\"ag\", \"i\", \"int\"].includes(args.characteristic))\n{\n    args.fields.modifier -= 10;\n}\nelse if ([\"wp\"].includes(args.characteristic))\n{\n    args.fields.modifier += 10;\n}","naF5EWr1CBkYRZTK":"if (args.opposedTest?.attackerTest?.item?.system?.isRanged) \n{\n    let choice = await foundry.applications.api.DialogV2.confirm({window: {title : this.item.name}, content : `<p>Abort damage with <strong>${this.effect.name}</strong>?</p>`})\n\n    if (choice)\n    {\n        args.abort = `<strong>${this.effect.name}</strong>: Damage cancelled`\n    }\n}","ncIjDE6TFx88IQA1":"return args.skill?.name == game.i18n.localize(\"NAME.Climb\") || args.skill?.name == game.i18n.localize(\"NAME.Athletics\");","neaaVy6D6tfcst5P":"args.fields.slBonus += this.actor.characteristics.i.bonus;\n","ngMm7SgtVqVovFJG":"if (args.test.result.critical && args.test.result.critical != \"Total Power\")\n{\n   args.test.result.other.push(`<a data-action=\"clickTable\" class=\"action-link critical\" data-modifier=\"20\" data-table = \"crit${args.test.result.hitloc.result}\"><i class=\"fas fa-list\"></i> Bonecrusher Critical (+20)</a> (only if Critical Cast selected)`)\n}","njPP9wDAsdh4WHIj":"if (args.totalWoundLoss > 0 && [\"trait\", \"weapon\"].includes(args.opposedTest.attackerTest.item?.type))\n{\n     this.script.message(`<b>Infected: ${args.actor.name}</b> must pass an <b>Easy (+20) Endurance</b> Test or gain a @UUID[Compendium.wfrp4e-core.items.kKccDTGzWzSXCBOb]{Festering Wound}`, {whisper: ChatMessage.getWhisperRecipients(\"GM\")})\n}","nkSmu7v9WiAaK4vq":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Tailor)';\nconst difficulty = 'easy';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n      \n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","nkbTnaeBpthyhw4J":"let fortunePoints = this.effect.sourceTest.result.overcast.usage.other.current\nlet current = this.actor.status.fortune.value\n\nthis.actor.update({\"system.status.fortune.value\" : fortunePoints + current})\n\nthis.script.message(`<b>${this.actor.prototypeToken.name}</b> fortune points increased from ${current} to ${fortunePoints + current}`)","nkdKBJ8ItqWiRAWL":"// Apply changes when the mask is worn\n\nif (args.equipped) {  \n  this.actor.createEmbeddedDocuments(\"ActiveEffect\", [this.item.effects.contents[1]?.convertToApplied()])  \n  this.script.message(`${this.actor.name} dons the <strong>${this.item.name}</strong>. <br>\n        They gain +50 to Swim Tests and can breathe underwater.<br>\n        If they wear the mask for more than an hour or benefit from any of its effects, they are exposed to @Corruption[moderate]{Moderate Corruption}. \n        `,\n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n}\n\n// Notify of lingering effects when mask is removed\nelse if (!args.equipped)\n{\n    await this.item.effects.contents[0].delete();\n    await this.item.update({name : this.item.name += \" (Used)\"})\n    this.script.message(`<strong>${this.item.name}</strong> on ${this.actor.name} has been taken off and loses its properties. However, the effects last for [[1d10+4]] days, after which they should be manually removed.`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n    )\n    \n}\n","nlQA0shW8FCXjY7u":"return args.type != \"cast\" || args.item.lore.value != \"fire\"","nqWu0ZplxzRiUEAg":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\n// Kind of insane but whatever\nlet opposedResult = test.opposedMessages[0]?.system.opposedHandler?.resultMessage?.system.opposedTest?.result\n\nreturn opposedResult?.winner == \"attacker\";","nuIpPD4uaZRuJni8":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.qdMbxW09FUoYBzmB\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","nvrFhHHVq3KzirlR":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Stealth\"))\n","nxNqWmmF6mJTnrLo":"return args.weapon?.system.usesHands.includes(this.item.system.location.key);","nzh8d46l1ikhkz8Q":"return (args.type == \"weapon\" && (args.item.system.weaponGroup.value == \"blackpowder\" || args.item.system.weaponGroup.value == \"engineering\")) || (args.type == \"cast\" && args.item.system.lore.value == \"fire\")","o1zD8mej9TWKNxUq":"args.fields.slBonus -= 1;","o3JUBKLvE6bBxK2n":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), { fields: { difficulty: \"average\" } })\nawait test.roll();\nif (test.failed) \n{\n    await this.actor.addCondition(\"prone\")\n    let injury = await fromUuid(\"Compendium.wfrp4e-core.items.ZhMADOqoo0y8Q9bx\");\n    injury = injury.toObject()\n    let toes = Math.clamp(Math.abs(test.result.SL) + 1, 1, 5)\n    injury.system.location.key = this.item.system.location.key[0] + injury.system.location.value\n    if (injury.system.location.key[0] == \"r\")\n    {\n        injury.system.location.value = `${toes} Right ${injury.system.location.value}s`\n    }\n    else if (injury.system.location.key[0] == \"l\")\n    {\n        injury.system.location.value = `${toes} Left ${injury.system.location.value}s`\n    }\n    foundry.utils.setProperty(injury, \"system.wfrp4e.count\", toes)\n    this.actor.createEmbeddedDocuments(\"Item\", [injury])\n}","o88xuUConwt0vFLw":"let points = this.effect.sourceTest.result.overcast.usage.other.current;\n\nthis.actor.update({\"system.status.fortune.value\" : this.actor.system.status.fortune.value + points});\n\nthis.script.message(`Gained ${points} Fortune Points`)","oDNfCNyt5KaUYmg2":"if(args.opposedTest.result.winner == \"defender\")\n{\n    let roll = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n    let msg = `Rolled ${roll}.`\n    if (roll >= 7)\n    {\n          msg = `Attack hits with an SL of ${roll - 6}.`\n    }\n    this.script.message(msg, {blind: true,  whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","oEsUsI74yGTZ9CwU":"return args.item?.name == game.i18n.localize(\"NAME.CharmAnimal\")","oGdsGPgJWcyWkiWl":"this.actor.addCondition(\"broken\")\n\nif (this.actor.has(game.i18n.localize(\"NAME.Undead\")))\n{\n    this.script.message(await this.actor.applyBasicDamage(this.effect.sourceTest.result.damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg: true}))\n}","oHenUKtaS3jT5xQn":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.4xF7M6ylIiGntekh\")\nitem = item.toObject()\nitem.name = this.effect.name\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})\n","oPg4se8iQRD14kmB":"let filters = [\n    {\n        property : \"type\",\n        value : \"weapon\"\n    },\n    {\n        property : \"system.weaponGroup.value\",\n        value : [\"twohanded\", \"polearm\"]\n    }\n]\n\nlet items = await ItemDialog.createFromFilters(filters, 1, {text : \"Choose an appropriate Polearm or Two-Handed Weapon\"})\nitems = items.map(i => i.toObject())\n\nitems.forEach(i => i.system.equipped.value = true);\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","oQI06eh8mJ9UqETO":"if (this.item.system.disabled) {\n  await this.effect.deleteCreatedItems();\n} else if (!this.actor.items.find(i => i.name === \"Stealthy\")) {\n  await this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.OzwDT6kzoLYeeR2d\", this.effect);\n}","oTXPA6rbPnYOKNmo":"let characteristics = {\n    \"ws\" : 35,\n    \"bs\" : 10,\n    \"s\" : 25,\n    \"t\" : 30,\n    \"i\" : 30,\n    \"ag\" : 25,\n    \"dex\" : 0,\n    \"int\" : 15,\n    \"wp\" : 35,\n    \"fel\" : 15\n}\nlet skills = [\"Cool\", \"Dodge\", \"Intimidate\", \"Intuition\", \"Language (Battle)\", \"Leadership\", \"Lore (Warfare)\", \"Perception\"]\nlet skillAdvancements = [25, 15, 25, 25, 15, 30, 20, 20]\n\nlet talents = [\"Combat Aware\", \"Combat Master\", \"Combat Reflexes\", \"Inspiring\", \"Luck\", \"Resolute\", \"Unshakable\", \"War Leader\"]\nlet trappings = [\"Hand Weapon\",  \"Shield\", \"Plate Breastplate\", \"Plate Bracers\", \"Plate Helm\", \"Plate Leggings\"]\nlet specialItems = [ \n    {name: \"Two Handed Weapon\", type: \"trapping\", trappingType: \"clothingAccessories\" }, \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWFRP4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nlet filters = [\n    {\n        property : \"type\",\n        value : \"weapon\"\n    },\n    {\n        property : \"system.weaponGroup.value\",\n        value : [\"twohanded\", \"polearm\"]\n    }\n]\n\nitems = items.concat(await ItemDialog.createFromFilters(filters, 1, {text: \"Choose an appropriate Polearm or Two-Handed Weapon\"}))\n\nlet ride = await foundry.applications.api.DialogV2.confirm({window : {title : \"Skill\"}, content : \"Add Chaos Steed and +20 Ride (Horse)?\"})\n\nif (ride)\n{\n    let skill = await game.wfrp4e.utility.findSkill(\"Ride (Horse)\")\n    skill = skill.toObject();\n    skill.system.advances.value = 20;\n    items = items.concat({name : \"Chaos Steed\", type: \"trapping\", \"system.trappingType.value\" : \"misc\"}, skill)\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nconsole.log(\">>>>>>><\", items)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","oV81zgbZsuTFG6L2":"let caster = this.effect.sourceActor;\n\nthis.actor.modifyWounds(caster.system.characteristics.fel.bonus);\n\nthis.script.message(`Healed ${caster.system.characteristics.fel.bonus} Wounds`);","oW1gtYVT5nrxDjM7":"return args.characteristic != \"ag\"","oWM43EdUiyHgUlfW":"if (args.test.item && args.test.item.name == game.i18n.localize(\"NAME.ConsumeAlcohol\"))\n    args.test.preData.canReverse = true","oWa7RkScnl6lR5vd":"if (args.test.characteristicKey == \"wp\") \n{\n    if (args.test.failed)\n    {\n        let item = await fromUuid(\"Compendium.wfrp4e-core.items.AGcJl5rHjkyIQBPP\")\n        let data = item.toObject();\n        this.actor.createEmbeddedDocuments(\"Item\", [data])\n        \n        this.script.message(`Willpower Test failed, <b>${this.actor.prototypeToken.name}</b> gains @UUID[Compendium.wfrp4e-core.items.AGcJl5rHjkyIQBPP] for [[1d10]] hours`)\n    }\n}","obIXhQXKFyyQoNNV":"this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {appendTitle: ` - ${this.effect.name}`, fields: { difficulty: \"average\" } }).then(async test => {\n    await test.roll()\n    if (test.failed) {\n        this.actor.modifyWounds(-1);\n        this.script.message(\"Takes 1 Damage\")\n    }\n})","ocBW3osTFnb5JCfe":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.MVI0lXcg6vvtooAF\")\nlet data = item.toObject()\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","ofddAHvzn1xUueSG":"args.AP.head.value -= tinDifference(args.AP.head.layers)\nargs.AP.body.value -= tinDifference(args.AP.body.layers)\nargs.AP.lArm.value -= tinDifference(args.AP.lArm.layers)\nargs.AP.rArm.value -= tinDifference(args.AP.rArm.layers)\nargs.AP.rLeg.value -= tinDifference(args.AP.rLeg.layers)\nargs.AP.lLeg.value -= tinDifference(args.AP.lLeg.layers)\n\nfunction tinDifference(layers)\n{ \n   let metalAP = layers.filter(i => i.metal).reduce((prev, current) => prev + current.value, 0)\n\n   let tinAP = layers.filter(i => i.metal).reduce((prev, current) => prev + Math.max(0, current.value - 2), 0)\n\n   return metalAP - tinAP;\n}","ogJBAXTXyhTqACPO":"return args.item?.system.attackType != \"melee\"","ohl803m0tUwNfKAk":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet data = item.toObject();\ndata.system.specification.value = 5 - this.actor.characteristics.s.bonus\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","okW06V9UiPC4Vcrn":"let characteristics = {\n    \"ws\" : 5,\n    \"bs\" : 0,\n    \"s\" : 5,\n    \"t\" : 5,\n    \"i\" : 10,\n    \"ag\" : 0,\n    \"dex\" : 0,\n    \"int\" : 0,\n    \"wp\" : 5,\n    \"fel\" : 5\n}\nlet skills = [\"Cool\", \"Dodge\"]\nlet skillAdvancements = [10, 10]\nlet talents = [\"Combat Reflexes\", \"Resolute\"]\nlet trappings = [\"Leather Jack\", \"Leather Leggings\", \"Leather Skullcap\", \"Hand Weapon\", \"Spear\", \"Shield\"]\nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n\n","okr3TtzpFoefUuJS":"let item = await fromUuid('Compendium.wfrp4e-core.items.EaqlLRQigwnsEAXX')\nlet data = item.toObject();\ndata.system.location.value = \"Collar Bone\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","oqgd9G6oI1ncPYLw":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.CV9btQn09S9Fn8Jk\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id});","p222EiR8RRtlPm31":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\nawait test.roll();\nreturn test.failed;","p7NJB1PsY6X5q8OO":"if (this.actor.system.details.experience.current < 100) {\n  return this.script.notification(game.i18n.localize(\"SCRIPT.NotEnoughXP\"))\n}\n\nlet traits = await warhammer.utility.findAllItems(\"trait\", null, true);\ntraits = traits.filter(t => t.name.includes(\"Companion Trait\"));\n\nlet items = await ItemDialog.create(traits);\nthis.actor.createEmbeddedDocuments(\"Item\", items);\nlet expLog = foundry.utils.duplicate(this.actor.details.experience.log || []);\nexpLog.push({amount : 100, reason: items[0].name, spent: this.actor.details.experience.spent + 100, total: this.actor.details.experience.total, type: \"spent\"});\nthis.actor.update({\n    \"system.details.experience.spent\": this.actor.details.experience.spent + 100,\n    \"system.details.experience.log\": expLog\n  });","pAgiAGyaLJY10894":"return args.skill?.name == game.i18n.localize(\"NAME.Charm\");","pBMioPUtDn1mk9f5":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.5KP9sOoLSGvj9EXp\")\nlet data = item.toObject();    \nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});","pG5OVokZzCRHIrwz":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.mgeiaDZXei7JBEgo\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","pHyXdPnWwoFrUA5n":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Entertain\"));","pLKv4moua6XhNdmA":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.1dUizIgLBgn4jICC\");\nlet data = item.toObject();\ndata.name += \" (Woodlands)\";\nthis.actor.createEmbeddedDocuments(\"Item\", Array(this.effect.sourceTest.result.overcast.usage.other.current).fill(data), {fromEffect : this.effect.id})","pNPjXEoQGHLKzq0r":"let talent = this.actor.has(\"Arcane Magic (Light)\", \"talent\")\nlet demon = this.actor.has(game.i18n.localize(\"NAME.Daemonic\"))\n\nif (!talent)\n{\n   await this.actor.addCondition(\"blinded\")\n}\n\nif (demon)\n{\n    await this.actor.addCondition(\"stunned\")\n}","pPV9oEydXb7oi6jX":" if (args.totalWoundLoss > 0)\n {\n    args.actor.addCondition('ablaze')\n }","pR4Q2OnPxXtwRVli":"let criticals = this.actor.itemTypes.critical;\n\nif (criticals.length)\n{\n    this.script.notification(\"Cannot suffer Critical Wounds\");\n    this.actor.deleteEmbeddedDocuments(\"Item\", criticals.map(i => i.id))\n}\n\nif (foundry.utils.getProperty(args.data, \"system.status.wounds.value\") == 0)\n{\n    this.script.notification(`Dormant for ${Math.ceil(CONFIG.Dice.randomUniform() * 10)} Rounds`)\n}","pVSnn4Zw6y1EBDhv":"args.actor.system.details.man -= 1;\nargs.actor.system.details.move.value -= 1;","pdvCwjxHI56EmxuU":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.sJ3yX1kvzu2hgNq5\")\nlet amphibious = item.toObject();\n\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.Item.9h82z72XGo9tfgQS\")\nlet as = item.toObject();\nas.name += \" (Sight)\";\nawait this.actor.createEmbeddedDocuments(\"Item\", [amphibious, as], {fromEffect : this.effect.id})","pj7gjxHrnrZonC6U":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.8pVzgPkgWpTJvfhG\")\nlet data = item.toObject();\ndata.name = `${data.name} (Undead, Warm-bloods)`;\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","pkKpxVqRHIzywerL":"const ablaze = this.actor.hasCondition(\"ablaze\");\n\nif (ablaze) {\n    ablaze.delete();\n    this.script.notification(\"Resisted Ablaze\");\n}","pnB9TzSEytkxk3Rb":"return this.actor.hasSystemEffect(\"infighting\")","ppc8L3WtIx6JzlAd":"if (args.equipped) {\n  await this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.mDgEMOoJpi8DkRYb\", this.effect);\n} else {\n  this.effect.deleteCreatedItems()\n}","pq1YQffxtOcqCRTn":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {appendTitle: ` - ${this.effect.name}`})\nawait test.roll();\nif (!test.succeeded)\n{\n    this.actor.addCondition(\"prone\")\n}","pqQkeUVpuZ0jOKnZ":"const tables = [\n  game.wfrp4e.tables.findTable(\"mutatephys\"),\n  game.wfrp4e.tables.findTable(\"mutatephys\", \"Khorne\"),\n];\n\nif (!tables.length) {\n  return ui.notifications.error(\"Mutation table not found, please ensure a table with the `mutatephys` key is imported in the world.\");\n}\n\nconst values = {}\n\nlet i = 0;\nfor (const table of tables) {\n  values[i] = table.name;\n  i++;\n}\n\nconst key = await ValueDialog.create({}, null, values);\nconst table = tables[key];\n\nconst results = (await table.drawMany(2)).results;\nconst uuids = results.map(result => `Compendium.${result.documentCollection}.${result.documentId}`);\n\nawait this.actor.addEffectItems(uuids, this.effect);\nthis.script.notification(\"Rolled and applied mutations\");","pvTcazVvW4v04otW":"if (args.totalWoundLoss > 0) {\n    await 0rgs.actor.addCondition(\"poisoned\", 2)\n}","pvk5OhTNdVgwXoUa":"args.fields.successBonus += 2;","px7eEdhOEt7zOTrq":"return [\"int\", \"t\", \"wp\", \"i\"].includes(args.characteristic)","pzimrxrqpv282Oqb":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.TaYriYcJkFuIdBKp\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id});\n","pzknBcJtZWeliE27":"return args.item?.name == game.i18n.localize(\"NAME.Leadership\") || args.item?.name == game.i18n.localize(\"NAME.Cool\")","q0LvphC8RDSyR0oY":"let choice = await ItemDialog.create(ItemDialog.objectToArray({\n    ws : game.wfrp4e.config.characteristics.ws,\n    t : game.wfrp4e.config.characteristics.t,\n    ag : game.wfrp4e.config.characteristics.ag,\n    wp : game.wfrp4e.config.characteristics.wp\n}, this.effect.img), 1, \"Choose Characteristic\");\n\nthis.effect.updateSource({\"flags.wfrp4e.characteristic\" : choice[0].id})","q3nRyXaxksdCiLFM":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.j6v78dnOOdCB6c3d\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","q8lOAWr2970sZeTw":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpentry)';\nconst difficulty = 'challenging';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      \n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","qAEZgtu5CrfUkxhx":"if (args.test.options.staunchBleeding) \n{\n if (args.test.succeeded) \n {\n   let staunch =  Number(args.test.result.SL) + 1\n   if (args.test.options.fieldDressing && args.test.result.reversed)\n   {\n     staunch =  Math.min(1, Number(args.test.result.SL)) + 1\n   }\n   args.test.result.other.push(`<b>${this.actor.name}</b> removed <b>${staunch}</b> Bleeding conditions from the patient.`)\n }\n   else if (this.actor.characteristics.int.bonus + Number(args.test.result.SL) < 0)\n   {\n      args.test.result.other.push(`The patient contracts a @UUID[Compendium.wfrp4e-core.items.Item.1hQuVFZt9QnnbWzg]{Minor Infection}.`)\n   }\n}","qDYJnO2JosPJrjpz":"if (args.totalWoundLoss <= 0) return;\n\n// Poisoned handled by Venom trait\n\nconst test = await args.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {\n  skipTargets: true,\n  appendTitle: ` — ${this.effect.name}`,\n  fields: {difficulty: \"average\"},\n  context: {\n    failure: `Gained 1 Corruption.`\n  }\n});\n\nawait test.roll();\n\nif (test.failed && args.actor.type === \"character\")\n  args.actor.update({\"system.status.corruption.value\": args.actor.system.status.corruption.value + 1});\n\n\nawait args.actor.applyEffect({effects : this.item.effects.getName(\"Bite of the Purple Skullback\")})","qK4q4o6cQhcGzFX3":"let fear = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet leader = await fromUuid(\"Compendium.wfrp4e-core.items.Item.vCgEAetBMngR53aT\")\nlet fearData = fear.toObject();\nlet leaderData = leader.toObject();\nfearData.system.specification.value = this.effect.sourceTest.result.overcast.usage.other.current; \ntalents = new Array(1 + this.effect.sourceTest.result.overcast.available).fill(leaderData); // Assume any unused overcast is for war leader\nthis.actor.createEmbeddedDocuments(\"Item\", [fearData].concat(talents), {fromEffect : this.effect.id})","qSwCYMMiIHmSV1X5":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n     let effectData = this.item.effects.contents[0].convertToApplied();\n\t effectData.system.sourceData.item = this.item.uuid\n     effectData.duration.seconds = 10800\n\tactor.applyEffect({effectData : [effectData]})\n}\nelse\n{\n\tthis.script.notification(\"None left!\", \"error\")\n}","qT0WBPxLMMO9gvCd":"if (!this.actor.has(\"Night Vision\") && !this.actor.has(\"Night Vision\", \"talent\") && !this.actor.hasCondition(\"blinded\"))\n{\n    this.actor.addCondition(\"blinded\", 1, {\"flags.wfrp4e.nightshroud\" : true})\n}","qTcK1TSjLTi0jNQK":"let AP = args.actor.status.armour;\n\nAP[\"head\"].value += 1;\nAP[\"rArm\"].value += 1;\nAP[\"lArm\"].value += 1;\nAP[\"body\"].value += 1;\nAP[\"lLeg\"].value += 1;\nAP[\"rLeg\"].value += 1;","qTk96NKh14YOIShf":"return args.skill?.name === game.i18n.localize(\"NAME.Haggle\");","qUwnVlWpsmDom3RK":"args.fields.modifier -= 5;","qZ8TBagp2d4dJAqI":"return !args.weapon || args.weapon?.system.isMelee","qZschZU0nee0kJlk":"args.fields.modifier -= 30;","qaVde0sTuMBRi2nl":"return [\"NAME.Evaluate\", \"NAME.Gamble\"].map(i => game.i18n.localize(i)).includes(args.skill?.name)","qcyl98GYD55BkJsD":"this.actor.status.encumbrance.state = 0;\nthis.actor.status.encumbrance.pct = 0;","qijgjcOBCDmhglRX":"return args.skill?.name == game.i18n.localize(\"NAME.SleightOfHand\");","qjli5evn8UA9uTeZ":"return args.actor.uuid == this.effect.sourceActor.uuid;","qmH61HmrEJcmQTiu":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.tNWrJUOArwfWXsPw\");\nitem = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id});","qmOt7h17hGAKqQe0":"\n\nif (!args.opposedTest.attackerTest.item?.system?.isMelee) \n{\n    let choice = await foundry.applications.api.DialogV2.confirm({ window: { title: this.effect.name }, content: `<p><strong>${this.effect.name}</strong>: Is this a ranged or magical attack that orignates outside the Dome?</p>` })\n\n    if (choice) \n    {\n        args.ward = 6;\n    }\n}\n","qnJu82zgnfOsnqZV":"let closed = !this.item.getFlag(\"wfrp4e-soc\", \"gunport\") || false;\n\nawait this.item.setFlag(\"wfrp4e-soc\", \"gunport\", closed);\nlet scriptData = this.effect.system.scriptData;\n\nif (closed) {\n  scriptData[0].label = \"Open\";\n} else {\n  scriptData[0].label = \"Close\";\n}\n\nawait this.effect.update({\"system.scriptData\": scriptData});","qu194dVXm9Vx1TGk":"if (args.test.options.useOnesSupportive && (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target)) {\n\n   let SL = Math.floor(args.test.target / 10) - Math.floor(args.test.result.roll / 10)\n   let ones = Number(args.test.result.roll.toString().split(\"\").pop())\n\n   if (ones > SL) {\n      args.test.data.result.SL = \"+\" + (ones + args.test.successBonus + args.test.slBonus)\n      args.test.result.other.push(`<b>${this.effect.name}</b>: Used unit dice as SL`)\n   }\n}","quPcuKsq2fcild4a":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"easy\"}, context: {failure : `<strong>${this.effect.name}</strong>: Vomit!`} })\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}","qxzhPtysAjPWspKf":"if (this.actor.has(\"Undead\") || this.actor.has(\"Daemonic\"))\n{\n    this.script.notification(`Cannot enter ${this.effect.name}!`);\n}","qzGPJflVW7c2Ciim":"return args.skill?.name !== game.i18n.localize(\"NAME.Cool\");","r6hi5vMdLhTaaPfb":"args.actor.details.move.value += this.effect.sourceTest.result.overcast.usage.other.current","rBAoyhzeU3Q8MVSk":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'difficult';\nconst target = 50;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        \n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","rCh3ltUrUMovd2Kc":"if (this.actor.hasCondition(\"surprised\"))\n{\n    this.script.notification(\"Cannot be surprised\");\n    this.actor.removeCondition(\"surprised\");\n}","rF0Z3hTUUnSxL3Mq":"let armour = (await fromUuid(\"Compendium.wfrp4e-core.items.VUJUZVN3VYhOaPjj\")).toObject()\nlet bite = (await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")).toObject()\nlet fear = (await fromUuid(\"Compendium.wfrp4e-core.items.pTorrE0l3VybAbtn\")).toObject()\nlet nightVision = (await fromUuid(\"Compendium.wfrp4e-core.items.FmHDbCOy3pH8yKhm\")).toObject()\nlet tracker = (await fromUuid(\"Compendium.wfrp4e-core.items.ClOlztW6hH8rslbp\")).toObject()\nlet weapon = (await fromUuid(\"Compendium.wfrp4e-core.items.AtpAudHA4ybXVlWM\")).toObject()\n\narmour.name = \"Armour (Hide)\"\narmour.system.specification.value = 2\nbite.system.specification.value = 3\nfear.system.specification.value = 2\nweapon.system.specification.value = 4\nlet items = [armour, bite, fear, nightVision, tracker, weapon]\n\n\nlet belligerent = (await fromUuid(\"Compendium.wfrp4e-core.items.GbDyBCu8ZjDp6dkj\")).toObject()//{Belligerent}\nlet bestial = (await fromUuid(\"Compendium.wfrp4e-core.items.AGcJl5rHjkyIQBPP\")).toObject()//{Bestial}\nlet big = (await fromUuid(\"Compendium.wfrp4e-core.items.a8MC97PLzl10WocT\")).toObject()//{Big}\nlet blessed = (await fromUuid(\"Compendium.wfrp4e-core.items.5muSFXd6oc760uVj\")).toObject()//{Blessed (Ulric)}\nlet champion = (await fromUuid(\"Compendium.wfrp4e-core.items.4mF5Sp3t09kZhBYc\")).toObject()//{Champion}\nlet die = (await fromUuid(\"Compendium.wfrp4e-core.items.UsJ2uIOOtHA7JqD5\")).toObject()//{Die Hard}\nlet fast = (await fromUuid(\"Compendium.wfrp4e-core.items.9MjH4xyVrd3Inzak\")).toObject()//{Fast}\nlet frenzy = (await fromUuid(\"Compendium.wfrp4e-core.items.yRhhOlt18COq4e1q\")).toObject()//{Frenzy}\nlet immunity = (await fromUuid(\"Compendium.wfrp4e-core.items.IAWyzDfC286a9MPz\")).toObject()//{Immunity to Psychology}\nlet regenerate = (await fromUuid(\"Compendium.wfrp4e-core.items.SfUUdOGjdYpr3KSR\")).toObject()//{Regenerate}\nlet size = (await fromUuid(\"Compendium.wfrp4e-core.items.8slW8CJ2oVTxeQ6q\")).toObject()//{Size (Large)}\n\nblessed.system.specification.value = \"Ulric\"\nsize.system.specification.value = \"Large\"\n\nlet optional = [belligerent, bestial, big, blessed, champion, die, fast, frenzy, immunity, regenerate, size];\n\nlet chosen = await ItemDialog.create(optional, \"unlimited\", \"Choose Optional Traits\");\n\nitems = items.concat(chosen || [])\nthis.script.notification(`Adding ${items.map(i => i.name).join(\", \")}`);\nthis.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect : this.effect.id})\n","rIISfbCShejmJNKw":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.oRx92ByVNEBN6YkK\")\nlet data = item.toObject()\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n","rJ8pspSekyDLkiqG":"return args.skill.name === game.i18n.localize(\"NAME.Cool\")","rLMaVNEGdZ6xj5Au":"return ![\"i\", \"int\", \"fel\"].includes(args.characteristic)","rRfff55c7elyvbCb":"return this.actor.flags.useless[this.item.system.location.key] && args.weapon?.system.usesHands.includes(this.item.system.location.key[0] + \"Arm\")","rUGSx06BuBvX9kgf":"if (args.test.result.charging)\n{\n   args.test.result.damage += 1\n   args.test.result.additionalDamage += 1\n   if (!args.test.result.resolute) {\n      args.test.result.breakdown.damage.other.push({label : this.effect.name, value : this.item.Advances});\n      args.test.result.resolute = true // Prevent duplicate messages\n     }\n}\n","rVRDoxiWILo7d8FF":"let specification = Number(this.item.specification.value) || 1;\nargs.actor.system.status.wounds.max += Math.floor(args.actor.system.status.wounds.max * 0.3 * specification);\nargs.actor.system.status.carries.max -= Math.floor(args.actor.system.status.carries.max * 0.1 * specification);\nargs.actor.system.details.price.gc += args.actor.system.details.price.gc * 0.2 * specification;","rVpPNILEzWL9lj6b":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.kJNAY1YRaCy9IgmT\")\nlet terrorTraitItem = item.toObject()\nterrorTraitItem.system.specification.value = Number(this.effect.item.system.specification.value) \nthis.actor.createEmbeddedDocuments(\"Item\", [terrorTraitItem]);","rX8FTinyTMj9WJri":"if (!this.actor.flags.holed) return;\nif (this.actor.flags.holed.applied === true) return;\nif (this.actor.hasCondition(\"dead\")) return;\n\nconst currentHoled = this.actor.flags.holed.holed || 0;\n\nconst openGunPorts = this.actor.itemTypes.vehicleMod.reduce((acc, m) => {\n  if (!m.name.toLowerCase().includes(\"gun port\")) \n    return acc;\n  \n  let closed = m.getFlag(\"wfrp4e-soc\", \"gunport\");\n  if (!closed) acc++;\n \n  return acc;\n}, 0);\n\nconst totalHoled = currentHoled + openGunPorts;\nconst toughness = this.actor.system.characteristics.t.value;\nthis.actor.flags.holed.total = totalHoled;\n\nif (totalHoled >= toughness) {\n  const speaker = ChatMessage.getSpeaker({actor: this.actor});\n  this.script.message(`\n        <p><b>${speaker.alias}</b> sank due to having <em>Holed (${totalHoled})</em> rating equal to, or exceeding its <em>Toughness (${toughness })</em></p>\n        <p>\n          <em>Holed</em> due to Critical Damage: ${currentHoled}<br/>\n          <em>Holed</em> due to opened Gun Ports: ${openGunPorts}\n        </p>\n      `, {   flavor: this.effect.name.split(\"(\")[0]});\n  this.actor.addCondition(\"dead\");\n} else if (totalHoled >= (toughness * 0.5)) {\n  this.actor.system.details.move.value -= 1;\n  this.actor.system.details.man -= 1;\n  this.actor.flags.holed.half = true;\n}\n\nthis.actor.flags.holed.applied = true;","rXMylpnEtZpwou6x":"this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty : \"average\"}}).then(async test =>\n{\n     await test.roll()\n     if (test.failed)\n     {\n         this.actor.addCondition(\"fatigued\")    \n     }\n})","ramav4ymrDDkPKK4":"if (this.actor.hasCondition(\"bleeding\"))\n{\n    this.actor.removeCondition(\"bleeding\");\n    this.script.notification(\"Removed 1 Bleeding Condition\")\n}\nelse \n{\n    this.script.notification(\"No Bleeding Conditions\");\n}","ratP9ByLjQPiLlFK":"args.data.canReverse = true","rdaMhMyHrJjQ6vVC":"game.wfrp4e.utility.postFear(this.item.Advances, this.actor.name)","re1UFtxvRRjpPB7Z":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.nF5z1OEhpi4t6a6S\");\nlet data = item.toObject();\ndata.system.location.key = this.item.system.location.key\nif (data.system.location.key[0] == \"r\")\n{\n\tdata.system.location.value = \"Right Ankle\"\n}\nelse if (data.system.location.key[0] == \"l\")\n{\n\tdata.system.location.value = \"Left Ankle\"\n}\n\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {skipLocationValue : true, fromEffect: this.effect.id})\n","red2bt4PGgIWAdTR":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n     let effectData = this.item.effects.contents[0].convertToApplied();\n     let minutes = Math.ceil(CONFIG.Dice.randomUniform() * 10) * 10;\n     effectData.duration.seconds = 60 * minutes\n     this.script.message(`<strong>${game.i18n.localize(\"Duration\")}</strong>: ${minutes} ${game.i18n.localize(\"Minutes\")}`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n\tactor.applyEffect({effectData : [effectData]})\n}\nelse\n{\n\tthis.script.notification(\"None left!\", \"error\")\n}","rgSwSeB3shIMVMb6":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.x0WMGwuQzReXcQrs\")\nlet data = item.toObject();    \nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id});","rgnGu3IQrS8Vj9Op":"const bonus = game.settings.get(\"wfrp4e\", \"homebrew\").advantageBonus;\n\nargs.fields.modifier += bonus;","rlTvhnDpj4lzfusf":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Sail\")) && args.skill?.name !== game.i18n.localize(\"NAME.Climb\");","rly9iBUy8EX7NhQT":"if (game.user.targets.size !== 1)\n  return ui.notifications.warn(\"You must target exactly one Boat.\");\n\nconst target = game.user.targets.first();\nconst vehicle = target.actor;\n\nif (!(vehicle.system instanceof VehicleModel)) \n  return ui.notifications.warn(\"You can only Constrict a Boat\");\n\nif (vehicle.size > 3)\n  return ui.notifications.warn(\"You can only Constrict vessels of Size Large or smaller\");\n\nconst turns = Math.ceil(vehicle.system.details.length.value / 10);\n\nconst mainEffect = this.item.effects.contents[0];\nconst effectData = mainEffect.toObject();\n\neffectData.statuses = [effectData.name.slugify()];\n\nfoundry.utils.setProperty(effectData, \"flags.wfrp4e.target\", target.id);\nfoundry.utils.setProperty(effectData, \"flags.wfrp4e.turns\", turns);\n\nawait this.actor.applyEffect({effectData: [effectData]});\n\nconst speaker = ChatMessage.getSpeaker({actor: this.actor});\n\nthis.script.message(`<b>${speaker.alias}</b> started wrapping itself around the <b>${target.name}</b> and will be able to start crushing it after ${turns} turns.`);","rnioLwiJP7ps5Jwy":"if (args.item.type  == \"skill\" && args.item.name == `${game.i18n.localize(\"NAME.Melee\")} (${game.i18n.localize(\"SPEC.Basic\")})`)\n{\n     args.item.system.modifier.value += 30;\n}","roKvPHDSpX4IV11C":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Perform\")) && args.characteristic != \"ag\"","roYVcP5Zqcsa8jVw":"args.actor.system.details.move.value -= 1;","rpxQU26BU7nwjtqY":"let location = this.item.system.location.key\nlet test = await this.actor.setupCharacteristic(\"dex\", {context : {failure : `<strong>${this.effect.name}</strong>: Drop the item!`}, skipTargets: true, appendTitle :  \" - \" + this.effect.name, fields : {difficulty : \"average\"}})\nawait test.roll();\n\n\nif (location && test.failed)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.notification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}\n\nreturn test.succeeded","rqTT8yOyK4bUwbdm":"let test = args.test\nif (test.spell.lore.value == \"fire\")\n{\n   if (test.result.overcast.usage.target?.AoE)\n   {\n       test.result.overcast.usage.target.current += test.actor.characteristics.wp.bonus\n       test.result.overcast.usage.target.initial += test.actor.characteristics.wp.bonus\n    }\n   if (test.result.overcast.usage.range)\n   {\n       test.result.overcast.usage.range.current *= 2\n       test.result.overcast.usage.range.initial *= 2\n   }\n \n}","rr4htuVq45onXdRG":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {appendTitle: ` - ${this.effect.name}`, fields : {difficulty : \"average\"}})\ntest.roll();","rxB1AqfVMDqTRieE":"return ![\"ws\", \"bs\", \"ag\"].includes(args.characteristic) && args.skill?.name != game.i18n.localize(\"NAME.Perception\")","s07GKMPCvQ8Heorc":"const value = this.effect.sourceActor.system.characteristics.wp.bonus;\nthis.script.message(await args.actor.applyBasicDamage(value, {damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg: true}));","s0kTuDE0qv68V2KI":"    this.actor.getActiveTokens().forEach(t => t.document.update({texture : {tint : \"#FFBF00\"}}));\n","s5bO0Sf0qpS27Tve":"await args.actor.addCondition(\"ablaze\", 3)\nawait args.actor.addCondition(\"prone\");","s6eZXfZkC1My6EXl":"let lore = this.effect.name.split(\" \")[2].toLowerCase();\nif (args.item.type == \"spell\" && args.item.system.lore.value == lore)\n{\n    args.item.system.cn.value = Math.max(0, args.item.system.cn.value - 1);\n}\n","s7gJQdzuM3fz2zQK":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.QluSTTTq3viHJJUh\")\nlet data = item.toObject();\ndata.system.location.value = \"Hip\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n   \nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}","s7kW3lm2eU5IPrLP":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.JQa5DLnTs2SEzRrc\")\nlet dv = item.toObject();\n\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.Item.OzwDT6kzoLYeeR2d\")\nlet stealthy = item.toObject();\n\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.Item.XSb3QVB9ipPBFt56\")\nlet shadow = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [dv, stealthy, shadow], {fromEffect : this.effect.id});","s8idWt9YdMTRfnjV":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.BqPZn6q3VHn9HUrW\")\nlet data = item.toObject();\ndata.system.specification.value = 4 - this.actor.characteristics.s.bonus\ndata.name = item.name.replace(\"(Feature)\", \"\");\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","s8xU6OOZbbfo6VIw":"args.fields.slBonus += this.actor.system.characteristics.ag.bonus\n","s94yKZ4o5XN4JWM1":"// Any attack with such ammunition which inflicts at least one Wound,\n// also inflicts one Bleeding Condition.\n\nif (args.totalWoundLoss > 0) {\n  args.actor.addCondition(\"bleeding\")\n}\n","s9J1TUkpGdvSWvPO":"this.actor.addCondition(\"blinded\");","sAVpm7hFRHpbCLXm":"return [\"ws\", \"bs\", \"s\",  \"t\", \"ag\", \"i\"].includes(args.characteristic)","sB4KB9bT3nQhAoqG":"// This script needs to be separate because equipTransfer is off on the other effect, and thus won't execute when added to an actor\n\nlet mainEffect = this.item.effects.contents[0];\nif (mainEffect.name.includes(\"<Lore>\"))\n{\n    let choice = await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.magicLores, this.item.img), 1, \"Choose Lore\");\n    if (choice.length)\n    {\n        mainEffect.update({name : mainEffect.name.replace(\"<Lore>\", choice[0].name)})\n        this.item.update({name : this.item.name += ` (${choice[0].name})`})\n    }\n}\n\nthis.effect.delete();","sHVLKIdPbzLVItCa":"if (args.actorsystem.details.move.oars.value > 0)\n  args.actor.system.details.move.oars.value -= 1;","sHfkTRqTWPg2JAGN":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.JQa5DLnTs2SEzRrc\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","sKO8TcLIkCTnFvXu":"args.abort = true;\nthis.script.notification(`Cannot use ${this.item.system.location.value}!`, \"error\")","sNSfDBIA2k17hPYI":"let ablaze = this.actor.hasCondition(\"ablaze\");\nif (ablaze)\n{\n\tablaze?.delete();\n\tthis.script.notification(\"Ignore Ablaze\");\n}\n","sPvfYQEnyAYNpIhF":"let shouldDamage = await foundry.applications.api.DialogV2.confirm({\n  window : {title: this.effect.name + \" - \" + args.actor.name},\n  content: \"Are you humanoid creature who have not made a sacrifice to Rhya (or another diety of nature or powerful nature spirit to whom the cult of Rhya are well disposed, such as Isha or Taal) since the last spring equinox?\"\n});\n\nif (shouldDamage) {\n  let damage = 1 + this.effect.sourceTest.result.baseSL;\n  await args.actor.applyBasicDamage(damage, {damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL});\n  args.actor.addCondition(\"fatigued\");\n}","sQDh3g11pWchxpW9":"return true","sSMg43ZjnNmpytfj":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  \" - \" + this.effect.name});\nawait test.roll();\n","sUHuj00IpoZ7Gd03":"return args.skill?.name != game.i18n.localize(\"NAME.Swim\");","sWyO1DNaqb2EdHoW":"if (!this.actor.items.getName(game.i18n.localize(\"NAME.Frenzy\"))) // Either frenzy trait or psychology\n{\n  // Add Frenzy psychology\n  let item = await fromUuid(\"Compendium.wfrp4e-core.items.DrNUTPeodEgpWTnT\")\n  let data = item.toObject();\n  data.effects[0].disabled = false;\n  this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n}\n\nthis.script.message(`<p><strong>By imbibing this potion, ${this.actor.prototypeToken.name}</strong> has becomes subject to Frenzy. This Frenzy lasts [[1d10]] Rounds, and may not be ended sooner.</p>`, \n  {whisper: ChatMessage.getWhisperRecipients(\"GM\"), blind: true })   ","sYlGRLApZ3Ub24ea":"this.actor.system.status.addArmour(3, {source: this.effect.name, magical: true})","sZwLitzwKBTaFca3":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.5hH73j2NgPdsLCZN\")\nlet data = item.toObject();\ndata.name = data.name.replace(\"Target\", \"Greenskins, Undead, Chaos\")\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","sagKJM6oDFlw4ED2":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\nreturn test.failed;","sbK1a7txpSoXFzyB":"if (args.test.options.useOnesArgumentative && (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target)) {\n\n   let SL = Math.floor(args.test.target / 10) - Math.floor(args.test.result.roll / 10)\n   let ones = Number(args.test.result.roll.toString().split(\"\").pop())\n\n   if (ones == 0) {\n      ones = 10;\n   }\n\n\n   if (ones > SL) {\n      args.test.data.result.SL = \"+\" + (ones + args.test.successBonus + args.test.slBonus)\n      args.test.result.other.push(`<b>${this.effect.name}</b>: Used unit dice as SL`)\n   }\n}","scfm5iWWBxWI6QaK":"let darkvision = await fromUuid(\"Compendium.wfrp4e-core.items.Item.JQa5DLnTs2SEzRrc\")\nlet fear = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet acutesense = await fromUuid(\"Compendium.wfrp4e-core.items.Item.9h82z72XGo9tfgQS\")\nfear = fear.toObject();\nfear.system.specification.value = 1;\nthis.actor.createEmbeddedDocuments(\"Item\", [darkvision, fear, acutesense], {fromEffect : this.effect.id})","sgS9rblPkQB36C8S":"if (this.item.name.includes(\"(\"))\n{\n\tlet trade = this.item.parenthesesText;\n\tif (trade?.toLowerCase() != \"any\")\n\t    return this.item.updateSource({\"system.tests.value\" : this.item.system.tests.value.replace(\"any one\", trade)})\n}\n\nlet index = game.packs\n.filter(i => i.metadata.type == \"Item\")\n.reduce((acc, pack) => acc.concat(pack.index.contents), [])\n.filter(i => i.type == \"skill\" && i.name.includes(game.i18n.localize(\"NAME.Trade\")))\n.map(i => {\n\ti.id = i._id\n\treturn i\n})\n\nlet choice = await ItemDialog.create(index, 1, {text : \"Choose a Trade Skill, or select none to enter manually.\", title : this.effect.name})\nlet text;\nif (!choice[0])\n{\n    let custom = await ValueDialog.create({text : \"Enter Custom Trade Skill\", title : \"Custom Trade\"});  \n    text = custom || \"\"\n}\nelse \n{\n    text = game.wfrp4e.utility.extractParenthesesText(choice[0].name)\n}\n\nawait this.item.updateSource({name : this.item.name.replace(\"(Any)\", \"\").replace(\"(any)\", \"\").trim() + ` (${text})`, \"system.tests.value\" : this.item.system.tests.value.replace(\"any one\", text)});","shkBUtUuMPDKvFm7":"let test = await this.actor.setupSkill(\"Dodge\", {fields : {difficulty : \"average\"}})\nlet caster = this.effect.sourceActor\n\nlet fallen = this.effect.sourceTest.result.SL + caster.characteristics.wp.bonus\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n   this.script.message(`<b>${this.actor.prototypeToken.name}</b> falls ${fallen} yards`)\n}","sjnoYbWpAugyDilW":"let test = await args.actor.setupSkill(\"Charm\",  {\n    appendTitle: ` – ${this.effect.name}`,\n    skipTargets: true,\n    fields: {difficulty: 'average'},\n    characteristic: 'fel',\n    context: {\n        success: \"Animal becomes docile towards Humans, Elves who honour Isha, and similar allies.\"\n    }\n});\nawait test.roll();","skVq3eDEYKFF2iZp":"// I'm assuming the endurance test specified is for the end-round check\nawait this.actor.addCondition(\"poisoned\", 4);\n","sm9d5lk6cM0OuUkf":"this.actor.applyFear(Math.min(4, this.effect.sourceTest.result.overcast.usage.other.current))","svCqdytEOtqFXCcs":"let characteristics = {\n    \"ws\" : 0,\n    \"bs\" : 0,\n    \"s\" : 0,\n    \"t\" : 10,\n    \"i\" : 15,\n    \"ag\" : 0,\n    \"dex\" : 10,\n    \"int\" : 20,\n    \"wp\" : 20,\n    \"fel\" : 10\n}\nlet skills = [\"Channelling\", \"Cool\", \"Dodge\", \"Entertain (Storytelling)\", \"Intuition\", \"Language (Magick)\", \"Lore (Magic)\", \"Perception\"]\nlet skillAdvancements = [5, 15, 10, 10, 15, 10, 10, 20]\n\nlet talents = [\"Arcane Magic\", \"Petty Magic\", \"Second Sight\"]\nlet trappings = [\"Hand Weapon\", \"Robes\", \"Quarterstaff\"]\nlet specialItems = [ \n    {name: \"Magic Item\", type: \"trapping\", trappingType: \"misc\" }, \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nlet ride = await foundry.applications.api.DialogV2.confirm({window : {title : \"Skill\"}, content : \"Add Chaos Steed and +20 Ride (Horse)?\"})\n\nif (ride)\n{\n    let skill = await game.wfrp4e.utility.findSkill(\"Ride (Horse)\")\n    skill = skill.toObject();\n    skill.system.advances.value = 20;\n    items = items.concat({name : \"Chaos Steed\", type: \"trapping\", \"system.trappingType.value\" : \"misc\"}, skill)\n}\n\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","sx7Ikn8WW00gBFb4":"let location = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 2 ? \"r\" : \"l\") + \"Arm\"\n\nif (location == \"lArm\")\n{\n\tthis.script.notification(\"Rolled Left\")\n}\nelse if (location == \"rArm\")\n{\n\tthis.script.notification(\"Rolled Right\")\n}\n\nthis.effect.updateSource({\"flags.wfrp4e.location\" : location});\n\nif (location)\n{\n    let dropped = this.actor.itemTypes.weapon.filter(i => i.isEquipped & i.system.usesHands.includes(location));\n\n    if (dropped.length)\n    {\n        this.script.notification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}\n\nlet roll = await new Roll(\"1d10\").roll()\n\nroll.toMessage(this.script.getChatData({flavor : `${this.effect.name} (Duration)`}));\n\nthis.effect.updateSource({\"duration.rounds\" : roll.total})","syBgPp7rOymCZejX":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\")\n}","syRJs8P4aBFB5USD":"if (this.actor?.system?.details?.god?.value !== \"Sigmar\") return\nif (this.actor?.currentCareer?.careergroup?.value !== \"Priest\" \n  && this.actor?.currentCareer?.careergroup?.value !== \"Warrior Priest\" ) return\n  \nlet currentSin = this.actor.system.status.sin.value \nlet updatedSin = currentSin + 2\nawait this.actor.update({\"system.status.sin.value\": updatedSin})","syqqBkyP5tGqZ78t":"this.actor.has(\"Immunity to Psychology\")?.delete();\n\nlet roll = await new Roll(\"1d10\").roll({allowInteractive : false});\n\nroll.toMessage(this.script.getChatData());\n\nthis.script.notification(`Removed Immunity to Psychology, Adding ${roll.total} Broken Conditions`)\nthis.actor.addCondition(\"broken\", roll.total, {\"flags.wfrp4e.blasted-mind\" : true})","sz0PqS1kroMOzUZk":"let characteristics = {\n    \"ws\" : -15,\n    \"bs\" : -30,\n    \"s\" : 0,\n    \"t\" : 0,\n    \"i\" : -10,\n    \"ag\" : -10,\n    \"dex\" : 0,\n    \"int\" : -20,\n    \"wp\" : 15,\n    \"fel\" : -20\n}\nlet skills = [\"Melee (Brawling)\"]\nlet skillAdvancements = [10]\n\nlet talents = [\"Fearless (Everything)\", \"Frenzy\", \"Implacable\"]\nlet trappings = [\"Plate Breastplate\", \"Plate Bracers\", \"Plate Helm\", \"Plate Leggings\"]\nlet specialItems = []    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWfrp4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWfrp4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nconsole.log(\">>>>>>><\", items)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","t48hkacYdOpzWvK9":"args.context.beatBlade = true;","t56mnblo1kv3gM1M":"return args.skill?.name.includes(`${game.i18n.localize(\"NAME.Melee\")} (${game.i18n.localize(\"SPEC.Basic\")})`) || (args.type == \"weapon\" && args.item?.system.weaponGroup.value == \"basic\");","t8LYOuN5peEdWeXP":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.mNoCuaVbFBflfO6X\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","tCIT1a12Gt6k2ohA":"let resistance\nif (this.item.name.includes(\"(\") && !this.item.name.toLowerCase().includes(\"(any)\"))\n{\n\tresistance = this.item.parenthesesText\n}\nelse \n{\n    resistance = await ValueDialog.create({text : \"Enter Resistance\", title : \"Resistance\"}) \n    \n    if (resistance)\n    {\n        this.item.updateSource({name : `${this.item.name.split(\"(\")[0].trim()} (${resistance})`})\n        this.effect.updateSource({name : this.effect.name + ` (${resistance})`})\n    }\n}    \nthis.item.updateSource({\"system.tests.value\" : this.item.system.tests.value.replace(\"the associated Threat\", resistance)})\n\nif (resistance && !this.effect.name.includes(\"(\"))\n{\n    this.effect.updateSource({name : this.effect.name += ` (${resistance})`})\n}","tDrs0aNIYmZPsOoS":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"prone\")\n}\n","tFAKRRRfTjQfdQz3":"this.actor.getActiveTokens().forEach(t => t.document.update({\"texture.tint\" : \"\"}));","tG1qGqzBLmAR3WHm":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\nif (test.failed) \n{\n    let add = 0\n\n    if (test.result.roll % 11 == 0 || test.result.roll == 100) \n    {\n        add = 1 // can't use isFumble if no hit location\n    }\n\n     await this.actor.addCondition(\"stunned\", Math.max(1, Math.abs(test.result.SL)) + add)\n     await this.actor.addCondition(\"blinded\", Math.max(1, Math.abs(test.result.SL)))\n\n}","tGVEV6TLl310mFLP":"let nonmagical = args.modifiers.ap.value - args.modifiers.ap.magical\nif (args.applyAP && nonmagical) \n{\n    let nonmagical = args.modifiers.ap.value - args.modifiers.ap.magical\n    args.modifiers.ap.ignored += nonmagical\n    args.modifiers.ap.details.push(\"<strong>\" + this.effect.name + \"</strong>: Ignore Non-Magical AP (\" + nonmagical + \")\");\n}","tHBlC7SpYiQ7SUGo":"return args.characteristic !== \"t\";","tKBq1nGZo8t6vvQ6":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.5hH73j2NgPdsLCZN\");\nthis.actor.createEmbeddedDocuments(\"Item\", [item.toObject()], {fromEffect : this.effect.id})","tNTO1LVN7JqHf4YN":"if (args.test.characteristicKey == \"wp\") \n{\n    if (args.test.failed)\n    {\n        this.actor.createEmbeddedDocuments(\"ActiveEffect\", [game.wfrp4e.config.symptomEffects[\"malaise\"]])\n        this.script.message(`Willpower Test failed, <b>${this.actor.prototypeToken.name}</b> gains @Condition[Malaise] for [[1d10]] hours`, {whisper: ChatMessage.getWhisperRecipients(\"GM\")})\n    }\n}","tUwP7TjrOOOnaCYJ":"let fatigued = this.actor.hasCondition(\"fatigued\")\nif (fatigued)\n{\n   this.script.notification(`Cleared ${fatigued.conditionValue} Fatigued Conditions`)\n   fatigued.delete();  \n}\nelse \n{\n\tthis.script.notification(`No Fatigued Conditions`)\n}","tcZug8ehU6lyYBd9":"return args.skill?.name != `${game.i18n.localize(\"NAME.Ranged\")} (${game.i18n.localize(\"SPEC.Blackpowder\")})`","tdICiJ26rJrDbxT6":"return args.characteristic != \"i\"","tg9N6aUo8WRPKj3H":"// If the creature currently has a Surprised, Unconscious, or Entangled Condition, it does not gain this Advantage.\nconst surprised = this.actor.hasCondition(\"surprised\")\nconst unconscious = this.actor.hasCondition(\"unconscious\")\nconst entangled = this.actor.hasCondition(\"entangled\")\nif (entangled || unconscious || surprised) return\n\n// If, at the beginning of its turn, this creature does not have at least Rating Advantage points, its Advantage pool immediately increases to Rating.\nconst grimRating = parseInt(this.item.specification.value) || 1\nif (grimRating > this.actor.status.advantage.value) {\n  this.actor.setAdvantage(grimRating)\n}","thxlWeZbow8iE7xA":"const uuid = \"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\";\nconst item = await fromUuid(uuid);\nconst data = item.toObject();\ndata.system.specification.value = 1;\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id});","tkZ8Ybqu518LQYEn":"await args.actor.addCondition(\"ablaze\");\n\targs.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.4CMKeDTDrRQZbPIJ\", this.effect, [{\"system.specification.value\": \"Krezok Soulflayer\"}])","tn6SwmjAuNzqE6dx":"let damage = 0\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Dodge\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();\n\nif (test.succeeded)\n{\n    damage = 10;\n}\nelse if (test.failed)\n{\n   damage = 20;\n}\n\nthis.script.message(await this.actor.applyBasicDamage(damage, {loc : \"roll\", hideDSN: true, suppressMsg : true}))","tnE8LF6E3svIlLca":"return args.skill?.name == game.i18n.localize(\"NAME.Research\");","tnilBagajWM8UGQt":"return args.item?.name != game.i18n.localize(\"NAME.ConsumeAlcohol\")","toSrgcvWq9b5eN0K":"let location = await game.wfrp4e.tables.rollTable(\"hitloc\", {hideDSN: true})\n\nthis.item.updateSource({name : `${this.item.name} (${location.description})`})\nthis.script.message(`<strong>Location:</strong> ${location.description}`, { whisper: ChatMessage.getWhisperRecipients(\"GM\") })","tolkNN5P7oOC8GKZ":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"difficult\"}})\nawait test.roll();\n\nif (test.failed)\n{\n    let sourceActor = this.effect.sourceActor;\n    if (sourceActor)\n    {\n        this.script.message(await this.actor.applyBasicDamage(sourceActor.system.characteristics.wp.bonus, {suppressMsg : true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL}))\n    }\n}","tuIsytv3jl2yAIb2":"return args.skill?.name !== game.i18n.localize(\"NAME.Charm\") && args.skill?.name !== game.i18n.localize(\"NAME.Intimidate\") && args.skill?.name !== game.i18n.localize(\"NAME.Leadership\")","u3olS2p7Ls1JXfAH":"this.script.message(await game.wfrp4e.tables.formatChatRoll(\"mutatephys\", {}, \"Tzeentch\"));","u46KnlxCjP42F6QY":"let table = await fromUuid(\"RollTable.uATmVS40DQLC1woJ\");\n\nif (table)\n{\n    table.roll();\n}\nelse \n{\n    this.script.notification(\"Personality table not found\", \"error\");\n}","u4fKgGFEnOCnvvsv":"return args.item?.system?.isRanged;","u5dNZ0s3lWfL8KFb":"return args.fields.charging","u6CYMSZADrfXd48Q":"args.fields.modifier += 20;","uA5qaat5EXzkzltq":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"difficult\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\nif (!test.succeeded)\n{\n    let plague = await fromUuid(\"Compendium.wfrp4e-core.items.Item.aKiuGzlVO51JvsjV\")\n    let obj = plague.toObject();\n    await this.actor.createEmbeddedDocuments(\"Item\", [obj]);\n}\n\nthis.effect.delete();","uACa6u4JLNMRgFlr":"const talents = await Promise.all([game.i18n.localize(\"NAME.FuriousAssault\"), game.i18n.localize(\"NAME.SeaLegsTalent\")].map(game.wfrp4e.utility.findTalent))\nthis.actor.createEmbeddedDocuments(\"Item\", talents, {fromEffect : this.effect.id})","uAy4w7y8Uu9POF8C":"args.item.system.qualities.value.push({name : \"impact\"})","uLBDnWC3S0lRitbj":"let test = await this.actor.setupCharacteristic(\"int\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`})\nawait test.roll();\n\nlet opposedResult = test.opposedMessages[0]?.system.opposedHandler?.resultMessage?.system.opposedTest?.result\n\nif (opposedResult?.winner == \"attacker\")\n{\n    if (test.failed && (test.result.roll % 11 == 0 || test.result.roll == 100))\n    {\n        this.actor.addCondition(\"unconscious\")\n        await this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + 1})\n        this.script.message(\"Gained a Corruption point\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    }\n    else \n    {\n        await this.actor.addCondition(\"stunned\", 1 + opposedResult.differenceSL);\n    }\n}\nelse \n{\n    return false;\n}","uMvD2HWFNGqCmrBM":"if (args.test.options.addChargingDice)\n{\n\targs.test.result.diceDamage = {formula: \"1d10\", value : Math.ceil(CONFIG.Dice.randomUniform() * 10) }\n\targs.test.result.additionalDamage += args.test.result.diceDamage.value;\n}","uNYstk3eXmWamhzs":"args.actor.addCondition(\"blinded\")","uOHAsKlkFuIaAmjb":"args.actor.modifyWounds(1)","uRiAvo9fb3U7FIIy":"if (!this.actor.has(\"Blessing of Might\",\"prayer\")) this.actor.addEffectItems(\"Compendium.wfrp4e-core.items.Item.KSDrXcieyRc37YI7\", this.effect)","uSwkYENTOcnfRrqA":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Melee\")) && args.weapon?.system?.attackType != \"melee\"","ucF4aiJ1gpDB333G":"if (args.test.options.catfall && (args.test.result.roll <= game.settings.get(\"wfrp4e\", \"automaticSuccess\") || args.test.result.roll <= args.test.target) && !args.test.result.catfall)\n{\n   args.test.result.other.push(`<b>${this.effect.name}</b>: Fall distance damage reduced by ${Number(args.test.result.SL) + 1} yards`)\n   args.test.result.catfall = true; // Prevent duplicate messages\n}","ugL5IBB6R2yWyMWd":"if (args.totalWoundLoss > 0)\n{\n    let apply = await foundry.applications.api.DialogV2.confirm({window : {title : this.effect.name}, content : `<p>Appy ${this.effect.name} Damage? Attacker must have used bare hands or a melee weapon made of metal.`})\n    if (apply)\n    {\n            \n        let damage = 5 + this.actor.characteristics.wp.bonus;\n        \n        let loc = args.opposedTest.attackerTest.weapon?.system.usesHands[0] || \"rArm\";\n        \n        let APatLoc = args.opposedTest.attacker.system.status.armour[loc];\n        \n        let metalAP = APatLoc.layers.reduce((metal, layer) => metal += (layer.metal ? layer.value : 0), 0)\n        \n        let APused = Math.max(0, APatLoc.value - metalAP); // remove metal AP at location;\n        \n        damage -= (APused + args.opposedTest.attacker.system.characteristics.t.bonus)\n        \n        let msg = await args.opposedTest.attacker.applyBasicDamage(damage, {suppressMsg : true, damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL});\n        msg += ` (ignored ${metalAP} metal AP on ${game.wfrp4e.config.locations[loc]})`\n        this.script.message(msg)\n    }\n}","uhCq5NwjQ2a2idPn":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Tailor)';\nconst difficulty = 'easy';\nconst target = 30;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        \n      }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","ulXfbycWUu36vdmS":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {appendTitle : ` - ${this.effect.name}`, fields : {difficulty : \"difficult\", slBonus : -1 * this.effect.sourceTest.result.SL}})\nawait test.roll();\nif (test.succeeded)\n{\n\tthis.script.notification(`Resisted ${this.effect.name}`);\n}\nreturn test.failed;","upfK6GM33qZCZjll":"return args.item?.name != `${game.i18n.localize(\"NAME.Play\")} (${game.i18n.localize(\"SPEC.Lute\")})`","ur2HAWDGSGvyAynU":"if (args.combat.combatant.actor.uuid === this.effect.sourceActor.uuid) {\n  this.effect.delete();\n}","uwdQvZtzy2HVeEzx":"if (args.totalWoundLoss > 0)\n{\n    let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\n    roll.toMessage(this.script.getChatData());\n    args.modifiers.other.push({label : this.effect.name, value : roll.total})\n    \n    args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"hard\"}, skipTargets: true, appendTitle :  \" - \" + this.effect.name}).then(async test => {\n        await test.roll();\n        if (test.failed)\n        {\n            this.script.message(\"<strong>\" + args.actor.name + \"</strong> takes a @Table[critbody]{Critical Hit} to the torse\", {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n        }\n    })\n}\n","ux3jaLpAUhZ5YqA6":"return args.item?.name != game.i18n.localize(\"NAME.Leadership\") && args.item?.name != game.i18n.localize(\"NAME.Cool\")","v00nVCRKqqRvY28t":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: {difficulty: \"hard\"}});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\", 3)\n}\n","v18mmwUmuKiVfwzQ":"let test = await this.actor.setupTest(game.i18n.localize(\"NAME.Endurance\"), {appendTitle : ` - ${this.effect.name}`, skipTargets: true});\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"stunned\");\n}","v4CCxVaVGf9i8U7X":"let cured = await ValueDialog.create({text : \"Enter the number of diseases/poisons cured\", title : this.effect.name})\n\nlet damage = 0;\n\nlet rolls = new Array(cured).fill(\"\").map(i => `max(0, 1d10 - ${this.actor.system.characteristics.fel.bonus})`)\n\nlet test = new Roll(`${rolls.join(\" + \")}`);\nawait test.roll();\ntest.toMessage({speaker : {alias : this.actor.name}, flavor : this.effect.name});\nthis.script.message(await this.actor.applyBasicDamage(test.total, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true }))","v4ITTsSY9EvCbhZP":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.9h82z72XGo9tfgQS\")\nthis.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id})","v5xrDWcrTNFJkyQB":"let addOption = await foundry.applications.api.DialogV2.confirm({\n    window : {title : \"Option\"},\n    content : \n    `\n    Add Option?\n    <p>\n    Ranged (Bow) +10 and a Longbow with 12 Arrows\n    </p>\n    `,\n})\n\nlet choice = []\n\nif (addOption)\n{\n    choice = [\n        {\n            type : \"skill\",\n            name : \"Ranged (Bow)\",\n            diff : {\n                system : {\n                    advances : {\n                        value : 10\n                    }\n                }\n            }\n        },\n        {\n            type : \"weapon\",\n            name : \"Longbow\",\n        },\n        {\n            type : \"ammunition\",\n            name : \"Arrow\",\n        }\n    ];\n}\n\n\n\n\n\nlet updateObj = this.actor.toObject();\nlet items = []\nfor (let c of choice)\n{\n    let existing \n    if (c.type == \"skill\")\n    {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type)\n        if (existing && c.diff?.system?.advances?.value)\n        {\n            existing.system.advances.value += c.diff.system.advances.value\n        }\n    }\n\n    if (!existing)\n    {\n        let item = await game.wfrp4e.utility.find(c.name, c.type)\n        if (item)\n        {\n            let equip = item.system.tags.has(\"equippable\");\n            item = item.toObject()\n            if (equip)\n            {\n                item.system.equipped.value = true;\n            }\n            items.push(foundry.utils.mergeObject(item, (c.diff || {})))\n        }\n        else\n            ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n\n}\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","v6LIG7EwWYALxCpP":"return !this.effect.getFlag(\"wfrp4e\", \"trained\")?.includes(\"entertain\") || (!args.skill?.name.includes(game.i18n.localize(\"NAME.Entertain\")) && !args.skill?.name.includes(game.i18n.localize(\"NAME.Perform\")) && !args.skill?.name.includes(game.i18n.localize(\"NAME.Play\")))","vBqrydNzHmEHClqZ":"let maxWounds = this.actor.system.status.wounds.max\nthis.actor.update({\"system.status.wounds.value\": maxWounds})","vFUVWZ1l8wpTjLcx":"if (!this.actor.has(game.i18n.localize(\"NAME.Daemonic\")))\n    return\n\nlet caster = this.effect.sourceActor;\nif (caster) \n{\n    let wp = caster.system.characteristics.wp\n    if (this.actor.system.characteristics.wp.value >= wp.value)\n    {\n        this.script.notification(\"Target has higher Willpower, no effect\")\n        return\n    }\n    this.actor.applyBasicDamage(wp.bonus, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL })\n}","vJQRBxDfPwHens0a":"if (args.totalWoundLoss > 0) \n{\n    args.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields: { difficulty: \"difficult\" } }).then(async test => {\n        await test.roll();\n        if (test.failed) \n        {\n           await args.actor.addCondition(\"poisoned\")\n            this.script.message(await args.actor.applyBasicDamage(3, {suppressMsg : true, damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL }))\n        }\n    })\n}","vM2BPwYhHQaBAt2C":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.KII1gWnxIZ8HzmU5\");\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})","vNUGuypkhx2P5YIA":"return args.characteristic !== \"fel\"","vNp9wgdSvnNEjZyS":"args.fields.slBonus -= 2; ","vPG4rV640aSzKzxe":"return !this.actor.flags.useless[this.item.system.location.key[0] + \"Arm\"] || [\"fel\", \"wp\", \"int\", \"t\"].includes(args.characteristic)","vS2D9QUslR7ZtXXm":"let test = await this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\nawait test.roll();\nif (test.failed)\n{\n    let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\n    roll.toMessage(this.script.getChatData())\n\n    this.script.message(await this.actor.applyBasicDamage(roll.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP, suppressMsg : true}))\n}","vSDMygIT9nNvEGWG":"// Each time the blade is used, the GM should secretly roll a d10.\n// On a 1, its poison has run dry, \n// and the next time it is employed it will shatter.\n\nif (Math.ceil(CONFIG.Dice.randomUniform() * 10) == 1) {\n  this.item.setFlag(\"wfrp4e\", \"brittle\", true)\n  ChatMessage.create({\n    content: `\n      <strong>${this.item.name}</strong> has run out of poison. It will shatter the next time it is used.`, \n    whisper: ChatMessage.getWhisperRecipients(\"GM\"),\n    blind: true\n  })\n}\n","vTebTUzXortx1Qut":"let specification = Number(this.item.specification.value) || 1;\nargs.actor.system.characteristics.t.initial += 10 * specification;\nargs.actor.system.status.carries.max -= Math.floor(args.actor.system.status.carries.max * 0.1 * specification);\nargs.actor.system.details.price.gc += args.actor.system.details.price.gc * 0.1 * specification;","vUpMQlbwDiYfMCNS":"this.actor.addCondition(\"ablaze\");","vY3xeTTL3ghPrJpN":"this.actor.addCondition(\"entangled\");","vZ5HCrhY8e4R1TrG":"let eye = await fromUuid(\"Compendium.wfrp4e-core.items.weczkAMPlTjX7lqU\")\nlet nose = await fromUuid(\"Compendium.wfrp4e-core.items.SpPRZZRHxly7uo2G\")\nthis.actor.createEmbeddedDocuments(\"Item\", [eye, nose]);","vc4bELo0cWYoILfB":"let choice = await ItemDialog.create(this.actor.itemTypes.disease, 1, \"Choose a disease to heal (must be naturally occuring)\")\n\nthis.script.message(`Cured <strong>${choice[0]?.name}</strong>`);\nchoice[0].delete()","vc8eVKtyjtOGvWlK":"if (!this.actor.hasCondition(\"entangled\"))\n{\n    this.effect.delete();\n}","vcM0IgsYVmfWrlO3":"fromUuid(\"Compendium.wfrp4e-core.items.rOV2s6PQBBrhpMOv\").then(item => {\n    this.actor.createEmbeddedDocuments(\"Item\", [item], {fromEffect : this.effect.id});\n})","vejhfB9aI58iF1vr":"let choice1 = [\n    {\n        type: \"trait\",\n        name: \"Disease\",\n    },\n    {\n        type: \"trait\",\n        name: \"Infected\",\n    },\n    {\n        type: \"trait\",\n        name: \"Distracting\",\n    },\n    {\n        type: \"trait\",\n        name: \"Infestation\",\n    },\n    {\n        type: \"trait\",\n        name: \"Territorial\",\n    }\n]\n\nlet updateObj;\nlet actor;\n\nasync function addTrait(c) {\n    let items = [];\n    console.log(\"TEST1\", c);\n    let existing;\n    if (c.type == \"trait\") {\n        existing = updateObj.items.find(i => i.name == c.name && i.type == c.type);\n    }\n    console.log(\"TEST\", existing);\n    if (!existing) {\n        let item = await game.wfrp4e.utility.find(c.name, c.type);\n        if (item) {\n            item = item.toObject();\n            items.push(item);\n        }\n        else\n            ui.notifications.warn(`Could not find ${c}`, { permanent: true });\n    }\n    console.log(\"WISH LIST2\", choice1, items);\n    actor.createEmbeddedDocuments(\"Item\", items);\n}\n\nasync function dialogChoice() {\n    for (let c of choice1) \n    {\n        if (await foundry.applications.api.DialogV2.confirm({window : {title: \"Option\"}, content:`<p>Add Option?</p><ol><li>${c.name}</li></ol>`}))\n        {\n            addTrait(c)\n            c.valid = true;\n        }\n    }\n}\n\nupdateObj = this.actor.toObject();\nactor = this.actor\nawait dialogChoice();\n\n","vgfs0DXvF5iKrz1M":"return args.characteristic != \"ag\" || this.item.getFlag(\"wfrp4e\", \"passed\")","vj3zArmX27vCxYJW":"return ![\"NAME.Perception\", \"NAME.Navigation\"].map(i => game.i18n.localize(i)).includes(args.skill?.name)","vjyTKcNrJzX4XWnS":"let SL = parseInt(this.effect.sourceTest.result.SL)\nif (SL < 0)\n   SL = 0\nthis.actor.addCondition(\"fatigued\", 1 + SL)","vn13U388mwquGN9y":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.wGTD2LezlI6Atyy0\");\nlet leader = item.toObject();\n\nitem = await fromUuid(\"Compendium.wfrp4e-core.items.Item.u0CFf3xwiyidD9T5\");\nlet luck = item.toObject();\nawait this.actor.createEmbeddedDocuments(\"Item\", [leader, luck], {fromEffect : this.effect.id});","vphNSTVxfZjApblV":"const bonus = this.effect.getFlag(\"wfrp4e-tribes\", \"bonus\");\n\nargs.fields.modifier += bonus;","vuzRRj5d9XdNYx3o":"let broken = this.actor.hasCondition(\"broken\")\nif (broken)\n{\n    broken.delete();\n    this.script.notification(\"Removed Broken\")\n}","vvVhAqreedtmOR9b":"args.totalWoundLoss = Math.max(0, args.totalWoundLoss - 1)\nargs.modifiers.other.push({label : this.effect.name, value : -1)","vvdo1NxjmGVkmFCT":"await this.actor.addCondition(\"stunned\");\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields: {difficulty : \"hard\"}, skipTargets: true, appendTitle :  \" - \" + this.effect.name})\nawait test.roll();\nif (test.failed)\n{\n\tawait this.actor.addCondition(\"prone\")\n\tawait this.actor.addCondition(\"stunned\")\n}\n          \nlet location = this.item.system.location.key;\n\nif (location)\n{\n    let dropped = this.item.system.weaponsAtLocation;\n\n    if (dropped.length)\n    {\n        this.script.notification(`Dropped ${dropped.map(i => i.name).join(\", \")}!`)\n        for(let weapon of dropped)\n        {\n            await weapon.system.toggleEquip();\n        }\n    }\n}","vzMxIDjRlQSxXtCW":"// Remove the miscast if doubles rolled and succeeded\n// Decrement the major miscast to minor miscast\nif(args.test.succeeded && args.test.result.tables.miscast && args.test.result.roll % 11 == 0)\n{\n    if (args.test.result.tables.miscast.key == \"minormis\")\n    {\n        delete args.test.result.tables.miscast;\n    }\n    else if (args.test.result.tables.miscast.key == \"majormis\")\n    {\n        args.test.result.tables.miscast.key = \"minormis\"\n        args.test.result.tables.miscast.label = game.i18n.localize(\"ROLL.MinorMis\");\n    }\n}","vzSj3vvPryp02EVC":"if (args.test.failed)\n                            {\n                                let applicableCharacteristics = [\"ws\", \"bs\", \"s\", \"fel\", \"ag\", \"t\", \"dex\"];\n                                if (applicableCharacteristics.includes(args.test.characteristicKey))\n                                {\n                                    this.actor.addCondition(\"stunned\");\n                                }\n                            }","w3r54pKZQKaH2Yer":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.pTorrE0l3VybAbtn\")\nlet data = item.toObject();\nlet slOver = this.effect.sourceTest.result.slOver;\nlet overcast = this.effect.sourceTest.result.overcast\nslOver -= ((overcast.total - overcast.available) * 2) // If they used an overcast, subtract 2 SL for each one\nlet added = Math.floor(slOver / 3) || 0\ndata.system.specification.value = 1 + added; // For each +3 SL, add 1 specification\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","w4JKuTECFmu3YmTR":"return !args.skill?.name?.includes(game.i18n.localize(\"NAME.Ride\"))","w4RuGIfseGoxXA3k":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'challenging';\nconst target = 20;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      \n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","w4zubIHP0XgMXsFe":"return !args.context.terror && !args.extendedTest?.getFlag(\"wfrp4e\", \"fear\");","w6tr8mWy0ZSUkHLt":"const uuids = [\n  \"Compendium.wfrp4e-core.items.Item.77p3QRKgFWakkndF\",     // Blather\n  \"Compendium.wfrp4e-core.items.Item.b4x1qEWcevX7xK58\",       // Schemer\n];\n\nconst items = await Promise.all(uuids.map(uuid => fromUuid(uuid)));\nawait this.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect: this.effect.id});","w7K0lbxQKJ2tsc6f":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.EO05HX7jql0g605A\")\nlet data = item.toObject();\ndata.system.specification.value = 60\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","wAETU6aTRr9d4oCU":"args.fields.slBonus++;","wAntJhgb8Og5vJXh":"args.context.staunchBleeding = true;","wFHjQyCR6Wzn6TeQ":"this.actor.system.status.addArmour(1, {source: this.effect, magical: true});","wRxgpGmlUpe7nwzJ":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 0,\n      \"bright\": 0,\n      \"angle\": 360,\n      \"alpha\": 0.5,\n      \"animation\": {\n          \"speed\": 0,\n          \"intensity\": 0,\n          \"type\": \"none\",\n      },\n      \"color\": \"\",\n  }}));","wS6OIR3QN4mOUHn0":"if (args.totalWoundLoss > args.actor.characteristics.t.bonus)\n{\n  args.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\")).then(async test => {\n    await test.roll()\n    if (test.failed) {\n      let disease = await fromUuid(\"Compendium.wfrp4e-core.items.M8XyRs9DN12XsFTQ\")\n      disease = disease.toObject()\n      disease.system.duration.active = true\n      args.actor.createEmbeddedDocuments(\"Item\", [disease])\n    }\n  })\n}","wUlYLBT59Efys5aS":"args.actor.addCondition(\"prone\");","wb1DpSdIhSqYG5cp":"args.fields.slBonus = -1 * parseInt(this.effect.sourceTest.result.SL)","wbM7tpw4TxvadcWm":"let items = this.effect.itemTargets;\nlet msg = \"\";\nfor(let item of items)\n{\n    if (item.system.properties.qualities.durable)\n    {\n        await item.update({\"system.qualities.value\" : []});\n        msg += `<p>${item.name} loses all Qualities</p>`\n    }\n    else \n    {\n        msg += `<p>${item.name} crumbles into dust!</p>` \n        await item.update({name : item.name + \" (Dust)\"})\n    }\n}\nif(msg)\n{\n    this.script.message(msg);\n}","we6JUzDvybekAbtn":"return args.type !== \"channelling\" && !args.skill?.name.includes(game.i18n.localize(\"NAME.Channelling\")) && args.skill?.name !== `${game.i18n.localize(\"NAME.Language\")} (${game.i18n.localize(\"SPEC.Magick\")})`","whUSkaR1yem21bXp":"let characteristics = {\n  \"ws\" : 10,\n  \"bs\" : 5,\n  \"s\" : 0,\n  \"t\" : 5,\n  \"i\" : 10,\n  \"ag\" : 0,\n  \"dex\" : 6,\n  \"int\" : -5,\n  \"wp\" : 0,\n  \"fel\" : 10\n}\nlet skills = [\"Melee (Basic)\", \"Track\"]\nlet skillAdvancements = [8, 7]\nlet talents = [\"Berserk Charge\", \"Careful Strike\", \"Strike to Injure\"]\nlet traits = [\"Flight (8)\", \"Fury\", \"Swarm\", \"Tracker\"]\nlet trappings = []\nlet items = [];\nlet spells = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n  updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n  let skill = skills[index]\n  let skillItem;\n  skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n  if (skillItem)\n      skillItem.system.advances.value += skillAdvancements[index]\n  else \n  {\n      skillItem = await game.wfrp4e.utility.findSkill(skill)\n      skillItem = skillItem.toObject();\n      skillItem.system.advances.value = skillAdvancements[index];\n      items.push(skillItem);\n  }\n}\n\nfor (let talent of talents)\n{\n  let talentItem = await game.wfrp4e.utility.findTalent(talent)\n  if (talentItem)\n  {\n      items.push(talentItem.toObject());\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n  }\n}\n\nconst traitRegex = /(?:,?(.+?)(\\+?\\d{1,2}\\+?)?\\s*?(?:\\((.+?)\\)\\s*(\\+?\\d{1,2})?|,|$))/gm\nfor (let trait of traits)\n{\n  let traitMatches = trait.matchAll(traitRegex).next().value\n  let traitName = traitMatches[1]\n  let traitVal = traitMatches[2] || traitMatches[4] // could be match 2 or 4 depending on if there's a specialization\n  let traitSpec = traitMatches[3]\n\n  let traitItem;\n  try {\n      traitItem = await WFRP_Utility.findItem(traitName, \"trait\")\n  }\n  catch { }\n  if (!traitItem) {\n      ui.notifications.warn(`Could not find ${trait}`, {permanent : true})\n  }\n  traitItem = traitItem.toObject()\n\n  if (Number.isNumeric(traitVal))\n  {\n      traitItem.system.specification.value = traitName.includes('Weapon','Horns','Tail','Tentacles','Bite') ? traitVal - parseInt(characteristicValues[3]/10) : traitVal;\n      traitItem.name = (traitItem.name +  ` ${traitSpec ? \"(\"+ traitSpec + \")\" : \"\"}`).trim()\n  }\n  else \n      traitItem.system.specification.value = traitSpec\n\n  items.push(traitItem)\n\n}\n\nfor (let trapping of trappings) \n{\n  let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n  if (trappingItem)\n  {\n      trappingItem = trappingItem.toObject()\n\n      trappingItem.system.equipped.value = true;\n\n      items.push(trappingItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n  }\n}\n\nfor (let spell of spells) \n{\n  let spellItem = await game.wfrp4e.utility.findItem(spell)\n  if (spellItem)\n  {\n      spellItem = spellItem.toObject()\n\n      items.push(spellItem);\n  }\n  else \n  {\n      ui.notifications.warn(`Could not find ${spell}`, {permanent : true})\n  }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","wkY4Uj2NjT8mQNT4":"args.item.system.damage.value = \"+6\";\nargs.item.system.qualities.value.push({name : \"magical\"});","wsqNM4NHnwaAAQym":"    args.applyAP = false;\n\n    this.script.notification(\"This test only applies to criminals, otherwise close the dialog.\");\n    this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"average\"}, skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test => \n    {\n      await test.roll();\n      if (test.failed)\n      {\n        args.actor.addCondition(\"unconscious\");\n      }\n    });","wyTCozh9qGTx6yK0":"if (args.context.terror || args.extendedTest?.getFlag(\"wfrp4e\", \"fear\"))\n{\n\targs.abort = true;\n\tthis.script.notification(\"Does not need to make Fear or Terror tests\");\n}","wzkxiKjxVEeNS1di":"let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\nthis.script.message(await this.actor.applyBasicDamage(roll.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg: true}))\n\nawait this.actor.addCondition(\"deafened\", 3)\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty: \"average\" }, skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context : {failure: \"Gain a Broken Condition\", success : \"Avoided Broken Condition\"}})\nawait test.roll();\nif (test.failed)\n{\n    this.actor.addCondition(\"broken\")\n}","x2RLUUNB7BiIDYCP":"\n                            let difficulty = \"\"\n                            if (this.effect.name.includes(\"Moderate\"))\n                                difficulty = \"easy\"\n                            else if (this.effect.name.includes(\"Severe\"))\n                                difficulty = \"average\"\n                            else\n                                difficulty = \"veasy\"\n        \n                            let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {context : {failure : this.actor.name + \" dies from Blight\"}, fields: {difficulty}, skipTargets: true, appendTitle :  \" - Blight\"})\n                            await test.roll();\n                            if (test.failed)\n                            {\n                                this.actor.addCondition(\"dead\");\n                            }\n                            ","x76tKw4L8dX00ikE":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.uqGxFOEqeurwkAO3\")\nlet data = item.toObject();\nfoundry.utils.setProperty(data, \"flags.wfrp4e.breath\", \"fire\")\ndata.system.specification.value = 5\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","x8XK2fzzXCnSwfjt":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Athletics\"))\nawait test.roll();\n\nif (test.succeeded)\n{\n\tthis.actor.removeCondition(\"prone\");\n}","x9G6Du5EWV6byf4C":"if (parseInt(this.effect.sourceTest.result.SL) >= 3)\n{\n     this.actor.modifyWounds(this.actor.system.characteristics.t.bonus * 2)\n}\nelse \n{\n   this.actor.modifyWounds(this.actor.system.characteristics.t.bonus)\n}","x9iKFYYc4Ocy8PTS":"let item = this.effect.getCreatedItems()?.[0];\nChatMessage.create({content : \"<em>Grace is beyond style</em>\", speaker : ChatMessage.getSpeaker({token: this.actor.getActiveTokens()[0]?.document, actor: this.actor})}, {chatBubble : true})\n\nlet choice = await ItemDialog.create(ItemDialog.objectToArray({\n    \"nobles\" : \"Nobles\",\n    \"guilders\" : \"Guilders\",\n    \"servants\" : \"Servants\"\n}), 1, \"Choose Group\")\n\nlet name = choice[0]?.name\n\nif (!name)\n{\n    return;\n}\n\nif (item)\n{\n    item.update({\n        name : item.name.split(\"(\")[0] + ` (${name})`, \n        \"system.tests.value\" : item.system.tests.value.split(\"(\")[0] + ` (${name}`\n    })\n}\nelse \n{\n    item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.sYbgpSnRqSZWgwFP\");\n    let data = item.toObject();\n    data.name += ` (${name})`\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect: this.effect.id})\n}","xBpLQa7yBPczDMY8":"    let scythe = (await fromUuid(\"Compendium.wfrp4e-core.items.CXg7XOFJwu4LZ9LM\")).toObject();\n    scythe.name = \"Scythe of Shyish\";\n    scythe.system.damage.value = \"WPB + 3\"\n    scythe.system.equipped = true;\n    scythe.img = this.effect.img;\n    scythe.system.qualities.value.push({name : \"magical\"})\n    this.actor.createEmbeddedDocuments(\"Item\", [scythe], {fromEffect : this.effect.id})","xIRU2SaqLeWmqGDI":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.vMYEkrWj0ip6ZOdv\")\nlet data = item.toObject();\ndata.name += \" (Disease)\"\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","xJZKVGE04o84Gibo":"if (!this.item.actor.name.includes(\"Brunner\")) return;\n\nargs.item.system.damage.value += \"+1\";","xL4S0H1RP8hhXW7c":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.xneBqGOs1QS7kfUr\")\nlet data = item.toObject();\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","xLKAuD6yzwjAL6tJ":"return !args.weapon || args.weapon?.system.properties?.qualities.shield || !this.item.system.usesLocation(args.weapon)","xMhhVol8Is3DJ3gb":"if (this.effect.sourceTest.succeeded)\n{\n    let blinded = 1 + this.effect.sourceTest.result.overcast.usage.other.count\n    this.actor.addCondition(\"blinded\", blinded)\n}","xPDMpOvC1ZBVxrNg":"args.fields.modifier += 10;","xPwa3NftkpMBc2AO":"return ![\"ws\", \"s\", \"ag\"].includes(args.characteristic)","xQ3xR2Wf0wHFa76H":"return [\"ws\", \"bs\", \"fel\", \"dex\"].includes(args.characteristic) || args.weapon","xQnoRTHotZKrwPrx":"return args.type == \"cast\" && args.item?.system.lore?.value == \"shadow\"","xRTmMwNfdirjsi8X":"this.actor.addCondition(\"ablaze\");\n\nthis.actor.applyBasicDamage(this.effect.sourceTest.result.damage)","xRd6oA1QWLVpfoBm":"if (!this.actor.has(game.i18n.localize(\"NAME.NightVision\")))\n{\n    let item = await fromUuid(\"Compendium.wfrp4e-core.items.FmHDbCOy3pH8yKhm\");\n    let data = item.toObject();\n    this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})\n}","xS2su09zcza9du09":"if ([game.i18n.localize(\"CORRUPTION.Minor\"), game.i18n.localize(\"CORRUPTION.Moderate\"), game.i18n.localize(\"CORRUPTION.Major\")].includes(this.item.system.specification.value))\n{\n\treturn\n}\n\nlet choice = await ItemDialog.create(ItemDialog.objectToArray({minor : game.i18n.localize(\"CORRUPTION.Minor\"), moderate : game.i18n.localize(\"CORRUPTION.Moderate\"), major : game.i18n.localize(\"CORRUPTION.Major\")}, this.item.img), 1, \"Choose Corruption Severity\");\n\nthis.item.updateSource({\"system.specification.value\" : choice[0]?.name || \"\"})","xUpKYT7BZCSmAfUy":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[0].convertToApplied()]})\n}\nelse\n{\n\tthis.script.notification(\"None left!\", \"error\")\n}","xVYVegD692CCv8Yl":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"hard\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\n\nlet newFortune = Math.max(0, this.actor.status.fortune.value - 1)\nthis.actor.update({ \"system.status.fortune.value\": newFortune  });\n\nif (test.failed)\n{ \n  let char = this.effect.sourceActor.characteristics;\n  let duration = Math.floor((char.wp.initial + char.wp.advances)/10) ;\n  this.script.message(\"<strong>Fatethief</strong> has been applied for \" + duration + \" days\"); \n}","xWPgIZOQLba5nZ23":"let nbFatigue = 1 + Number(this.effect.sourceTest.result.SL);\nthis.actor.addCondition(\"fatigued\", nbFatigue);  \n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Endurance\"), {fields : {difficulty : \"hard\"}, appendTitle : ` - ${this.effect.name}`})\nawait test.roll();\n\nif (test.succeeded)\n{\n  this.script.notification(this.actor.name + \"resisted !\")\n}\nelse if (test.failed)\n{\n  this.actor.addCondition(\"unconscious\", 1);\n}","xYTkj8jhSVOSoLbC":"this.actor.flags.useless[this.item.system.location.key[0] + \"Arm\"] = true;","xcy5GOUSZ0meIejZ":"if (args.test.isFumble)\n{\n    args.test.result.other.push(\"@Table[warp-grinder-fumble]\")\n}","xgdhf0wlNP2cHIQx":"await this.actor.addCondition(\"entangled\", this.effect.sourceTest.result.overcast.usage.other.current)","xgplXZMs459X7XXM":"// Apply changes when the mask is worn\n\nif (args.equipped) {  \n  this.actor.createEmbeddedDocuments(\"ActiveEffect\", [this.item.effects.contents[1]?.convertToApplied()])  \n  this.script.message(`${this.actor.name} dons the <strong>${this.item.name}</strong>. <br>\n        They suffer –20 to all attempts to resist Disease.<br>\n        If they wear the mask for more than an hour or benefit from any of its effects, they are exposed to @Corruption[moderate]{Moderate Corruption}. \n        `,\n      {whisper: ChatMessage.getWhisperRecipients(\"GM\")}) \n}\n\n// Notify of lingering effects when mask is removed\nelse if (!args.equipped)\n{\n    await this.item.effects.contents[0].delete();\n    await this.item.update({name : this.item.name += \" (Used)\"})\n    this.script.message(`<strong>${this.item.name}</strong> on ${this.actor.name} has been taken off and loses its properties. However, the effects last for [[1d10+4]] days, after which they should be manually removed.`, \n    {whisper: ChatMessage.getWhisperRecipients(\"GM\")}\n    )\n    \n}\n","xihniGjgqOhuaKWc":"                 \n                            if (args.test.failed)\n                            {\n                                let applicableCharacteristics = [\"ws\", \"bs\", \"s\", \"fel\", \"ag\", \"t\", \"dex\"];\n                                if (applicableCharacteristics.includes(args.test.characteristicKey))\n                                {\n                                    this.actor.addCondition(\"stunned\");\n                                }\n                            }","xiyQSXozoLxt0MZs":"const uuids = [\n  \"Compendium.wfrp4e-core.items.Item.wMwSRDmgiF2IdCJr\",     // Painless\n  \"Compendium.wfrp4e-core.items.Item.IAWyzDfC286a9MPz\",       // Immunity to Psychology\n];\n\nconst items = await Promise.all(uuids.map(uuid => fromUuid(uuid)));\nawait this.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect: this.effect.id});","xkdQhZ9KKqmocNLO":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.Item.tXKX29QZBdHmyMc7\")\nlet data = item.toObject();\nawait this.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","xklncIMwQIespDxS":"let test = await this.actor.setupCharacteristic(\"t\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"vhard\"}});\nawait test.roll();\nCorruptionMessageModel.createCorruptionMessage(\"minor\", this.script.getChatData())\n\nif (test.failed)\n{\n    this.actor.addCondition(\"unconscious\");\n}","xnHobI9HojObLHMp":"args.applyTB = false;\nargs.applyAP = false;","xobGBJbgFjQCrwvq":"let roll;\nif (this.actor.has(game.i18n.localize(\"NAME.Daemonic\")) || this.actor.has(game.i18n.localize(\"NAME.Undead\")) || [\"Goblin\", \"Orc\", \"Undead\"].includes(this.actor.system.details.species.value))\n{\n    roll = await new Roll(`1d10 + ${this.effect.sourceTest.result.overcast.usage.other.current}`).roll()\n}\nelse \n{\n    roll = await new Roll(`1d10`).roll()\n}\n\nroll.toMessage(this.script.getChatData())\nawait this.actor.applyBasicDamage(roll.total, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true})\n\nif (this.actor.has(\"Undead\") || args.actor.has(\"Daemonic\"))\n{\n  this.actor.addCondition(\"ablaze\")\n}","xot4JWCRzLkobHtL":"args.actor.removeCondition(\"broken\", 1);","xpgXWoK2zDnG1uiF":"    let stunned = args.actor.hasCondition(\"stunned\")\n    if (stunned)\n    {\n        stunned.system.scriptData = stunned.system.scriptData.filter(s => s.trigger != \"dialog\")\n        stunned.system._scripts = null;\n    }\n\n\n\n    let poisoned = args.actor.hasCondition(\"poisoned\")\n    if (poisoned)\n    {\n        poisoned.system.scriptData = poisoned.system.scriptData.filter(s => s.trigger != \"dialog\")\n        poisoned.system._scripts = null;\n    }\n\n\n\n    let deafened = args.actor.hasCondition(\"deafened\")\n    if (deafened)\n    {\n        deafened.system.scriptData = deafened.system.scriptData.filter(s => s.trigger != \"dialog\")\n        deafened.system._scripts = null;\n    }\n\n\n\n\n    let entangled = args.actor.hasCondition(\"entangled\")\n    if (entangled)\n    {\n        entangled.system.scriptData = entangled.system.scriptData.filter(s => s.trigger != \"dialog\")\n        entangled.system._scripts = null;\n    }\n\n\n\n\n    let fatigued = args.actor.hasCondition(\"fatigued\")\n    if (fatigued)\n    {\n        fatigued.system.scriptData = fatigued.system.scriptData.filter(s => s.trigger != \"dialog\")\n        fatigued.system._scripts = null;\n    }\n\n\n\n    let blinded = args.actor.hasCondition(\"blinded\")\n    if (blinded)\n    {\n        blinded.system.scriptData = blinded.system.scriptData.filter(s => s.trigger != \"dialog\")\n        blinded.system._scripts = null;\n    }\n\n\n\n    let broken = args.actor.hasCondition(\"broken\")\n    if (broken)\n    {\n        broken.system.scriptData = broken.system.scriptData.filter(s => s.trigger != \"dialog\")\n        broken.system._scripts = null;\n    }\n\n\n\n    let prone = args.actor.hasCondition(\"prone\")\n    if (prone)\n    {\n        prone.system.scriptData = prone.system.scriptData.filter(s => s.trigger != \"dialog\")\n        prone.system._scripts = null;\n    }\n\n","xq3RANOtmPhy77ne":"args.update({texture : {tint : \"#FFBF00\"}});","xqWxV9w5ezBQdJkZ":"return args.context.corruption;","xvGxwv7X0Vq3vNqb":"args.fields.modifier -= 10;","xvH4PKJasHcehOZz":"return args.skill?.name == `${game.i18n.localize(\"NAME.Lore\")} (${this.item.parenthesesText})`","y3F1K1sYBymPZCjz":"let characteristics = {\n    \"ws\" : 10,\n    \"bs\" : 0,\n    \"s\" : 5,\n    \"t\" : 0,\n    \"i\" : 5,\n    \"ag\" : 10,\n    \"dex\" : 0,\n    \"int\" : 0,\n    \"wp\" : 0,\n    \"fel\" : 0\n}\nlet skills = [\"Athletics\", \"Animal Care\", \"Language (Battle)\", \"Melee (Basic)\", \"Melee (Cavalry)\", \"Ride\"]\nlet skillAdvancements = [10,10, 10, 10, 10, 20]\n\nlet talents = [\"Roughrider\", \"Strike Mighty Blow\"]\nlet trappings = [\"Hand Weapon\",  \"Shield\", \"Lance\", \"Plate Breastplate\", \"Plate Bracers\", \"Plate Helm\", \"Plate Leggings\"]\nlet specialItems = [ \n    {name: \"Chaos Steed\", type: \"trapping\", trappingType: \"misc\" }, \n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWFRP4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nconsole.log(\">>>>>>><\", items)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","y3agVFVBR8tVqWyx":"let test = await this.actor.setupCharacteristic(\"wp\", {skipTargets: true, appendTitle :  ` - ${this.effect.name}`});\nawait test.roll();","y7hk7prQ0lLTyv1Y":"return args.item?.system?.isRanged && (args.item.system.weaponGroup.value !== \"blackpowder\" || args.item.system.weaponGroup.value !== \"engineering\")","yAL0YwZWVm8o1nxa":"if (this.actor.hasCondition(\"dead\") && !this.actor.gardenOfCorpses)\n{\n    this.script.message(\"[[3d10]] @UUID[Compendium.wfrp4e-core.actors.T79RqnDOAQLn3I1s]{zombies} spring forth from the remains.\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    this.actor.gardenOfCorpses = true;\n    // local storage is sufficient to prevent multiple messages\n}","yCgH3N9AurIiAv0i":"if (!this.item.name.includes(\"(\") || this.item.system.tests.value.includes(\"(Sense)\") || this.item.system.tests.value.toLowerCase().includes(\"(any)\"))\n{\n    let tests = this.item.system.tests.value\n    let name = this.item.name\n\n    // If name already specifies, make sure tests value reflects that\n    if (name.includes(\"(\") && !name.toLowerCase().includes(\"(any)\"))\n    {\n        let sense = name.split(\"(\")[1].split(\")\")[0]\n        tests = `${tests.split(\"(\")[0].trim()} (${sense})`;\n    }\n    else // If no sense specified, provide dialog choice\n    {\n        let choice = await ItemDialog.create(ItemDialog.objectToArray({\n            taste : \"Taste\",\n            sight : \"Sight\",\n            smell : \"Smell\",\n            hearing : \"Hearing\",\n            touch : \"Touch\"\n        }, this.item.img), 1, {title : this.item.name, text : \"Choose Sense\"});\n        if (choice[0])\n        {\n            name = `${name.split(\"(\")[0].trim()} (${choice[0].name})`\n            tests = `${tests.split(\"(\")[0].trim()} (${choice[0].name})`\n        }\n    }\n\n        this.item.updateSource({name, \"system.tests.value\" : tests})\n}","yDvxF9llUYwJg0sE":"if (getProperty(args.data, \"system.loaded.value\") == true)\n{\n    let repeaterValue = Math.ceil(CONFIG.Dice.randomUniform() * 10);\n    let qualities = foundry.utils.deepClone(this.item.system.qualities.value);\n    let repeater = qualities.find(i => i.name == \"repeater\")\n    if (repeater)\n    {\n        repeater.value = repeaterValue\n    }\n    else \n    {\n        qualities.push({name : \"repeater\", value : repeaterValue})\n    }\n    foundry.utils.setProperty(args.data, \"system.loaded.amt\", repeaterValue)\n    this.item.update({\"system.qualities.value\" : qualities});\n    this.script.notification(\"Repeater \" + repeaterValue);\n}\nelse if (foundry.utils.getProperty(args.data, \"system.loaded.value\") == false)\n{\n   let qualities = foundry.utils.deepClone(this.item.system.qualities.value).filter(i => i.name != \"repeater\");\n   this.item.update({\"system.qualities.value\" : qualities});\n}","yFMvxecXAZ6T2O0S":"if (args.totalWoundLoss >= 1)\n{\n    let roll = await new Roll(\"1d10\").roll({allowInteractive : false});\n    await roll.toMessage(this.script.getChatData());\n    if (roll.total == 9)\n    {\n        this.script.message(`Two @UUID[Compendium.wfrp4e-eis.actors.cLOGeMqUty61nYB9]{Blue Horror of Tzeentch} claw their way out of ${this.actor.name}'s screaming flesh, killing them in the process.`, {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n    }\n}","yIGItnshXI4W46cp":"return args.skill?.name != game.i18n.localize(\"NAME.Charm\");","yMMzZ7daCqRlGT3N":"let item = args.opposedTest.attackerTest.item;\nif (!item.isMagical && (item.type == \"weapon\" || item.type == \"trait\"))\n{\n    args.modifiers.other.push({label : this.effect.name, details : \"Remove Damage Rating\", value : -1 * (args.totalWoundLoss - args.opposedTest.result.differenceSL)})\n}\n","yPxYRObUiqAIhlNB":"this.actor.system.status.encumbrance.max += 1","yQziCK8G8I1RYkTj":"let add;\nif (args.opposedTest?.attackerTest?.weapon?.isRanged && args.opposedTest?.result.hitloc?.value === \"head\") {\n    add = await foundry.applications.api.DialogV2.confirm({window : {title : this.effect.name}, content : \"Add 1 AP? Bascinet provides 4 AP instead of 3 against missile attacks from the front\"})\n}\n\nif (add) {\n\n    args.modifiers.ap.metal++;\n    args.modifiers.ap.used++;\n    args.modifiers.ap.value++;\n    args.modifiers.ap.details.push(\"+1 AP against missile attacks to the front\");\n}","yRRzSKlcN3L7rEEe":"return args.skill?.name.includes(game.i18n.localize(\"NAME.Entertain\")) || args.skill?.name.includes(game.i18n.localize(\"NAME.Perform\")) || args.skill?.name.includes(game.i18n.localize(\"NAME.Play\"));","yTmRoUstxHMso91c":"if (args.item.name == game.i18n.localize(\"NAME.MagicResistanceTrait\") && args.item.type == \"trait\")\n{\n    args.item.system.specification.value = Number(args.item.system.specification.value) + 1\n}","yXUPiWuQ5o0JBY4i":"return args.skill?.name == game.i18n.localize(\"NAME.Endurance\") || args.characteristic == \"int\"","yYNBZjmBnytXpRn3":"this.actor.reset();","yamap8V6Gx2Z9Smu":"const uuids = [\n  \"Compendium.wfrp4e-core.items.Item.nWLsoWQBCjPRKxYx\",     // Robust\n  \"Compendium.wfrp4e-core.items.Item.jviOQmy0luQOySC2\",         // Tenacious\n];\n\nconst items = await Promise.all(uuids.map(uuid => fromUuid(uuid)));\nawait this.actor.createEmbeddedDocuments(\"Item\", items, {fromEffect: this.effect.id});","yatUu0cd7iKs50rq":"return args.skill?.name != game.i18n.localize(\"NAME.Track\");","ybxDG2ezvRx02LYx":"return !args.context.corruption","ynNCBAYwJFkTiXV1":"this.actor.system.status.addArmour(4, {source : this.effect})","ynV7tz0OdCwlsQp6":"let msg = \"\"\nmsg += `<p>${await this.actor.applyBasicDamage(8, {loc : \"roll\", suppressMsg: true, hideDSN: true})}</p>`\nmsg += `<p>${await this.actor.applyBasicDamage(8, {loc : \"roll\", suppressMsg: true, hideDSN: true})}</p>`\nmsg += `<p>${await this.actor.applyBasicDamage(8, {loc : \"roll\", suppressMsg: true, hideDSN: true})}</p>`\n\nthis.script.message(msg);","ynoHNXXCGRS6fTqF":"let msg = \"\"\n\nlet i_gain = (await new Roll(\"1d10\").roll()).total\n\nif (args.actor.characteristics.i.value <= 0)\n{\n   i_gain += (await new Roll(\"2d10\").roll()).total\n}\n\nmsg = `<b>${this.actor.prototypeToken.name}</b> gains ${i_gain} Initiative`\n\nlet newValue = i_gain + args.actor.characteristics.i.modifier\n\nthis.actor.update({\"system.characteristics.i.modifier\" : newValue})\n\n\nlet hitloc = await game.wfrp4e.tables.rollTable(\"hitloc\")\n\nlet value = hitloc.result\nlet desc = hitloc.description\n\nthis.effect.updateSource({\"flags.wfrp4e.location\" : value})\n\nmsg += ` as eyes push out of their ${desc}`\n\nthis.script.message(msg)","yr1FmaTY18JXWa8s":"return [\"witchcraft\", \"necromancy\", \"daemonology\", \"slaanesh\", \"nurgle\", \"tzeentch\", \"undivided\"].includes(args.spell?.system.lore.value);","yvtF2t9aibxibAIM":"const test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Perception\"), {\n  skipTargets: true,\n  appendTitle: ` — ${this.effect.name}`,\n  fields: {difficulty: \"challenging\"},\n  context: {\n    failure: `Gained @Condition[Prone] Condition.`,\n    success: `Able to move.`\n  }\n});\n\nawait test.roll();\n\nif (test.failed)\n  this.actor.addCondition(\"prone\");","yzN7ZNlgCiSVJqsU":"let sourceItem = this.effect.sourceItem;\n\nif (sourceItem)\n{\n\tthis.actor.applyEffect({effectUuids : [sourceItem.effects.contents[1].uuid]})\n\tthis.script.notification(\"Applied after effects\");\n}","z14Tb2YKCjiE5ZTU":"this.actor.getActiveTokens().forEach(t => t.document.update({light : {\n      \"dim\": 30,\n      \"bright\": 20,\n      \"angle\": 90,\n      \"alpha\": 0.6,\n      \"animation\": {\n          \"speed\": 3,\n          \"intensity\": 3,\n          \"type\": \"torch\",\n      },\n      \"color\": \"#ffcc66\",\n  }}));","z5HfNUrHy5MS3K7a":"let test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, context : {failure: \"1 Corruption Point Gained\"}})\nawait test.roll();\nif (test.failed && this.actor.type == \"character\")\n{\n    this.actor.update({\"system.status.corruption.value\" : parseInt(this.actor.status.corruption.value) + 1})\n    this.script.message(\"Gained a Corruption point\", {whisper : ChatMessage.getWhisperRecipients(\"GM\")})\n}","z8mwLihZQu0JtUHY":"\nlet characteristics = {\n    \"ws\" : 20,\n    \"bs\" : 20,\n    \"s\" : 0,\n    \"t\" : 20,\n    \"i\" : 30,\n    \"ag\" : 0,\n    \"dex\" : 10,\n    \"int\" : 65,\n    \"wp\" : 70,\n    \"fel\" : 20\n}\nlet skills = [\"Channelling\", \"Cool\", \"Intimidate\", \"Language (Magick)\", \"Language (Nehekharan)\", \"Leadership\", \"Lore (Magic)\", \"Perception\"]\nlet skillAdvancements = [20, 30, 25, 30, 20, 20, 30, 20]\nlet talents = [\"Aethyric Attunement\", \"Arcane Magic\", \"Hardy\", \"Instinctive Diction\", \"Magical Sense\", \"Menacing\", \"Menacing\", \"Petty Magic\", \"Read/Write\", \"Second Sight\", \"War Wizard\"]\nlet trappings = [\"Hand Weapon\"]\nlet specialItems = [ \n    {name: \"Mouldering Robes\", type: \"trapping\", trappingType: \"clothingAccessories\" }, \n    {name: \"Pouches containing ritual components\", type: \"trapping\", trappingType: \"clothingAccessories\" }, \n    {name: \"Staff\", type: \"weapon\", damage: \"SB+2\"}, \n    {name: \"Dark Magic (Necromancy)\", type: \"talent\"},\n]    \nlet items = [];\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let item of specialItems) {\n    let newItem\n    if (item.type == \"weapon\") {\n        newItem = new ItemWFRP4e({ name: item.name, type: item.type, system: { equipped: true, damage: {value: item.damage}}  })\n    } else if (item.type == \"trapping\") {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type, system: { worn: true, trappingType: { value: item.trappingType}  } } )\n    } else {\n        newItem = new ItemWFRP4e({ img: \"systems/wfrp4e/icons/blank.png\", name: item.name, type: item.type  })\n    }\n    items.push(newItem.toObject())\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\nupdateObj.name = updateObj.name += \" \" + this.effect.name\n\nawait this.actor.update(updateObj)\nconsole.log(\">>>>>>><\", items)\nthis.actor.createEmbeddedDocuments(\"Item\", items);\n","z926Cl2vxUfyLY0V":"if (![\"rArm\", \"lArm\"].includes(this.effect.getFlag(\"wfrp4e\", \"location\")))\n\treturn true\n\nreturn [\"fel\", \"wp\", \"int\", \"t\"].includes(args.characteristic)","z9NEbIUBsKMaTuCz":"if (args.opposedTest.result.hitloc && args.opposedTest.result.hitloc.value == \"head\") \n{\n    args.actor.addCondition(\"entangled\")\n}","zA6TDttpwMSMl7D8":"// An imbiber must take a Consume Alcohol Test.\nthis.actor.setupSkill(game.i18n.localize(\"NAME.ConsumeAlcohol\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`}).then(async test => {\n  await test.roll()\n  // If they succeed, \n  // as a result of whatever potential futures they glimpse, \n  // they can spend a Fortune Point within the next hour to reverse the dice of any failed Test.\n  if (test.succeeded) {\n    this.script.message(`As a result of whatever potential futures they glimpse, <strong>${this.actor.prototypeToken.name}</strong> can spend a Fortune Point within the next hour to reverse the dice of any failed Test.`, \n    {\n      whisper: ChatMessage.getWhisperRecipients(\"GM\"), \n      blind: true \n    })    \n  }\n})","zBHTIBU8OlYj1YIO":"args.fields.modifier += this.effect.sourceActor?.system.characteristics.wp.value;","zF1IKmobCB8ea58M":"return this.sourceActor.uuid === this.actor.uuid || ![\"ws\", \"ag\"].includes(args.characteristic);","zFYCaGR0wbFWjl4T":"return args.skill?.name != game.i18n.localize(\"NAME.OutdoorSurvival\");","zI5hXv2NLGWqnmDD":"if (args.totalWoundLoss > 0)\n{\n\targs.actor.applyEffect({effectUuids : this.item.effects.contents[0].uuid})\n}","zIErcRiBmIZRbary":"if (args.test.failed)\n                            {\n                                let applicableCharacteristics = [\"ws\", \"bs\", \"s\", \"fel\", \"ag\", \"t\", \"dex\"];\n                                if (applicableCharacteristics.includes(args.test.characteristicKey))\n                                {\n                                    this.actor.addCondition(\"stunned\");\n                                }\n                            }","zIpl3SkWv8zzlr2D":"let filters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"petty\"\n    }\n]\n\nlet petty = (await ItemDialog.createFromFilters(filters, 4, {text : \"Choose 4 Petty Spells\"})).map(i => i.toObject());\n\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"system.lore.value\",\n        value : [\"death\"]\n    }\n]\n\nlet arcane = (await ItemDialog.createFromFilters(filters, 8, {text : \"Choose 8 Arcane Spells & Lore of Death\"})).map(i => i.toObject());\n\nfilters = [\n    {\n        property : \"type\",\n        value : \"spell\"\n    },\n    {\n        property : \"name\",\n        value: /^((?!\\().)*$/gm, // Remove all spells with parentheses (all arcane spells spells)\n        regex: true\n    },\n    {\n        property : \"system.lore.value\",\n        value : \"necromancy\"\n    }\n]\n\nlet necromancy = (await ItemDialog.createFromFilters(filters, 3, {text : \"Choose 3 from the Lore of Necromancy\"})).map(i => i.toObject());\n\nlet items = [...necromancy, ...petty, ...arcane]\n\nthis.actor.createEmbeddedDocuments(\"Item\", items);","zK38Rl5t9zbFi4Se":"if (args.opposedTest.result.hitloc.value == this.item.system.location.key && args.totalWoundLoss > 0)\n{\n    args.actor.addCondition(\"bleeding\", 1);\n    this.script.notification(\"Added Bleeding\")\n}","zL7ECmBBMAqf5Esn":"let hasMagazine = await foundry.applications.api.DialogV2.confirm({window : {title : this.effect.name}, content: \"<p>Does the vessel have a magazine or any other kind of store for blackpowder?</p>\"});\n\nif (!hasMagazine) return;\n\nlet roll = new Roll(\"d10\");\nawait roll.evaluate();\n// await roll.toMessage();\nlet anchor = roll.toAnchor();\n\nlet crits = [];\n\nfor (let i = 0; i < roll.total; i++) {\n  let result = await WFRP_Tables.rollTable('crithull');\n  let collection = game.packs.get(result.object.documentCollection)\n\n  if (collection)\n    await collection.getDocuments()\n\n  if (!collection)\n    collection = game.items;\n\n    let item = collection.get(result.object.documentId)\n    if (item)\n      crits.push(item);\n}\n\nconst items = await this.actor.createEmbeddedDocuments(\"Item\", crits);\nconst speaker = ChatMessage.getSpeaker({actor: this.actor});\nconst uuids = items.map(i => `@UUID[${i.uuid}]`);\nthis.script.message(`<p><b>${this.item.name}</b> caused an additional ${anchor.outerHTML} Critical Hits to the Hull!</p><ul><li>${uuids.join('<li>')}</ul>`)","zLBLEDl3aGcAxai2":"const hasTraits = args.actor.has(\"Daemonic\") || args.actor.has(\"Undead\") || args.actor.has(\"Spellcaster\");\nconst hasSinOrCorruption = args.actor.status.sin.value > 0 || args.actor.status.corruption.value > 0;\nconst isSpellcaster = args.actor.itemTags.talent.some(i =>\n    i.name.includes(game.i18n.localize(\"NAME.ArcaneMagic\")) ||\n    i.name.includes(game.i18n.localize(\"NAME.ChaosMagic\")) ||\n    i.name.includes(game.i18n.localize(\"NAME.PettyMagic\"))\n  );\nconst shouldDamage = hasTraits || hasSinOrCorruption || isSpellcaster;\n\nif (shouldDamage) {\n  const roll = new Roll(\"1d10\");\n  await roll.evaluate();\n  let damage = roll.total;\n  await roll.toMessage();\n  await this.script.message(await this.actor.applyBasicDamage(damage, {damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg: true}));\n}","zR4WAjzXHTZuiu5G":"let actor = this.actor;\n                            let effect = this.effect;\n                            let bleedingAmt;\n                            let bleedingRoll;\n                            let msg = \"\"\n\n                            let damage = effect.conditionValue;\n                            let scriptArgs = {msg, damage};\n                            await Promise.all(actor.runScripts(\"preApplyCondition\", {effect, data : scriptArgs}))\n                            msg = scriptArgs.msg;\n                            damage = scriptArgs.damage;\n                            msg += await actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, minimumOne : false, suppressMsg : true})\n\n                            if (actor.status.wounds.value == 0 && !actor.hasCondition(\"unconscious\"))\n                            {\n                                await actor.addCondition(\"unconscious\")\n                                msg += \"<br>\" + game.i18n.format(\"BleedUnc\", {name: actor.prototypeToken.name })\n                            }\n\n                            if (actor.hasCondition(\"unconscious\"))\n                            {\n                                bleedingAmt = effect.conditionValue;\n                                bleedingRoll = (await new Roll(\"1d100\").roll()).total;\n                                if (bleedingRoll <= bleedingAmt * 10)\n                                {\n                                    msg += \"<br>\" + game.i18n.format(\"BleedFail\", {name: actor.prototypeToken.name}) + \" (\" + game.i18n.localize(\"Rolled\") + \" \" + bleedingRoll + \")\";\n                                    await actor.addCondition(\"dead\")\n                                }\n                                else if (bleedingRoll % 11 == 0)\n                                {\n                                    msg += \"<br>\" + game.i18n.format(\"BleedCrit\", { name: actor.prototypeToken.name } ) + \" (\" + game.i18n.localize(\"Rolled\") + bleedingRoll + \")\"\n                                    await actor.removeCondition(\"bleeding\")\n                                }\n                                else\n                                {\n                                    msg += \"<br>\" + game.i18n.localize(\"BleedRoll\") + \": \" + bleedingRoll;\n                                }\n                            }\n\n                            await Promise.all(actor.runScripts(\"applyCondition\", {effect, data : {bleedingRoll}}))\n                            if (args.suppressMessage)\n                            {\n                                let messageData = game.wfrp4e.utility.chatDataSetup(msg);\n                                messageData.speaker = {alias: this.effect.name}\n                                messageData.flavor = this.effect.name;\n                                return messageData\n                            }\n                            else\n                            {\n                                return this.script.message(msg)\n                            }\n                            ","zUv9e0A3OEXWY9Mv":"let item = await fromUuid(\"Compendium.wfrp4e-core.items.pLW9SVX0TVTYPiPv\")\nlet data = item.toObject();\ndata.system.specification.value = 9 - this.actor.system.characteristics.s.bonus\nthis.actor.createEmbeddedDocuments(\"Item\", [data], {fromEffect : this.effect.id})","zWZG8OmxqTpzHjFV":"args.actor.characteristics.ag.modifier -= 10;\n\n                            if (args.actor.details.move.value > 3)\n                            {\n                                args.actor.details.move.value -= 1;\n                                if (args.actor.details.move.value < 3)\n                                    args.actor.details.move.value = 3\n                            }","zXh8rgMxWoCLTxVd":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Sail';\nconst difficulty = 'challenging';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","zY4ZjY7uyKIKMYmX":"this.script.message(await game.wfrp4e.tables.formatChatRoll(\"fleshy-curse\"))\n\nlet test = await this.actor.setupSkill(game.i18n.localize(\"NAME.Cool\"), {skipTargets: true, appendTitle :  ` - ${this.effect.name}`, fields : {difficulty : \"hard\"}})\nawait test.roll();\nif (test.succeeded)\n{\n    this.effect.delete()\n}","zadppy7FEbXvgUON":" let characteristics = {\n    \"ws\" : 5,\n    \"bs\" : 0,\n    \"s\" : 0,\n    \"t\" : 0,\n    \"i\" : 0,\n    \"ag\" : 10,\n    \"dex\" : 10,\n    \"int\" : 0,\n    \"wp\" : 0,\n    \"fel\" : 5\n}\nlet skills = [\"Perception\", \"Sleight of Hand\", \"Stealth (Urban)\"]\nlet skillAdvancements = [10, 10, 10]\nlet talents = [\"Criminal\", \"Etiquette (Criminals)\"]\nlet trappings = [\"Rope, 10 yards\", \"Lockpick\", \"Mask\"]\nlet items = []\n\nlet updateObj = this.actor.toObject();\n\nfor (let ch in characteristics)\n{\n    updateObj.system.characteristics[ch].modifier += characteristics[ch];\n}\n\nfor (let index = 0; index < skills.length; index++)\n{\n    let skill = skills[index]\n    let skillItem;\n    skillItem = updateObj.items.find(i => i.name == skill && i.type == \"skill\")\n    if (skillItem)\n        skillItem.system.advances.value += skillAdvancements[index]\n    else \n    {\n        skillItem = await game.wfrp4e.utility.findSkill(skill)\n        skillItem = skillItem.toObject();\n        skillItem.system.advances.value = skillAdvancements[index];\n        items.push(skillItem);\n    }\n}\n\nfor (let talent of talents)\n{\n    let talentItem = await game.wfrp4e.utility.findTalent(talent)\n    if (talentItem)\n    {\n        items.push(talentItem.toObject());\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${talent}`, {permanent : true})\n    }\n}\n\nfor (let trapping of trappings) \n{\n    let trappingItem = await game.wfrp4e.utility.findItem(trapping)\n    if (trappingItem)\n    {\n        trappingItem = trappingItem.toObject()\n\n        trappingItem.system.equipped.value = true;\n\n        items.push(trappingItem);\n    }\n    else \n    {\n        ui.notifications.warn(`Could not find ${trapping}`, {permanent : true})\n    }\n}\n\n\nawait this.actor.update(updateObj)\nthis.actor.createEmbeddedDocuments(\"Item\", items);","zasFOZohkrdFIBwr":"let modifier = 0\n                            if (this.effect.name.includes(\"Moderate\"))\n                                modifier = -20\n                            else\n                                modifier = -10\n                            args.fields.modifier += modifier","zdGAvfL7zJ7wpYxG":"const repaired_message = `<p>Finished repairing <em>${this.item.name}</em>.</p>`;\nconst test = 'Trade (Carpenter)';\nconst difficulty = 'easy';\nconst target = 40;\n\nconst extendedTestData = {\n  name: this.item.name,\n  type: \"extendedTest\",\n  img: this.item.img,\n  system: {\n    SL: {\n      current: 0,\n      target: target\n    },\n    test: {\n      value: test\n    },\n    completion: {\n      value: \"remove\"\n    },\n    difficulty: {\n      value: difficulty\n    }\n  },\n  effects: [\n    {\n      name: `Repair the ${this.item.name}`,\n      img: this.item.img,\n      system: {\n        transferData : {\n            type: \"document\",\n            documentType: \"Item\"\n          },\n          scriptData: [\n            {\n              label: this.item.name,\n              script: `\n              let id = this.item.flags.wfrp4e.fromEffect;\n              let effect = this.actor.appliedEffects.find(e => e.id === id);\n              this.script.message(\"${repaired_message}\");\n              await effect.item.delete();\n            `,\n              trigger: \"deleteEffect\"\n            }\n          ]\n        }\n      \n      }\n  ]\n};\n\nawait this.actor.createEmbeddedDocuments(\"Item\", [extendedTestData], {fromEffect: this.effect.id});\n","zi8Z3NlwVj3IfgAW":"if (this.item.system.quantity.value)\n{\n\tthis.item.system.reduceQuantity();\n\tlet actor = Array.from(game.user.targets)[0]?.actor || this.actor;\n\tactor.applyEffect({effectData : [this.item.effects.contents[3].convertToApplied()]})\n}\nelse\n{\n\tthis.script.notification(\"None left!\", \"error\")\n}","ziG9H5Kdb7xC3dFE":"return !args.skill?.name.includes(game.i18n.localize(\"NAME.Art\"));","zk44dFEGkylB7kW6":"        let modifier; let target = args.data.targets[0]\n        if (target.actor.details.size.value == \"tiny\")\n            modifier = 30\n        if (target.actor.details.size.value == \"ltl\")\n            modifier = 20\n        if (target.actor.details.size.value == \"sml\")\n            modifier = 10\n\t\n        args.fields.modifier += (modifier || 0); // Offset size modifier ","zkc1gIPLj0VoAONT":"let AP = args.actor.status.armour;\n\nAP[\"head\"].value += 2;\nAP[\"rArm\"].value += 2;\nAP[\"lArm\"].value += 2;\nAP[\"body\"].value += 2;\nAP[\"lLeg\"].value += 2;\nAP[\"rLeg\"].value += 2;","zphxI8VSWbNQCMBy":"args.size = \"lrg\"","zqShIJnrRReGgP94":"let {added, removed} = this.effect.getFlag(\"wfrp4e\", \"propertiesChanged\");\n\nfor(let property of (added || []))\n{\n    let hasValue = game.wfrp4e.config.propertyHasValue[property];\n    if (!args.item.system.qualities.value.find(i => i.name == property))\n    {\n        args.item.system.qualities.value.push({name : property, value : (hasValue ? 2 : null)})\n    }\n}\n\nfor(let property of (removed || []))\n{\n    args.item.system.flaws.value = args.item.system.flaws.value.filter(i => i.name != property)\n}","zsiV6XEHlCNGLLPl":"return args.skill?.name ==  game.i18n.localize(\"NAME.SetTrap\");","zsoTVkHe4nHY1M52":"this.script.message(await this.actor.applyBasicDamage(10 + parseInt(this.effect.sourceTest.result.SL), {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP}))","ztIkD5Zt6ko9D4Ca":"args.fields.modifier -= 10","zxG5KbliWE9xWNQD":"this.script.message(\"Automatically passes any \" + this.script.label);\nargs.abort = true;","zzk2uRSFjFHB5kjw":"\n   let roll = Math.ceil(CONFIG.Dice.randomUniform() * 10)\n   if (args.test.isFumble && roll == 1 && !args.test.result.misfire)\n  {\n          args.test.result.misfire = game.i18n.localize(\"Misfire\") + \" (Rolled 1)\"\n          args.test.result.misfireDamage = eval(parseInt(args.test.result.roll.toString().split('').pop()) + args.test.item.Damage)\n  }\n  else if (args.test.isFumble && roll != 1)\n      args.test.result.other.push(\"Misfire Roll: \" + roll)"});
    });

}

let fields$2 = foundry.data.fields;

class VehicleRoleModel extends BaseItemModel {
    static LOCALIZATION_PREFIXES = ["WH.Models.vehicleRole"];

    static metadata = Object.freeze(foundry.utils.mergeObject(super.metadata, {
        isVehicle: true
    }, {inplace: false}));

    static defineSchema() {
        let schema = super.defineSchema();
        schema.test = new fields$2.StringField();
        return schema;
    }

    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
            ["test", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.test.label",
                type: "text",
                config: {
                    keyPath: "system.test"
                }
            }]
        ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of VehicleRoleModel
     *
     * @final
     * @returns {boolean}
     */
    get isVehicleRole() {
        return true;
    }

    isVitalFor(test) {
        return test.system.roles.vital.split(",").map(i => i.trim()).includes(this.parent.name);
    }

    async roll(actor, options={})
    {
        let skill = await this.chooseSkill(actor);
        if (skill)
        {
          let test = await actor.setupSkill(skill.name, foundry.utils.mergeObject({appendTitle : ` - ${this.parent.name}`, roleId : this.parent.id}, options));
          test.roll();
        }
    }

    async chooseSkill(actor)
    {
        let choices = this.test.split(",").map(i => i.trim());
        let skills = [];
        for(let choice of choices)
        {
            skills = skills.concat(actor.itemTypes.skill.filter(s => s.name.includes(choice)));
        }
        
        if (skills.length == 0)
        {
            return ui.notifications.error(game.i18n.localize("VEHICLE.NoSkill"))
        }

        if (choices.length == 1)
        {
            return skills[0];
        }

        else 
        {
            return (await ItemDialog.create(skills, 1, game.i18n.localize("VEHICLE.ChooseSkill")))[0];
        }
    }
}

let fields$1 = foundry.data.fields;

class VehicleTestModel extends BaseItemModel {
    static LOCALIZATION_PREFIXES = ["WH.Models.vehicleTest"];

    static metadata = Object.freeze(foundry.utils.mergeObject(super.metadata, {
        isVehicle: true
    }, {inplace: false}));

    static defineSchema() {
        let schema = super.defineSchema();
        schema.roles = new fields$1.SchemaField({
            value : new fields$1.StringField(),
            vital : new fields$1.StringField()
        });
        schema.handling = new fields$1.BooleanField({});
        return schema;
    }

    static get compendiumBrowserFilters() {
        return new Map([
            ...Array.from(super.compendiumBrowserFilters),
            ["handling", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.handling.label",
                type: "boolean",
                config: {
                    keyPath: "system.handling"
                }
            }],
            ["rolesValue", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.roles.value.label",
                type: "text",
                config: {
                    multiple: true,
                    keyPath: "system.roles.value"
                }
            }],
            ["rolesVital", {
                label: this.LOCALIZATION_PREFIXES + ".FIELDS.roles.vital.label",
                type: "text",
                config: {
                    keyPath: "system.roles.vital"
                }
            }]
        ]);
    }

    /**
     * Used to identify an Item as one being a child or instance of VehicleTestModel
     *
     * @final
     * @returns {boolean}
     */
    get isVehicleTest() {
        return true;
    }

    roll()
    {
        let crewTest = new CrewTest(this.parent);
        crewTest.renderChatPrompt();
    }
}

class CargoDialog extends HandlebarsApplicationMixin(ApplicationV2)
{
  static DEFAULT_OPTIONS = {
    tag: "form",
    classes: ["warhammer", "standard-form"],
    window: {
      title: "Manage Trade"
    },
    form: {
      submitOnChange: false,
      closeOnSubmit: true,
      handler: this._onSubmit
    }

  }


  /* -------------------------------------------- */
  constructor(cargoData, options) {
    super(options);
    this.cargoData = cargoData;
  }

  /** @override */
  static PARTS = {
    form: {
      template: "systems/wfrp4e/templates/apps/trade/trade-cargo.hbs",
      scrollable: [""]
    },
    footer: {
      template: "templates/generic/form-footer.hbs"
    }
  };

  async _prepareContext(options) {
    let context = await super._prepareContext(options);
    context.cargoData = this.cargoData;
    context.buttons = [{ type: "submit", label: "TRADE.CreateCargoItem" }];
    return context
  }


  /* -------------------------------------------- */
  static async _onSubmit(ev, form, formData) {
    this.cargoData.system.encumbrance.value = parseInt(formData.object.size);
    let cargoDiscount = parseInt(formData.object.modifier || 0);
    this.cargoData.system.price.gc = this.cargoData.system.encumbrance.value / (this.cargoData.system.tradeType == "river" ? 10 : 1) * parseFloat(this.cargoData.system.unitPrice.value) * (1.0 + (cargoDiscount / 100));

    let message =
      `${game.i18n.format("TRADE.MerchantDataBuy", { cargoName: this.cargoData.name, cargoSize: this.cargoData.system.encumbrance.value, cargoPrice: this.cargoData.system.price.gc })}<br>
      <p><a class='chat-button' data-action='buyCargo'>${game.i18n.localize("TRADE.BuyCargo")}</a></p>`;

    let messageData = game.wfrp4e.utility.chatDataSetup(message);
    messageData["flags.wfrp4e.cargoData"] = this.cargoData;
    ChatMessage.create(messageData);
  }

  /* -------------------------------------------- */
  async _onRender(options) {
    await super._onRender(options);

    this.priceElement = this.element.querySelector("[name='price']");

    // Update from quantity!
    this.sizeElement = this.element.querySelector('[name="size"]');
    this.sizeElement.addEventListener("change", event => {
      let discount = Number(this.modifierElement.value);
      let newSize = Number(event.target.value);
      let newPrice = newSize / 10 * this.cargoData.system.unitPrice.value * (1.0 + (discount / 100));
      this.priceElement.value = newPrice;
    });
    // Update from discount!
    this.modifierElement = this.element.querySelector('[name="modifier"]');
    this.modifierElement.addEventListener("change", event => {
      let discount = Number(event.target.value);
      let newSize = Number(this.sizeElement.value);
      let newPrice = newSize / 10 * this.cargoData.system.unitPrice.value * (1.0 + (discount / 100));
      this.priceElement.value = newPrice;
    });
  }

}

class TradeDialog extends HandlebarsApplicationMixin(ApplicationV2)
{
  static DEFAULT_OPTIONS = {
    tag: "form",
    classes : ["warhammer"],
    window: {
      title: "Trade",
      contentClasses: ["standard-form"]
    },
    form: {
      submitOnChange: false,
      closeOnSubmit : true,
      handler : this._onSubmit
    }

  }

    /** @override */
    static PARTS = {
      form: {
        template: "systems/wfrp4e/templates/apps/trade/trade-dialog.hbs",
        scrollable: [""],
        classes : ["standard-form"]
      },
      footer: {
        template: "templates/generic/form-footer.hbs"
      }
    };


    constructor(tradeData, options)
    {
      super(options);

      if (game.modules.get("foundryvtt-simple-calendar")?.active) 
      {
          this.season = SimpleCalendar.api.getCurrentSeason();
          if (this.season == "fall")
          {
              this.season = "autumn";
          }
      }
      this.tradeType = tradeData.tradeType;
      this.cargo = tradeData.cargo;
      this.gazetteer = tradeData.gazetteer;
    }

    async _prepareContext(options) {
      let context = await super._prepareContext(options);
      context.cargo = this.cargoData;
      context.gazetteer = this.gazetteer;
      context.settlements = this.gazetteer.map(i => i.name);
      context.tradeType = this.tradeType;
      context.seasons = game.wfrp4e.trade.seasons;
      context.buttons = [{ type: "submit", label: "Submit", icon: "fa-solid fa-save" }];
      return context
    }

    static _onSubmit(ev, form, formData)
    {
      let settlementData = {};
  
      let settlementIndex = formData.object.settlement;
      let season = formData.object.season;
      if (Number.isNumeric(settlementIndex))
      {
        let selected = this.gazetteer[Number(settlementIndex)];
        settlementData = {
          wealth : Number(selected.w),
          size : Number(selected.size),
          trade : selected.isTrade,
          produces : selected.produces,
          season
        };
      }
      settlementData.name = formData.object.name;
      settlementData.wealth = Number(formData.object.wealth);
      settlementData.size = Number(formData.object.size);
      settlementData.trade = formData.object.trade;
      settlementData.season = season;
      settlementData.produces = formData.object.produces.split(",").map(i=> {
        i = i.trim();
        return warhammer.utility.findKey(i.split("(")[0].trim(), game.wfrp4e.trade.tradeData[this.tradeType].cargoTypes)
      }).filter(i => !!i);

      settlementData.surplus = this.encodeSurplusDemand(formData.object.surplus);
      settlementData.demand = this.encodeSurplusDemand(formData.object.demand);

      this.options.resolve(settlementData);
      return settlementData;
    }

  
    /* -------------------------------------------- */
    async _onRender(options) {
      super._onRender(options);

  
      this.settlement = this.element.querySelector("[name='settlement']");
      this.settlement.addEventListener("change", ev => {
        if (ev.target.value != "")
        {
          let index = ev.target.selectedIndex - 1;
          this.wealth.value = this.gazetteer[index].w;
          this.size.value = this.gazetteer[index].size;
          this.produces.value = this.gazetteer[index].produces.map(i => this.formatCargoType(i) || i).join(", ");
          if (this.surplus)
          {
            this.surplus.value = this.formatSurplusDemand(this.gazetteer[index].surplus);
          }
          if (this.demand)
          {
            this.demand.value = this.formatSurplusDemand(this.gazetteer[index].demand);
          }
          this.trade.checked = this.gazetteer[index].isTrade;
          this.name.value = this.gazetteer[index].name;
        }
      });
  
      this.wealth = this.element.querySelector("[name='wealth']");
      this.wealth.addEventListener("change", this._clearSettlement.bind(this));
  
      this.size = this.element.querySelector("[name='size']");
      this.size.addEventListener("change", this._clearSettlement.bind(this));
  
      this.produces = this.element.querySelector("[name='produces']");
      this.produces.addEventListener("change", this._clearSettlement.bind(this));
  
      this.surplus = this.element.querySelector("[name='surplus']");
      this.surplus?.addEventListener("change", this._clearSettlement.bind(this));

      this.demand = this.element.querySelector("[name='demand']");
      this.demand?.addEventListener("change", this._clearSettlement.bind(this));

      this.trade = this.element.querySelector("[name='trade']");
      this.trade.addEventListener("change", this._clearSettlement.bind(this));
  
      this.name = this.element.querySelector("[name='name']");
      this.name.addEventListener("change", this._clearSettlement.bind(this));

    }

    _clearSettlement()
    {
      this.settlement.value = "";
    }


    // This is all really gross but I don't have time to clean it up right now
    formatCargoType(string)
    {
      if (string.includes("("))
      {
        let parenthesesValue = string.split("(")[1].split(")")[0];
        let name = string.split("(")[0].trim(0);
        return `${game.wfrp4e.trade.tradeData[this.tradeType].cargoTypes[name]} (${parenthesesValue})`;
      }
      else 
      {
        return game.wfrp4e.trade.tradeData[this.tradeType].cargoTypes[string]
      }
    }

    formatSurplusDemand(values)
    {
      if (values?.length)
      {
        let strings = [];
        for(let text of values)
        {
          let [name, value]= text.split("+").map(i => i.trim());
          name = this.formatCargoType(name);
          
          strings.push(`${name} +${value}`);
          
        }
        return strings.join(", ");
      }
      else return "";
    }

    encodeSurplusDemand(string)
    {
      if (!string)
      {
        return [];
      }
      let encoded = [];
      let strings = string.split(",").map(i => i.trim());

      for(let string of strings)
      {
        let value = string.split("+")[1].trim();
        let key;
        if (string.includes("("))
        {
          key = string.split("(")[0].trim();
          string.split("(")[1].split(")")[0];

          key = warhammer.utility.findKey(key, game.wfrp4e.trade.tradeData[this.tradeType].cargoTypes);

        }
        else 
        {
          key = warhammer.utility.findKey(string.split("+")[0].trim(), game.wfrp4e.trade.tradeData[this.tradeType].cargoTypes);
        }

        encoded.push(`${key} +${value}`);
      }
      return encoded;

    }
  }

let d100 = () => Math.ceil(CONFIG.Dice.randomUniform() * 100);
let d20 = () => Math.ceil(CONFIG.Dice.randomUniform() * 20);
let d10 = () => Math.ceil(CONFIG.Dice.randomUniform() * 10);
class TradeGenerator
{

    constructor(settlement, tradeType)
    {
        this.settlement = settlement;
        this.tradeData = null;
        this.rolls = [];
        this.tradeType = tradeType;
    }

    async attemptTrade()
    {
        if (this.tradeType == "river")
        {
            return this.attemptRiverTrade();
        }
        else if (this.tradeType == "maritime")
        {
            return this.attemptMaritimeTrade();
        }
    }

    //#region River Trading

    async attemptRiverTrade()
    {
        let cargoAvailable = this.rollForCargoRiver();

        if (cargoAvailable)
        {
            let merchant = await this.createMerchant();
            let item = await this.createCargoItem(cargoAvailable, merchant);
            this.createCargoMessage(item, this.tradeData);
        }
        else 
        {
            ChatMessage.create({content : game.i18n.format("TRADE.NoCargoFound", {town : this.settlement.name, rolls: this.rolls.join(", ")})});
        }
    }

    rollForCargoRiver()
    {
        let available = [];

        let target = (this.settlement.wealth + this.settlement.size) * 10;
        let roll = d100();
        this.rolls.push(roll);
        if (roll <= target)
        {
            // If has product list, choose from product
            if (this.settlement.produces.length)
            {
                this.randomCargo(this.settlement.produces);
            }
            else // If no product list, choose randomly
            {
                this.randomCargo();
            }
            available = available.concat(this.settlement.produces);
        }

        // if (this.settlement.produces.length)
        // {
        //     let roll = d100();
        //     this.rolls.push(roll);
        //     if (roll <= target)
        //     {
        //         available = available.concat(this.settlement.produces);
        //     }
        // }
        if (this.settlement.trade)
        {
            let roll = d100();
            this.rolls.push(roll);
            if (roll <= target)
            {
                available = available.concat(this.randomCargo());
            }
        }
        return available[Math.floor(CONFIG.Dice.randomUniform() * available.length)];
    }

    
    attemptSell(cargo)
    {
        let message;
        let price = Number(cargo.system.price.gc);
    
        let targetScore = (this.settlement.size * 10) + ((this.settlement.trade) ? 30 : 0);
        let score1 = d100();
        let score2 = d100();
    
        if (this.settlement.produces.includes(cargo.system.cargoType.value))
        {
            message = "This good is already produced at <b>" + this.settlement.name + "</b>";
        }
        else if (cargo.system.origin.value == this.settlement.name)
        {
            message = "You cannot sell cargo in the same settlement you bought it from.";
        }
        else if (score1 <= targetScore) 
        {
          let sellPrice = price + (price * game.wfrp4e.trade.tradeData[this.tradeType].wealthAvailability[this.settlement.wealth].offered);
          sellPrice += sellPrice * ((d20() - 10) / 100);
          sellPrice = Math.round(sellPrice);
          message = "A merchant is willing to buy the whole cargo for " + `<a class="money-drag" data-amt="${sellPrice}g"><strong>${sellPrice} GC</strong></a>`;
        } 
        else if (score2 <= targetScore) 
        {
          let sellPrice = price / 2 + (price / 2 * game.wfrp4e.trade.tradeData[this.tradeType].wealthAvailability[this.settlement.wealth].offered);
          sellPrice += sellPrice * ((d20() - 10) / 100);
          sellPrice = Math.round(sellPrice);
          message = "A merchant is willing to buy half the size of the cargo for " + `<a class="money-drag" data-amt="${sellPrice}g"><strong>${sellPrice} GC</strong</a>`;
        } 
        else 
        {
          message = "You cannot find anyone who wants to buy this cargo in <b>" + this.settlement.name + "</b>";
        }
        return ChatMessage.create(game.wfrp4e.utility.chatDataSetup(message));
    }

    async createCargoItem(cargoKey, merchant)
    {
        let size = this._computeSize();
        let {price, quality} = await this._computePriceQuality(cargoKey);

        let name = "TRADE." + cargoKey.capitalize(); // Auto-build tanslation key
        this.tradeData = { name: game.i18n.localize(name), town: this.settlement.name.capitalize(), merchant};

        let itemData = { system: foundry.utils.duplicate(game.model.Item.cargo) };
        itemData.name = game.i18n.format("TRADE.CargoItemName", { name: this.tradeData.name });
        itemData.system.cargoType.value = cargoKey;
        itemData.system.origin.value = this.tradeData.town;
        itemData.system.unitPrice.value = price;
        itemData.system.price.gc = price * (size / 10);
        itemData.system.quality.value = quality;
        itemData.system.description.value = `<p>${game.i18n.format("TRADE.CargoDescr", { name : merchant.name, town: this.tradeData.town })}</p>`;
        itemData.system.encumbrance.value = size;
        itemData.system.tradeType = this.tradeType;

        return itemData
    }


    //#endregion

    //#region Maritime Trading
    async attemptMaritimeTrade()
    {
        let cargoAvailable = this.getMaritimeCargo();
        let items = await this.createMaritimeCargoItems(cargoAvailable);
        if (items.length == 0)
        {
            ChatMessage.create({content : game.i18n.format("TRADE.NoCargoFound", {town : this.settlement.name, rolls: this.rolls.join(", ")})});
        }
    }

    getMaritimeCargo()
    {
        let available = [];

        for (let good of this.settlement.produces)
        {
            available.push(good);
        }

        for (let good of this.settlement.surplus)
        {
            available.push(good.split("+")[0].trim());
        }

        if (this.settlement.trade)
        {
            available.push(this.randomCargo());
        }
        return available;
    }

    attemptSellMaritime(cargo, far)
    {
        let message;
        let rollMessage;
        let price = Number(cargo.system.price.gc);

        let produces = this.settlement.produces.includes(cargo.system.cargoType.value);
        let surplus = Number(this.settlement.surplus.find(i => i.split("+")[0].trim() == cargo.system.cargoType.value)?.split("+")[1]) || 0;
        let demand = Number(this.settlement.demand.find(i => i.split("+")[0].trim() == cargo.system.cargoType.value)?.split("+")[1]) || 0;

        let buyer = false;
        let halfBuyer = false;
        let quarterBuyer = this.settlement.trade || demand;

        let target;
        let roll;
        let halfRoll;

        // Case 1 - Settlement does not produce and has no surplus
        if (!produces && !surplus )
        {
            target = (this.settlement.size + demand) * 10 + (this.settlement.trade ? 30 : 0);

            roll = d100();
            halfRoll = d100();
            if (roll <= target)
            {
                buyer = true;
            }
            else if (halfRoll <= target)
            {
                halfBuyer = true;
            }
        }

        // Case 2 - Settlement produces but has no surplus
        else if (produces && !surplus)
        {

            target = this.settlement.size * (far ? 10 : 5);
            roll = d100();
            if (roll <= target)
            {
                buyer = true;
            }
        }

        // Case 3 - Settlement has surplus
        else if (surplus)
        {
            target = this.settlement.size * 5;
            roll = d100();
            if (roll <= target)
            {
                buyer = true;
            }
        }


        if (cargo.system.origin.value == this.settlement.name)
        {
            message = "<p>You cannot sell cargo in the same settlement you bought it from.</p>";
            buyer = false;
            halfBuyer = false;
            quarterBuyer = false;
        }
        else 
        {
            if (halfRoll) 
            {
                rollMessage = `Rolled ${roll}, ${halfRoll} vs ${target}`;
            }
            else 
            {
                rollMessage = `Rolled ${roll} vs ${target}`;
            }

            if (buyer) 
            {
                message = `<p>A buyer was found at <strong>${this.settlement.name}</strong>`;
            }
            else if (halfBuyer)
            {
                message = `<p>A buyer was found at <strong>${this.settlement.name}</strong>, but they are only willing to buy half the cargo.`;
            }
            else
            {
                message = `<p>No buyer was found at <strong>${this.settlement.name}</strong>`;
                if (quarterBuyer)
                {
                    message += `, but it's possible to offload to a merchant who will buy at a quarter price.</p>`;
                }
            }

            message += ` (${rollMessage})</p>`;
        }

        if (buyer || halfBuyer || quarterBuyer)
        {
            let offerPrices = game.wfrp4e.trade.tradeData[this.tradeType].offerPrice;
            let offerIndex = Math.clamp(this.settlement.wealth + this.settlement.size + demand, 0, offerPrices.length - 1);
            let offerPriceMultiplier = offerPrices[offerIndex];

            let offerPrice = price + (price * offerPriceMultiplier);
            // Add slight variation
            offerPrice += Math.round(offerPrice * ((d20() - 10) / 100));

            if (!buyer && halfBuyer)
            {
                offerPrice /= 2;
            }

            else if (!buyer && quarterBuyer)
            {
                offerPrice /= 4;
            }

            message += "<p>They are willing to pay " + `<a class="money-drag" data-amt="${offerPrice}g"><strong>${offerPrice} GC</strong></a></p>`;

            //TODO:  Add haggling (136)
        }

        return ChatMessage.create(game.wfrp4e.utility.chatDataSetup(message));
    }

    
    async createMaritimeCargoItems(cargoKeys)
    {
        let items = [];

        for (let key of cargoKeys)
        {    
            let sizeRoll = d10();

            this.rolls.push(sizeRoll);

            if (sizeRoll != 1)
            {
                let merchant = await this.createMerchant();
                let surplus = Number(this.settlement.surplus.find(i => i.split("+")[0].trim() == key)?.split("+")[1]) || 0;

                let size = (sizeRoll * 10) * (this.settlement.wealth + this.settlement.size + surplus);
                let {price, quality} = await this._computePriceQuality(key);
                
                let name = "TRADE." + key.capitalize(); // Auto-build tanslation key
                this.tradeData = { name: game.i18n.localize(name), town: this.settlement.name.capitalize(), merchant};
                
                let itemData = { system: foundry.utils.duplicate(game.model.Item.cargo) };
                itemData.name = game.i18n.format("TRADE.CargoItemName", { name: this.tradeData.name });
                itemData.system.cargoType.value = key;
                itemData.system.origin.value = this.tradeData.town;
                itemData.system.unitPrice.value = price;
                itemData.system.price.gc = price * size;
                itemData.system.quality.value = quality;
                itemData.system.description.value = `<p>${game.i18n.format("TRADE.CargoDescr", { name : merchant.name, town: this.tradeData.town })}</p>`;
                itemData.system.encumbrance.value = size;
                itemData.system.tradeType = this.tradeType;
                items.push(itemData);

                await this.createCargoMessage(itemData, this.tradeData);
            } 
        }
        return items;
    }

    
    //#endregion

   
    randomCargo(products=[]) {

        // If supplied with products, randomnly select index
        if (products.length)
        {
            return products[Math.floor(CONFIG.Dice.randomUniform() * products.length)]
        }


        // Otherwise
        let roll = d100();
        let cargoTable = game.wfrp4e.trade.tradeData[this.tradeType].cargoTable[this.settlement.season];
        for (let key in cargoTable) 
        {
            let cargoData = cargoTable[key];
            if (roll <= cargoData.max && roll >= cargoData.min) 
            {
                return key;
            }
        }
    }

    async rollMerchantTest(merchant)
    {
        let roll = d100();

        let SL =  Math.floor(merchant.haggle / 10) - Math.floor(roll / 10);

        if (roll <= merchant.haggle)
        {
            SL += merchant.dealmaker;
        }
        merchant.test = {roll, SL};
    }

    static async buyCargo(cargoData) {
        let actor = game.user.character;
        if (!actor) return ui.notifications.error("Please assign a character.");
    
        // Perform the total amount of money to pay and get the available amount from the PCs
        let toPay;
        if (cargoData.system.price.gc.toString().includes("."))
        {
          let fraction = Number("." + cargoData.system.price.gc.toString().split(".")[1]);
          toPay = Math.trunc(cargoData.system.price.gc) + game.i18n.localize("MARKET.Abbrev.GC");
    
          let ss = 20 * fraction;
          if (ss.toString().includes("."))
          {
            fraction = Number("." + ss.toString().split(".")[1]);
            toPay += `${Math.trunc(ss)}${game.i18n.localize("MARKET.Abbrev.SS")}`;
            let bp = Math.round(12 * fraction);
            if (bp)
              toPay += `${bp}${game.i18n.localize("MARKET.Abbrev.BP")}`;
          }
          else toPay += `${ss}${game.i18n.localize("MARKET.Abbrev.SS")}`;
        }
        else toPay = `${cargoData.system.price.gc}${game.i18n.localize("MARKET.Abbrev.GC")}`;
    
    
        // Check if enough money or not
        let newMoneyInventory = game.wfrp4e.market.payCommand(toPay, actor);
        if (newMoneyInventory) {
          actor.updateEmbeddedDocuments("Item", newMoneyInventory);
    
          cargoData.type = "cargo";
          cargoData.img = "modules/wfrp4e-dotr/assets/icons/cargo.png";
          let itemCargo = await Item.create(cargoData, { temporary: true });
          itemCargo.postItem(1);
        }
      }

    async createMerchant()
    {
        let species = (await game.wfrp4e.tables.rollTable("species")).species;
        let gender = (await new Roll("1d2").roll({allowInteractive : false})).total == 1 ? "male" : "female";
        let name = game.wfrp4e.names.generateName({ species, gender });
        let rolls = [d10(), d10(), d10()];
        let haggle = rolls.reduce((sum, val) => sum + val, 0) + 40;
        let dealmaker = rolls.filter(i => i == 10).length >= 2;

        let merchant = {species, gender, name, haggle, dealmaker};
        await this.rollMerchantTest(merchant);
        return merchant;
    }

    createCargoMessage(itemData, tradeData)
    {
        if (!tradeData)
        {
            throw Error("No successful trade data provided")
        }
        let message =
        `<p style="text-align:center"><strong>${game.i18n.format("TRADE.CargoTitle", tradeData)}</strong></p>
          <b>Enc</b>: ${itemData.system.encumbrance.value}<br>
          <b>${game.i18n.localize("TRADE.Price")}</b>: ${itemData.system.price.gc} ${game.i18n.localize("MARKET.Abbrev.GC")}<br>
          <b>${game.i18n.localize("TRADE.Quality")}</b>: ${game.i18n.localize("TRADE." + itemData.system.quality.value.capitalize())}<br><br>
          ${game.i18n.format("TRADE.MerchantData", tradeData.merchant)}<br>`;

          if (tradeData.merchant.test)
          {
           message += `<p>${game.i18n.format("TRADE.MerchantTest", tradeData.merchant.test)}</p>`;
          }

          message += `<p><a class="chat-button" data-action="manageTrade">${game.i18n.localize("TRADE.ManageCargo")}</a></p>`;
          let messageData = game.wfrp4e.utility.chatDataSetup(message, "gmroll");
          messageData["flags.wfrp4e.cargoData"] = itemData;
          return ChatMessage.create(messageData);
    }


    _computeSize()
    {
        let baseSize = d100();

        if (this.settlement.trade)
        {
            let tens = Math.floor(baseSize / 10);
            let unit = baseSize % 10;
            let reversed = unit * 10 + tens;
            if (reversed > baseSize)
            {
                baseSize = reversed;
            }
        }

        let roundedSize = Math.ceil(baseSize / 10) * 10;
        return roundedSize * (this.settlement.wealth + this.settlement.size);
    }

    async _computePriceQuality(cargoKey)
    {
        let variation = (Math.ceil(CONFIG.Dice.randomUniform() * 20) - 10) / 100;
        let cargoTable = game.wfrp4e.trade.tradeData[this.tradeType].cargoTable[this.settlement.season];
        let cargoData = cargoTable[cargoKey];

        let price = (await new Roll(cargoData.price.toString()).roll({allowInteractive : false})).total;
        let randomize = Math.round(price * variation);
        price += randomize;// random +/-10% variation to simulate market variance

        let quality = "average";

        // Get the price in case of brandy
        if (this.tradeType != "maritime" && (cargoKey == "wine" || cargoKey == "brandy")) {

            let wineBrandyPrice = game.wfrp4e.trade.tradeData[this.tradeType].wineBrandyPrice;
            let score = Math.ceil(CONFIG.Dice.randomUniform() * 10);
            for (let i = 0; i < wineBrandyPrice.length; i++) 
            {
                if (score <= wineBrandyPrice[i].score) 
                {
                    price = wineBrandyPrice[i].price;
                    quality = wineBrandyPrice[i].quality;
                    break; 
                }
            }
        }

        return {price, quality};
    }
}

class TradeManager
{
    gazetteers = {
        maritime : [],
        river : []
    }

    tradeData = {
        maritime : {},
        river : {}
    }

    seasons = {
        "spring": "Spring",
        "summer": "Summer",
        "autumn": "Autumn",
        "winter": "Winter"
    }

    get cargoTypes() {
        return foundry.utils.mergeObject(this.tradeData.maritime.cargoTypes || {}, this.tradeData.river.cargoTypes || {});
    }

    addGazzetteerFile(path, type)
    {
        fetch(path).then(r => r.json()).then(async records => {
            this.gazetteers[type] = this.gazetteers[type].concat(records);
        });
    }

    addTradeData(data, type)
    {
        foundry.utils.mergeObject(this.tradeData[type], data);
    }

    async getTradeType()
    {
        let buttons = [];

        if (this.tradeData.river?.dotr)
        {
            buttons.push({
                action : "river",
                label : game.i18n.localize("TRADE.River"),
                callback : () => "river"
            });
        }
        if (this.tradeData.maritime.soc)
        {
            buttons.push({
                action : "maritime",
                label : game.i18n.localize("TRADE.Maritime"),
                callback : () => "maritime"
            });
        }

        if (foundry.utils.isEmpty(buttons))
        {
            ui.notifications.error("No Trade Data found, see console for details");
            throw new Error("No Trade Data found: The Death on the Reik module is required for River trading, and the Sea of Claws module is required for Maritime trading. These modules provide the base data needed to compute trading results. ")
        }

        else if (buttons.length == 1)
        {
            return buttons[0]?.action;
        }

        return foundry.applications.api.DialogV2.wait({
            window : {title : "Trade"},
            content : "Choose the type of Trade",
            buttons
        })
    }

    async attemptBuy()
    {
        let type = await this.getTradeType();
        
        if (!this.gazetteers[type]?.length)
        {
            return ui.notifications.error("TRADE.ErrorNoGazetteer");
        }

        let settlementData = await new Promise(resolve => {
            new TradeDialog({cargo : null, gazetteer: this.gazetteers[type], tradeType : type}, {resolve}).render(true);
        });

        let tradeGenerator = new TradeGenerator(settlementData, type);

        tradeGenerator.attemptTrade();
        
    }  
    
    
    async attemptSell(cargo)
    {
        if (!cargo.system.cargoType.value)
        {
            return ui.notifications.error("This cargo does not have a Cargo Type defined")
        }


        let type = cargo.system.tradeType;
        
        if (!this.gazetteers[type]?.length)
        {
            return ui.notifications.error("TRADE.ErrorNoGazetteer");
        }

        let settlementData = await new Promise(resolve => {
            new TradeDialog({cargo : null, gazetteer: this.gazetteers[type], tradeType : type}, {resolve}).render(true);
        });

        let tradeGenerator = new TradeGenerator(settlementData, type);
        
        if (type == "river")
        {
            tradeGenerator.attemptSell(cargo);
        }
        else if (type == "maritime")
        {
            let far = await foundry.applications.api.DialogV2.confirm({window : {title : "Distance"}, content : `Is ${settlementData.name} over 100 miles from ${cargo.system.origin.value}?`});
            tradeGenerator.attemptSellMaritime(cargo, far);
        }
    }    


    // ************************* Old Code ************************************

    static async buyCargo(event) {

        let msgId = $(event.currentTarget).parents(".message").attr("data-message-id");
        let message = game.messages.get(msgId);

        let cargoData = message.getFlag("wfrp4e", "cargoData");
        let actor = game.user.character;
        if (!actor) return ui.notifications.error("Please assign a character.");
    
        // Perform the total amount of money to pay and get the available amount from the PCs
        let toPay;
        if (cargoData.system.price.gc.toString().includes("."))
        {
          let fraction = Number("." + cargoData.system.price.gc.toString().split(".")[1]);
          toPay = Math.trunc(cargoData.system.price.gc) + game.i18n.localize("MARKET.Abbrev.GC");
    
          let ss = 20 * fraction;
          if (ss.toString().includes("."))
          {
            fraction = Number("." + ss.toString().split(".")[1]);
            toPay += `${Math.trunc(ss)}${game.i18n.localize("MARKET.Abbrev.SS")}`;
            let bp = Math.round(12 * fraction);
            if (bp)
              toPay += `${bp}${game.i18n.localize("MARKET.Abbrev.BP")}`;
          }
          else toPay += `${ss}${game.i18n.localize("MARKET.Abbrev.SS")}`;
        }
        else toPay = `${cargoData.system.price.gc}${game.i18n.localize("MARKET.Abbrev.GC")}`;
    
    
        // Check if enough money or not
        let newMoneyInventory = game.wfrp4e.market.payCommand(toPay, actor);
        if (newMoneyInventory) 
        {
          actor.updateEmbeddedDocuments("Item", newMoneyInventory);
    
          cargoData.type = "cargo";
          cargoData.img = "modules/wfrp4e-dotr/assets/icons/cargo.png";
          let itemCargo = await Item.create(cargoData, { temporary: true });
          itemCargo.postItem(1);
        }
      }

      static async manageTrade(cargoData) 
      {
        cargoData.modifier = 0;
        new CargoDialog(cargoData).render(true);
      }
   
}

let fields = foundry.data.fields;

class WFRP4eAvoidTestModel extends AvoidTestModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.difficulty  = new fields.StringField({});
        schema.characteristic  = new fields.StringField({});
        schema.skill  = new fields.StringField({});

        return schema;
    }
}

class WFRP4eActiveEffectModel extends WarhammerActiveEffectModel {

    static defineSchema() {
        let schema = super.defineSchema();
        schema.condition = new fields.SchemaField({
            value : new fields.NumberField({nullable : true}),
            numbered : new fields.BooleanField({initial: false}),
            trigger : new fields.StringField()
        });

        return schema;
    }

    async expandData(htmlOptions) {
        htmlOptions.async = true;
        const data = {description : {value : await foundry.applications.ux.TextEditor.implementation.enrichHTML(this.parent.description, htmlOptions)}};
        data.description.value = data.description.value || "";
        return data;
    }

    static _avoidTestModel = WFRP4eAvoidTestModel;
}

class WFRPTestMessageModel extends WarhammerTestMessageModel 
{
    get test() 
    {
        return TestWFRP.recreate(this.testData)   
    }

    static get actions() 
    { 
        return foundry.utils.mergeObject(super.actions, {
            overcastClick : this.onOvercastClick,
            overcastReset : this.onOvercastReset,
            moveVortex : this.onMoveVortex,
            applyCriticalDeflection : this.onApplyCriticalDeflection,
        });
    }

    get canEdit()
    {
      let msg = this.parent;
      return msg.isOwner || msg.isAuthor;
    }

    async getHeaderToken()
    {
      let token = this.test.actor.getActiveTokens()[0]?.document || this.test.actor.prototypeToken;

      let path = token.hidden ? "systems/wfrp4e/tokens/unknown.png" : token.texture.src;

      if (foundry.helpers.media.VideoHelper.hasVideoExtension(path))
      {
        path = await game.video.createThumbnail(path, { width: 50, height: 50 }).then(img => chatOptions.flags.img = img);
      }

      return path;
      
    }

    async onRender(html)
    {
      let header = html.querySelector(".message-header");

      let div = document.createElement("div");
      div.classList.add("message-token");
      let image = document.createElement("img");
      image.src = await this.getHeaderToken();
      image.style.zIndex = 1;
      div.appendChild(image);
      if (this.test.actor.isMounted && this.test.actor.mount)
      {
        div.classList.add("mounted");
        let mount = document.createElement("img");
        mount.src = this.test.actor.mount.getActiveTokens()[0]?.document?.texture.src;
        mount.style.zIndex = 0;
        div.appendChild(mount);
    }
      header.insertBefore(div, header.firstChild);

      warhammer.utility.replacePopoutTokens(html);
    }

  static async onPlaceAreaEffect(event, target) {
    if (!this.canEdit)
      return ui.notifications.error("CHAT.EditError")
    
    let effectUuid = target.dataset.uuid;
    let test = this.test;
    let radius;
    if (test?.result.overcast?.usage.target)
    {
      radius = test.result.overcast.usage.target.current;

      if (test.spell)
      {
        radius /= 2; // Spells define their diameter, not radius
      }
    }

    let effect = await fromUuid(effectUuid);
    let effectData = effect.convertToApplied(test);
    if (!(await effect.runPreApplyScript({effectData})))
    {
        return;
    }
    let template = await AreaTemplate.fromEffect(effectUuid, this.parent.id, radius, foundry.utils.diffObject(effectData, effect.convertToApplied(test)));
    await template.drawPreview(event);
  }
  
      // Respond to overcast button clicks
  static onOvercastClick(event, target) {
    event.preventDefault();
    let msg = this.parent;
    if (!this.canEdit)
      return ui.notifications.error("CHAT.EditError")

    let test = msg.system.test;
    let overcastChoice = target.dataset.overcast;
    // Set overcast and rerender card
    test._overcast(overcastChoice);
    
    //@HOUSE
    if (game.settings.get("wfrp4e", "homebrew").mooOvercasting)
    {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");
    }
    //@/HOUSE

    
  }

  // Button to reset the overcasts
  static onOvercastReset(event) {
    event.preventDefault();
    this.parent;
    if (!this.canEdit)
      return ui.notifications.error("CHAT.EditError")

    let test = this.test;
    // Reset overcast and rerender card
    test._overcastReset();
        
    //@HOUSE
    if (game.settings.get("wfrp4e", "homebrew").mooOvercasting)
    {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");
    }
    //@/HOUSE
  }

  static onMoveVortex(event)
  {
    this.parent;
    if (!this.canEdit)
      return ui.notifications.error("CHAT.EditError")
    let test = this.test;
    test.moveVortex();
  }

    static async onApplyCriticalDeflection(ev)
    {
        const targetTokens = game.user.targets.length > 0 ? game.user.targets.map(t => t.actor) : this.test.targets;
        const targetIntersection = targetTokens.filter(t => this.test.targets.includes(t));
        const hitLoc = this.test.hitloc.result;
        const type = ev.target.innerText;

        for (const target of targetIntersection) {
            if (target.isOwner) {
                let armour = target.physicalNonDamagedArmourAtLocation(hitLoc);
                if (armour.length)
                {
                    let chosen = await ItemDialog.create(armour, 1, {text : "Choose Armour to damage", title : `${type} - ${target.name}`});
                    if (chosen[0])
                    {
                        chosen[0].system.damageItem(1, [hitLoc]);
                        ChatMessage.create({content: `<p>1 Damage applied to @UUID[${chosen[0].uuid}]{${chosen[0].name}} (${type})</p>`, speaker : ChatMessage.getSpeaker({actor : target})});
                    }
                }
                else
                {
                    ui.notifications.error("ErrorNoArmourToDamage", {localize: true});
                }
            }
        }
    }

}

foundry.data.fields;

class GenericAspectModel extends BaseItemModel
{
    static placement = "talents"
    static label = "Aspect"
    static plural = "Aspects"

    /**
     * Used to identify an Item as one being a child or instance of GenericAspectModel
     *
     * @final
     * @returns {boolean}
     */
    get isAspect() {
        return true;
    }

    get tags() {
        return super.tags.add("aspect");
    }

    get placement() 
    {
        return this.constructor.placement;
    }

    get label() 
    {
        return this.constructor.label;
    }
    
    get pluralLabel() 
    {
        return this.constructor.plural;
    }

    /**
     * Whether the Aspect can be "used" or not. Usage may – depending on Aspect – mean Rolling, initiating a Test,
     * or doing something else entirely.
     *
     * @returns {boolean}
     * @public
     */
    get usable()
    {
        return false;
    }

    /**
     * Method which serves as a public wrapper for _performUsage() method, while also calling a pre-use and post-use hook.
     *
     * @param {{}} options
     *
     * @returns {Promise<TestWFRP|Roll|null>}
     * @public
     */
    async use(options = {})
    {
        if (!this.usable)
            return null;

        if (!Hooks.call('wfrp4e:beforeUseAspect', this.parent, options))
            return null;

        const result = await this._performUsage(options);

        Hooks.callAll('wfrp4e:afterUseAspect', this.parent, result, options);

        return result;
    }

    /**
     * Method which should implement entire logic behind "using an Aspect" such as rolling or initiating a Test.
     *
     * Should return either object of TestWFRP class, object of Roll class or null if Aspect is not rollable.
     *
     * @returns {Promise<TestWFRP|Roll|null>}
     * @protected
     */
    async _performUsage({} = {})
    {
        return null;
    }

    get listHeader()
    {
        return null;
    }

    get listContent() 
    {
        return null;
    }
}

class BaseWFRP4eItemSheet extends WarhammerItemSheetV2
{

  static type=""

  static hasConditionEffects = false

  static DEFAULT_OPTIONS = {
    classes: ["wfrp4e"],
    defaultTab : "description",
    position : {
      width: 500,
      height: 700,
    },
    window : {
      controls : [
        {
          icon : 'fa-solid fa-comment',
          label : "Post to Chat",
          action : "postToChat"
        },
      ]
    },
    actions : {
      postToChat : function() {this.item.postItem();},
      configureProperties : this._onConfigureProperties,
      clickCondition : {buttons : [0, 2], handler : this._onClickCondition}
    }
  }
 
  async _prepareContext(options)
  {
    let context = await super._prepareContext(options);
    context.physical = this.item.system.tags.has("physical");
    context.hide = {
      quantity : false,
      encumbrance : false,
      price : false,
      availability : false,
      category : true
    };
    return context;
  }

  async _onFirstRender(context, options)
  {
      await super._onFirstRender(context, options);

      this.setTheme();
  }

  setTheme(theme = game.settings.get("wfrp4e", "theme"))
  {
    if (!theme.item.enabled)
    {
      this.element.classList.add("no-theme");
      this.element.classList.remove("classic-font");
    }
    else 
    {
      this.element.classList.remove("no-theme");

      if (theme.item.font == "classic")
      {
        this.element.classList.add("classic-font");
      }
      else
      {
        this.element.classList.remove("classic-font");
      }
    }
  }

  static TABS = {
    description: {
      id: "description",
      group: "primary",
      label: "Description",
    },
    details: {
      id: "details",
      group: "primary",
      label: "Details",
    },
    effects: {
      id: "effects",
      group: "primary",
      label: "Effects",
    }
  }

  //#region Effects


  _getConditionData() {
    try {
      let conditions = foundry.utils.duplicate(game.wfrp4e.config.statusEffects).filter(i => !["fear", "grappling", "engaged"].includes(i.id)).map(e => new ActiveEffectWFRP4e(e));
      let currentConditions = this.item.effects.filter(e => e.isCondition);
      delete conditions.splice(conditions.length - 1, 1);

      for (let condition of conditions) {
        let owned = currentConditions.find(e => e.conditionId == condition.conditionId);
        if (owned) {
          condition.existing = true;
          condition.system.condition.value = owned.conditionValue;
        }
        else if (condition.isNumberedCondition) {
          condition.system.condition.value = 0;
        }
      }
      return conditions;
    }
    catch (e)
    {
      ui.notifications.error("Error Adding Condition Data: " + e);
    }
  }

  _prepareEffectsContext(context) 
  {
      super._prepareEffectsContext(context);
      if (this.constructor.hasConditionEffects)
      {
        context.effects.conditions = this._getConditionData();
      }
      return context;
  }

  //#endregion

  _getContextMenuOptions()
  { 
    let getParent = this._getParent.bind(this);
    return [
      {
        name: "Edit",
        icon: '<i class="fas fa-edit"></i>',
        condition: li => !!li.dataset.uuid || getParent(li, "[data-uuid]"),
        callback: async li => {
          let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
          const document = await fromUuid(uuid);
          document.sheet.render(true);
        }
      },
      {
        name: "Remove",
        icon: '<i class="fas fa-times"></i>',
        condition: li => !!li.dataset.uuid || getParent(li, "[data-uuid]"),
        callback: async li => 
        {
          let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
          const document = await fromUuid(uuid);
          document.delete();
        }
      },
      {
        name: "Duplicate",
        icon: '<i class="fa-solid fa-copy"></i>',
        condition: li => !!li.dataset.uuid || getParent(li, "[data-uuid]"),
        callback: async li => 
        {
            let uuid = li.dataset.uuid || getParent(li, "[data-uuid]").dataset.uuid;
            const document = await fromUuid(uuid);
            this.item.createEmbeddedDocuments("ActiveEffect", [document.toObject()]);
        }
      },
    ];
  }

  async _handleEnrichment() {
    let enrichment = {};
    enrichment["system.description.value"] = await foundry.applications.ux.TextEditor.implementation.enrichHTML(this.item.system.description.value, { async: true, secrets: this.item.isOwner, relativeTo: this.item });
    enrichment["system.gmdescription.value"] = await foundry.applications.ux.TextEditor.implementation.enrichHTML(this.item.system.gmdescription.value, { async: true, secrets: this.item.isOwner, relativeTo: this.item });

    return foundry.utils.expandObject(enrichment)
  }


  //#region Action Handlers

  static _onConfigureProperties()
  {
    new ItemProperties(this.document).render(true);
  }

  
  static _onClickCondition(ev) {
    let conditionKey = this._getParent(ev.target, ".condition")?.dataset.key;
    let existing = this.item.hasCondition(conditionKey);
    
    if (!existing?.isNumberedCondition && ev.button == 0)
    {
      this.item.removeCondition(conditionKey);
    }
    
    ev.button == 0 ? this.item.addCondition(conditionKey) : this.item.removeCondition(conditionKey); 
  }

    //#endregion
  /** @inheritDoc */
  _attachFrameListeners() {
    super._attachFrameListeners();
    GenericActions.addEventListeners(this.element, this);
  }

}

class TalentSheet extends BaseWFRP4eItemSheet
{
  static type="talent"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class MutationSheet extends BaseWFRP4eItemSheet
{
  static type="mutation"
  static hasConditionEffects = true;

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class CriticalSheet extends BaseWFRP4eItemSheet
{
  static type="critical"
  static hasConditionEffects = true;

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }

}

class InjurySheet extends BaseWFRP4eItemSheet
{
  static type="injury"
  static hasConditionEffects = true;

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class AmmunitionSheet extends BaseWFRP4eItemSheet
{
  static type="ammunition"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class SkillSheet extends BaseWFRP4eItemSheet
{
  static type="skill"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class ArmourSheet extends BaseWFRP4eItemSheet
{
  static type="armour"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class CareerSheet extends BaseWFRP4eItemSheet
{
  static type="career"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
    actions : {
      copySkills : this._onCopySkills
    }
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }

  async _prepareContext(options)
  {
    let context = await super._prepareContext(options);
    context.physical = this.item.system.tags.has("physical");
    return context;
  }


  _focus = null;

  _addEventListeners()
  {
    super._addEventListeners();
    this.element.querySelectorAll(".skill,.talent,.trapping").forEach(e => {
      e.style.width = e.value.length + 2 + "ch";
    });

    this.element.querySelectorAll(".empty").forEach(e => {
      e.addEventListener("keydown", e => {
      if (e.key === "Tab")
      {
        let parent = this._getParent(e.target, ".form-group");
        this.focus = parent.dataset.group;
      }
      else 
      {
        this.focus = null;
      }
    });});

    if (this.focus)
    {
      this.element.querySelector(`.${this.focus} .empty`)?.focus();
    }
  }

  static _onCopySkills(ev, target)
  {
    navigator.clipboard.writeText(this.item.system.skills.join(", "));
    ui.notifications.info("Copied skills to clipboard");
  }

}

class CargoSheet extends BaseWFRP4eItemSheet
{
  static type="cargo"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }

  async _prepareContext(options)
  {
    let context = await super._prepareContext(options);
    context.cargoTypes = game.wfrp4e.trade.tradeData[this.item.system.tradeType]?.cargoTypes || {};
    context.hide.quantity = true;
    return context;
  }
}

class ContainerSheet extends BaseWFRP4eItemSheet
{
  static type="container"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class ExtendedTestSheet extends BaseWFRP4eItemSheet
{
  static type="extendedTest"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class DiseaseSheet extends BaseWFRP4eItemSheet
{
  static type="disease"
  static hasConditionEffects = true;

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }

  async _prepareContext(options)
  {
    let context = await super._prepareContext(options);
    context.units = {"minutes" : game.i18n.localize("Minutes"), "hours" : game.i18n.localize("Hours"), "days": game.i18n.localize("Days")};
    return context;
  }
}

class MoneySheet extends BaseWFRP4eItemSheet
{
  static type="money"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }

  async _prepareContext(options)
  {
    let context = await super._prepareContext(options);
    context.hide.availability = true;
    context.hide.price = true;
    return context;
  }
}

class PrayerSheet extends BaseWFRP4eItemSheet
{
  static type="prayer"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class PsychologySheet extends BaseWFRP4eItemSheet
{
  static type="injury"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }

  static TABS = {
    description: {
      id: "description",
      group: "primary",
      label: "Description",
    },
    effects: {
      id: "effects",
      group: "primary",
      label: "Effects",
    }
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class SpellSheet extends BaseWFRP4eItemSheet
{
  static type="spell"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }

  async _prepareContext(options)
  {
    let context = await super._prepareContext(options);
      if (game.wfrp4e.config.magicLores[this.document.system.lore.value]) 
      {
        context.loreValue = game.wfrp4e.config.magicLores[this.document.system.lore.value];
      }
      else 
      {
        context.loreValue = this.document.system.lore.value;
      }
    return context;
  }

  
  _addEventListeners()
  {    
    super._addEventListeners();
    this.element.querySelector("[data-action='editLore']")?.addEventListener("change", this.constructor._onEditLore.bind(this));
  }

  static _onEditLore(ev)
  {
    let lore = ev.target.value;
    let key = warhammer.utility.findKey(lore, game.wfrp4e.config.magicLores);
    if (key)
    {
      this.document.update({"system.lore.value" : key});
    }
    else 
    {
      this.document.update({"system.lore.value" : lore});
    }
  }

}

class TraitSheet extends BaseWFRP4eItemSheet
{
  static type="trait"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }

  async _prepareContext(options)
  {
    let context = await super._prepareContext(options);
    context.hide.category = false;
    return context;
  }
}

class TrappingSheet extends BaseWFRP4eItemSheet
{
  static type="trapping"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class VehicleModSheet extends BaseWFRP4eItemSheet
{
  static type="vehicleMod"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class VehicleRoleSheet extends BaseWFRP4eItemSheet
{
  static type="vehicleRole"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class VehicleTestSheet extends BaseWFRP4eItemSheet
{
  static type="vehicleTest"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }
}

class WeaponSheet extends BaseWFRP4eItemSheet
{
  static type="weapon"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }

  async _prepareContext(options)
  {
    let context = await super._prepareContext(options);
    return context;
  }
}

class TemplateModel extends BaseItemModel
{
  static LOCALIZATION_PREFIXES = ["WH.Models.template"];
  static defineSchema() 
  {
        let fields = foundry.data.fields;
        let schema = super.defineSchema();

        schema.alterName = new fields.SchemaField({
          pre : new fields.StringField(),
          post : new fields.StringField()
        });

        schema.characteristics = new fields.SchemaField({
          ws: new fields.NumberField(),
          bs: new fields.NumberField(),
          s: new fields.NumberField(),
          t: new fields.NumberField(),
          i: new fields.NumberField(),
          ag: new fields.NumberField(),
          dex: new fields.NumberField(),
          int: new fields.NumberField(),
          wp: new fields.NumberField(),
          fel: new fields.NumberField(),
        });

        schema.skills = ListModel.createListModel(new fields.SchemaField({
          name : new fields.StringField({}),
          advances : new fields.NumberField({}),
          group : new fields.NumberField({nullable : true}),
          specialisations : new fields.NumberField({nullable : true, required: false, blank: true})
        }));

        schema.talents = ListModel.createListModel(new fields.SchemaField({
          name : new fields.StringField({}),
          advances : new fields.NumberField({}),
          group : new fields.NumberField({nullable : true, required: false, blank: true})
        }));

        schema.lores = ListModel.createListModel(new fields.SchemaField({
          name : new fields.StringField({}),
          number : new fields.NumberField()
        }));

        schema.traits = new fields.EmbeddedDataField(DiffReferenceListModel);

        schema.trappings = new fields.EmbeddedDataField(ChoiceModel);
    
        return schema;
    }

  static get compendiumBrowserFilters() {
    return new Map([
      ...Array.from(super.compendiumBrowserFilters),
      ["prefix", {
        label: this.LOCALIZATION_PREFIXES + ".FIELDS.alterName.pre.label",
        type: "text",
        config: {
          keyPath: "system.alterName.pre"
        }
      }],
      ["suffix", {
        label: this.LOCALIZATION_PREFIXES + ".FIELDS.alterName.post.label",
        type: "text",
        config: {
          keyPath: "system.alterName.post"
        }
      }],
      ["characteristics", {
        label: "Characteristics",
        type: "set",
        config: {
          choices: game.wfrp4e.config.characteristics,
          keyPath: "system.characteristics",
          valueGetter: (data) => {
            return Object.entries(data.system.characteristics).reduce((acc, [k, v]) => {
              if (v) acc.push(k);
              return acc;
            }, [])
          },
          multiple: true
        }
      }],
      ["skills", {
        label: "Skills",
        type: "text",
        config: {
          keyPath: "system.skills",
          valueGetter: (data) => {
            return Object.entries(data.system.skills.list).reduce((acc, [k, v]) => {
              if (v.advances) acc.push(v.name);
              return acc;
            }, [])
          },
          multiple: true
        }
      }],
      ["talents", {
        label: "Talents",
        type: "text",
        config: {
          keyPath: "system.talents",
          valueGetter: (data) => {
            return Object.entries(data.system.talents.list).reduce((acc, [k, v]) => {
              acc.push(v.name);
              return acc;
            }, [])
          },
          multiple: true
        }
      }],
      ["lores", {
        label: "Lore",
        type: "set",
        config: {
          blank: "*",
          choices: game.wfrp4e.config.magicLores,
          keyPath: "system.lores",
          valueGetter: (data) => {
            const loreList = Object.entries(game.wfrp4e.config.magicLores);
            const templateLores = Object.entries(data.system.lores.list)
              .reduce((acc, [k, v]) => {
                if (v.name === '*') {
                  loreList.forEach(([k, n]) => acc.add(k));
                  acc.add('');

                  return acc;
                }

                const lore = loreList.find(([k, n]) => n === v.name);
                if (lore)
                  acc.add(lore[0]);

                return acc;
              }, new Set());

            return Array.from(templateLores);
          },
          multiple: true
        }
      }],
    ]);
  }

    /**
     * Used to identify an Item as one being a child or instance of TemplateModel
     *
     * @final
     * @returns {boolean}
     */
    get isTemplate() {
      return true;
  }

  async _onCreate(data, options, user)
  {
    await super._onCreate(data, options, user);
    if (this.parent.isEmbedded && game.user.id == user)
    {
      this.apply(this.parent.actor);
    }
  }

  async _onDelete(options, user)
  {
    await super._onDelete(options, user);
    if (this.parent.isEmbedded && game.user.id == user)
    {
      this.undo(this.parent.actor);
    }
  }

  async apply(actor)
  {
    let items = [];
    let update = {};
    update.name = `${this.alterName.pre} ${actor.name} ${this.alterName.post}`.trim();

    // If skills/talents specify groups, offer the choice for any of the same group
    let skillChoices = items.concat(await this._handleGroups(this.skills.list));
    let talentChoices = items.concat(await this._handleGroups(this.talents.list));


    // If a skill has 2 or more "specialisations" that means pick 2 specialisations
    if (skillChoices.find(i => i.specialisations > 1))
    {
      // Load all the skills, find all those with the same base name as the skill choice
      let allSkills = await warhammer.utility.findAllItems("skill", "Loading Skills");
      let initialSkillChoices = foundry.utils.deepClone(skillChoices);
      for (let skill of initialSkillChoices)
        {
          if (skill.specialisations > 1)
          {
            let specialisations = allSkills.filter(i => i.baseName == skill.name);
            let chosen = await ItemDialog.create(specialisations, skill.specialisations, {text : `${skill.name} (any ${skill.specialisations}) +${skill.advances}`, title : this.parent.name});
            // Choose between those specialisations and add them back into the skill choices
            skillChoices = skillChoices.concat(chosen.map(i => {
              return {
                name : i.name,
                advances : skill.advances
              }
            }));
          }
        }
    }

    // Delete all skill choices with specialisations (as the chosen specialisations were added above)
    skillChoices = skillChoices.filter(i => !i.specialisations || i.specialisations <= 1);

    // Turn all skills into Items with the appropriate advances
    let skills = await Promise.all(skillChoices.map(async s => {
      let foundSkill = await game.wfrp4e.utility.findSkill(s.name);
      if (foundSkill)
      {
        foundSkill = foundSkill.toObject();
        foundSkill.system.advances.value = s.advances;
        return foundSkill
      }
    }));

    // Advanced talents just mean more talent items, so fill a second array with any extra talents 
    let advancedTalents = [];
    
    // Turn all talents into Items
    let talents = await Promise.all(talentChoices.map(async t => {
      let foundTalent = await game.wfrp4e.utility.findTalent(t.name);
      if (foundTalent)
      {
        foundTalent = foundTalent.toObject();
        if (t.advances > 1)
        {
          advancedTalents = advancedTalents.concat(Array(t.advances - 1).fill(foundTalent));
        }
        return foundTalent
      }
    }));
    talents = talents.concat(advancedTalents);

    if (this.lores.list.length)
    {
      let spells = (await warhammer.utility.findAllItems("spell", "Loading Spells", true, ["system.lore.value"])).sort((a, b) => a.name > b.name ? 1 : -1);
      for(let lore of this.lores.list)
      {
        if (lore.name == "*")
        {
          lore.name = (await ItemDialog.create(ItemDialog.objectToArray(game.wfrp4e.config.magicLores), 1, {title : this.parent.name, text : "Select a Lore"}))?.[0]?.name;
        }
        let filtered = spells.filter(s => {
          let spellLore = game.wfrp4e.config.magicLores[s.system.lore.value] || s.system.lore.value;
          return lore.name == spellLore;
        });

        items = items.concat((await ItemDialog.create(filtered, lore.number, {title : this.parent.name, text : `Select ${lore.number}`, indexed : true})) || []);
      }
    }

    items = items.concat(skills.filter(i => i));
    items = items.concat(talents.filter(i => i));
    items = items.concat(await this.traits.awaitDocuments());
    items = items.concat(await this.trappings.promptDecision());

    await actor.update(update);
    await actor.createEmbeddedDocuments("Item", items, {fromTemplate : this.parent.id});
  }

  async undo(actor)
  {
    await actor.deleteEmbeddedDocuments("Item", actor.items.contents.filter(i => i.getFlag("wfrp4e", "fromTemplate") == this.parent.id).map(i => i.id));
    if (this.alterName.pre && actor.name.substr(0, this.alterName.pre.length) == this.alterName.pre)
    {
      await actor.update({name : actor.name.substr(this.alterName.pre.length + 1)});
    }

    if (this.alterName.post && actor.name.substr(actor.name.length - this.alterName.post.length, this.alterName.post.length) == this.alterName.post)
    {
      await actor.update({name : actor.name.substr(0, actor.name.length - (this.alterName.post.length + 1))});
    }
  }

  getCreatedItems()
  {
    if (this.parent.isEmbedded)
    {
      return this.parent.actor.items.contents.filter(i => i.getFlag("wfrp4e", "fromTemplate") == this.parent.id)
    }
    else return [];
  }

  async _handleGroups(list)
  {
    let items = list.filter(i => !i.group);

    // Take all groups in the list and sort them into an object with the keys as the groups
    let groups = Object.fromEntries(list.map(i => i.group).filter(i => i != null).map(i => [i, []]));

    for(let group in groups)
    {
      groups[group] = list.filter(i => i.group == group);
    }

    for(let choices of Object.values(groups))
    {
      if (choices.length > 1)
      {
        let choice = await ItemDialog.create(choices, 1, {title : this.parent.name});
        items = items.concat(choice);
      }
    }

    return items;
  }
}

class TemplateSheet extends BaseWFRP4eItemSheet
{
  static type="template"

  static DEFAULT_OPTIONS = {
    classes: [this.type],
    actions : {
      editDiff: this._onEditDiff,
      openSheet : this._onOpenSheet
    }
  }
  
  static PARTS = {
    header : {scrollable: [""], template : 'systems/wfrp4e/templates/sheets/item/item-header.hbs', classes: ["sheet-header"] },
    tabs: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/item-tabs.hbs' },
    description: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-description.hbs' },
    details: { scrollable: [""], template: `systems/wfrp4e/templates/sheets/item/types/${this.type}.hbs` },
    effects: { scrollable: [""], template: 'systems/wfrp4e/templates/sheets/item/tabs/item-effects.hbs' },
  }

  async _prepareContext(options)
  {
    let context = await super._prepareContext(options);
    context.traits = await this.document.system.traits.awaitDocuments();

    context.loreIcons = {
      [game.i18n.localize("WFRP4E.MagicLores.petty")] : "modules/wfrp4e-core/icons/spells/petty.png",
      [game.i18n.localize("WFRP4E.MagicLores.beasts")] : "modules/wfrp4e-core/icons/spells/beasts.png",
      [game.i18n.localize("WFRP4E.MagicLores.death")] : "modules/wfrp4e-core/icons/spells/death.png",
      [game.i18n.localize("WFRP4E.MagicLores.fire")] : "modules/wfrp4e-core/icons/spells/fire.png",
      [game.i18n.localize("WFRP4E.MagicLores.heavens")] : "modules/wfrp4e-core/icons/spells/heavens.png",
      [game.i18n.localize("WFRP4E.MagicLores.metal")] : "modules/wfrp4e-core/icons/spells/metal.png",
      [game.i18n.localize("WFRP4E.MagicLores.life")] : "modules/wfrp4e-core/icons/spells/life.png",
      [game.i18n.localize("WFRP4E.MagicLores.light")] : "modules/wfrp4e-core/icons/spells/light.png",
      [game.i18n.localize("WFRP4E.MagicLores.shadow")] : "modules/wfrp4e-core/icons/spells/shadow.png",
      [game.i18n.localize("WFRP4E.MagicLores.hedgecraft")] : "modules/wfrp4e-core/icons/spells/hedgecraft.png",
      [game.i18n.localize("WFRP4E.MagicLores.witchcraft")] : "modules/wfrp4e-core/icons/spells/witchcraft.png",
      [game.i18n.localize("WFRP4E.MagicLores.daemonology")] : "modules/wfrp4e-core/icons/spells/daemonology.png",
      [game.i18n.localize("WFRP4E.MagicLores.necromancy")] : "modules/wfrp4e-core/icons/spells/necromancy.png",
      [game.i18n.localize("WFRP4E.MagicLores.undivided")] : "modules/wfrp4e-core/icons/spells/undivided.png",
      [game.i18n.localize("WFRP4E.MagicLores.nurgle")] : "modules/wfrp4e-core/icons/spells/nurgle.png",
      [game.i18n.localize("WFRP4E.MagicLores.slaanesh")] : "modules/wfrp4e-core/icons/spells/slaanesh.png",
      [game.i18n.localize("WFRP4E.MagicLores.tzeentch")] : "modules/wfrp4e-core/icons/spells/tzeentch.png"
    };

    return context;
  }

  async  _onDropItem(data, ev)
  {
    let item = await Item.implementation.fromDropData(data);
    if (item.type == "skill")
    {
      this.document.update(this.document.system.skills.add({name : item.name}));
    }
    else if (item.type == "talent")
    {
        this.document.update(this.document.system.talents.add({name : item.name}));
    }
    else if (item.type == "trait")
    {
      this.document.update(this.document.system.traits.add(item));
    }
  }

  static async _onOpenSheet(event)
  {
    let index = this._getIndex(event);
    let document = await this.document.system.traits.list[index].document;
    document.sheet.render(true, {editable : false});
  }

  static async _onEditDiff(event)
  {
      let index = this._getIndex(event);
      let doc = this.document.system.traits.list[index];
      let diffedDocument = await doc.document;
      let update ={};
      update.diff = await WarhammerDiffEditor.wait(doc.diff, {document : diffedDocument.originalDocument});
      
      if (update.diff.name)
      {
          update.name = update.diff.name;
      }
      else 
      {
          update.name = diffedDocument.originalDocument.name;
      }
      this.document.update(this.document.system.traits.edit(index, update));
  }
}

class ChatMessageWFRP extends WarhammerChatMessage 
{

    async _preCreate(data, options, user)
    {
        await super._preCreate(data, options, user);
        this.updateSource({"content" : this.constructor.addEffectButtons(data.content)});
    }

    async _onCreate(document, options, user)
    {
        await super._onCreate(document, options, user);
        let test = this.system.test;
        if (test)
        {
          test.postTestGM(document);
        }
    }

    static get actions() 
    { 
        return foundry.utils.mergeObject({
          settlementSize : this._onClickSettlementSize,
          crewTest : this._onCrewTest,
          postProperty : this._onPostProperty,
          placeTemplate : this._onPlaceTemplate,
          conditionScript : this._onConditionScript,
          applyCondition : this._onApplyCondition,
          manageTrade : this._manageTrade,
          buyCargo : this._buyCargo,
          travel : this._onTravelClick
        }, super.actions);
    }

    /** @inheritDoc */
    async renderHTML(options)
    {
        let html = await super.renderHTML(options);
        if (this.getFlag("wfrp4e", "socketResult"))
        {
          html.classList.add("socket-result");
          html.style.display = "none";
        }
        GenericActions.addEventListeners(html, this);
        return html;
    }


    static _manageTrade(ev)
    {
      TradeManager.manageTrade(foundry.utils.deepClone(this.getFlag("wfrp4e", "cargoData")));
    }

    static _buyCargo(ev, target)
    {
      TradeGenerator.buyCargo(this.getFlag("wfrp4e", "cargoData"));
    }

    static _onApplyCondition(ev, target)
    {
      let actors = targetsWithFallback();

      if (canvas.scene) 
      { 
        game.canvas.tokens.setTargets([]);
      }
      
      if (actors.length == 0)
      {
        actors.push(game.user.character);
        ui.notifications.notify(`${game.i18n.format("EFFECT.Applied", {name: game.wfrp4e.config.conditions[target.dataset.cond]})} ${game.user.character.name}`);
      }
  
      actors.forEach(a => {
        a.addCondition(target.dataset.cond);
      });
    } 

    static async _onConditionScript(ev, target)
    {
      let condkey = target.dataset.condId;
      let combatantId = target.dataset.combatantId;
      let combatant = game.combat.combatants.get(combatantId);

      let conditionResult;
  
      let effect = combatant.actor.hasCondition(condkey);
  
      if (combatant.actor.isOwner && effect)
        conditionResult = await effect.scripts[0].execute({suppressMessage : true});
      else
        return ui.notifications.error(game.i18n.localize("CONDITION.ApplyError"))
  
      if (game.user.isGM)
        this.update(conditionResult);
      else
        await SocketHandlers.call("updateMessage", { id: this.id, updateData: conditionResult }, "GM");
    }

    static _onPostProperty(ev, target)
    {
      game.wfrp4e.utility.postProperty(target.text);
    }

    static _onPlaceTemplate(ev, target)
    {
      let actorId = target.dataset.actorId;
      let itemId = target.dataset.itemId;
      let type = target.dataset.type;

      AreaTemplate.fromString(target.text, actorId, itemId, this.id, type=="diameter").drawPreview(ev);
    }

    static _onClickSettlementSize(ev, target)
    {
      let options = {
        name: target.dataset.name,
        settlement: target.dataset.settlement.toLowerCase(),
        rarity: target.dataset.rarity.toLowerCase(),
        modifier: 0
      };
      MarketWFRP4e.testForAvailability(options);
    }

    static async _onCrewTest(ev, target)
    {
      let crewTestUuid = this.getFlag("wfrp4e", "crewTestData")?.uuid;
      let crewTest = await fromUuid(crewTestUuid);
      let roleUuid = target.dataset.uuid;
      let vital = target.dataset.vital == "true";
      let role = await fromUuid(roleUuid);
      if (role)
      {
        let chosenActor = await role.actor.system.passengers.choose(role.name);
        if (chosenActor)
        {
          role.system.roll(chosenActor, {appendTitle : ` - ${vital ? game.i18n.localize("CHAT.CrewTestVital") : game.i18n.localize("CHAT.CrewTest")}`, skipTargets : true, crewTest, crewTestMessage : this.id, roleVital : vital});
        }
      }
    }
    
  // If content includes "@Condition[...]" add a button to apply that effect
  // Optionally provide a set of conditions
  static addEffectButtons(content, conditions = [])
  {
    content = content?.toString();
    // Don't add buttons if already added, or from posted items
    if (content?.includes("apply-conditions") || content?.includes("post-item"))
    {
      return content;
    }

    let regex = /@Condition\[(.+?)\]/gm;

    let matches = Array.from(content.matchAll(regex));

    conditions = conditions.concat(matches.map(m => m[1].toLowerCase())).filter(i => game.wfrp4e.config.conditions[i]);

    // Dedup
    conditions = conditions.filter((c, i) => conditions.indexOf(c) == i);

    if (conditions.length)
    {
      let html = `<div class="apply-conditions">`;
      conditions.forEach(c => 
          html += `<a class="chat-button" data-action="applyCondition" data-cond="${c}">${game.i18n.format("CHAT.ApplyCondition", {condition: game.wfrp4e.config.conditions[c]})}</a>`
      );

      html += `</div>`;
      content += html;
    }
    return content
  }
}

function calendar()
{
return {
    name: "Imperial Calendar",
    description: "The calendar as defined by the Empire, dating from the year of Sigmar's coronation.",
    years: {
      yearZero: 2512,
      firstWeekday: 1,
    },
    months: {
      values: [
        {name: "Hexenstag", ordinal: 1, days: 1, intercalary : true},
        {name: "Nachhexen",  ordinal: 1, days: 32},
        {name: "Jahrdrung",  ordinal: 2, days: 33},
        {name: "Mitterfruhl", days: 1, ordinal : 3, intercalary : true},
        {name: "Plugzeit",  ordinal: 3, days: 33},
        {name: "Sigmarzeit",  ordinal: 4, days: 33},
        {name: "Sommerzeit",  ordinal: 5, days: 33},
        {name: "Sonnstill", days: 1, ordinal : 6, intercalary : true},
        {name: "Vorgeheim",  ordinal: 6, days: 33},
        {name: "Geheimnistag", days: 1, ordinal : 7, intercalary : true},
        {name: "Nachgeheim",  ordinal: 7, days: 32},
        {name: "Erntezeit",  ordinal: 8, days: 33},
        {name: "Mittherbst", days: 1, ordinal : 9, intercalary : true},
        {name: "Brauzeit",  ordinal: 9, days: 33},
        {name: "Kaldezeit",  ordinal: 10, days: 33},
        {name: "Ulriczeit",  ordinal: 11, days: 33},
        {name: "Mondstille", days: 1, ordinal : 12, intercalary : true},
        {name: "Vorhexen",  ordinal: 12, days: 33}
      ]
    },
    days: {
      values: [
        {name: "Wellentag", ordinal: 1},
        {name: "Aubentag", ordinal: 2},
        {name: "Marktag", ordinal: 3},
        {name: "Backertag", ordinal: 4},
        {name: "Bezahltag", ordinal: 5},
        {name: "Konigstag", ordinal: 6},
        {name: "Angestag", ordinal: 7},
        {name: "Festag", ordinal: 8, isRestDay: true}
      ],
      daysPerYear: 400,
      hoursPerDay: 24,
      minutesPerHour: 60,
      secondsPerMinute: 60
    },
    seasons: {
      values: [
        {name: "Spring", ordinal: 1, monthStart: 3, monthEnd: 5},
        {name: "Summer", ordinal: 2, monthStart: 6, monthEnd: 8},
        {name: "Fall", ordinal: 3, monthStart: 9, monthEnd: 11},
        {name: "Winter", ordinal: 4, monthStart: 12, monthEnd: 2}
      ]
    }
  };
}

class EndeavourJournalSheet extends foundry.applications.sheets.journal.JournalEntryPageProseMirrorSheet 
{
    static DEFAULT_OPTIONS = {
        actions : {
            configureScript : this._onConfigureScript,
            removeEffect : this._onRemoveEffect,
            openEffect : this._onOpenEffect,
            performEndeavour : this._onPerformEndeavour
        },
    }

    async _onRender(options)
    {
        await super._onRender(options);
        let html = await foundry.applications.handlebars.renderTemplate("systems/wfrp4e/templates/partials/endeavour.hbs", this.document.flags.wfrp4e?.endeavour || {});
        this.element.querySelector(".journal-header")?.insertAdjacentHTML("beforeend", html);

        // Kinda weird but I'm not sure a good way to check if it's being rendered in a journal or independently
        if (!this.element.querySelector(".journal-header"))
        {
            this.element.insertAdjacentHTML("beforeend", `<button type="button" data-action="performEndeavour">Perform Endeavour</button>`);
        }


        new foundry.applications.ux.DragDrop(
            {
                dropSelector: ".effect",
                permissions : {
                    drop: () => true
                },
                callbacks: {
                  drop: this._onDrop.bind(this)
                }
              }
        ).bind(this.element);
    }

    static async _onConfigureScript(ev, target)
    {
        new WarhammerScriptEditor(this.document, {path : "flags.wfrp4e.endeavour.script"}).render(true);
    }

    static async _onRemoveEffect(ev, target)
    {
        this.document.update({"flags.wfrp4e.endeavour.effect" : null});
    }

    static async _onOpenEffect()
    {
        ui.notifications.warn("Changes cannot be made to this Active Effect while within an Endeavour!");
        new ActiveEffect.implementation(this.document.flags.wfrp4e.endeavour.effect, {parent: this.document}).sheet.render({force: true, editable: false});
    }

    async _onDrop(ev)
    {
        let dragData = JSON.parse(ev.dataTransfer.getData("text/plain"));

        if (dragData.type == "ActiveEffect")
        {
            let effect = await ActiveEffect.implementation.fromDropData(dragData);
            if (effect)
            {
                this.document.update({"flags.wfrp4e.endeavour.effect" : effect.toObject()});
            }
        }
    }

    static async  _onPerformEndeavour(ev, target)
    {
        let data = this.document.getFlag("wfrp4e", "endeavour");

        // Get Actor, if no actor assigned, choose from owned actors
        let actor = game.user.character;
        if (!actor)
        {
            if (game.user.isGM)
            {
                actor = await DragDialog.create({title : this.document.name, text : "Provide an Actor to perform the Endeavour"});
            }
            else 
            {
                ui.notifications.warn("No Actor assigned, select from Owned Actors");

                let ownedActors = game.actors.filter(a => a.isOwner);
                actor = await ItemDialog(ownedActors, 1, {title: this.document.name, text: "Provide an Actor to perform the Endeavour"});
            }
        }


        // Script takes priority, if a script is defined, just run it and do nothing with the other data
        if (data.script)
        {
            let asyncFunction = Object.getPrototypeOf(async function () { }).constructor;
            try 
            {
                new asyncFunction(["actor, journal, test, effect"], data.script).bind(this)(actor, this.document, data.test, data.effect);
            }
            catch(e)
            {
                ui.notifications.error(e.message);
            }
        }

        // If a test is defined, roll it, and if an effect is defined, add to actor if the test succeeded
        else if (data.test?.characteristic || data.test?.skill)
        {
            let test;
            if (data.test.skill)
            {
                test = await actor.setupSkill(data.test.skill, {fields: {characteristic : data.test.characteristic}, appendTitle: ` - ${this.document.name}`});
            }
            else 
            {
                test = await actor.setupCharacteristic(data.test.characteristic, {appendTitle: ` - ${this.document.name}`});
            }
            await test.roll();

            if (test.succeeded && data.effect)
            {
                actor.createEmbeddedDocuments("ActiveEffect", [data.effect]);
            }
        }

        // If only an effect is defined, just add it to the actor that performs the endeavour
        else if (data.effect)
        {
            actor.createEmbeddedDocuments("ActiveEffect", [data.effect]);
        }
        else 
        {
            ui.notifications.error("Endeavour Test, Script, or Active Effect has not been defined.");
        }
    }
}

/* -------------------------------------------- */
/*  Foundry VTT Initialization                  */
/* -------------------------------------------- */

Hooks.once("init", function () {

  {
    CONFIG.debug.wfrp4e = true;
    warhammer.utility.log("Development Mode: Logs on");
  }

  // Register sheet application classes
  const {DocumentSheetConfig} = foundry.applications.apps;
  const actorClass = CONFIG.Actor.documentClass;
  const itemClass = CONFIG.Item.documentClass;
  DocumentSheetConfig.unregisterSheet(actorClass, "core", foundry.appv1.sheets.ActorSheet);
  DocumentSheetConfig.registerSheet(actorClass, "wfrp4e", ActorSheetWFRP4eCharacter, { types: ["character"], makeDefault: true, label : "SHEET.CharacterSheet" });
  DocumentSheetConfig.registerSheet(actorClass, "wfrp4e", ActorSheetWFRP4eNPC, { types: ["npc"], makeDefault: true, label : "SHEET.NPCSheet"});
  DocumentSheetConfig.registerSheet(actorClass, "wfrp4e", ActorSheetWFRP4eCreature, { types: ["creature"], makeDefault: true, label : "SHEET.CreatureSheet"});
  DocumentSheetConfig.registerSheet(actorClass, "wfrp4e", ActorSheetWFRP4eVehicle, { types: ["vehicle"], makeDefault: true, label : "SHEET.VehicleSheet" });
  
  DocumentSheetConfig.unregisterSheet(itemClass, "core", foundry.appv1.sheets.ItemSheet);
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", AmmunitionSheet, { types: ["ammunition"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", ArmourSheet, { types: ["armour"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", CareerSheet, { types: ["career"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", CargoSheet, { types: ["cargo"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", ContainerSheet, { types: ["container"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", CriticalSheet, { types: ["critical"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", DiseaseSheet, { types: ["disease"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", ExtendedTestSheet, { types: ["extendedTest"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", InjurySheet, { types: ["injury"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", MoneySheet, { types: ["money"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", MutationSheet, { types: ["mutation"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", PrayerSheet, { types: ["prayer"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", PsychologySheet, { types: ["psychology"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", SkillSheet, { types: ["skill"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", SpellSheet, { types: ["spell"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", TalentSheet, { types: ["talent"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", TraitSheet, { types: ["trait"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", TrappingSheet, { types: ["trapping"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", VehicleModSheet, { types: ["vehicleMod"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", VehicleRoleSheet, { types: ["vehicleRole"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", VehicleTestSheet, { types: ["vehicleTest"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", WeaponSheet, { types: ["weapon"], makeDefault: true });
  DocumentSheetConfig.registerSheet(itemClass, "wfrp4e", TemplateSheet, { types: ["template"], makeDefault: true });
  DocumentSheetConfig.registerSheet(ActiveEffect, "wfrp4e", WFRP4eActiveEffectConfig, {makeDefault :true});

  DocumentSheetConfig.registerSheet(CONFIG.JournalEntryPage.documentClass, "wfrp4e", EndeavourJournalSheet, {label : "Endeavour Journal Page"}); 

  CONFIG.Actor.dataModels["character"] = CharacterModel;
  CONFIG.Actor.dataModels["npc"] = NPCModel;
  CONFIG.Actor.dataModels["creature"] = CreatureModel;
  CONFIG.Actor.dataModels["vehicle"] = VehicleModel;

  CONFIG.Item.dataModels["ammunition"] = AmmunitionModel;
  CONFIG.Item.dataModels["armour"] = ArmourModel;
  CONFIG.Item.dataModels["career"] = CareerModel;
  CONFIG.Item.dataModels["container"] = ContainerModel;
  CONFIG.Item.dataModels["critical"] = CriticalModel;
  CONFIG.Item.dataModels["disease"] = DiseaseModel;
  CONFIG.Item.dataModels["injury"] = InjuryModel;
  CONFIG.Item.dataModels["money"] = MoneyModel;
  CONFIG.Item.dataModels["mutation"] = MutationModel;
  CONFIG.Item.dataModels["prayer"] = PrayerModel;
  CONFIG.Item.dataModels["psychology"] = PsychologyModel;
  CONFIG.Item.dataModels["talent"] = TalentModel;
  CONFIG.Item.dataModels["trapping"] = TrappingModel;
  CONFIG.Item.dataModels["skill"] = SkillModel;
  CONFIG.Item.dataModels["spell"] = SpellModel;
  CONFIG.Item.dataModels["trait"] = TraitModel;
  CONFIG.Item.dataModels["weapon"] = WeaponModel;
  CONFIG.Item.dataModels["vehicleMod"] = VehicleModModel;
  CONFIG.Item.dataModels["vehicleTest"] = VehicleTestModel;
  CONFIG.Item.dataModels["vehicleRole"] = VehicleRoleModel;
  CONFIG.Item.dataModels["extendedTest"] = ExtendedTestModel;
  CONFIG.Item.dataModels["cargo"] = CargoModel;
  CONFIG.Item.dataModels["template"] = TemplateModel;

  CONFIG.ActiveEffect.dataModels["base"] = WFRP4eActiveEffectModel;
  CONFIG.ChatMessage.dataModels["test"] = WFRPTestMessageModel;
  CONFIG.ChatMessage.dataModels["handler"] = OpposedHandlerMessage;
  CONFIG.ChatMessage.dataModels["opposed"] = OpposedTestMessage;
  CONFIG.ChatMessage.dataModels["item"] = PostedItemMessageModel;
  CONFIG.ChatMessage.dataModels["pay"] = PayMessageModel;
  CONFIG.ChatMessage.dataModels["credit"] = CreditMessageModel;
  CONFIG.ChatMessage.dataModels["xp"] = XPMessageModel;
  CONFIG.ChatMessage.dataModels["corruption"] = CorruptionMessageModel;
  CONFIG.ChatMessage.dataModels["psych"] = PsychMessageModel;

  game.wfrp4e = {
    apps: {
      ActorSheetWFRP4eCharacter,
      ActorSheetWFRP4eCreature,
      ActorSheetWFRP4eNPC,
      ActorSheetWFRP4eVehicle,
      CharGenWfrp4e,
      StatBlockParser,
      BrowserWfrp4e,
      ActorSettings,
      WFRPActiveEffectConfig: WFRP4eActiveEffectConfig,
      HomebrewSettings: HomebrewConfig,
      CareerSelector,
      ItemProperties,
      ChargenStage
    },
    documents: {
      ActorWFRP4e,
      ItemWFRP4e,
      GenericAspectModel
    },
    rolls : {
      TestWFRP,
      CharacteristicTest,
      SkillTest,
      WeaponTest,
      CastTest,
      WomCastTest,
      ChannelTest,
      PrayerTest,
      TraitTest
    },
    utility: WFRP_Utility,
    tables: WFRP_Tables,
    config: WFRP4E,
    market: MarketWFRP4e,
    audio: WFRP_Audio,
    names: NameGenWfrp,
    migration: Migration,
    opposedHandler: OpposedHandler,
    tags : new TagManager(),
    trade : new TradeManager()
  };

  CombatHelpersWFRP.registerHelpers();

  CONFIG.Actor.documentClass = ActorWFRP4e;
  CONFIG.Item.documentClass = ItemWFRP4e;
  CONFIG.ActiveEffect.documentClass = ActiveEffectWFRP4e;
  CONFIG.ChatMessage.documentClass = ChatMessageWFRP;
  CONFIG.RollTable.documentClass = WarhammerRollTable;
  CONFIG.ActiveEffect.legacyTransferral = false;

  CONFIG.calendar = calendar();

  CONFIG.cursors.default = "systems/wfrp4e/ui/cursors/normal.png";
  CONFIG.cursors["default-down"] = "systems/wfrp4e/ui/cursors/normal.png";
  CONFIG.cursors.pointer = "systems/wfrp4e/ui/cursors/active.png";
  CONFIG.cursors["pointer-down"] = "systems/wfrp4e/ui/cursors/active.png";

  warhammer.utility.registerPremiumModuleInitialization();
});

registerHooks();
loadScripts();
